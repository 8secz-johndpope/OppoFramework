package com.android.server.am;

import android.annotation.OppoHook;
import android.annotation.OppoHook.OppoHookType;
import android.annotation.OppoHook.OppoRomType;
import android.app.ActivityManager;
import android.app.ActivityManager.ProcessErrorStateInfo;
import android.app.ActivityManager.RecentTaskInfo;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.app.ActivityManager.RunningServiceInfo;
import android.app.ActivityManager.RunningTaskInfo;
import android.app.ActivityManager.StackId;
import android.app.ActivityManager.StackInfo;
import android.app.ActivityManager.TaskDescription;
import android.app.ActivityManager.TaskThumbnail;
import android.app.ActivityManager.TaskThumbnailInfo;
import android.app.ActivityManagerInternal;
import android.app.ActivityManagerInternal.SleepToken;
import android.app.ActivityManagerNative;
import android.app.ActivityOptions;
import android.app.ActivityThread;
import android.app.AlertDialog;
import android.app.AppGlobals;
import android.app.ApplicationErrorReport.CrashInfo;
import android.app.ApplicationThreadNative;
import android.app.BroadcastOptions;
import android.app.Dialog;
import android.app.IActivityContainer;
import android.app.IActivityContainerCallback;
import android.app.IActivityController;
import android.app.IActivityManager.ContentProviderHolder;
import android.app.IActivityManager.WaitResult;
import android.app.IAppTask;
import android.app.IAppTask.Stub;
import android.app.IApplicationThread;
import android.app.IInstrumentationWatcher;
import android.app.INotificationManager;
import android.app.IOppoKinectActivityController;
import android.app.IProcessObserver;
import android.app.IServiceConnection;
import android.app.IStopUserCallback;
import android.app.ITaskStackListener;
import android.app.IUiAutomationConnection;
import android.app.IUidObserver;
import android.app.IUserSwitchObserver;
import android.app.Notification;
import android.app.Notification.Builder;
import android.app.NotificationManager;
import android.app.OppoThemeHelper;
import android.app.PendingIntent;
import android.app.ProfilerInfo;
import android.app.assist.AssistContent;
import android.app.assist.AssistStructure;
import android.app.backup.IBackupManager;
import android.app.usage.UsageStatsManagerInternal;
import android.content.BroadcastReceiver;
import android.content.ClipData;
import android.content.ComponentName;
import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IContentProvider;
import android.content.IIntentReceiver;
import android.content.IIntentSender;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.content.UriPermission;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.ConfigurationInfo;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageManager;
import android.content.pm.InstrumentationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.PackageManagerInternal;
import android.content.pm.ParceledListSlice;
import android.content.pm.PathPermission;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.UserInfo;
import android.content.res.CompatibilityInfo;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.graphics.Point;
import android.graphics.Rect;
import android.net.ProxyInfo;
import android.net.Uri;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Debug;
import android.os.Debug.MemoryInfo;
import android.os.DropBoxManager;
import android.os.Environment;
import android.os.FactoryTest;
import android.os.FileObserver;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBinder;
import android.os.IBinder.DeathRecipient;
import android.os.IPermissionController;
import android.os.IProcessInfoService;
import android.os.IProgressListener;
import android.os.LocaleList;
import android.os.Looper;
import android.os.Message;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.os.PowerManagerInternal;
import android.os.Process;
import android.os.Process.ProcessStartResult;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.SELinux;
import android.os.ServiceManager;
import android.os.StatFs;
import android.os.StrictMode.ViolationInfo;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.TransactionTooLargeException;
import android.os.UEventObserver;
import android.os.UEventObserver.UEvent;
import android.os.UpdateLock;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.WorkSource;
import android.os.storage.IMountService;
import android.os.storage.MountServiceInternal;
import android.os.storage.StorageManager;
import android.provider.Settings;
import android.provider.Settings.Global;
import android.provider.Settings.Secure;
import android.provider.Settings.System;
import android.service.voice.IVoiceInteractionSession;
import android.service.voice.VoiceInteractionManagerInternal;
import android.telecom.TelecomManager;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.AtomicFile;
import android.util.DebugUtils;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.Log;
import android.util.Pair;
import android.util.PrintWriterPrinter;
import android.util.Slog;
import android.util.SparseArray;
import android.util.TimeUtils;
import android.util.Xml;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import android.view.inputmethod.InputMethodManagerInternal;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.AssistUtils;
import com.android.internal.app.DumpHeapActivity;
import com.android.internal.app.IAppOpsCallback;
import com.android.internal.app.IAppOpsService;
import com.android.internal.app.IVoiceInteractor;
import com.android.internal.app.ProcessMap;
import com.android.internal.app.procstats.ProcessStats.ProcessStateHolder;
import com.android.internal.os.BackgroundThread;
import com.android.internal.os.BatteryStatsImpl;
import com.android.internal.os.BatteryStatsImpl.BatteryCallback;
import com.android.internal.os.BatteryStatsImpl.Uid.Pkg.Serv;
import com.android.internal.os.BatteryStatsImpl.Uid.Proc;
import com.android.internal.os.IResultReceiver;
import com.android.internal.os.ProcessCpuTracker;
import com.android.internal.os.ProcessCpuTracker.FilterStats;
import com.android.internal.os.ProcessCpuTracker.Stats;
import com.android.internal.os.TransferPipe;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.FastPrintWriter;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.MemInfoReader;
import com.android.internal.util.Preconditions;
import com.android.internal.util.XmlUtils;
import com.android.server.AgingCriticalEvent;
import com.android.server.AppOpsService;
import com.android.server.AttributeCache;
import com.android.server.ColorOSDeviceIdleHelper;
import com.android.server.IntentResolver;
import com.android.server.LocalServices;
import com.android.server.LocationManagerService;
import com.android.server.LockGuard;
import com.android.server.OppoDynamicLogManager;
import com.android.server.ServiceThread;
import com.android.server.SystemService;
import com.android.server.SystemServiceManager;
import com.android.server.UiThread;
import com.android.server.Watchdog;
import com.android.server.Watchdog.Monitor;
import com.android.server.am.UriPermission.PersistedTimeComparator;
import com.android.server.am.UriPermission.Snapshot;
import com.android.server.coloros.OppoListManager;
import com.android.server.display.OppoBrightUtils;
import com.android.server.fingerprint.dcs.DcsFingerprintStatisticsUtil;
import com.android.server.firewall.IntentFirewall;
import com.android.server.firewall.IntentFirewall.AMSInterface;
import com.android.server.job.JobSchedulerShellCommand;
import com.android.server.job.controllers.JobStatus;
import com.android.server.location.LocationFudger;
import com.android.server.oppo.DumpObject;
import com.android.server.oppo.IElsaManager;
import com.android.server.oppo.OppoJunkRecorder;
import com.android.server.pm.Installer;
import com.android.server.policy.PhoneWindowManager;
import com.android.server.secrecy.policy.DecryptTool;
import com.android.server.statusbar.StatusBarManagerInternal;
import com.android.server.vr.VrManagerInternal;
import com.android.server.wm.WindowManagerService;
import com.google.android.collect.Lists;
import com.google.android.collect.Maps;
import com.mediatek.aal.AalUtils;
import com.mediatek.am.AMEventHookAction;
import com.mediatek.am.AMEventHookData.ActivityThreadResumedDone;
import com.mediatek.am.AMEventHookData.BeforeSendBroadcast;
import com.mediatek.am.AMEventHookData.EndOfAMSCtor;
import com.mediatek.am.AMEventHookData.EndOfActivityIdle;
import com.mediatek.am.AMEventHookData.EndOfErrorDumpThread;
import com.mediatek.am.AMEventHookData.PackageStoppedStatusChanged;
import com.mediatek.am.AMEventHookData.ReadyToGetProvider;
import com.mediatek.am.AMEventHookData.ReadyToStartComponent;
import com.mediatek.am.AMEventHookData.ReadyToStartComponent.Index;
import com.mediatek.am.AMEventHookData.StartProcessForActivity;
import com.mediatek.am.AMEventHookData.SystemReady;
import com.mediatek.am.AMEventHookData.SystemUserUnlock;
import com.mediatek.am.AMEventHookData.UpdateSleep;
import com.mediatek.am.AMEventHookData.WakefulnessChanged;
import com.mediatek.am.AMEventHookResult;
import com.mediatek.am.IAWSProcessRecord;
import com.mediatek.am.IAWSStoreRecord;
import com.mediatek.anrmanager.ANRManager;
import com.mediatek.anrmanager.ANRManager.AnrDumpMgr;
import com.mediatek.anrmanager.ANRManager.AnrMonitorHandler;
import com.mediatek.anrmanager.ANRManager.DumpThread;
import com.mediatek.anrmanager.ANRManager.IAnrActivityManagerService;
import com.mediatek.appworkingset.AWSManager;
import com.mediatek.common.MPlugin;
import com.mediatek.common.amsplus.ICustomizedOomExt;
import com.mediatek.cta.CtaUtils;
import com.mediatek.multiwindow.MultiWindowManager;
import com.mediatek.pq.IAppDetectionService;
import com.mediatek.server.am.AMEventHook;
import com.mediatek.server.am.AMEventHook.Event;
import com.mediatek.server.am.AutoBootControl.ReceiverController;
import com.mediatek.server.am.BootEvent;
import com.mediatek.suppression.service.SuppressionInternal;
import com.oppo.debug.ASSERT;
import com.oppo.hypnus.Hypnus;
import dalvik.system.VMRuntime;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.ref.WeakReference;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import libcore.io.IoUtils;
import libcore.util.EmptyArray;
import oppo.util.OppoMultiLauncherUtil;
import oppo.util.OppoStatistics;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

/*  JADX ERROR: NullPointerException in pass: ReSugarCode
    java.lang.NullPointerException
    	at jadx.core.dex.visitors.ReSugarCode.initClsEnumMap(ReSugarCode.java:159)
    	at jadx.core.dex.visitors.ReSugarCode.visit(ReSugarCode.java:44)
    	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:12)
    	at jadx.core.ProcessClass.process(ProcessClass.java:32)
    	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
    	at java.lang.Iterable.forEach(Iterable.java:75)
    	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
    	at jadx.core.ProcessClass.process(ProcessClass.java:37)
    	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:292)
    	at jadx.api.JavaClass.decompile(JavaClass.java:62)
    	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:200)
    */
/*  JADX ERROR: NullPointerException in pass: ExtractFieldInit
    java.lang.NullPointerException
    	at jadx.core.dex.visitors.ExtractFieldInit.checkStaticFieldsInit(ExtractFieldInit.java:58)
    	at jadx.core.dex.visitors.ExtractFieldInit.visit(ExtractFieldInit.java:44)
    	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:12)
    	at jadx.core.ProcessClass.process(ProcessClass.java:32)
    	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
    	at java.lang.Iterable.forEach(Iterable.java:75)
    	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
    	at jadx.core.ProcessClass.process(ProcessClass.java:37)
    	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:292)
    	at jadx.api.JavaClass.decompile(JavaClass.java:62)
    	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:200)
    */
@OppoHook(level = OppoHookType.CHANGE_CODE_AND_ACCESS, note = "zhangyinxiang@Plf.Framework, modify for OppoActivityManagerService", property = OppoRomType.ROM)
public class ActivityManagerService extends ActivityManagerNative implements Monitor, BatteryCallback {
    public static final String ACTION_TRIGGER_IDLE = "com.android.server.ACTION_TRIGGER_IDLE";
    static final int ALLOW_FULL_ONLY = 2;
    static final int ALLOW_NON_FULL = 0;
    static final int ALLOW_NON_FULL_IN_PROFILE = 1;
    static final boolean ANIMATE = true;
    static final int APP_BOOST_DEACTIVATE_MSG = 58;
    static final int APP_BOOST_MESSAGE_DELAY = 3000;
    static final int APP_BOOST_TIMEOUT = 2500;
    private static final long APP_DEXOPT_TIMEOUT = 20000;
    static final long APP_SWITCH_DELAY_TIME = 5000;
    private static final String ATTR_CREATED_TIME = "createdTime";
    private static final String ATTR_MODE_FLAGS = "modeFlags";
    private static final String ATTR_PREFIX = "prefix";
    private static final String ATTR_SOURCE_PKG = "sourcePkg";
    private static final String ATTR_SOURCE_USER_ID = "sourceUserId";
    private static final String ATTR_TARGET_PKG = "targetPkg";
    private static final String ATTR_TARGET_USER_ID = "targetUserId";
    private static final String ATTR_URI = "uri";
    private static final String ATTR_USER_HANDLE = "userHandle";
    static final int BACKGROUND_SETTLE_TIME = 60000;
    static final long BATTERY_STATS_TIME = 1800000;
    static final int BROADCAST_BG_TIMEOUT = 60000;
    static final int BROADCAST_FG_TIMEOUT = 10000;
    static final int CANCEL_HEAVY_NOTIFICATION_MSG = 25;
    static final int CHECK_EXCESSIVE_WAKE_LOCKS_IMM_MSG = 401;
    static final int CHECK_EXCESSIVE_WAKE_LOCKS_MSG = 27;
    static final int CLEAR_DNS_CACHE_MSG = 28;
    static final int COLLECT_PSS_BG_MSG = 1;
    static final int COLLECT_PSS_FG_MSG = 2;
    static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT = 10000;
    static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG = 59;
    static final int CONTENT_PROVIDER_RETAIN_TIME = 20000;
    static final int CONTENT_PROVIDER_WAIT_TIMEOUT = 20000;
    static final int CONTINUE_USER_SWITCH_MSG = 35;
    static final int CPU_MIN_CHECK_DURATION = 0;
    private static final int CREATE_RESERVE_DELAY_TIME = 20000;
    private static final int DATA_MIN_SIZE = 16;
    private static final int DATA_PROTECT_WRITE_SIZE = 40;
    private static final String DATA_RESERVE_PATH = "/data/system/reserve.log";
    private static final boolean DBG_CUSTOMIZE = false;
    private static final boolean DBG_LIST_PARSE = false;
    public static boolean DEBUG_COLOROS_AMS = false;
    public static final int DELAY_TIME_MILLSECOND = 1000;
    static final int DELETE_DUMPHEAP_MSG = 52;
    static final int DISMISS_DIALOG_UI_MSG = 48;
    static final int DISPATCH_PROCESSES_CHANGED_UI_MSG = 31;
    static final int DISPATCH_PROCESS_DIED_UI_MSG = 32;
    static final int DISPATCH_UIDS_CHANGED_UI_MSG = 54;
    static final int DO_PENDING_ACTIVITY_LAUNCHES_MSG = 21;
    static final int DROPBOX_MAX_SIZE = 196608;
    static final long[] DUMP_MEM_BUCKETS = null;
    static final int[] DUMP_MEM_OOM_ADJ = null;
    static final String[] DUMP_MEM_OOM_COMPACT_LABEL = null;
    static final String[] DUMP_MEM_OOM_LABEL = null;
    static final String[] EMPTY_STRING_ARRAY = null;
    static final int ENTER_ANIMATION_COMPLETE_MSG = 44;
    private static final String FEATURE_DISALLOW_APP_RUN_STR = "oppo.customize.function.disallow_app_run";
    static final int FINALIZE_PENDING_INTENT_MSG = 23;
    static final int FINISH_BOOTING_MSG = 45;
    static final int FIRST_ACTIVITY_STACK_MSG = 100;
    static final int FIRST_BROADCAST_QUEUE_MSG = 200;
    static final int FIRST_COMPAT_MODE_MSG = 300;
    static final int FIRST_SUPERVISOR_STACK_MSG = 100;
    static final int FOREGROUND_PROFILE_CHANGED_MSG = 53;
    public static final float FULLSCREEN_SCREENSHOT_SCALE = 0.6f;
    static final int FULL_PSS_LOWERED_INTERVAL = 120000;
    static final int FULL_PSS_MIN_INTERVAL = 600000;
    static final int GC_BACKGROUND_PROCESSES_MSG = 5;
    static final int GC_MIN_INTERVAL = 60000;
    static final int GC_TIMEOUT = 5000;
    static final int IDLE_UIDS_MSG = 60;
    static final int IMMERSIVE_MODE_LOCK_MSG = 37;
    static final int INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT = 60000;
    static final String INTENT_QUERY_EXTRA = "query";
    private static final String INTENT_REMOTE_BUGREPORT_FINISHED = "android.intent.action.REMOTE_BUGREPORT_FINISHED";
    static final boolean IS_ENG_BUILD = false;
    static final boolean IS_USER_BUILD = false;
    static final boolean IS_USER_DEBUG_BUILD = false;
    private static final String KEYGUARD_PROC_NAME = "com.android.keyguard";
    private static final String KEYGUARD_STARTPROC_TIMEOUT_ACTION = "android.intent.action.KEYGUARD_TIMEOUT";
    static final int KEY_DISPATCHING_TIMEOUT = 8000;
    static final int KILL_APPLICATION_MSG = 22;
    private static final int KSM_SHARED = 0;
    private static final int KSM_SHARING = 1;
    private static final int KSM_UNSHARED = 2;
    private static final int KSM_VOLATILE = 3;
    static final int LOCK_SCREEN_HIDDEN = 0;
    static final int LOCK_SCREEN_LEAVING = 1;
    static final int LOCK_SCREEN_SHOWN = 2;
    static final int LOG_STACK_STATE = 62;
    private static final int MAX_DUP_SUPPRESSED_STACKS = 5000;
    static final int MAX_PERSISTED_URI_GRANTS = 128;
    private static final int MEMINFO_COMPACT_VERSION = 1;
    static final long MONITOR_CPU_MAX_TIME = 268435455;
    static final long MONITOR_CPU_MIN_TIME = 5000;
    static final boolean MONITOR_CPU_USAGE = true;
    static final boolean MONITOR_THREAD_CPU_USAGE = false;
    static final int MY_PID = 0;
    static final int NOTIFY_ACTIVITY_DISMISSING_DOCKED_STACK_MSG = 68;
    static final int NOTIFY_ACTIVITY_PINNED_LISTENERS_MSG = 64;
    static final int NOTIFY_CLEARTEXT_NETWORK_MSG = 50;
    static final int NOTIFY_FORCED_RESIZABLE_MSG = 67;
    static final int NOTIFY_PINNED_ACTIVITY_RESTART_ATTEMPT_LISTENERS_MSG = 65;
    static final int NOTIFY_PINNED_STACK_ANIMATION_ENDED_LISTENERS_MSG = 66;
    static final int NOTIFY_TASK_STACK_CHANGE_LISTENERS_DELAY = 100;
    static final int NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG = 49;
    static final int NOT_ALLOWED_START_MSG = 600;
    public static final String OPPO_LAUNCHER = "com.oppo.launcher";
    static final int PENDING_ASSIST_EXTRAS_LONG_TIMEOUT = 2000;
    static final int PENDING_ASSIST_EXTRAS_TIMEOUT = 500;
    private static final int PERSISTENT_MASK = 9;
    static final int PERSIST_URI_GRANTS_MSG = 38;
    static final int POST_DUMP_HEAP_NOTIFICATION_MSG = 51;
    static final int POST_HEAVY_NOTIFICATION_MSG = 24;
    static final int POWER_CHECK_DELAY = 0;
    private static final int[] PROCESS_STATE_STATS_FORMAT = null;
    static final int PROC_START_TIMEOUT = 10000;
    static final int PROC_START_TIMEOUT_MSG = 20;
    static final int PROC_START_TIMEOUT_WITH_WRAPPER = 1200000;
    private static final boolean REMOVE_FROM_RECENTS = true;
    static final int REPORT_MEM_USAGE_MSG = 33;
    static final int REPORT_TIME_TRACKER_MSG = 55;
    static final int REPORT_USER_SWITCH_COMPLETE_MSG = 56;
    static final int REPORT_USER_SWITCH_MSG = 34;
    static final int REQUEST_ALL_PSS_MSG = 39;
    static final int RESERVED_BYTES_PER_LOGCAT_LINE = 100;
    private static final int RESERVE_FILE_SIZE = 64;
    static final int RESET_SLEEP_CHECK_FLAG_MSG = 400;
    private static final String SEINFO_DEFAULT = "default";
    private static final String SEINFO_OPPODCIM = "oppo_dcim";
    private static final String SEINFO_UNTRUSTED = "untrusted";
    static final int SEND_LOCALE_TO_MOUNT_DAEMON_MSG = 47;
    static final int SERVICE_TIMEOUT_MSG = 12;
    static final int SERVICE_USAGE_INTERACTION_TIME = 1800000;
    static final int SHOW_COMPAT_MODE_DIALOG_UI_MSG = 30;
    static final int SHOW_ERROR_UI_MSG = 1;
    static final int SHOW_FACTORY_ERROR_UI_MSG = 3;
    static final int SHOW_FINGERPRINT_ERROR_UI_MSG = 15;
    static final int SHOW_NOT_ALLOW_DIALOG_MSG = 410;
    static final int SHOW_NOT_RESPONDING_UI_MSG = 2;
    static final int SHOW_STRICT_MODE_VIOLATION_UI_MSG = 26;
    static final int SHOW_SYSTEM_SERVICE_CRASH_MSG = 420;
    static final int SHOW_UID_ERROR_UI_MSG = 14;
    static final int SHOW_UNSUPPORTED_DISPLAY_SIZE_DIALOG_MSG = 70;
    static final int SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG = 57;
    static final int START_CHOOSER_ACTIVITY_MSG = 500;
    static final int START_FORCESTOP_MSG = 511;
    static final int START_OPPO_SITE_MSG = 700;
    static final int START_PROFILES_MSG = 40;
    static final int START_USER_SWITCH_UI_MSG = 46;
    static final int STOCK_PM_FLAGS = 1024;
    static final int SUPPRESS_ACTION_ALLOWED = 0;
    static final int SUPPRESS_ACTION_DELAYED = 1;
    static final int SUPPRESS_ACTION_SKIPPED = 2;
    static final int SUPPRESS_ACTION_STOP = 1;
    static final int SUPPRESS_ACTION_UNSTOP = 0;
    private static final String SYSTEMUI_PROC_NAME = "com.android.systemui";
    static final String SYSTEM_DEBUGGABLE = "ro.debuggable";
    static final int SYSTEM_USER_CURRENT_MSG = 43;
    static final int SYSTEM_USER_START_MSG = 42;
    static final int SYSTEM_USER_UNLOCK_MSG = 61;
    static final String TAG = null;
    private static final String TAG_BACKUP = null;
    private static final String TAG_BROADCAST = null;
    private static final String TAG_CLEANUP = null;
    private static final String TAG_CONFIGURATION = null;
    private static final String TAG_FOCUS = null;
    private static final String TAG_IMMERSIVE = null;
    private static final String TAG_LOCKSCREEN = null;
    private static final String TAG_LOCKTASK = null;
    private static final String TAG_LRU = null;
    private static final String TAG_MU = null;
    private static final String TAG_OOM_ADJ = null;
    private static final String TAG_POWER = null;
    private static final String TAG_PROCESSES = null;
    private static final String TAG_PROCESS_OBSERVERS = null;
    private static final String TAG_PROVIDER = null;
    private static final String TAG_PSS = null;
    private static final String TAG_RECENTS = null;
    private static final String TAG_SERVICE = null;
    private static final String TAG_STACK = null;
    private static final String TAG_SWITCH = null;
    private static final String TAG_UID_OBSERVERS = null;
    private static final String TAG_URI_GRANT = "uri-grant";
    private static final String TAG_URI_GRANTS = "uri-grants";
    private static final String TAG_URI_PERMISSION = null;
    private static final String TAG_VISIBILITY = null;
    private static final String TAG_VISIBLE_BEHIND = null;
    static final boolean TAKE_FULLSCREEN_SCREENSHOTS = true;
    private static final String TENCENT_NAME = "com.tencent.mm";
    static final int UPDATE_CONFIGURATION_MSG = 4;
    static final int UPDATE_HTTP_PROXY_MSG = 29;
    static final int UPDATE_TIME = 41;
    static final int UPDATE_TIME_ZONE = 13;
    static final long USAGE_STATS_INTERACTION_INTERVAL = 86400000;
    static final int USER_SWITCH_TIMEOUT_MSG = 36;
    static final boolean VALIDATE_UID_STATES = true;
    static final int VR_MODE_APPLY_IF_NEEDED_MSG = 69;
    static final int VR_MODE_CHANGE_MSG = 63;
    static final int WAIT_FOR_DEBUGGER_UI_MSG = 6;
    static final int WAKE_LOCK_MIN_CHECK_DURATION = 0;
    static final boolean isAgingTestVersion = false;
    static ANRManager mANRManager;
    static final ArrayList<Integer> mInterestingPids = null;
    private static final ThreadLocal<Identity> sCallerIdentity = null;
    static KillHandler sKillHandler;
    static ServiceThread sKillThread;
    static ThreadLocal<PriorityState> sThreadPriorityState;
    private final String CUSTOMIZE_LIST_PATH;
    final int GL_ES_VERSION;
    private final int MAX_NUM_NOT_SHOW;
    final boolean assertEnable;
    File dataDir;
    private boolean dexStart;
    final boolean isDiskEncrypted;
    final boolean isVoldDecryptTriggered;
    private AMEventHook mAMEventHook;
    ProcessChangeItem[] mActiveProcessChanges;
    ChangeItem[] mActiveUidChanges;
    final SparseArray<UidRecord> mActiveUids;
    final String[] mActivitiesResumeBehindKeyguardArray;
    final ArrayList<String> mActivitiesResumeBehindKeyguardList;
    final ActivityStarter mActivityStarter;
    int mAdjSeq;
    boolean mAllowLowerMemLevel;
    private final HashSet<Integer> mAlreadyLoggedViolatedStacks;
    boolean mAlwaysFinishActivities;
    AnrDumpMgr mAnrDumpMgr;
    AnrMonitorHandler mAnrHandler;
    HashMap<String, IBinder> mAppBindArgs;
    final AppErrors mAppErrors;
    final AppOpsService mAppOpsService;
    long mAppSwitchesAllowedTime;
    final SparseArray<ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>>> mAssociations;
    boolean mAutoStopProfiler;
    final ArrayList<ProcessChangeItem> mAvailProcessChanges;
    final ArrayList<ChangeItem> mAvailUidChanges;
    String mBackupAppName;
    BackupRecord mBackupTarget;
    final BatteryStatsService mBatteryStatsService;
    BroadcastQueue mBgBroadcastQueue;
    final Handler mBgHandler;
    private boolean mBinderTransactionTrackingEnabled;
    private long mBoostStartTime;
    @GuardedBy("this")
    boolean mBootAnimationComplete;
    boolean mBooted;
    @GuardedBy("this")
    boolean mBooting;
    final BroadcastQueue[] mBroadcastQueues;
    final ServiceThread mBroadcastThread;
    @GuardedBy("this")
    boolean mCallFinishBooting;
    @GuardedBy("this")
    boolean mCheckedForSetup;
    CompatModeDialog mCompatModeDialog;
    final CompatModePackages mCompatModePackages;
    Configuration mConfiguration;
    int mConfigurationSeq;
    Context mContext;
    IActivityController mController;
    boolean mControllerIsAMonkey;
    CoreSettingsObserver mCoreSettingsObserver;
    private final Runnable mCreateDataReserveFile;
    private final boolean mCtmFlag;
    private final String mCtmName;
    private AppTimeTracker mCurAppTimeTracker;
    BroadcastStats mCurBroadcastStats;
    private String mCurResumedPackage;
    private int mCurResumedUid;
    private List<String> mCustomizeList;
    ICustomizedOomExt mCustomizedOomExt;
    String mDebugApp;
    boolean mDebugTransient;
    Rect mDefaultPinnedStackBounds;
    String mDeviceOwnerName;
    private HashMap<Integer, Long> mDexOptTimeMap;
    private AlertDialog mDialogForDisallow;
    boolean mDidAppSwitch;
    boolean mDidDexOpt;
    private List<String> mDisallowedRuningAppList;
    private Object mDisallowedRuningAppListLock;
    boolean mDoingSetFocusedActivity;
    private String mErrorPkgName;
    private long mErrorTime;
    volatile int mFactoryTest;
    BroadcastQueue mFgBroadcastQueue;
    private OppoProcessWhiteListUtils mFileUtils;
    private int mFinishBroadcastCount;
    ActivityRecord mFocusedActivity;
    FontScaleSettingObserver mFontScaleSettingObserver;
    boolean mForceResizableActivities;
    final ProcessMap<ArrayList<ProcessRecord>> mForegroundPackages;
    final SparseArray<ForegroundToken> mForegroundProcesses;
    boolean mFullPssPending;
    float mFullscreenThumbnailScale;
    private final AtomicFile mGrantFile;
    @GuardedBy("this")
    private final SparseArray<ArrayMap<GrantUri, UriPermission>> mGrantedUriPermissions;
    final MainHandler mHandler;
    final ServiceThread mHandlerThread;
    boolean mHasRecents;
    ProcessRecord mHeavyWeightProcess;
    ProcessRecord mHomeProcess;
    private Hypnus mHyp;
    boolean mIgnoreSleepCheckLater;
    private boolean mInVrMode;
    private Installer mInstaller;
    final InstrumentationReporter mInstrumentationReporter;
    public IntentFirewall mIntentFirewall;
    final HashMap<Key, WeakReference<PendingIntentRecord>> mIntentSenderRecords;
    private boolean mIsBoosted;
    boolean mIsWallpaperFg;
    HashMap<String, IBinder> mIsolatedAppBindArgs;
    final SparseArray<ProcessRecord> mIsolatedProcesses;
    ActivityInfo mLastAddedTaskActivity;
    ComponentName mLastAddedTaskComponent;
    int mLastAddedTaskUid;
    BroadcastStats mLastBroadcastStats;
    final AtomicLong mLastCpuTime;
    private int mLastFocusedUserId;
    long mLastFullPssTime;
    long mLastIdleTime;
    long mLastMemUsageReportTime;
    int mLastMemoryLevel;
    int mLastNumProcesses;
    long mLastPowerCheckRealtime;
    long mLastPowerCheckUptime;
    long mLastWriteTime;
    @GuardedBy("this")
    boolean mLaunchWarningShown;
    final ArrayList<ContentProviderRecord> mLaunchingProviders;
    boolean mLenientBackgroundCheck;
    private UEventObserver mLmkObserver;
    com.android.server.DeviceIdleController.LocalService mLocalDeviceIdleController;
    PowerManagerInternal mLocalPowerManager;
    int mLockScreenShown;
    SparseArray<String[]> mLockTaskPackages;
    long mLowRamStartTime;
    long mLowRamTimeSinceLastIdle;
    int mLruProcessActivityStart;
    int mLruProcessServiceStart;
    final ArrayList<ProcessRecord> mLruProcesses;
    int mLruSeq;
    String mMemWatchDumpFile;
    int mMemWatchDumpPid;
    String mMemWatchDumpProcName;
    int mMemWatchDumpUid;
    final ProcessMap<Pair<Long, String>> mMemWatchProcesses;
    String mNativeDebuggingApp;
    int mNewNumAServiceProcs;
    int mNewNumServiceProcs;
    int mNextIsolatedProcessUid;
    private final File mNotAllowAppFilename;
    int mNumCachedHiddenProcs;
    int mNumNonCachedProcs;
    int mNumServiceProcs;
    volatile boolean mOnBattery;
    OppoActivityControlerScheduler mOppoActivityControlerScheduler;
    private OppoAppScaleHelper mOppoAppScaleHelper;
    IOppoKinectActivityController mOppoKinectController;
    String mOrigDebugApp;
    boolean mOrigWaitForDebugger;
    PackageManagerInternal mPackageManagerInt;
    final ArrayList<PendingAssistExtras> mPendingAssistExtras;
    final ArrayList<ProcessChangeItem> mPendingProcessChanges;
    final ArrayList<ProcessRecord> mPendingPssProcesses;
    final ArrayList<ChangeItem> mPendingUidChanges;
    final ArrayList<ProcessRecord> mPersistentStartingProcesses;
    final SparseArray<ProcessRecord> mPidsSelfLocked;
    ProcessRecord mPreviousProcess;
    long mPreviousProcessVisibleTime;
    final AtomicBoolean mProcessCpuMutexFree;
    final Thread mProcessCpuThread;
    final ProcessCpuTracker mProcessCpuTracker;
    int mProcessLimit;
    int mProcessLimitOverride;
    final ProcessList mProcessList;
    final ProcessMap<ProcessRecord> mProcessNames;
    final RemoteCallbackList<IProcessObserver> mProcessObservers;
    private final long[] mProcessStateStatsLongs;
    final ProcessStatsService mProcessStats;
    final ArrayList<ProcessRecord> mProcessesOnHold;
    volatile boolean mProcessesReady;
    final ArrayList<ProcessRecord> mProcessesToGc;
    String mProfileApp;
    ParcelFileDescriptor mProfileFd;
    String mProfileFile;
    ProcessRecord mProfileProc;
    int mProfileType;
    final ProviderMap mProviderMap;
    final IntentResolver<BroadcastFilter, BroadcastFilter> mReceiverResolver;
    final RecentTasks mRecentTasks;
    final HashMap<IBinder, ReceiverList> mRegisteredReceivers;
    final ArrayList<ProcessRecord> mRemovedProcesses;
    private IVoiceInteractionSession mRunningVoice;
    boolean mSafeMode;
    int mSamplingInterval;
    final ActiveServices mServices;
    private boolean mShowDialogs;
    boolean mShuttingDown;
    final ArrayList<SleepToken> mSleepTokens;
    private boolean mSleeping;
    private ActivityRecord mSplitActivity;
    final ActivityStackSupervisor mStackSupervisor;
    final SparseArray<ArrayMap<String, ArrayList<Intent>>> mStickyBroadcasts;
    private final StringBuilder mStrictModeBuffer;
    final StringBuilder mStringBuilder;
    private String[] mSupportedSystemLocales;
    boolean mSupportsFreeformWindowManagement;
    boolean mSupportsLeanbackOnly;
    boolean mSupportsMultiWindow;
    boolean mSupportsPictureInPicture;
    SuppressManager mSuppressManager;
    boolean mSuppressResizeConfigChanges;
    private final File mSystemDir;
    volatile boolean mSystemReady;
    private ActivityStack mSystemReadyFocusedStack;
    SystemServiceManager mSystemServiceManager;
    final ActivityThread mSystemThread;
    private final RemoteCallbackList<ITaskStackListener> mTaskStackListeners;
    boolean mTestPssMode;
    int mThumbnailHeight;
    int mThumbnailWidth;
    final long[] mTmpLong;
    String mTopAction;
    ComponentName mTopComponent;
    String mTopData;
    int mTopProcessState;
    String mTrackAllocationApp;
    boolean mTrackingAssociations;
    final UiHandler mUiHandler;
    final RemoteCallbackList<IUidObserver> mUidObservers;
    UnsupportedDisplaySizeDialog mUnsupportedDisplaySizeDialog;
    final UpdateLock mUpdateLock;
    UsageStatsManagerInternal mUsageStatsService;
    private boolean mUseFifoUiScheduling;
    final UserController mUserController;
    private boolean mUserIsMonkey;
    final SparseArray<UidRecord> mValidateUids;
    private int mViSessionId;
    WakeLock mVoiceWakeLock;
    boolean mWaitForDebugger;
    private int mWakefulness;
    ComponentName mWallpaperClassName;
    ProcessRecord mWallpaperProcess;
    WindowManagerService mWindowManager;
    private volatile int mWtfClusterCount;
    private volatile long mWtfClusterStart;
    private List<String> splitBack;

    final /* synthetic */ class -void_reportMemUsage_java_util_ArrayList_memInfos_LambdaImpl0 implements FilterStats {
        public boolean needed(Stats arg0) {
            return ActivityManagerService.m3-com_android_server_am_ActivityManagerService_lambda$2(arg0);
        }
    }

    abstract class ForegroundToken implements DeathRecipient {
        int pid;
        IBinder token;

        ForegroundToken() {
        }
    }

    class AnrActivityManagerService implements IAnrActivityManagerService {
        AnrActivityManagerService() {
        }

        public boolean getShuttingDown() {
            return ActivityManagerService.this.mShuttingDown;
        }

        public void getPidFromLruProcesses(int appPid, int parentPid, ArrayList<Integer> firstPids, SparseArray<Boolean> lastPids) {
            for (int i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                ProcessRecord r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                if (!(r == null || r.thread == null)) {
                    int pid = r.pid;
                    if (!(pid <= 0 || pid == appPid || pid == parentPid || pid == ActivityManagerService.MY_PID)) {
                        if (r.persistent) {
                            firstPids.add(Integer.valueOf(pid));
                        } else {
                            lastPids.put(pid, Boolean.TRUE);
                        }
                    }
                }
            }
        }

        public ArrayList<Integer> getInterestingPids() {
            return ActivityManagerService.mInterestingPids;
        }

        public File dumpStackTraces(boolean clearTraces, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {
            return ActivityManagerService.dumpStackTraces(clearTraces, (ArrayList) firstPids, processCpuTracker, (SparseArray) lastPids, nativeProcs);
        }

        public int getProcessRecordPid(Object obj) {
            if (obj != null) {
                return ((ProcessRecord) obj).pid;
            }
            return -1;
        }

        public boolean getMonitorCpuUsage() {
            return true;
        }

        public void updateCpuStatsNow() {
            ActivityManagerService.this.updateCpuStatsNow();
        }

        public ProcessCpuTracker getProcessCpuTracker() {
            return ActivityManagerService.this.mProcessCpuTracker;
        }
    }

    private final class AppDeathRecipient implements DeathRecipient {
        final ProcessRecord mApp;
        final IApplicationThread mAppThread;
        final int mPid;

        AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) {
            if (ActivityManagerDebugConfig.DEBUG_ALL) {
                Slog.v(ActivityManagerService.TAG, "New death recipient " + this + " for thread " + thread.asBinder());
            }
            this.mApp = app;
            this.mPid = pid;
            this.mAppThread = thread;
        }

        public void binderDied() {
            if (ActivityManagerDebugConfig.DEBUG_ALL) {
                Slog.v(ActivityManagerService.TAG, "Death received in " + this + " for thread " + this.mAppThread.asBinder());
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.appDiedLocked(this.mApp, this.mPid, this.mAppThread, true);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }
    }

    class AppTaskImpl extends Stub {
        private int mCallingUid;
        private int mTaskId;

        public AppTaskImpl(int taskId, int callingUid) {
            this.mTaskId = taskId;
            this.mCallingUid = callingUid;
        }

        private void checkCaller() {
            if (this.mCallingUid != Binder.getCallingUid()) {
                throw new SecurityException("Caller " + this.mCallingUid + " does not match caller of getAppTasks(): " + Binder.getCallingUid());
            }
        }

        public void finishAndRemoveTask() {
            checkCaller();
            synchronized (ActivityManagerService.this) {
                long origId;
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    origId = Binder.clearCallingIdentity();
                    if (ActivityManagerService.this.removeTaskByIdLocked(this.mTaskId, false, true)) {
                        Binder.restoreCallingIdentity(origId);
                    } else {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public RecentTaskInfo getTaskInfo() {
            RecentTaskInfo -wrap0;
            checkCaller();
            synchronized (ActivityManagerService.this) {
                long origId;
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    origId = Binder.clearCallingIdentity();
                    TaskRecord tr = ActivityManagerService.this.mStackSupervisor.anyTaskForIdLocked(this.mTaskId);
                    if (tr == null) {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                    -wrap0 = ActivityManagerService.this.createRecentTaskInfoFromTaskRecord(tr);
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            return -wrap0;
        }

        public void moveToFront() {
            checkCaller();
            long origId = Binder.clearCallingIdentity();
            try {
                synchronized (this) {
                    ActivityManagerService.this.mStackSupervisor.startActivityFromRecentsInner(this.mTaskId, null);
                }
            } finally {
                Binder.restoreCallingIdentity(origId);
            }
        }

        public int startActivity(IBinder whoThread, String callingPackage, Intent intent, String resolvedType, Bundle bOptions) {
            TaskRecord tr;
            IApplicationThread appThread;
            checkCaller();
            int callingUser = UserHandle.getCallingUserId();
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    tr = ActivityManagerService.this.mStackSupervisor.anyTaskForIdLocked(this.mTaskId);
                    if (tr == null) {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                    appThread = ApplicationThreadNative.asInterface(whoThread);
                    if (appThread == null) {
                        throw new IllegalArgumentException("Bad app thread " + appThread);
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return ActivityManagerService.this.mActivityStarter.startActivityMayWait(appThread, -1, callingPackage, intent, resolvedType, null, null, null, null, 0, 0, null, null, null, bOptions, false, callingUser, null, tr);
        }

        public void setExcludeFromRecents(boolean exclude) {
            checkCaller();
            synchronized (ActivityManagerService.this) {
                long origId;
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    origId = Binder.clearCallingIdentity();
                    TaskRecord tr = ActivityManagerService.this.mStackSupervisor.anyTaskForIdLocked(this.mTaskId);
                    if (tr == null) {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                    Intent intent = tr.getBaseIntent();
                    if (exclude) {
                        intent.addFlags(8388608);
                    } else {
                        intent.setFlags(intent.getFlags() & -8388609);
                    }
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }
    }

    static final class Association {
        int mCount;
        int mLastState = 17;
        long mLastStateUptime;
        int mNesting;
        final String mSourceProcess;
        final int mSourceUid;
        long mStartTime;
        long[] mStateTimes = new long[18];
        final ComponentName mTargetComponent;
        final String mTargetProcess;
        final int mTargetUid;
        long mTime;

        Association(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent, String targetProcess) {
            this.mSourceUid = sourceUid;
            this.mSourceProcess = sourceProcess;
            this.mTargetUid = targetUid;
            this.mTargetComponent = targetComponent;
            this.mTargetProcess = targetProcess;
        }
    }

    static class CpuBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        CpuBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (this.mActivityManagerService.checkCallingPermission("android.permission.DUMP") != 0) {
                pw.println("Permission Denial: can't dump cpuinfo from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + "android.permission.DUMP");
                return;
            }
            synchronized (this.mActivityManagerService.mProcessCpuTracker) {
                pw.print(this.mActivityManagerService.mProcessCpuTracker.printCurrentLoad());
                pw.print(this.mActivityManagerService.mProcessCpuTracker.printCurrentState(SystemClock.uptimeMillis()));
            }
        }
    }

    static class DbBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        DbBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (this.mActivityManagerService.checkCallingPermission("android.permission.DUMP") != 0) {
                pw.println("Permission Denial: can't dump dbinfo from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + "android.permission.DUMP");
            } else {
                this.mActivityManagerService.dumpDbInfo(fd, pw, args);
            }
        }
    }

    private final class FontScaleSettingObserver extends ContentObserver {
        private final Uri mFontScaleUri = System.getUriFor("font_scale");

        public FontScaleSettingObserver() {
            super(ActivityManagerService.this.mHandler);
            ActivityManagerService.this.mContext.getContentResolver().registerContentObserver(this.mFontScaleUri, false, this, -1);
        }

        public void onChange(boolean selfChange, Uri uri, int userId) {
            if (this.mFontScaleUri.equals(uri)) {
                ActivityManagerService.this.updateFontScaleIfNeeded(userId);
            }
        }
    }

    public static class GrantUri {
        public boolean prefix;
        public final int sourceUserId;
        public final Uri uri;

        public GrantUri(int sourceUserId, Uri uri, boolean prefix) {
            this.sourceUserId = sourceUserId;
            this.uri = uri;
            this.prefix = prefix;
        }

        public int hashCode() {
            return ((((this.sourceUserId + 31) * 31) + this.uri.hashCode()) * 31) + (this.prefix ? 1231 : 1237);
        }

        public boolean equals(Object o) {
            boolean z = false;
            if (!(o instanceof GrantUri)) {
                return false;
            }
            GrantUri other = (GrantUri) o;
            if (this.uri.equals(other.uri) && this.sourceUserId == other.sourceUserId && this.prefix == other.prefix) {
                z = true;
            }
            return z;
        }

        public String toString() {
            String result = Integer.toString(this.sourceUserId) + " @ " + this.uri.toString();
            if (this.prefix) {
                return result + " [prefix]";
            }
            return result;
        }

        public String toSafeString() {
            String result = Integer.toString(this.sourceUserId) + " @ " + this.uri.toSafeString();
            if (this.prefix) {
                return result + " [prefix]";
            }
            return result;
        }

        public static GrantUri resolve(int defaultSourceUserHandle, Uri uri) {
            return new GrantUri(ContentProvider.getUserIdFromUri(uri, defaultSourceUserHandle), ContentProvider.getUriWithoutUserId(uri), false);
        }
    }

    static class GraphicsBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        GraphicsBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (this.mActivityManagerService.checkCallingPermission("android.permission.DUMP") != 0) {
                pw.println("Permission Denial: can't dump gfxinfo from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + "android.permission.DUMP");
            } else {
                this.mActivityManagerService.dumpGraphicsHardwareUsage(fd, pw, args);
            }
        }
    }

    private class Identity {
        public final int pid;
        public final IBinder token;
        public final int uid;

        Identity(IBinder _token, int _pid, int _uid) {
            this.token = _token;
            this.pid = _pid;
            this.uid = _uid;
        }
    }

    class IntentFirewallInterface implements AMSInterface {
        IntentFirewallInterface() {
        }

        public int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) {
            return ActivityManagerService.this.checkComponentPermission(permission, pid, uid, owningUid, exported);
        }

        public Object getAMSLock() {
            return ActivityManagerService.this;
        }
    }

    static class ItemMatcher {
        boolean all = true;
        ArrayList<ComponentName> components;
        ArrayList<Integer> objects;
        ArrayList<String> strings;

        ItemMatcher() {
        }

        void build(String name) {
            ComponentName componentName = ComponentName.unflattenFromString(name);
            if (componentName != null) {
                if (this.components == null) {
                    this.components = new ArrayList();
                }
                this.components.add(componentName);
                this.all = false;
                return;
            }
            try {
                int objectId = Integer.parseInt(name, 16);
                if (this.objects == null) {
                    this.objects = new ArrayList();
                }
                this.objects.add(Integer.valueOf(objectId));
                this.all = false;
            } catch (RuntimeException e) {
                if (this.strings == null) {
                    this.strings = new ArrayList();
                }
                this.strings.add(name);
                this.all = false;
            }
        }

        int build(String[] args, int opti) {
            while (opti < args.length) {
                String name = args[opti];
                if ("--".equals(name)) {
                    return opti + 1;
                }
                build(name);
                opti++;
            }
            return opti;
        }

        boolean match(Object object, ComponentName comp) {
            if (this.all) {
                return true;
            }
            int i;
            if (this.components != null) {
                for (i = 0; i < this.components.size(); i++) {
                    if (((ComponentName) this.components.get(i)).equals(comp)) {
                        return true;
                    }
                }
            }
            if (this.objects != null) {
                for (i = 0; i < this.objects.size(); i++) {
                    if (System.identityHashCode(object) == ((Integer) this.objects.get(i)).intValue()) {
                        return true;
                    }
                }
            }
            if (this.strings != null) {
                String flat = comp.flattenToString();
                for (i = 0; i < this.strings.size(); i++) {
                    if (flat.contains((CharSequence) this.strings.get(i))) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    final class KillHandler extends Handler {
        static final int KILL_PROCESS_GROUP_MSG = 4000;

        public KillHandler(Looper looper) {
            super(looper, null, true);
        }

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case KILL_PROCESS_GROUP_MSG /*4000*/:
                    Trace.traceBegin(64, "killProcessGroup");
                    Process.killProcessGroup(msg.arg1, msg.arg2);
                    Trace.traceEnd(64);
                    return;
                default:
                    super.handleMessage(msg);
                    return;
            }
        }
    }

    public static final class Lifecycle extends SystemService {
        private final ActivityManagerService mService;

        public Lifecycle(Context context) {
            super(context);
            BootEvent.setEnabled(true);
            this.mService = new OppoActivityManagerService(context);
        }

        public void onStart() {
            this.mService.start();
        }

        public ActivityManagerService getService() {
            return this.mService;
        }
    }

    private final class LocalService extends ActivityManagerInternal {
        /* synthetic */ LocalService(ActivityManagerService this$0, LocalService localService) {
            this();
        }

        private LocalService() {
        }

        public String checkContentProviderAccess(String authority, int userId) {
            return ActivityManagerService.this.checkContentProviderAccess(authority, userId);
        }

        public void onWakefulnessChanged(int wakefulness) {
            ActivityManagerService.this.onWakefulnessChanged(wakefulness);
        }

        public int startIsolatedProcess(String entryPoint, String[] entryPointArgs, String processName, String abiOverride, int uid, Runnable crashHandler) {
            return ActivityManagerService.this.startIsolatedProcess(entryPoint, entryPointArgs, processName, abiOverride, uid, crashHandler);
        }

        public SleepToken acquireSleepToken(String tag) {
            SleepTokenImpl token;
            Preconditions.checkNotNull(tag);
            ComponentName requestedVrService = null;
            ComponentName callingVrActivity = null;
            int userId = -1;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    if (ActivityManagerService.this.mFocusedActivity != null) {
                        requestedVrService = ActivityManagerService.this.mFocusedActivity.requestedVrComponent;
                        callingVrActivity = ActivityManagerService.this.mFocusedActivity.info.getComponentName();
                        userId = ActivityManagerService.this.mFocusedActivity.userId;
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            if (requestedVrService != null) {
                ActivityManagerService.this.applyVrMode(false, requestedVrService, userId, callingVrActivity, true);
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    token = new SleepTokenImpl(tag);
                    ActivityManagerService.this.mSleepTokens.add(token);
                    ActivityManagerService.this.updateSleepIfNeededLocked();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return token;
        }

        public ComponentName getHomeActivityForUser(int userId) {
            ComponentName componentName = null;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityRecord homeActivity = ActivityManagerService.this.mStackSupervisor.getHomeActivityForUser(userId);
                    if (homeActivity != null) {
                        componentName = homeActivity.realActivity;
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return componentName;
        }

        public void onUserRemoved(int userId) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.onUserStoppedLocked(userId);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void onLocalVoiceInteractionStarted(IBinder activity, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.onLocalVoiceInteractionStartedLocked(activity, voiceSession, voiceInteractor);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void notifyStartingWindowDrawn() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.mActivityMetricsLogger.notifyStartingWindowDrawn();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void notifyAppTransitionStarting(int reason) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.mActivityMetricsLogger.notifyTransitionStarting(reason);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void notifyAppTransitionFinished() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.notifyAppTransitionDone();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void notifyAppTransitionCancelled() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.notifyAppTransitionDone();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public List<IBinder> getTopVisibleActivities() {
            List<IBinder> topVisibleActivities;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    topVisibleActivities = ActivityManagerService.this.mStackSupervisor.getTopVisibleActivities();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return topVisibleActivities;
        }

        public void notifyDockedStackMinimizedChanged(boolean minimized) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.setDockedStackMinimized(minimized);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void killForegroundAppsForUser(int userHandle) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ArrayList<ProcessRecord> procs = new ArrayList();
                    int NP = ActivityManagerService.this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> apps = (SparseArray) ActivityManagerService.this.mProcessNames.getMap().valueAt(ip);
                        int NA = apps.size();
                        for (int ia = 0; ia < NA; ia++) {
                            ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                            if (!app.persistent) {
                                if (app.removed) {
                                    procs.add(app);
                                } else if (app.userId == userHandle && app.foregroundActivities) {
                                    app.removed = true;
                                    procs.add(app);
                                }
                            }
                        }
                    }
                    int N = procs.size();
                    for (int i = 0; i < N; i++) {
                        ActivityManagerService.this.removeProcessLocked((ProcessRecord) procs.get(i), false, true, "kill all fg");
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void setPendingIntentWhitelistDuration(IIntentSender target, long duration) {
            if (target instanceof PendingIntentRecord) {
                ((PendingIntentRecord) target).setWhitelistDuration(duration);
            } else {
                Slog.w(ActivityManagerService.TAG, "markAsSentFromNotification(): not a PendingIntentRecord: " + target);
            }
        }

        public void updatePersistentConfigurationForUser(Configuration values, int userId) {
            Preconditions.checkNotNull(values, "Configuration must not be null");
            Preconditions.checkArgumentNonnegative(userId, "userId " + userId + " not supported");
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.updateConfigurationLocked(values, null, false, true, userId, false);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public int startActivitiesAsPackage(String packageName, int userId, Intent[] intents, Bundle bOptions) {
            int startActivitiesInPackage;
            Preconditions.checkNotNull(intents, "intents");
            String[] resolvedTypes = new String[intents.length];
            for (int i = 0; i < intents.length; i++) {
                resolvedTypes[i] = intents[i].resolveTypeIfNeeded(ActivityManagerService.this.mContext.getContentResolver());
            }
            int packageUid = 0;
            try {
                packageUid = AppGlobals.getPackageManager().getPackageUid(packageName, 268435456, userId);
            } catch (RemoteException e) {
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    startActivitiesInPackage = ActivityManagerService.this.startActivitiesInPackage(packageUid, packageName, intents, resolvedTypes, null, bOptions, userId);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return startActivitiesInPackage;
        }

        public int getUidProcessState(int uid) {
            return ActivityManagerService.this.getUidState(uid);
        }
    }

    final class MainHandler extends Handler {
        public MainHandler(Looper looper) {
            super(looper, null, true);
        }

        public void handleMessage(Message msg) {
            Message nmsg;
            int i;
            ProcessRecord r;
            ProcessRecord app;
            Context context;
            Object[] objArr;
            String text;
            INotificationManager inm;
            ActivityRecord r2;
            int uid;
            int userId;
            switch (msg.what) {
                case 4:
                    System.putConfigurationForUser(ActivityManagerService.this.mContext.getContentResolver(), (Configuration) msg.obj, msg.arg1);
                    break;
                case 5:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.performAppGcsIfAppropriateLocked();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 12:
                    if (ActivityManagerService.mANRManager.isAnrDeferrable()) {
                        Slog.d(ActivityManagerService.TAG, "Skip SERVICE_TIMEOUT ANR: " + msg.obj);
                        ActivityManagerService.this.mDidDexOpt = true;
                    }
                    ProcessRecord pr = msg.obj;
                    if (pr == null || !pr.isWaitingPermissionChoice) {
                        if (!ActivityManagerService.this.mDidDexOpt) {
                            if (!ActivityManagerService.this.isDoingDexopt(pr != null ? pr.uid : 0)) {
                                ActivityManagerService.this.mServices.serviceTimeout((ProcessRecord) msg.obj);
                                break;
                            }
                        }
                        if (ActivityManagerService.this.mDidDexOpt) {
                            ActivityManagerService.this.mDidDexOpt = false;
                        }
                        nmsg = ActivityManagerService.this.mHandler.obtainMessage(12);
                        nmsg.obj = msg.obj;
                        ActivityManagerService.this.mHandler.sendMessageDelayed(nmsg, ActivityManagerService.APP_DEXOPT_TIMEOUT);
                        return;
                    }
                    nmsg = ActivityManagerService.this.mHandler.obtainMessage(12);
                    nmsg.obj = msg.obj;
                    ActivityManagerService.this.mHandler.sendMessageDelayed(nmsg, ActivityManagerService.APP_DEXOPT_TIMEOUT);
                    return;
                case 13:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.updateTimeZone();
                                }
                            }
                        } catch (RemoteException e) {
                            Slog.w(ActivityManagerService.TAG, "Failed to update time zone for: " + r.info.processName);
                        } catch (Throwable th) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 20:
                    if (ActivityManagerService.mANRManager.isAnrDeferrable()) {
                        Slog.d(ActivityManagerService.TAG, "Skip PROC_START_TIMEOUT: " + msg.obj);
                        ActivityManagerService.this.mDidDexOpt = true;
                    }
                    if (!ActivityManagerService.this.mDidDexOpt) {
                        app = msg.obj;
                        synchronized (ActivityManagerService.this) {
                            try {
                                ActivityManagerService.boostPriorityForLockedSection();
                                ActivityManagerService.this.processStartTimedOutLocked(app);
                            } finally {
                                ActivityManagerService.resetPriorityAfterLockedSection();
                            }
                        }
                        break;
                    }
                    ActivityManagerService.this.mDidDexOpt = false;
                    nmsg = ActivityManagerService.this.mHandler.obtainMessage(20);
                    nmsg.obj = msg.obj;
                    ActivityManagerService.this.mHandler.sendMessageDelayed(nmsg, 10000);
                    return;
                case 21:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mActivityStarter.doPendingActivityLaunchesLocked(true);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 22:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            Bundle bundle = msg.obj;
                            ActivityManagerService.this.forceStopPackageLocked(bundle.getString("pkg"), msg.arg1, false, false, true, false, false, msg.arg2, bundle.getString(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY));
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 23:
                    ((PendingIntentRecord) msg.obj).completeFinalize();
                    break;
                case 24:
                    INotificationManager inm2 = NotificationManager.getService();
                    if (inm2 != null) {
                        ActivityRecord root = msg.obj;
                        ProcessRecord process = root.app;
                        if (process != null) {
                            try {
                                Context context2 = ActivityManagerService.this.mContext.createPackageContext(process.info.packageName, 0);
                                context = ActivityManagerService.this.mContext;
                                objArr = new Object[1];
                                objArr[0] = context2.getApplicationInfo().loadLabel(context2.getPackageManager());
                                text = context.getString(17040320, objArr);
                                try {
                                    inm2.enqueueNotificationWithTag("android", "android", null, 17040320, new Builder(context2).setSmallIcon(17303262).setWhen(0).setOngoing(true).setTicker(text).setColor(ActivityManagerService.this.mContext.getColor(17170523)).setContentTitle(text).setContentText(ActivityManagerService.this.mContext.getText(17040321)).setContentIntent(PendingIntent.getActivityAsUser(ActivityManagerService.this.mContext, 0, root.intent, 268435456, null, new UserHandle(root.userId))).build(), new int[1], root.userId);
                                    break;
                                } catch (Throwable e2) {
                                    Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e2);
                                    break;
                                } catch (RemoteException e3) {
                                    break;
                                }
                            } catch (Throwable e4) {
                                Slog.w(ActivityManagerService.TAG, "Unable to create context for heavy notification", e4);
                                break;
                            }
                        }
                        return;
                    }
                    return;
                case 25:
                    inm = NotificationManager.getService();
                    if (inm != null) {
                        try {
                            inm.cancelNotificationWithTag("android", null, 17040320, msg.arg1);
                            break;
                        } catch (Throwable e22) {
                            Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e22);
                            break;
                        } catch (RemoteException e5) {
                            break;
                        }
                    }
                    return;
                case 27:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.checkExcessivePowerUsageLocked(true);
                            removeMessages(27);
                            sendMessageDelayed(obtainMessage(27), (long) ActivityManagerService.POWER_CHECK_DELAY);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 28:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.clearDnsCache();
                                }
                            }
                        } catch (RemoteException e6) {
                            Slog.w(ActivityManagerService.TAG, "Failed to clear dns cache for: " + r.info.processName);
                        } catch (Throwable th2) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 29:
                    ProxyInfo proxy = msg.obj;
                    String host = IElsaManager.EMPTY_PACKAGE;
                    String port = IElsaManager.EMPTY_PACKAGE;
                    String exclList = IElsaManager.EMPTY_PACKAGE;
                    Uri pacFileUrl = Uri.EMPTY;
                    if (proxy != null) {
                        host = proxy.getHost();
                        port = Integer.toString(proxy.getPort());
                        exclList = proxy.getExclusionListAsString();
                        pacFileUrl = proxy.getPacFileUrl();
                    }
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                                }
                            }
                        } catch (RemoteException e7) {
                            Slog.w(ActivityManagerService.TAG, "Failed to update http proxy for: " + r.info.processName);
                        } catch (Throwable th3) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 33:
                    final ArrayList<ProcessMemInfo> arrayList = msg.obj;
                    new Thread() {
                        public void run() {
                            ActivityManagerService.this.reportMemUsage(arrayList);
                        }
                    }.start();
                    break;
                case 34:
                    ActivityManagerService.this.mUserController.dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                    break;
                case 35:
                    ActivityManagerService.this.mUserController.continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                    break;
                case 36:
                    ActivityManagerService.this.mUserController.timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                    break;
                case 37:
                    boolean nextState = msg.arg1 != 0;
                    if (ActivityManagerService.this.mUpdateLock.isHeld() != nextState) {
                        if (ActivityManagerDebugConfig.DEBUG_IMMERSIVE) {
                            Slog.d(ActivityManagerService.TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + ((ActivityRecord) msg.obj));
                        }
                        if (!nextState) {
                            ActivityManagerService.this.mUpdateLock.release();
                            break;
                        } else {
                            ActivityManagerService.this.mUpdateLock.acquire();
                            break;
                        }
                    }
                    break;
                case 38:
                    ActivityManagerService.this.writeGrantedUriPermissions();
                    break;
                case 39:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 40:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mUserController.startProfilesLocked();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 41:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.updateTimePrefs(msg.arg1 != 0);
                                }
                            }
                        } catch (RemoteException e8) {
                            Slog.w(ActivityManagerService.TAG, "Failed to update preferences for: " + r.info.processName);
                        } catch (Throwable th4) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 42:
                    ActivityManagerService.this.mBatteryStatsService.noteEvent(32775, Integer.toString(msg.arg1), msg.arg1);
                    ActivityManagerService.this.mSystemServiceManager.startUser(msg.arg1);
                    break;
                case 43:
                    ActivityManagerService.this.mBatteryStatsService.noteEvent(16392, Integer.toString(msg.arg2), msg.arg2);
                    ActivityManagerService.this.mBatteryStatsService.noteEvent(32776, Integer.toString(msg.arg1), msg.arg1);
                    ActivityManagerService.this.mSystemServiceManager.switchUser(msg.arg1);
                    break;
                case 44:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            r2 = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                            if (!(r2 == null || r2.app == null || r2.app.thread == null)) {
                                try {
                                    r2.app.thread.scheduleEnterAnimationComplete(r2.appToken);
                                } catch (RemoteException e9) {
                                }
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 45:
                    if (msg.arg1 != 0) {
                        Trace.traceBegin(64, "FinishBooting");
                        ActivityManagerService.this.finishBooting();
                        Trace.traceEnd(64);
                    }
                    if (msg.arg2 != 0) {
                        ActivityManagerService.this.enableScreenAfterBoot();
                        break;
                    }
                    break;
                case 47:
                    try {
                        Locale l = msg.obj;
                        IMountService mountService = IMountService.Stub.asInterface(ServiceManager.getService(OppoProcessManager.RESUME_REASON_MOUNT_STR));
                        Log.d(ActivityManagerService.TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                        mountService.setField("SystemLocale", l.toLanguageTag());
                        break;
                    } catch (Throwable e10) {
                        Log.e(ActivityManagerService.TAG, "Error storing locale for decryption UI", e10);
                        break;
                    }
                case 49:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                                try {
                                    ((ITaskStackListener) ActivityManagerService.this.mTaskStackListeners.getBroadcastItem(i)).onTaskStackChanged();
                                } catch (RemoteException e11) {
                                }
                            }
                            ActivityManagerService.this.mTaskStackListeners.finishBroadcast();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 50:
                    uid = msg.arg1;
                    byte[] firstPacket = (byte[]) msg.obj;
                    synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                        for (i = 0; i < ActivityManagerService.this.mPidsSelfLocked.size(); i++) {
                            ProcessRecord p = (ProcessRecord) ActivityManagerService.this.mPidsSelfLocked.valueAt(i);
                            if (p.uid == uid) {
                                try {
                                    p.thread.notifyCleartextNetwork(firstPacket);
                                } catch (RemoteException e12) {
                                }
                            }
                        }
                    }
                case 51:
                    String procName;
                    long memLimit;
                    String reportPackage;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            procName = ActivityManagerService.this.mMemWatchDumpProcName;
                            uid = ActivityManagerService.this.mMemWatchDumpUid;
                            Pair<Long, String> val = (Pair) ActivityManagerService.this.mMemWatchProcesses.get(procName, uid);
                            if (val == null) {
                                val = (Pair) ActivityManagerService.this.mMemWatchProcesses.get(procName, 0);
                            }
                            if (val != null) {
                                memLimit = ((Long) val.first).longValue();
                                reportPackage = (String) val.second;
                            } else {
                                memLimit = 0;
                                reportPackage = null;
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    if (procName != null) {
                        if (ActivityManagerDebugConfig.DEBUG_PSS) {
                            Slog.d(ActivityManagerService.TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                        }
                        inm = NotificationManager.getService();
                        if (inm != null) {
                            context = ActivityManagerService.this.mContext;
                            objArr = new Object[1];
                            objArr[0] = procName;
                            text = context.getString(17040328, objArr);
                            Intent deleteIntent = new Intent();
                            deleteIntent.setAction("com.android.server.am.DELETE_DUMPHEAP");
                            Intent intent = new Intent();
                            intent.setClassName("android", DumpHeapActivity.class.getName());
                            intent.putExtra("process", procName);
                            intent.putExtra("size", memLimit);
                            if (reportPackage != null) {
                                intent.putExtra("direct_launch", reportPackage);
                            }
                            userId = UserHandle.getUserId(uid);
                            try {
                                inm.enqueueNotificationWithTag("android", "android", null, 17040328, new Builder(ActivityManagerService.this.mContext).setSmallIcon(17303262).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(ActivityManagerService.this.mContext.getColor(17170523)).setContentTitle(text).setContentText(ActivityManagerService.this.mContext.getText(17040329)).setContentIntent(PendingIntent.getActivityAsUser(ActivityManagerService.this.mContext, 0, intent, 268435456, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(ActivityManagerService.this.mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build(), new int[1], userId);
                                break;
                            } catch (Throwable e222) {
                                Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e222);
                                break;
                            } catch (RemoteException e13) {
                                break;
                            }
                        }
                        return;
                    }
                    return;
                case 52:
                    ActivityManagerService.this.revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, 3, UserHandle.myUserId());
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mMemWatchDumpFile = null;
                            ActivityManagerService.this.mMemWatchDumpProcName = null;
                            ActivityManagerService.this.mMemWatchDumpPid = -1;
                            ActivityManagerService.this.mMemWatchDumpUid = -1;
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 53:
                    ActivityManagerService.this.mUserController.dispatchForegroundProfileChanged(msg.arg1);
                    break;
                case 55:
                    msg.obj.deliverResult(ActivityManagerService.this.mContext);
                    break;
                case 56:
                    ActivityManagerService.this.mUserController.dispatchUserSwitchComplete(msg.arg1);
                    break;
                case ActivityManagerService.SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG /*57*/:
                    try {
                        msg.obj.shutdown();
                    } catch (RemoteException e14) {
                        Slog.w(ActivityManagerService.TAG, "Error shutting down UiAutomationConnection");
                    }
                    ActivityManagerService.this.mUserIsMonkey = false;
                    break;
                case ActivityManagerService.APP_BOOST_DEACTIVATE_MSG /*58*/:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            if (ActivityManagerService.this.mIsBoosted) {
                                if (ActivityManagerService.this.mBoostStartTime < SystemClock.uptimeMillis() - 2500) {
                                    ActivityManagerService.nativeMigrateFromBoost();
                                    ActivityManagerService.this.mIsBoosted = false;
                                    ActivityManagerService.this.mBoostStartTime = 0;
                                } else {
                                    ActivityManagerService.this.mHandler.sendMessageDelayed(ActivityManagerService.this.mHandler.obtainMessage(ActivityManagerService.APP_BOOST_DEACTIVATE_MSG), 2500);
                                }
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case ActivityManagerService.CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG /*59*/:
                    app = (ProcessRecord) msg.obj;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.processContentProviderPublishTimedOutLocked(app);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 60:
                    ActivityManagerService.this.idleUids();
                    break;
                case ActivityManagerService.SYSTEM_USER_UNLOCK_MSG /*61*/:
                    userId = msg.arg1;
                    ActivityManagerService.this.mSystemServiceManager.unlockUser(userId);
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mRecentTasks.loadUserRecentsLocked(userId);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    if (userId == 0) {
                        ActivityManagerService.this.startPersistentApps(DumpState.DUMP_DOMAIN_PREFERRED);
                    }
                    ActivityManagerService.this.installEncryptionUnawareProviders(userId);
                    if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support"))) {
                        SystemUserUnlock eventData = SystemUserUnlock.createInstance();
                        Object[] objArr2 = new Object[1];
                        objArr2[0] = Integer.valueOf(userId);
                        eventData.set(objArr2);
                        ActivityManagerService.this.mAMEventHook.hook(Event.AM_SystemUserUnlock, eventData);
                    }
                    ActivityManagerService.this.mUserController.finishUserUnlocked((UserState) msg.obj);
                    break;
                case ActivityManagerService.LOG_STACK_STATE /*62*/:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mStackSupervisor.logStackState();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 63:
                    boolean vrMode;
                    ComponentName requestedPackage;
                    ComponentName callingPackage;
                    VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
                    r2 = (ActivityRecord) msg.obj;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            vrMode = r2.requestedVrComponent != null;
                            requestedPackage = r2.requestedVrComponent;
                            userId = r2.userId;
                            callingPackage = r2.info.getComponentName();
                            if (ActivityManagerService.this.mInVrMode != vrMode) {
                                ActivityManagerService.this.mInVrMode = vrMode;
                                ActivityManagerService.this.mShowDialogs = ActivityManagerService.shouldShowDialogs(ActivityManagerService.this.mConfiguration, ActivityManagerService.this.mInVrMode);
                                if (r2.app != null) {
                                    ProcessRecord proc = r2.app;
                                    if (proc.vrThreadTid > 0 && proc.curSchedGroup == 2) {
                                        if (ActivityManagerService.this.mInVrMode) {
                                            Process.setThreadScheduler(proc.vrThreadTid, 1073741825, 1);
                                        } else {
                                            Process.setThreadScheduler(proc.vrThreadTid, 0, 0);
                                        }
                                    }
                                }
                            }
                        } catch (IllegalArgumentException e15) {
                            Slog.w(ActivityManagerService.TAG, "Failed to set scheduling policy, thread does not exist:\n" + e15);
                        } catch (Throwable th5) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    vrService.setVrMode(vrMode, requestedPackage, userId, callingPackage);
                    break;
                case 64:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                                try {
                                    ((ITaskStackListener) ActivityManagerService.this.mTaskStackListeners.getBroadcastItem(i)).onActivityPinned();
                                } catch (RemoteException e16) {
                                }
                            }
                            ActivityManagerService.this.mTaskStackListeners.finishBroadcast();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 65:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                                try {
                                    ((ITaskStackListener) ActivityManagerService.this.mTaskStackListeners.getBroadcastItem(i)).onPinnedActivityRestartAttempt();
                                } catch (RemoteException e17) {
                                }
                            }
                            ActivityManagerService.this.mTaskStackListeners.finishBroadcast();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 66:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                                try {
                                    ((ITaskStackListener) ActivityManagerService.this.mTaskStackListeners.getBroadcastItem(i)).onPinnedStackAnimationEnded();
                                } catch (RemoteException e18) {
                                }
                            }
                            ActivityManagerService.this.mTaskStackListeners.finishBroadcast();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 67:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                                try {
                                    ((ITaskStackListener) ActivityManagerService.this.mTaskStackListeners.getBroadcastItem(i)).onActivityForcedResizable((String) msg.obj, msg.arg1);
                                } catch (RemoteException e19) {
                                }
                            }
                            ActivityManagerService.this.mTaskStackListeners.finishBroadcast();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 68:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                                try {
                                    ((ITaskStackListener) ActivityManagerService.this.mTaskStackListeners.getBroadcastItem(i)).onActivityDismissingDockedStack();
                                } catch (RemoteException e20) {
                                }
                            }
                            ActivityManagerService.this.mTaskStackListeners.finishBroadcast();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 69:
                    r2 = (ActivityRecord) msg.obj;
                    boolean needsVrMode = (r2 == null || r2.requestedVrComponent == null) ? false : true;
                    if (needsVrMode) {
                        ActivityManagerService.this.applyVrMode(msg.arg1 == 1, r2.requestedVrComponent, r2.userId, r2.info.getComponentName(), false);
                        break;
                    }
                    break;
                case 400:
                    Slog.d(ActivityManagerService.TAG, "reset mIgnoreSleepCheckLater");
                    ActivityManagerService.this.mIgnoreSleepCheckLater = false;
                    break;
                case 401:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.checkExcessivePowerUsageLocked(false);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 500:
                    Intent in = msg.obj;
                    in.addFlags(1024);
                    ActivityManagerService.this.mContext.startActivity(Intent.createChooser(in, null).addFlags(67109376), null);
                    break;
                case ActivityManagerService.START_FORCESTOP_MSG /*511*/:
                    String localPkg = msg.obj;
                    ArraySet<Integer> pidsSet = ActivityManagerService.this.getPidsForPackage(localPkg);
                    if (!(ActivityManagerService.this.mFocusedActivity == null || localPkg == null)) {
                        if (!localPkg.equals(ActivityManagerService.this.mFocusedActivity.packageName)) {
                            if (!OppoSplitWindowAppReader.isInBackStopFilterList(ActivityManagerService.this.mContext, localPkg, pidsSet, msg.arg1)) {
                                Slog.d(ActivityManagerService.TAG, "pkgName: " + localPkg + " userId: " + msg.arg1 + " killed for back_key");
                                ActivityManagerService.this.forceStopPackage(localPkg, msg.arg1);
                                break;
                            }
                        }
                    }
                    break;
                case ActivityManagerService.START_OPPO_SITE_MSG /*700*/:
                    String in2 = msg.obj;
                    Intent intent2 = new Intent("android.intent.action.WEB_SEARCH");
                    intent2.addFlags(268435456);
                    intent2.putExtra(ActivityManagerService.INTENT_QUERY_EXTRA, in2);
                    ActivityManagerService.this.mContext.startActivity(intent2);
                    break;
            }
        }
    }

    static class MemBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        MemBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (this.mActivityManagerService.checkCallingPermission("android.permission.DUMP") != 0) {
                pw.println("Permission Denial: can't dump meminfo from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + "android.permission.DUMP");
                return;
            }
            Slog.i("dumpsys_meminfo", "dump meminfo form pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
            this.mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, "  ", args, false, null);
        }
    }

    static final class MemItem {
        final boolean hasActivities;
        final int id;
        final boolean isProc = false;
        final String label;
        final long pss;
        final String shortLabel;
        ArrayList<MemItem> subitems;
        final long swapPss;

        public MemItem(String _label, String _shortLabel, long _pss, long _swapPss, int _id, boolean _hasActivities) {
            this.label = _label;
            this.shortLabel = _shortLabel;
            this.pss = _pss;
            this.swapPss = _swapPss;
            this.id = _id;
            this.hasActivities = _hasActivities;
        }

        public MemItem(String _label, String _shortLabel, long _pss, long _swapPss, int _id) {
            this.label = _label;
            this.shortLabel = _shortLabel;
            this.pss = _pss;
            this.swapPss = _swapPss;
            this.id = _id;
            this.hasActivities = false;
        }
    }

    static class NeededUriGrants extends ArrayList<GrantUri> {
        final int flags;
        final String targetPkg;
        final int targetUid;

        NeededUriGrants(String targetPkg, int targetUid, int flags) {
            this.targetPkg = targetPkg;
            this.targetUid = targetUid;
            this.flags = flags;
        }
    }

    public class PendingAssistExtras extends Binder implements Runnable {
        public final ActivityRecord activity;
        public AssistContent content = null;
        public final Bundle extras;
        public boolean haveResult = false;
        public final String hint;
        public final Intent intent;
        public final IResultReceiver receiver;
        public Bundle receiverExtras;
        public Bundle result = null;
        public AssistStructure structure = null;
        public final int userHandle;

        public PendingAssistExtras(ActivityRecord _activity, Bundle _extras, Intent _intent, String _hint, IResultReceiver _receiver, Bundle _receiverExtras, int _userHandle) {
            this.activity = _activity;
            this.extras = _extras;
            this.intent = _intent;
            this.hint = _hint;
            this.receiver = _receiver;
            this.receiverExtras = _receiverExtras;
            this.userHandle = _userHandle;
        }

        public void run() {
            Slog.w(ActivityManagerService.TAG, "getAssistContextExtras failed: timeout retrieving from " + this.activity);
            synchronized (this) {
                this.haveResult = true;
                notifyAll();
            }
            ActivityManagerService.this.pendingAssistExtrasTimedOut(this);
        }
    }

    static class PermissionController extends IPermissionController.Stub {
        ActivityManagerService mActivityManagerService;

        PermissionController(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        @OppoHook(level = OppoHookType.CHANGE_CODE, note = "WangLan@Plf.Framework, modify for permission intercept", property = OppoRomType.OPPO)
        public boolean checkPermission(String permission, int pid, int uid) {
            boolean z = true;
            int newUid = uid;
            if (UserHandle.getUserId(uid) == OppoMultiAppManager.USER_ID) {
                newUid = UserHandle.getUid(this.mActivityManagerService.mUserController.getCurrentUserIdLocked(), UserHandle.getAppId(uid));
                Slog.d(ActivityManagerService.TAG, "multi app: checkPermission uid from " + uid + " to " + newUid);
            }
            if (Binder.getCallingUid() < 10000) {
                if (permission.startsWith(OppoPermissionConstants.PERMISSION_SEND_SMS)) {
                    permission = OppoPermissionConstants.PERMISSION_SEND_SMS;
                } else if (permission.startsWith(OppoPermissionConstants.PERMISSION_CALL_PHONE)) {
                    permission = OppoPermissionConstants.PERMISSION_CALL_PHONE;
                }
                if (this.mActivityManagerService.checkPermission(permission, pid, newUid) != 0) {
                    z = false;
                }
                return z;
            }
            if (OppoPermissionCallback.checkOppoPermission(permission, pid, newUid, this.mActivityManagerService) != 0) {
                z = false;
            }
            return z;
        }

        public String[] getPackagesForUid(int uid) {
            return this.mActivityManagerService.mContext.getPackageManager().getPackagesForUid(uid);
        }

        public boolean isRuntimePermission(String permission) {
            boolean z = true;
            try {
                if (this.mActivityManagerService.mContext.getPackageManager().getPermissionInfo(permission, 0).protectionLevel != 1) {
                    z = false;
                }
                return z;
            } catch (NameNotFoundException nnfe) {
                Slog.e(ActivityManagerService.TAG, "No such permission: " + permission, nnfe);
                return false;
            }
        }
    }

    private static final class PriorityState {
        private int prevPriority;
        private int regionCounter;

        /* synthetic */ PriorityState(PriorityState priorityState) {
            this();
        }

        private PriorityState() {
            this.regionCounter = 0;
            this.prevPriority = Integer.MIN_VALUE;
        }
    }

    static final class ProcessChangeItem {
        static final int CHANGE_ACTIVITIES = 1;
        static final int CHANGE_PROCESS_STATE = 2;
        int changes;
        boolean foregroundActivities;
        int pid;
        int processState;
        int uid;

        ProcessChangeItem() {
        }
    }

    static class ProcessInfoService extends IProcessInfoService.Stub {
        final ActivityManagerService mActivityManagerService;

        ProcessInfoService(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        public void getProcessStatesFromPids(int[] pids, int[] states) {
            this.mActivityManagerService.getProcessStatesAndOomScoresForPIDs(pids, states, null);
        }

        public void getProcessStatesAndOomScoresFromPids(int[] pids, int[] states, int[] scores) {
            this.mActivityManagerService.getProcessStatesAndOomScoresForPIDs(pids, states, scores);
        }
    }

    private final class SleepTokenImpl extends SleepToken {
        private final long mAcquireTime = SystemClock.uptimeMillis();
        private final String mTag;

        public SleepTokenImpl(String tag) {
            this.mTag = tag;
        }

        public void release() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    if (ActivityManagerService.this.mSleepTokens.remove(this)) {
                        ActivityManagerService.this.updateSleepIfNeededLocked();
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public String toString() {
            return "{\"" + this.mTag + "\", acquire at " + TimeUtils.formatUptime(this.mAcquireTime) + "}";
        }
    }

    public class SuppressManager {
        public static final int DOING_SUPPRESS_ADD = 0;
        public static final int DOING_SUPPRESS_FINISH = 2;
        public static final int DOING_SUPPRESS_SKIP = 1;

        public int checkCallingPermission(String permission) {
            return ActivityManagerService.this.checkCallingPermission(permission);
        }

        public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, int allowMode, String name, String callerPackage) {
            return ActivityManagerService.this.mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll, allowMode, "doSuppressPackage", callerPackage);
        }

        public void resumeFocusedStackTopActivityLocked() {
            ActivityManagerService.this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }

        public void scheduleIdleLocked() {
            ActivityManagerService.this.mStackSupervisor.scheduleIdleLocked();
        }

        public void broadcastIntentLocked(Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
            ActivityManagerService.this.broadcastIntentLocked(null, null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, options, ordered, sticky, callingPid, callingUid, userId);
        }

        public void triggerEventHook(Event event, Object data) {
            ActivityManagerService.this.mAMEventHook.hook(event, data);
        }

        public int[] getUsers() {
            return ActivityManagerService.this.mUserController.getUsers();
        }

        public BroadcastQueue[] getBroadcastQueues() {
            return ActivityManagerService.this.mBroadcastQueues;
        }

        public void resetProcessCrashTimeLocked(boolean resetEntireUser, int appId, int userId) {
            ActivityManagerService.this.mAppErrors.resetProcessCrashTimeLocked(resetEntireUser, appId, userId);
        }

        public boolean getBooted() {
            return ActivityManagerService.this.mBooted;
        }

        public boolean getProcessesReady() {
            return ActivityManagerService.this.mProcessesReady;
        }

        public ServiceThread getKillThread() {
            ActivityManagerService activityManagerService = ActivityManagerService.this;
            return ActivityManagerService.sKillThread;
        }

        public boolean isUserRunningLocked(int userId, int flags) {
            return ActivityManagerService.this.mUserController.isUserRunningLocked(userId, flags);
        }

        public boolean isSuppressedProcessesLocked(String packageName, ArrayList<Object> procs, int appId, int userId) {
            int NP = ActivityManagerService.this.mProcessNames.getMap().size();
            for (int ip = 0; ip < NP; ip++) {
                SparseArray<ProcessRecord> apps = (SparseArray) ActivityManagerService.this.mProcessNames.getMap().valueAt(ip);
                int NA = apps.size();
                for (int ia = 0; ia < NA; ia++) {
                    ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                    SuppressionInternal mSuppressionInternal = (SuppressionInternal) LocalServices.getService(SuppressionInternal.class);
                    if (mSuppressionInternal == null) {
                        return false;
                    }
                    int doingSuppress = mSuppressionInternal.doingSuppress(packageName, userId, appId, app.userId, app.uid, app.setAdj, app.pkgDeps, app.pkgList);
                    if (doingSuppress != 1) {
                        if (doingSuppress == 2) {
                            return false;
                        }
                        procs.add(app);
                    }
                }
            }
            for (int i = procs.size() - 1; i >= 0; i--) {
                ((ProcessRecord) procs.get(i)).removed = true;
            }
            return true;
        }

        public void killSuppressedProcessesLocked(String packageName, ArrayList<Object> procs, List<String> packageList, int userId) {
            SuppressionInternal mSuppressionInternal = (SuppressionInternal) LocalServices.getService(SuppressionInternal.class);
            if (mSuppressionInternal != null) {
                for (int i = 0; i < procs.size(); i++) {
                    ProcessRecord proc = (ProcessRecord) procs.get(i);
                    if (mSuppressionInternal.isAllPackagesInList(proc.pkgList, packageList)) {
                        ActivityManagerService.this.removeProcessLocked(proc, false, true, packageName == null ? "Suppress " + userId : "Suppress " + packageName);
                    }
                }
                ActivityManagerService.this.updateOomAdjLocked();
            }
        }

        public boolean bringDownDisabledPackageServicesLocked(String packageName, Set<String> filterByClasses, int userId, boolean evenPersistent, boolean killProcess, boolean doit) {
            return ActivityManagerService.this.mServices.bringDownDisabledPackageServicesLocked(packageName, filterByClasses, userId, evenPersistent, killProcess, doit);
        }

        public void removeDyingProviderLocked(String packageName, int userId) {
            ArrayList providers = new ArrayList();
            ActivityManagerService.this.mProviderMap.collectPackageProvidersLocked(packageName, null, true, false, userId, providers);
            for (int i = providers.size() - 1; i >= 0; i--) {
                ActivityManagerService.this.removeDyingProviderLocked(null, (ContentProviderRecord) providers.get(i), true);
            }
        }

        public void removeUriPermissionsForPackageLocked(String packageName, int userHandle, boolean persistable) {
            ActivityManagerService.this.removeUriPermissionsForPackageLocked(packageName, userHandle, persistable);
        }

        public boolean cleanupDisabledPackageReceiversLocked(BroadcastQueue broadcastQueue, String packageName, Set<String> filterByClasses, int userId, boolean doit) {
            return broadcastQueue.cleanupDisabledPackageReceiversLocked(packageName, filterByClasses, userId, doit);
        }
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "WangLan@Plf.Framework, modify for permission intercept", property = OppoRomType.OPPO)
    final class UiHandler extends Handler {
        public UiHandler() {
            super(UiThread.get().getLooper(), null, true);
        }

        /* JADX WARNING: Missing block: B:26:0x0098, code:
            com.android.server.am.ActivityManagerService.resetPriorityAfterLockedSection();
            r18.this$0.ensureBootCompleted();
     */
        /* JADX WARNING: Missing block: B:68:0x0235, code:
            com.android.server.am.ActivityManagerService.resetPriorityAfterLockedSection();
     */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public void handleMessage(Message msg) {
            Dialog d;
            AlertDialog d2;
            ActivityRecord ar;
            switch (msg.what) {
                case 1:
                    ActivityManagerService.this.mAppErrors.handleShowAppErrorUi(msg);
                    ActivityManagerService.this.ensureBootCompleted();
                    break;
                case 2:
                    ActivityManagerService.this.mAppErrors.handleShowAnrUi(msg);
                    ActivityManagerService.this.ensureBootCompleted();
                    break;
                case 3:
                    new FactoryErrorDialog(ActivityManagerService.this.mContext, msg.getData().getCharSequence("msg")).show();
                    ActivityManagerService.this.ensureBootCompleted();
                    break;
                case 6:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ProcessRecord app = msg.obj;
                            if (msg.arg1 != 0) {
                                if (!app.waitedForDebugger) {
                                    d = new AppWaitingForDebuggerDialog(ActivityManagerService.this, ActivityManagerService.this.mContext, app);
                                    app.waitDialog = d;
                                    app.waitedForDebugger = true;
                                    d.show();
                                }
                            } else if (app.waitDialog != null) {
                                app.waitDialog.dismiss();
                                app.waitDialog = null;
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 14:
                    if (ActivityManagerService.this.mShowDialogs) {
                        d2 = new BaseErrorDialog(ActivityManagerService.this.mContext);
                        d2.getWindow().setType(2010);
                        d2.setCancelable(false);
                        d2.setTitle(ActivityManagerService.this.mContext.getText(17039688));
                        d2.setMessage(ActivityManagerService.this.mContext.getText(17040852));
                        d2.setButton(-1, ActivityManagerService.this.mContext.getText(17039370), obtainMessage(48, d2));
                        d2.show();
                        break;
                    }
                    break;
                case 15:
                    if (ActivityManagerService.this.mShowDialogs) {
                        d2 = new BaseErrorDialog(ActivityManagerService.this.mContext);
                        d2.getWindow().setType(2010);
                        d2.setCancelable(false);
                        d2.setTitle(ActivityManagerService.this.mContext.getText(17039688));
                        d2.setMessage(ActivityManagerService.this.mContext.getText(17040853));
                        d2.setButton(-1, ActivityManagerService.this.mContext.getText(17039370), obtainMessage(48, d2));
                        d2.show();
                        break;
                    }
                    break;
                case 26:
                    HashMap<String, Object> data = msg.obj;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ProcessRecord proc = (ProcessRecord) data.get("app");
                            if (proc != null) {
                                if (proc.crashDialog == null) {
                                    AppErrorResult res = (AppErrorResult) data.get("result");
                                    if (ActivityManagerService.this.mShowDialogs && !ActivityManagerService.this.mSleeping) {
                                        if (!ActivityManagerService.this.mShuttingDown) {
                                            d = new StrictModeViolationDialog(ActivityManagerService.this.mContext, ActivityManagerService.this, res, proc);
                                            d.show();
                                            proc.crashDialog = d;
                                            break;
                                        }
                                    }
                                    res.set(0);
                                    break;
                                }
                                Slog.e(ActivityManagerService.TAG, "App already has strict mode dialog: " + proc);
                                ActivityManagerService.resetPriorityAfterLockedSection();
                                return;
                            }
                            Slog.e(ActivityManagerService.TAG, "App not found when showing strict mode dialog.");
                            break;
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                case 30:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ar = msg.obj;
                            if (ActivityManagerService.this.mCompatModeDialog != null) {
                                if (ActivityManagerService.this.mCompatModeDialog.mAppInfo.packageName.equals(ar.info.applicationInfo.packageName)) {
                                } else {
                                    ActivityManagerService.this.mCompatModeDialog.dismiss();
                                    ActivityManagerService.this.mCompatModeDialog = null;
                                }
                            }
                            if (ar != null) {
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 31:
                    ActivityManagerService.this.dispatchProcessesChanged();
                    break;
                case 32:
                    ActivityManagerService.this.dispatchProcessDied(msg.arg1, msg.arg2);
                    break;
                case 46:
                    ActivityManagerService.this.mUserController.showUserSwitchDialog((Pair) msg.obj);
                    break;
                case 48:
                    ((Dialog) msg.obj).dismiss();
                    break;
                case 54:
                    ActivityManagerService.this.dispatchUidsChanged();
                    break;
                case 70:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ar = (ActivityRecord) msg.obj;
                            if (ActivityManagerService.this.mUnsupportedDisplaySizeDialog != null) {
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog.dismiss();
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog = null;
                            }
                            if (ar != null && ActivityManagerService.this.mCompatModePackages.getPackageNotifyUnsupportedZoomLocked(ar.packageName)) {
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog = new UnsupportedDisplaySizeDialog(ActivityManagerService.this, ActivityManagerService.this.mContext, ar.info.applicationInfo);
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog.show();
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case ActivityManagerService.SHOW_NOT_ALLOW_DIALOG_MSG /*410*/:
                    if (ActivityManagerService.this.mDialogForDisallow == null) {
                        ActivityManagerService.this.mDialogForDisallow = new BaseErrorDialog(ActivityManagerService.this.mContext);
                        ActivityManagerService.this.mDialogForDisallow.setCancelable(false);
                        ActivityManagerService.this.mDialogForDisallow.setMessage(ActivityManagerService.this.mContext.getText(17040967));
                        ActivityManagerService.this.mDialogForDisallow.setButton(-1, ActivityManagerService.this.mContext.getText(17039370), obtainMessage(48, ActivityManagerService.this.mDialogForDisallow));
                    }
                    if (!ActivityManagerService.this.mDialogForDisallow.isShowing()) {
                        ActivityManagerService.this.mDialogForDisallow.show();
                        break;
                    }
                    break;
                case ActivityManagerService.SHOW_SYSTEM_SERVICE_CRASH_MSG /*420*/:
                    d2 = new BaseErrorDialog(ActivityManagerService.this.mContext);
                    d2.getWindow().setType(2010);
                    d2.setCancelable(false);
                    d2.setTitle(ActivityManagerService.this.mContext.getResources().getText(17041015));
                    d2.setMessage(ActivityManagerService.this.mContext.getResources().getText(17041016));
                    d2.setButton(-1, ActivityManagerService.this.mContext.getText(17039370), ActivityManagerService.this.mUiHandler.obtainMessage(48, d2));
                    d2.show();
                    break;
                case 600:
                    if (ActivityManagerService.this.mShowDialogs) {
                        String packageName = msg.obj;
                        if (packageName != null) {
                            OppoAppStartupManager.getInstance().handleAppStartForbidden(packageName);
                        }
                        if (OppoAppStartupManager.getInstance().getDialogTitleText() == null || OppoAppStartupManager.getInstance().getDialogContentText() == null || OppoAppStartupManager.getInstance().getDialogButtonText() == null) {
                            d = new BaseErrorDialog(ActivityManagerService.this.mContext);
                            d.show();
                            if (d != null) {
                                d.dismiss();
                            }
                        } else {
                            AlertDialog dialog = new AlertDialog.Builder(ActivityManagerService.this.mContext, 201523207).create();
                            dialog.getWindow().setType(2002);
                            dialog.setCancelable(false);
                            dialog.setTitle(OppoAppStartupManager.getInstance().getDialogTitleText());
                            dialog.setMessage(OppoAppStartupManager.getInstance().getDialogContentText());
                            dialog.setButton(-1, OppoAppStartupManager.getInstance().getDialogButtonText(), obtainMessage(48, dialog));
                            dialog.show();
                        }
                        OppoAppStartupManager.getInstance().resetDialogShowText();
                        break;
                    }
                    break;
            }
        }
    }

    /*  JADX ERROR: Method load error
        jadx.core.utils.exceptions.DecodeException: Load method exception: bogus opcode: 00e9 in method: com.android.server.am.ActivityManagerService.<clinit>():void, dex: 
        	at jadx.core.dex.nodes.MethodNode.load(MethodNode.java:118)
        	at jadx.core.dex.nodes.ClassNode.load(ClassNode.java:248)
        	at jadx.core.ProcessClass.process(ProcessClass.java:29)
        	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
        	at java.lang.Iterable.forEach(Iterable.java:75)
        	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
        	at jadx.core.ProcessClass.process(ProcessClass.java:37)
        	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:292)
        	at jadx.api.JavaClass.decompile(JavaClass.java:62)
        	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:200)
        Caused by: java.lang.IllegalArgumentException: bogus opcode: 00e9
        	at com.android.dx.io.OpcodeInfo.get(OpcodeInfo.java:1227)
        	at com.android.dx.io.OpcodeInfo.getName(OpcodeInfo.java:1234)
        	at jadx.core.dex.instructions.InsnDecoder.decode(InsnDecoder.java:581)
        	at jadx.core.dex.instructions.InsnDecoder.process(InsnDecoder.java:74)
        	at jadx.core.dex.nodes.MethodNode.load(MethodNode.java:104)
        	... 9 more
        */
    static {
        /*
        // Can't load method instructions: Load method exception: bogus opcode: 00e9 in method: com.android.server.am.ActivityManagerService.<clinit>():void, dex: 
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.<clinit>():void");
    }

    private static native int nativeMigrateFromBoost();

    private static native int nativeMigrateToBoost();

    BroadcastQueue broadcastQueueForIntent(Intent intent) {
        boolean isFg = (intent.getFlags() & 268435456) != 0;
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND) {
            Slog.i(TAG_BROADCAST, "Broadcast intent " + intent + " on " + (isFg ? "foreground" : "background") + " queue");
        }
        return isFg ? this.mFgBroadcastQueue : this.mBgBroadcastQueue;
    }

    ReceiverRecord broadcastRecordForNotOrderReceiverLocked(IBinder receiver, int hasCode) {
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            ReceiverRecord mReceiverRecord = queue.getMatchingNotOrderedReceiver(receiver, hasCode);
            if (mReceiverRecord != null) {
                return mReceiverRecord;
            }
        }
        return null;
    }

    public boolean canShowErrorDialogs() {
        if (!this.mShowDialogs || this.mSleeping || this.mShuttingDown || this.mLockScreenShown == 2) {
            return false;
        }
        return true;
    }

    public static void boostPriorityForLockedSection() {
        int tid = Process.myTid();
        int prevPriority = Process.getThreadPriority(tid);
        PriorityState state = (PriorityState) sThreadPriorityState.get();
        if (state.regionCounter == 0 && prevPriority > -2) {
            state.prevPriority = prevPriority;
            Process.setThreadPriority(tid, -2);
        }
        state.regionCounter = state.regionCounter + 1;
    }

    public static void resetPriorityAfterLockedSection() {
        PriorityState state = (PriorityState) sThreadPriorityState.get();
        state.regionCounter = state.regionCounter - 1;
        if (state.regionCounter == 0 && state.prevPriority > -2) {
            Process.setThreadPriority(Process.myTid(), state.prevPriority);
        }
    }

    public void setSystemProcess() {
        try {
            ServiceManager.addService("activity", this, true);
            ServiceManager.addService("procstats", this.mProcessStats);
            ServiceManager.addService("meminfo", new MemBinder(this));
            ServiceManager.addService("gfxinfo", new GraphicsBinder(this));
            ServiceManager.addService("dbinfo", new DbBinder(this));
            ServiceManager.addService("cpuinfo", new CpuBinder(this));
            ServiceManager.addService("permission", new PermissionController(this));
            ServiceManager.addService("processinfo", new ProcessInfoService(this));
            ServiceManager.addService("anrmanager", mANRManager, true);
            ApplicationInfo info = this.mContext.getPackageManager().getApplicationInfo("android", 1049600);
            this.mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
                    app.persistent = true;
                    app.pid = MY_PID;
                    app.maxAdj = -900;
                    app.makeActive(this.mSystemThread.getApplicationThread(), this.mProcessStats);
                    synchronized (this.mPidsSelfLocked) {
                        this.mPidsSelfLocked.put(app.pid, app);
                    }
                    updateLruProcessLocked(app, false, null);
                    updateOomAdjLocked();
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } catch (NameNotFoundException e) {
            throw new RuntimeException("Unable to find android system package", e);
        }
    }

    public void setWindowManager(WindowManagerService wm) {
        this.mWindowManager = wm;
        this.mStackSupervisor.setWindowManager(wm);
        this.mActivityStarter.setWindowManager(wm);
    }

    public void setUsageStatsManager(UsageStatsManagerInternal usageStatsManager) {
        this.mUsageStatsService = usageStatsManager;
    }

    public void startObservingNativeCrashes() {
        new NativeCrashListener(this).start();
    }

    public IAppOpsService getAppOpsService() {
        return this.mAppOpsService;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "WangLan@Plf.Framework : Modify for permission intercept and BPM", property = OppoRomType.OPPO)
    public ActivityManagerService(Context systemContext) {
        boolean z;
        this.mHyp = null;
        this.dexStart = false;
        this.mIsBoosted = false;
        this.mBoostStartTime = 0;
        this.mTaskStackListeners = new RemoteCallbackList();
        this.mInstrumentationReporter = new InstrumentationReporter();
        this.mShowDialogs = true;
        this.mFileUtils = null;
        this.mInVrMode = false;
        this.mUseFifoUiScheduling = false;
        this.mIgnoreSleepCheckLater = false;
        this.mBroadcastQueues = new BroadcastQueue[4];
        this.MAX_NUM_NOT_SHOW = 100;
        this.assertEnable = SystemProperties.getBoolean("persist.sys.assert.panic", false);
        this.isDiskEncrypted = SystemProperties.get("ro.crypto.state", "unencrypted").equals("encrypted");
        if (SystemProperties.get("vold.decrypt", "normal").equals("normal")) {
            z = false;
        } else {
            z = true;
        }
        this.isVoldDecryptTriggered = z;
        this.mOppoAppScaleHelper = null;
        this.mFocusedActivity = null;
        this.mLockTaskPackages = new SparseArray();
        this.mPendingAssistExtras = new ArrayList();
        this.mProcessList = new ProcessList();
        this.mProcessNames = new ProcessMap();
        this.mIsolatedProcesses = new SparseArray();
        this.mNextIsolatedProcessUid = 0;
        this.mHeavyWeightProcess = null;
        this.mPidsSelfLocked = new SparseArray();
        this.mForegroundProcesses = new SparseArray();
        this.mProcessesOnHold = new ArrayList();
        this.mPersistentStartingProcesses = new ArrayList();
        this.mRemovedProcesses = new ArrayList();
        this.mLruProcesses = new ArrayList();
        this.mLruProcessActivityStart = 0;
        this.mLruProcessServiceStart = 0;
        this.mProcessesToGc = new ArrayList();
        this.mPendingPssProcesses = new ArrayList();
        this.mBinderTransactionTrackingEnabled = false;
        this.mLastFullPssTime = SystemClock.uptimeMillis();
        this.mFullPssPending = false;
        this.mActiveUids = new SparseArray();
        this.mValidateUids = new SparseArray();
        this.mIntentSenderRecords = new HashMap();
        this.mAlreadyLoggedViolatedStacks = new HashSet();
        this.mStrictModeBuffer = new StringBuilder();
        this.mRegisteredReceivers = new HashMap();
        this.mReceiverResolver = new IntentResolver<BroadcastFilter, BroadcastFilter>() {
            protected boolean allowFilterResult(BroadcastFilter filter, List<BroadcastFilter> dest) {
                IBinder target = filter.receiverList.receiver.asBinder();
                for (int i = dest.size() - 1; i >= 0; i--) {
                    if (((BroadcastFilter) dest.get(i)).receiverList.receiver.asBinder() == target) {
                        return false;
                    }
                }
                return true;
            }

            protected BroadcastFilter newResult(BroadcastFilter filter, int match, int userId) {
                if (userId == -1 || filter.owningUserId == -1 || userId == filter.owningUserId) {
                    return (BroadcastFilter) super.newResult(filter, match, userId);
                }
                return null;
            }

            protected BroadcastFilter[] newArray(int size) {
                return new BroadcastFilter[size];
            }

            protected boolean isPackageForFilter(String packageName, BroadcastFilter filter) {
                return packageName.equals(filter.packageName);
            }
        };
        this.mStickyBroadcasts = new SparseArray();
        this.mAssociations = new SparseArray();
        this.mBackupAppName = null;
        this.mBackupTarget = null;
        this.mLaunchingProviders = new ArrayList();
        this.mGrantedUriPermissions = new SparseArray();
        this.mConfiguration = new Configuration();
        this.mConfigurationSeq = 0;
        this.mSuppressResizeConfigChanges = false;
        this.mStringBuilder = new StringBuilder(256);
        this.mTopAction = "android.intent.action.MAIN";
        this.mProcessesReady = false;
        this.mSystemReady = false;
        this.mOnBattery = false;
        this.mBooting = false;
        this.mCallFinishBooting = false;
        this.mBootAnimationComplete = false;
        this.mLaunchWarningShown = false;
        this.mCheckedForSetup = false;
        this.mSleeping = false;
        this.mTopProcessState = 2;
        this.mWakefulness = 1;
        this.mSleepTokens = new ArrayList();
        String[] strArr = new String[1];
        strArr[0] = "com.oppo.camera/.Camera";
        this.mActivitiesResumeBehindKeyguardArray = strArr;
        this.mActivitiesResumeBehindKeyguardList = new ArrayList(Arrays.asList(this.mActivitiesResumeBehindKeyguardArray));
        this.mLockScreenShown = 0;
        this.mShuttingDown = false;
        this.mAdjSeq = 0;
        this.mLruSeq = 0;
        this.mNumNonCachedProcs = 0;
        this.mNumCachedHiddenProcs = 0;
        this.mNumServiceProcs = 0;
        this.mNewNumAServiceProcs = 0;
        this.mNewNumServiceProcs = 0;
        this.mAllowLowerMemLevel = false;
        this.mLastMemoryLevel = 0;
        this.mLastIdleTime = SystemClock.uptimeMillis();
        this.mLowRamTimeSinceLastIdle = 0;
        this.mLowRamStartTime = 0;
        this.mCurResumedPackage = null;
        this.mCurResumedUid = -1;
        this.mForegroundPackages = new ProcessMap();
        this.mTestPssMode = false;
        this.mDebugApp = null;
        this.mWaitForDebugger = false;
        this.mDebugTransient = false;
        this.mOrigDebugApp = null;
        this.mOrigWaitForDebugger = false;
        this.mAlwaysFinishActivities = false;
        this.mLenientBackgroundCheck = false;
        this.mController = null;
        this.mOppoKinectController = null;
        this.mControllerIsAMonkey = false;
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mSamplingInterval = 0;
        this.mAutoStopProfiler = false;
        this.mProfileType = 0;
        this.mMemWatchProcesses = new ProcessMap();
        this.mTrackAllocationApp = null;
        this.mNativeDebuggingApp = null;
        this.mTmpLong = new long[2];
        this.mProcessObservers = new RemoteCallbackList();
        this.mActiveProcessChanges = new ProcessChangeItem[5];
        this.mPendingProcessChanges = new ArrayList();
        this.mAvailProcessChanges = new ArrayList();
        this.mUidObservers = new RemoteCallbackList();
        this.mActiveUidChanges = new ChangeItem[5];
        this.mPendingUidChanges = new ArrayList();
        this.mAvailUidChanges = new ArrayList();
        this.mProcessCpuTracker = new ProcessCpuTracker(MONITOR_THREAD_CPU_USAGE);
        this.mLastCpuTime = new AtomicLong(0);
        this.mProcessCpuMutexFree = new AtomicBoolean(true);
        this.mLastWriteTime = 0;
        this.mUpdateLock = new UpdateLock("immersive");
        this.mBooted = false;
        this.mProcessLimit = 32;
        this.mProcessLimitOverride = -1;
        this.mSuppressManager = null;
        this.mOppoActivityControlerScheduler = null;
        this.mLastMemUsageReportTime = 0;
        this.mFinishBroadcastCount = 0;
        this.mViSessionId = 1000;
        this.mBgHandler = new Handler(BackgroundThread.getHandler().getLooper()) {

            final /* synthetic */ class -void_handleMessage_android_os_Message_msg_LambdaImpl0 implements FilterStats {
                public boolean needed(Stats arg0) {
                    return AnonymousClass3.m4-com_android_server_am_ActivityManagerService$3_lambda$1(arg0);
                }
            }

            public void handleMessage(Message msg) {
                int num;
                long[] tmp;
                ProcessRecord proc;
                int i;
                int pid;
                switch (msg.what) {
                    case 1:
                        long start = SystemClock.uptimeMillis();
                        MemInfoReader memInfoReader = null;
                        synchronized (ActivityManagerService.this) {
                            try {
                                ActivityManagerService.boostPriorityForLockedSection();
                                if (ActivityManagerService.this.mFullPssPending) {
                                    ActivityManagerService.this.mFullPssPending = false;
                                    memInfoReader = new MemInfoReader();
                                }
                            } finally {
                                ActivityManagerService.resetPriorityAfterLockedSection();
                            }
                        }
                        if (memInfoReader != null) {
                            List<Stats> stats;
                            ActivityManagerService.this.updateCpuStatsNow();
                            long nativeTotalPss = 0;
                            synchronized (ActivityManagerService.this.mProcessCpuTracker) {
                                stats = ActivityManagerService.this.mProcessCpuTracker.getStats(new -void_handleMessage_android_os_Message_msg_LambdaImpl0());
                            }
                            int N = stats.size();
                            for (int j = 0; j < N; j++) {
                                synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                                    if (ActivityManagerService.this.mPidsSelfLocked.indexOfKey(((Stats) stats.get(j)).pid) >= 0) {
                                    } else {
                                        long nativePss = Debug.getPss(((Stats) stats.get(j)).pid, ActivityManagerService.this.mTmpLong, null);
                                        nativeTotalPss += nativePss;
                                        if (SystemProperties.get("ro.mtk_aws_support").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON) && AWSManager.getInstance() != null) {
                                            AWSManager.getInstance().recordST(((Stats) stats.get(j)).pid, ((Stats) stats.get(j)).uid, ((Stats) stats.get(j)).baseName);
                                            ProcessRecord processRecord = new ProcessRecord(null, new ApplicationInfo(), ((Stats) stats.get(j)).baseName, ((Stats) stats.get(j)).uid);
                                            processRecord.setPid(((Stats) stats.get(j)).pid);
                                            AWSManager.getInstance().storeRecord(ActivityManagerService.this.convertStoreRecord(processRecord, ActivityManagerService.this.mTmpLong[1] + nativePss));
                                        }
                                    }
                                }
                            }
                            memInfoReader.readMemInfo();
                            synchronized (ActivityManagerService.this) {
                                try {
                                    ActivityManagerService.boostPriorityForLockedSection();
                                    if (ActivityManagerDebugConfig.DEBUG_PSS) {
                                        Slog.d(ActivityManagerService.TAG_PSS, "Collected native and kernel memory in " + (SystemClock.uptimeMillis() - start) + "ms");
                                    }
                                    long cachedKb = memInfoReader.getCachedSizeKb();
                                    long freeKb = memInfoReader.getFreeSizeKb();
                                    long zramKb = memInfoReader.getZramTotalSizeKb();
                                    long kernelKb = memInfoReader.getKernelUsedSizeKb();
                                    EventLogTags.writeAmMeminfo(1024 * cachedKb, 1024 * freeKb, 1024 * zramKb, 1024 * kernelKb, 1024 * nativeTotalPss);
                                    ActivityManagerService.this.mProcessStats.addSysMemUsageLocked(cachedKb, freeKb, zramKb, kernelKb, nativeTotalPss);
                                } finally {
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                }
                            }
                        }
                        num = 0;
                        tmp = new long[2];
                        while (true) {
                            synchronized (ActivityManagerService.this) {
                                try {
                                    ActivityManagerService.boostPriorityForLockedSection();
                                    if (ActivityManagerService.this.mPendingPssProcesses.size() > 0) {
                                        proc = (ProcessRecord) ActivityManagerService.this.mPendingPssProcesses.remove(0);
                                        i = proc.pssProcState;
                                        long j2 = proc.lastPssTime;
                                        if (proc.thread != null && i == proc.setProcState && 1000 + j2 < SystemClock.uptimeMillis()) {
                                            pid = proc.pid;
                                            break;
                                        }
                                        proc = null;
                                        pid = 0;
                                        break;
                                    }
                                    if (ActivityManagerService.this.mTestPssMode || ActivityManagerDebugConfig.DEBUG_PSS) {
                                        Slog.d(ActivityManagerService.TAG_PSS, "Collected PSS of " + num + " processes in " + (SystemClock.uptimeMillis() - start) + "ms");
                                    }
                                    ActivityManagerService.this.mPendingPssProcesses.clear();
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                    return;
                                } finally {
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                }
                            }
                        }
                        break;
                    case 2:
                        if (AWSManager.getInstance() != null) {
                            AWSManager.getInstance().storeRecord(ActivityManagerService.this.convertStoreRecord(null, -1));
                            break;
                        }
                        break;
                }
                return;
                if (proc != null) {
                    long pss = Debug.getPss(pid, tmp, null);
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            if (pss != 0 && proc.thread != null && proc.setProcState == i && proc.pid == pid && proc.lastPssTime == j2) {
                                num++;
                                ActivityManagerService.this.recordPssSampleLocked(proc, i, pss, tmp[0], tmp[1], SystemClock.uptimeMillis());
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                }
            }

            /* renamed from: -com_android_server_am_ActivityManagerService$3_lambda$1 */
            static /* synthetic */ boolean m4-com_android_server_am_ActivityManagerService$3_lambda$1(Stats st) {
                return st.vsize > 0 && st.uid < 10000;
            }
        };
        this.mDexOptTimeMap = new HashMap();
        this.mProcessStateStatsLongs = new long[1];
        this.mLmkObserver = new UEventObserver() {
            public void onUEvent(UEvent event) {
                Slog.d(ActivityManagerService.TAG, "lowmemorykiller uevent: " + event);
                new Thread(new Runnable() {
                    public void run() {
                        ArrayList<ProcessMemInfo> memInfos;
                        synchronized (ActivityManagerService.this) {
                            try {
                                ActivityManagerService.boostPriorityForLockedSection();
                                memInfos = new ArrayList(ActivityManagerService.this.mLruProcesses.size());
                                for (int i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                    ProcessRecord rec = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                    if (rec.thread != null) {
                                        memInfos.add(new ProcessMemInfo(rec.processName, rec.pid, rec.setAdj, rec.setProcState, rec.adjType, rec.makeAdjReason()));
                                    }
                                }
                            } finally {
                                ActivityManagerService.resetPriorityAfterLockedSection();
                            }
                        }
                        try {
                            ActivityManagerService.this.reportLowmemStats(memInfos);
                        } catch (Exception e) {
                            Slog.e(ActivityManagerService.TAG, "Exception when lowmemorykiller reportLowmemStats!", e);
                        }
                    }
                }).start();
            }
        };
        this.mSupportedSystemLocales = null;
        strArr = new String[2];
        strArr[0] = TENCENT_NAME;
        strArr[1] = "com.tencent.mobileqq";
        this.splitBack = Arrays.asList(strArr);
        this.mSplitActivity = null;
        this.mDisallowedRuningAppList = new ArrayList();
        this.mDisallowedRuningAppListLock = new Object();
        this.dataDir = Environment.getDataDirectory();
        this.mSystemDir = new File(this.dataDir, "system");
        this.mNotAllowAppFilename = new File(this.mSystemDir, "not_allow_packages.xml");
        this.CUSTOMIZE_LIST_PATH = "/system/etc/oppo_customize_whitelist.xml";
        this.mCustomizeList = new ArrayList();
        this.mDialogForDisallow = null;
        this.mCreateDataReserveFile = new Runnable() {
            public void run() {
                Slog.d(ActivityManagerService.TAG, "run create reserve file");
                ActivityManagerService.this.oppoCreateFileInData();
            }
        };
        this.mAMEventHook = AMEventHook.createInstance();
        this.mSystemReadyFocusedStack = null;
        this.mCustomizedOomExt = null;
        this.mContext = systemContext;
        this.mFactoryTest = FactoryTest.getMode();
        this.mSystemThread = ActivityThread.currentActivityThread();
        Slog.i(TAG, "Memory class: " + ActivityManager.staticGetMemoryClass());
        this.mHandlerThread = new ServiceThread(TAG, -2, false);
        this.mHandlerThread.start();
        this.mHandler = new MainHandler(this.mHandlerThread.getLooper());
        this.mUiHandler = new UiHandler();
        if (sKillHandler == null) {
            sKillThread = new ServiceThread(TAG + ":kill", 10, true);
            sKillThread.start();
            sKillHandler = new KillHandler(sKillThread.getLooper());
        }
        this.mBroadcastThread = new ServiceThread("BroadcastQueue", -2, false);
        this.mBroadcastThread.start();
        this.mFgBroadcastQueue = new BroadcastQueue(this, this.mBroadcastThread, "foreground", 10000, false);
        this.mBgBroadcastQueue = new BroadcastQueue(this, this.mBroadcastThread, "background", 60000, false);
        this.mBroadcastQueues[0] = this.mFgBroadcastQueue;
        this.mBroadcastQueues[1] = this.mBgBroadcastQueue;
        OppoBroadcastManager.getInstance(this);
        this.mOppoAppScaleHelper = new OppoAppScaleHelper(this.mContext);
        this.mServices = new ActiveServices(this);
        this.mProviderMap = new ProviderMap(this);
        this.mAppErrors = new AppErrors(this.mContext, this);
        File systemDir = new File(Environment.getDataDirectory(), "system");
        systemDir.mkdirs();
        this.mBatteryStatsService = new BatteryStatsService(systemDir, this.mHandler);
        this.mBatteryStatsService.getActiveStatistics().readLocked();
        this.mBatteryStatsService.scheduleWriteToDisk();
        if (ActivityManagerDebugConfig.DEBUG_POWER) {
            z = true;
        } else {
            z = this.mBatteryStatsService.getActiveStatistics().getIsOnBattery();
        }
        this.mOnBattery = z;
        this.mBatteryStatsService.getActiveStatistics().setCallback(this);
        this.mProcessStats = new ProcessStatsService(this, new File(systemDir, "procstats"));
        this.mAppOpsService = new AppOpsService(new File(systemDir, "appops.xml"), this.mHandler);
        this.mAppOpsService.startWatchingMode(63, null, new IAppOpsCallback.Stub() {
            public void opChanged(int op, int uid, String packageName) {
                if (op == 63 && packageName != null && ActivityManagerService.this.mAppOpsService.checkOperation(op, uid, packageName) != 0) {
                    ActivityManagerService.this.runInBackgroundDisabled(uid);
                }
            }
        });
        this.mGrantFile = new AtomicFile(new File(systemDir, "urigrants.xml"));
        this.mUserController = new UserController(this);
        this.GL_ES_VERSION = SystemProperties.getInt("ro.opengles.version", 0);
        if (SystemProperties.getInt("sys.use_fifo_ui", 0) != 0) {
            this.mUseFifoUiScheduling = true;
        }
        this.mTrackingAssociations = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.track-associations"));
        this.mConfiguration.setToDefaults();
        this.mConfiguration.setLocales(LocaleList.getDefault());
        this.mConfiguration.seq = 1;
        this.mConfigurationSeq = 1;
        this.mProcessCpuTracker.init();
        this.mCompatModePackages = new CompatModePackages(this, systemDir, this.mHandler);
        this.mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), this.mHandler);
        this.mStackSupervisor = new ActivityStackSupervisor(this);
        this.mActivityStarter = new ActivityStarter(this, this.mStackSupervisor);
        this.mRecentTasks = new RecentTasks(this, this.mStackSupervisor);
        this.mProcessCpuThread = new Thread("CpuTracker") {
            public void run() {
                while (true) {
                    try {
                        synchronized (this) {
                            long now = SystemClock.uptimeMillis();
                            long nextCpuDelay = (ActivityManagerService.this.mLastCpuTime.get() + ActivityManagerService.MONITOR_CPU_MAX_TIME) - now;
                            long nextWriteDelay = (ActivityManagerService.this.mLastWriteTime + 1800000) - now;
                            if (nextWriteDelay < nextCpuDelay) {
                                nextCpuDelay = nextWriteDelay;
                            }
                            if (nextCpuDelay > 0) {
                                ActivityManagerService.this.mProcessCpuMutexFree.set(true);
                                wait(nextCpuDelay);
                            }
                        }
                    } catch (InterruptedException e) {
                    }
                    try {
                        ActivityManagerService.this.updateCpuStatsNow();
                    } catch (Exception e2) {
                        Slog.e(ActivityManagerService.TAG, "Unexpected exception collecting process stats", e2);
                    }
                }
            }
        };
        Watchdog.getInstance().addMonitor(this);
        Watchdog.getInstance().addThread(this.mHandler);
        this.mAMEventHook.hook(Event.AM_EndOfAMSCtor, EndOfAMSCtor.createInstance());
        this.mCtmFlag = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_ctm_flag", "0"));
        this.mCtmName = SystemProperties.get("ro.ctm_name", "invalid");
        OppoProcessManagerHelper.init(this);
        this.mCustomizeList = loadCustomizeWhiteList("/system/etc/oppo_customize_whitelist.xml");
        new Thread(new Runnable() {
            public void run() {
                ActivityManagerService.this.readDisallowAppListFile();
            }
        }).start();
    }

    public void setSystemServiceManager(SystemServiceManager mgr) {
        this.mSystemServiceManager = mgr;
    }

    public void setInstaller(Installer installer) {
        this.mInstaller = installer;
    }

    private void start() {
        Process.removeAllProcessGroups();
        this.mProcessCpuThread.start();
        this.mBatteryStatsService.publish(this.mContext);
        this.mAppOpsService.publish(this.mContext);
        Slog.d("AppOps", "AppOpsService published");
        LocalServices.addService(ActivityManagerInternal.class, new LocalService(this, null));
        configLogTag();
        mANRManager = new ANRManager(new AnrActivityManagerService(), MY_PID, this.mContext);
        mANRManager.startANRManager();
        this.mAnrDumpMgr = mANRManager.mAnrDumpMgr;
        this.mAnrHandler = mANRManager.mAnrHandler;
        this.mSuppressManager = new SuppressManager();
    }

    void onUserStoppedLocked(int userId) {
        this.mRecentTasks.unloadUserDataFromMemoryLocked(userId);
    }

    public void initPowerManagement() {
        this.mStackSupervisor.initPowerManagement();
        this.mBatteryStatsService.initPowerManagement();
        this.mLocalPowerManager = (PowerManagerInternal) LocalServices.getService(PowerManagerInternal.class);
        this.mVoiceWakeLock = ((PowerManager) this.mContext.getSystemService("power")).newWakeLock(1, "*voice*");
        this.mVoiceWakeLock.setReferenceCounted(false);
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        if (code == 1599295570) {
            ProcessRecord app;
            boolean callingFromJunk = false;
            int callingPid = Binder.getCallingPid();
            ArrayList<ProcessRecord> procList = new ArrayList();
            ArrayList<IBinder> procs = new ArrayList();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    int NP = this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                        int NA = apps.size();
                        for (int ia = 0; ia < NA; ia++) {
                            app = (ProcessRecord) apps.valueAt(ia);
                            if (app.thread != null) {
                                procs.add(app.thread.asBinder());
                                if (app.pid == callingPid && app.processName != null && app.processName.equals("com.coloros.oppoguardelf")) {
                                    callingFromJunk = true;
                                }
                                procList.add(app);
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            int N = procs.size();
            for (int i = 0; i < N; i++) {
                Parcel data2 = Parcel.obtain();
                boolean isSkip = false;
                try {
                    app = (ProcessRecord) procList.get(i);
                    if (app.uid > 10000) {
                        if (callingFromJunk) {
                            isSkip = true;
                        } else {
                            OppoProcessManagerHelper.resumeProcessForSystemCall(app);
                        }
                    }
                    if (!isSkip) {
                        ((IBinder) procs.get(i)).transact(1599295570, data2, null, 0);
                    }
                } catch (RemoteException e) {
                }
                data2.recycle();
            }
        }
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e2) {
            if (!(e2 instanceof SecurityException)) {
                Slog.e(TAG, "Activity Manager Crash", e2);
            }
            throw e2;
        }
    }

    void updateCpuStats() {
        if (this.mLastCpuTime.get() < SystemClock.uptimeMillis() - 5000 && this.mProcessCpuMutexFree.compareAndSet(true, false)) {
            synchronized (this.mProcessCpuThread) {
                this.mProcessCpuThread.notify();
            }
        }
    }

    void updateCpuStatsNow() {
        synchronized (this.mProcessCpuTracker) {
            this.mProcessCpuMutexFree.set(false);
            long now = SystemClock.uptimeMillis();
            boolean haveNewCpuStats = false;
            if (this.mLastCpuTime.get() < now - 5000) {
                this.mLastCpuTime.set(now);
                this.mProcessCpuTracker.update();
                if (this.mProcessCpuTracker.hasGoodLastStats()) {
                    haveNewCpuStats = true;
                    if ("true".equals(SystemProperties.get("events.cpu"))) {
                        int user = this.mProcessCpuTracker.getLastUserTime();
                        int system = this.mProcessCpuTracker.getLastSystemTime();
                        int iowait = this.mProcessCpuTracker.getLastIoWaitTime();
                        int irq = this.mProcessCpuTracker.getLastIrqTime();
                        int softIrq = this.mProcessCpuTracker.getLastSoftIrqTime();
                        int total = ((((user + system) + iowait) + irq) + softIrq) + this.mProcessCpuTracker.getLastIdleTime();
                        if (total == 0) {
                            total = 1;
                        }
                        Integer[] numArr = new Object[6];
                        numArr[0] = Integer.valueOf((((((user + system) + iowait) + irq) + softIrq) * 100) / total);
                        numArr[1] = Integer.valueOf((user * 100) / total);
                        numArr[2] = Integer.valueOf((system * 100) / total);
                        numArr[3] = Integer.valueOf((iowait * 100) / total);
                        numArr[4] = Integer.valueOf((irq * 100) / total);
                        numArr[5] = Integer.valueOf((softIrq * 100) / total);
                        EventLog.writeEvent(EventLogTags.CPU, numArr);
                    }
                }
            }
            BatteryStatsImpl bstats = this.mBatteryStatsService.getActiveStatistics();
            synchronized (bstats) {
                synchronized (this.mPidsSelfLocked) {
                    if (haveNewCpuStats) {
                        if (bstats.startAddingCpuLocked()) {
                            int totalUTime = 0;
                            int totalSTime = 0;
                            int N = this.mProcessCpuTracker.countStats();
                            for (int i = 0; i < N; i++) {
                                Stats st = this.mProcessCpuTracker.getStats(i);
                                if (st.working) {
                                    ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(st.pid);
                                    totalUTime += st.rel_utime;
                                    totalSTime += st.rel_stime;
                                    Proc ps;
                                    if (pr != null) {
                                        ps = pr.curProcBatteryStats;
                                        if (ps == null || !ps.isActive()) {
                                            ps = bstats.getProcessStatsLocked(pr.info.uid, pr.processName);
                                            pr.curProcBatteryStats = ps;
                                        }
                                        ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);
                                        pr.curCpuTime += (long) (st.rel_utime + st.rel_stime);
                                    } else {
                                        ps = st.batteryStats;
                                        if (ps == null || !ps.isActive()) {
                                            ps = bstats.getProcessStatsLocked(bstats.mapUid(st.uid), st.name);
                                            st.batteryStats = ps;
                                        }
                                        ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);
                                    }
                                }
                            }
                            bstats.finishAddingCpuLocked(totalUTime, totalSTime, this.mProcessCpuTracker.getLastUserTime(), this.mProcessCpuTracker.getLastSystemTime(), this.mProcessCpuTracker.getLastIoWaitTime(), this.mProcessCpuTracker.getLastIrqTime(), this.mProcessCpuTracker.getLastSoftIrqTime(), this.mProcessCpuTracker.getLastIdleTime());
                        }
                    }
                }
                if (this.mLastWriteTime < now - 1800000) {
                    this.mLastWriteTime = now;
                    this.mBatteryStatsService.scheduleWriteToDisk();
                }
            }
        }
    }

    public void batteryNeedsCpuUpdate() {
        new Thread(new Runnable() {
            public void run() {
                ActivityManagerService.this.updateCpuStatsNow();
            }
        }).start();
    }

    public void batteryPowerChanged(boolean onBattery) {
        updateCpuStatsNow();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    if (ActivityManagerDebugConfig.DEBUG_POWER) {
                        onBattery = true;
                    }
                    this.mOnBattery = onBattery;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void batterySendBroadcast(Intent intent) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, -1, 1000, -1);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private HashMap<String, IBinder> getCommonServicesLocked(boolean isolated) {
        if (isolated) {
            if (this.mIsolatedAppBindArgs == null) {
                this.mIsolatedAppBindArgs = new HashMap();
                this.mIsolatedAppBindArgs.put("package", ServiceManager.getService("package"));
            }
            return this.mIsolatedAppBindArgs;
        }
        if (this.mAppBindArgs == null) {
            this.mAppBindArgs = new HashMap();
            this.mAppBindArgs.put("package", ServiceManager.getService("package"));
            this.mAppBindArgs.put("window", ServiceManager.getService("window"));
            this.mAppBindArgs.put("alarm", ServiceManager.getService("alarm"));
        }
        return this.mAppBindArgs;
    }

    /* JADX WARNING: Missing block: B:79:0x01fb, code:
            if (r5 != null) goto L_0x01fd;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    boolean setFocusedActivityLocked(ActivityRecord r, String reason) {
        if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
            Slog.d(TAG_FOCUS, "mFocusedActivity:" + this.mFocusedActivity + " reason " + reason);
        }
        if (MultiWindowManager.isSupported()) {
            if (MultiWindowManager.DEBUG) {
                Slog.v(TAG_FOCUS, "setFocusedActivityLocked: r =  " + r + ", mFocusedActivity = " + this.mFocusedActivity);
            }
            if (r == null || (this.mFocusedActivity == r && r.task.getLaunchStackId() != 2)) {
                return false;
            }
        } else if (r == null || this.mFocusedActivity == r) {
            return false;
        }
        if (r.isFocusable()) {
            String str;
            if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
                Slog.d(TAG_FOCUS, "setFocusedActivityLocked: r=" + r);
            }
            boolean wasDoingSetFocusedActivity = this.mDoingSetFocusedActivity;
            if (wasDoingSetFocusedActivity) {
                Slog.w(TAG, "setFocusedActivityLocked: called recursively, r=" + r + ", reason=" + reason);
            }
            this.mDoingSetFocusedActivity = true;
            ActivityRecord last = this.mFocusedActivity;
            this.mFocusedActivity = r;
            if (!r.task.isApplicationTask()) {
                r.appTimeTracker = null;
            } else if (this.mCurAppTimeTracker != r.appTimeTracker) {
                if (this.mCurAppTimeTracker != null) {
                    this.mCurAppTimeTracker.stop();
                    this.mHandler.obtainMessage(55, this.mCurAppTimeTracker).sendToTarget();
                    this.mStackSupervisor.clearOtherAppTimeTrackers(r.appTimeTracker);
                    this.mCurAppTimeTracker = null;
                }
                if (r.appTimeTracker != null) {
                    this.mCurAppTimeTracker = r.appTimeTracker;
                    startTimeTrackingFocusedActivityLocked();
                }
            } else {
                startTimeTrackingFocusedActivityLocked();
            }
            if (r.task.voiceInteractor != null) {
                startRunningVoiceLocked(r.task.voiceSession, r.info.applicationInfo.uid);
            } else {
                finishRunningVoiceLocked();
                if (last != null) {
                    IVoiceInteractionSession session = last.task.voiceSession;
                    if (session == null) {
                        session = last.voiceSession;
                    }
                    finishVoiceTask(session);
                }
            }
            if (this.mStackSupervisor.moveActivityStackToFront(r, reason + " setFocusedActivity")) {
                this.mWindowManager.setFocusedApp(r.appToken, true);
            }
            applyUpdateLockStateLocked(r);
            applyUpdateVrModeLocked(r);
            if (this.mFocusedActivity.userId != this.mLastFocusedUserId) {
                this.mHandler.removeMessages(53);
                this.mHandler.obtainMessage(53, this.mFocusedActivity.userId, 0).sendToTarget();
                this.mLastFocusedUserId = this.mFocusedActivity.userId;
            }
            if (this.mFocusedActivity != r) {
                Slog.w(TAG, "setFocusedActivityLocked: r=" + r + " but focused to " + this.mFocusedActivity);
            }
            this.mDoingSetFocusedActivity = wasDoingSetFocusedActivity;
            int i = this.mFocusedActivity == null ? -1 : this.mFocusedActivity.userId;
            if (this.mFocusedActivity == null) {
                str = "NULL";
            } else {
                str = this.mFocusedActivity.shortComponentName;
            }
            EventLogTags.writeAmFocusedActivity(i, str, reason);
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.globalpq.support")) && this.mFocusedActivity != null) {
                String mForegroundAP = this.mFocusedActivity.packageName;
                IBinder b = ServiceManager.getService("appdetection");
                if (b != null) {
                    try {
                        IAppDetectionService.Stub.asInterface(b).updatePQparameterFromPackage(mForegroundAP);
                    } catch (RemoteException e) {
                        e.printStackTrace();
                    }
                }
            }
            return true;
        }
        if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
            Slog.d(TAG_FOCUS, "setFocusedActivityLocked: unfocusable r=" + r);
        }
        return false;
    }

    final void resetFocusedActivityIfNeededLocked(ActivityRecord goingAway) {
        if (this.mFocusedActivity == goingAway) {
            ActivityStack focusedStack = this.mStackSupervisor.getFocusedStack();
            if (focusedStack != null) {
                ActivityRecord top = focusedStack.topActivity();
                if (!(top == null || top.userId == this.mLastFocusedUserId)) {
                    this.mHandler.removeMessages(53);
                    this.mHandler.sendMessage(this.mHandler.obtainMessage(53, top.userId, 0));
                    this.mLastFocusedUserId = top.userId;
                }
            }
            if (!setFocusedActivityLocked(focusedStack.topRunningActivityLocked(), "resetFocusedActivityIfNeeded")) {
                if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
                    Slog.d(TAG_FOCUS, "resetFocusedActivityIfNeeded: Setting focus to NULL prev mFocusedActivity=" + this.mFocusedActivity + " goingAway=" + goingAway);
                }
                this.mFocusedActivity = null;
                EventLogTags.writeAmFocusedActivity(-1, "NULL", "resetFocusedActivityIfNeeded");
            }
        }
    }

    public void setFocusedStack(int stackId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setFocusedStack()");
        if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
            Slog.d(TAG_FOCUS, "setFocusedStack: stackId=" + stackId);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack stack = this.mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                    return;
                }
                if (setFocusedActivityLocked(stack.topRunningActivityLocked(), "setFocusedStack")) {
                    this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void setFocusedTask(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setFocusedTask()");
        if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
            Slog.d(TAG_FOCUS, "setFocusedTask: taskId=" + taskId);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                } else if (this.mUserController.shouldConfirmCredentials(task.userId)) {
                    this.mActivityStarter.showConfirmDeviceCredential(task.userId);
                    if (task.stack != null && task.stack.mStackId == 2) {
                        this.mStackSupervisor.moveTaskToStackLocked(task.taskId, 1, false, false, "setFocusedTask", true);
                    }
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                } else {
                    if (setFocusedActivityLocked(task.topRunningActivityLocked(), "setFocusedTask")) {
                        this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                    }
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void registerTaskStackListener(ITaskStackListener listener) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "registerTaskStackListener()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (listener != null) {
                    this.mTaskStackListeners.register(listener);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void notifyActivityDrawn(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
            Slog.d(TAG_VISIBILITY, "notifyActivityDrawn: token=" + token);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = this.mStackSupervisor.isInAnyStackLocked(token);
                if (r != null) {
                    r.task.stack.notifyActivityDrawnLocked(r);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void applyUpdateLockStateLocked(ActivityRecord r) {
        int i;
        boolean nextState = r != null ? r.immersive : false;
        MainHandler mainHandler = this.mHandler;
        MainHandler mainHandler2 = this.mHandler;
        if (nextState) {
            i = 1;
        } else {
            i = 0;
        }
        mainHandler.sendMessage(mainHandler2.obtainMessage(37, i, 0, r));
    }

    final void applyUpdateVrModeLocked(ActivityRecord r) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(63, 0, 0, r));
    }

    private void applyVrModeIfNeededLocked(ActivityRecord r, boolean enable) {
        int i;
        MainHandler mainHandler = this.mHandler;
        MainHandler mainHandler2 = this.mHandler;
        if (enable) {
            i = 1;
        } else {
            i = 0;
        }
        mainHandler.sendMessage(mainHandler2.obtainMessage(69, i, 0, r));
    }

    private void applyVrMode(boolean enabled, ComponentName packageName, int userId, ComponentName callingPackage, boolean immediate) {
        VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
        if (immediate) {
            vrService.setVrModeImmediate(enabled, packageName, userId, callingPackage);
        } else {
            vrService.setVrMode(enabled, packageName, userId, callingPackage);
        }
    }

    final void showAskCompatModeDialogLocked(ActivityRecord r) {
        Message msg = Message.obtain();
        msg.what = 30;
        if (r.task.askedCompatMode) {
            r = null;
        }
        msg.obj = r;
        this.mUiHandler.sendMessage(msg);
    }

    final void showUnsupportedZoomDialogIfNeededLocked(ActivityRecord r) {
        if (this.mConfiguration.densityDpi != DisplayMetrics.DENSITY_DEVICE_STABLE && r.appInfo.requiresSmallestWidthDp > this.mConfiguration.smallestScreenWidthDp) {
            Message msg = Message.obtain();
            msg.what = 70;
            msg.obj = r;
            this.mUiHandler.sendMessage(msg);
        }
    }

    private int updateLruProcessInternalLocked(ProcessRecord app, long now, int index, String what, Object obj, ProcessRecord srcApp) {
        app.lastActivityTime = now;
        if (app.activities.size() > 0) {
            return index;
        }
        int lrui = this.mLruProcesses.lastIndexOf(app);
        if (lrui < 0) {
            Slog.wtf(TAG, "Adding dependent process " + app + " not on LRU list: " + what + " " + obj + " from " + srcApp);
            return index;
        } else if (lrui >= index || lrui >= this.mLruProcessActivityStart) {
            return index;
        } else {
            this.mLruProcesses.remove(lrui);
            if (index > 0) {
                index--;
            }
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d(TAG_LRU, "Moving dep from " + lrui + " to " + index + " in LRU list: " + app);
            }
            this.mLruProcesses.add(index, app);
            return index;
        }
    }

    static void killProcessGroup(int uid, int pid) {
        if (sKillHandler != null) {
            sKillHandler.sendMessage(sKillHandler.obtainMessage(4000, uid, pid));
            return;
        }
        Slog.w(TAG, "Asked to kill process group before system bringup!");
        Process.killProcessGroup(uid, pid);
    }

    final void removeLruProcessLocked(ProcessRecord app) {
        int lrui = this.mLruProcesses.lastIndexOf(app);
        if (lrui >= 0) {
            if (!app.killed) {
                Slog.e(TAG, "Removing process that hasn't been killed: " + app, new RuntimeException("here").fillInStackTrace());
                Process.killProcessQuiet(app.pid);
                killProcessGroup(app.uid, app.pid);
            }
            if (lrui <= this.mLruProcessActivityStart) {
                this.mLruProcessActivityStart--;
            }
            if (lrui <= this.mLruProcessServiceStart) {
                this.mLruProcessServiceStart--;
            }
            this.mLruProcesses.remove(lrui);
        }
    }

    final void updateLruProcessLocked(ProcessRecord app, boolean activityChange, ProcessRecord client) {
        boolean hasActivity;
        if (app.activities.size() > 0 || app.hasClientActivities) {
            hasActivity = true;
        } else {
            hasActivity = app.treatLikeActivity;
        }
        if (activityChange || !hasActivity) {
            int N;
            this.mLruSeq++;
            long now = SystemClock.uptimeMillis();
            app.lastActivityTime = now;
            if (hasActivity) {
                N = this.mLruProcesses.size();
                if (N > 0 && this.mLruProcesses.get(N - 1) == app) {
                    if (ActivityManagerDebugConfig.DEBUG_LRU) {
                        Slog.d(TAG_LRU, "Not moving, already top activity: " + app);
                    }
                    if (this.mHyp == null) {
                        this.mHyp = new Hypnus();
                    }
                    if (!(app.hasClientActivities || this.mHyp == null)) {
                        this.mHyp.hypnusSetScene(app.pid, app.processName);
                    }
                    return;
                }
            } else if (this.mLruProcessServiceStart > 0 && this.mLruProcesses.get(this.mLruProcessServiceStart - 1) == app) {
                if (ActivityManagerDebugConfig.DEBUG_LRU) {
                    Slog.d(TAG_LRU, "Not moving, already top other: " + app);
                }
                return;
            }
            int lrui = this.mLruProcesses.lastIndexOf(app);
            if (!app.persistent || lrui < 0) {
                int nextIndex;
                int j;
                if (lrui >= 0) {
                    if (lrui < this.mLruProcessActivityStart) {
                        this.mLruProcessActivityStart--;
                    }
                    if (lrui < this.mLruProcessServiceStart) {
                        this.mLruProcessServiceStart--;
                    }
                    this.mLruProcesses.remove(lrui);
                }
                if (hasActivity) {
                    N = this.mLruProcesses.size();
                    if (app.activities.size() != 0 || this.mLruProcessActivityStart >= N - 1) {
                        if (ActivityManagerDebugConfig.DEBUG_LRU) {
                            Slog.d(TAG_LRU, "Adding to top of LRU activity list: " + app);
                        }
                        this.mLruProcesses.add(app);
                        if (this.mHyp == null) {
                            this.mHyp = new Hypnus();
                        }
                        if (this.mHyp != null) {
                            this.mHyp.hypnusSetScene(app.pid, app.processName);
                        }
                    } else {
                        if (ActivityManagerDebugConfig.DEBUG_LRU) {
                            Slog.d(TAG_LRU, "Adding to second-top of LRU activity list: " + app);
                        }
                        this.mLruProcesses.add(N - 1, app);
                        int uid = app.info.uid;
                        int i = N - 2;
                        while (i > this.mLruProcessActivityStart && ((ProcessRecord) this.mLruProcesses.get(i)).info.uid == uid) {
                            if (((ProcessRecord) this.mLruProcesses.get(i - 1)).info.uid != uid) {
                                if (ActivityManagerDebugConfig.DEBUG_LRU) {
                                    Slog.d(TAG_LRU, "Pushing uid " + uid + " swapping at " + i + ": " + this.mLruProcesses.get(i) + " : " + this.mLruProcesses.get(i - 1));
                                }
                                ProcessRecord tmp = (ProcessRecord) this.mLruProcesses.get(i);
                                this.mLruProcesses.set(i, (ProcessRecord) this.mLruProcesses.get(i - 1));
                                this.mLruProcesses.set(i - 1, tmp);
                                i--;
                            }
                            i--;
                        }
                    }
                    nextIndex = this.mLruProcessServiceStart;
                } else {
                    int index = this.mLruProcessServiceStart;
                    if (client != null) {
                        int clientIndex = this.mLruProcesses.lastIndexOf(client);
                        if (ActivityManagerDebugConfig.DEBUG_LRU && clientIndex < 0) {
                            Slog.d(TAG_LRU, "Unknown client " + client + " when updating " + app);
                        }
                        if (clientIndex <= lrui) {
                            clientIndex = lrui;
                        }
                        if (clientIndex >= 0 && index > clientIndex) {
                            index = clientIndex;
                        }
                    }
                    if (ActivityManagerDebugConfig.DEBUG_LRU) {
                        Slog.d(TAG_LRU, "Adding at " + index + " of LRU list: " + app);
                    }
                    this.mLruProcesses.add(index, app);
                    nextIndex = index - 1;
                    this.mLruProcessActivityStart++;
                    this.mLruProcessServiceStart++;
                }
                for (j = app.connections.size() - 1; j >= 0; j--) {
                    ConnectionRecord cr = (ConnectionRecord) app.connections.valueAt(j);
                    if (!(cr.binding == null || cr.serviceDead || cr.binding.service == null || cr.binding.service.app == null || cr.binding.service.app.lruSeq == this.mLruSeq || cr.binding.service.app.persistent)) {
                        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex, "service connection", cr, app);
                    }
                }
                for (j = app.conProviders.size() - 1; j >= 0; j--) {
                    ContentProviderRecord cpr = ((ContentProviderConnection) app.conProviders.get(j)).provider;
                    if (!(cpr.proc == null || cpr.proc.lruSeq == this.mLruSeq || cpr.proc.persistent)) {
                        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex, "provider reference", cpr, app);
                    }
                }
                return;
            }
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d(TAG_LRU, "Not moving, persistent: " + app);
            }
        }
    }

    final ProcessRecord getProcessRecordLocked(String processName, int uid, boolean keepIfLarge) {
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.v(TAG_SWITCH, "processName: " + processName + " uid " + uid + " keepIfLarge " + keepIfLarge);
        }
        if (uid == 1000) {
            SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().get(processName);
            if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
                Slog.v(TAG_SWITCH, "procs: " + procs);
            }
            if (procs == null) {
                return null;
            }
            int procCount = procs.size();
            int i = 0;
            while (i < procCount) {
                int procUid = procs.keyAt(i);
                if (UserHandle.isApp(procUid) || !UserHandle.isSameUser(procUid, uid)) {
                    if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
                        Slog.v(TAG_SWITCH, "procUid: " + procUid);
                    }
                    i++;
                } else {
                    if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
                        Slog.v(TAG_SWITCH, "i: " + i + " proc " + procs.valueAt(i));
                    }
                    return (ProcessRecord) procs.valueAt(i);
                }
            }
        }
        ProcessRecord proc = (ProcessRecord) this.mProcessNames.get(processName, uid);
        if (!(proc == null || keepIfLarge || this.mLastMemoryLevel <= 0 || proc.setProcState < 16 || TENCENT_NAME.equals(proc.processName))) {
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d(TAG_PSS, "May not keep " + proc + ": pss=" + proc.lastCachedPss);
            }
            if (proc.lastCachedPss >= this.mProcessList.getCachedRestoreThresholdKb()) {
                if (proc.baseProcessTracker != null) {
                    proc.baseProcessTracker.reportCachedKill(proc.pkgList, proc.lastCachedPss);
                }
                proc.kill(Long.toString(proc.lastCachedPss) + "k from cached", true);
            }
        }
        return proc;
    }

    void notifyPackageUse(String packageName, int reason) {
        try {
            AppGlobals.getPackageManager().notifyPackageUse(packageName, reason);
        } catch (RemoteException e) {
        }
    }

    boolean isNextTransitionForward() {
        int transit = this.mWindowManager.getPendingAppTransition();
        if (transit == 6 || transit == 8 || transit == 10) {
            return true;
        }
        return false;
    }

    int startIsolatedProcess(String entryPoint, String[] entryPointArgs, String processName, String abiOverride, int uid, Runnable crashHandler) {
        int i;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ApplicationInfo info = new ApplicationInfo();
                info.uid = 1000;
                info.processName = processName;
                info.className = entryPoint;
                info.packageName = "android";
                ProcessRecord proc = startProcessLocked(processName, info, false, 0, IElsaManager.EMPTY_PACKAGE, null, true, true, uid, true, abiOverride, entryPoint, entryPointArgs, crashHandler, null);
                i = proc != null ? proc.pid : 0;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) {
        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0, keepIfLarge, null, null, null, null, null);
    }

    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge, ActivityRecord r) {
        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0, keepIfLarge, null, null, null, null, r);
    }

    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler, ActivityRecord r) {
        ProcessRecord app;
        if (!getDisallowedRunningList().isEmpty()) {
            if (isInDisallowedRunningAppList(info.packageName)) {
                return null;
            }
        }
        if (hostingType != null) {
            if (!(!hostingType.equals(OppoProcessManager.RESUME_REASON_BROADCAST_STR) || info == null || info.sourceDir == null || new File(info.sourceDir).exists())) {
                Slog.d(TAG, "don't start process:" + processName + ", because apk file isn't exists! apkfile is " + info.sourceDir);
                return null;
            }
        }
        boolean openTraceLog = false;
        if (processName != null && "com.coloros.safecenter:clear_filter".equals(processName)) {
            Slog.d(TAG, "start process:" + processName + ", hostType:" + hostingType + ", beDead:" + knownToBeDead + ", isolated:" + isolated + ", flag:" + intentFlags);
            openTraceLog = true;
        }
        long startTime = SystemClock.elapsedRealtime();
        if (isolated) {
            app = null;
        } else {
            app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
            checkTime(startTime, "startProcess: after getProcessRecord");
            if (openTraceLog) {
                Slog.d(TAG, "trace proc, app:" + app + ", uid:" + info.uid);
            }
            if ((intentFlags & 4) == 0) {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES || openTraceLog) {
                    Slog.v(TAG, "Clearing bad process: " + info.uid + "/" + info.processName);
                }
                this.mAppErrors.resetProcessCrashTimeLocked(info);
                if (this.mAppErrors.isBadProcessLocked(info)) {
                    Object[] objArr = new Object[3];
                    objArr[0] = Integer.valueOf(UserHandle.getUserId(info.uid));
                    objArr[1] = Integer.valueOf(info.uid);
                    objArr[2] = info.processName;
                    EventLog.writeEvent(EventLogTags.AM_PROC_GOOD, objArr);
                    this.mAppErrors.clearBadProcessLocked(info);
                    if (app != null) {
                        app.bad = false;
                    }
                }
            } else if (this.mAppErrors.isBadProcessLocked(info)) {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES || openTraceLog) {
                    Slog.v(TAG, "Bad process: " + info.uid + "/" + info.processName);
                }
                return null;
            }
        }
        nativeMigrateToBoost();
        this.mIsBoosted = true;
        this.mBoostStartTime = SystemClock.uptimeMillis();
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG), 3000);
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES || openTraceLog) {
            Slog.v(TAG_PROCESSES, "startProcess: name=" + processName + " app=" + app + " knownToBeDead=" + knownToBeDead + " thread=" + (app != null ? app.thread : null) + " pid=" + (app != null ? app.pid : -1));
        }
        if (app != null && app.pid > 0) {
            if ((knownToBeDead || app.killed) && app.thread != null) {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP || openTraceLog) {
                    Slog.v(TAG_PROCESSES, "App died: " + app);
                }
                checkTime(startTime, "startProcess: bad proc running, killing");
                killProcessGroup(app.uid, app.pid);
                handleAppDiedLocked(app, true, true);
                checkTime(startTime, "startProcess: done killing old proc");
            } else {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES || openTraceLog) {
                    Slog.v(TAG_PROCESSES, "App already running: " + app);
                }
                app.addPackage(info.packageName, info.versionCode, this.mProcessStats);
                checkTime(startTime, "startProcess: done, added package to proc");
                return app;
            }
        }
        String hostingNameStr = hostingName != null ? hostingName.flattenToShortString() : null;
        if (app == null) {
            checkTime(startTime, "startProcess: creating new process record");
            app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
            if (app == null) {
                Slog.w(TAG, "Failed making new process record for " + processName + "/" + info.uid + " isolated=" + isolated);
                return null;
            }
            app.crashHandler = crashHandler;
            checkTime(startTime, "startProcess: done creating new process record");
        } else {
            app.addPackage(info.packageName, info.versionCode, this.mProcessStats);
            checkTime(startTime, "startProcess: added package to existing proc");
        }
        if (this.mProcessesReady || isAllowedWhileBooting(info) || allowWhileBooting) {
            OppoCrashClearManager.getInstance().collectCrashInfo(app, hostingType, r);
            checkTime(startTime, "startProcess: stepping in to startProcess");
            startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
            checkTime(startTime, "startProcess: done starting proc!");
            if (app.pid == 0) {
                app = null;
            }
            return app;
        }
        if (!this.mProcessesOnHold.contains(app)) {
            this.mProcessesOnHold.add(app);
        }
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES || openTraceLog) {
            Slog.v(TAG_PROCESSES, "System not ready, putting on hold: " + app);
        }
        checkTime(startTime, "startProcess: returning with proc on hold");
        return app;
    }

    boolean isAllowedWhileBooting(ApplicationInfo ai) {
        return (ai.flags & 8) != 0;
    }

    private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) {
        startProcessLocked(app, hostingType, hostingNameStr, null, null, null);
    }

    private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
        long startTime = SystemClock.elapsedRealtime();
        if (app.pid > 0 && app.pid != MY_PID) {
            checkTime(startTime, "startProcess: removing from pids map");
            synchronized (this.mPidsSelfLocked) {
                this.mPidsSelfLocked.remove(app.pid);
                this.mHandler.removeMessages(20, app);
            }
            checkTime(startTime, "startProcess: done removing from pids map");
            app.setPid(0);
        }
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES && this.mProcessesOnHold.contains(app)) {
            Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
        }
        this.mProcessesOnHold.remove(app);
        checkTime(startTime, "startProcess: starting to update cpu stats");
        updateCpuStats();
        checkTime(startTime, "startProcess: done updating cpu stats");
        if (hostingType.equals("activity")) {
            OppoAbnormalAppManager.getInstance().setPackageUnRestricted(app.info.packageName);
        }
        try {
            String requiredAbi;
            int len;
            int[] newgids;
            int n;
            ProcessRecord oldApp;
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, UserHandle.getUserId(app.uid));
            StartProcessForActivity eventData = StartProcessForActivity.createInstance();
            Object[] objArr = new Object[2];
            objArr[0] = hostingType;
            objArr[1] = app.info.packageName;
            eventData.set(objArr);
            this.mAMEventHook.hook(Event.AM_StartProcessForActivity, eventData);
            int uid = app.uid;
            int[] gids = null;
            int mountExternal = 0;
            if (!app.isolated) {
                checkTime(startTime, "startProcess: getting gids from package manager");
                int[] permGids = AppGlobals.getPackageManager().getPackageGids(app.info.packageName, 268435456, app.userId);
                mountExternal = ((MountServiceInternal) LocalServices.getService(MountServiceInternal.class)).getExternalStorageMountMode(uid, app.info.packageName);
                if (app.info.packageName != null && app.userId == OppoMultiAppManager.USER_ID && OppoMultiLauncherUtil.getInstance().isMultiApp(app.info.packageName)) {
                    mountExternal = 1;
                    Slog.d(TAG, "multi app: startProcessLocked mountExternal: " + 1 + " " + app.info.packageName);
                }
                if (app.info.packageName != null && ("com.android.providers.media".equals(app.info.packageName) || "com.coloros.filemanager".equals(app.info.packageName) || "com.coloros.gallery3d".equals(app.info.packageName))) {
                    mountExternal = 1;
                    Slog.d(TAG, "multi app: media or filemanager mountExternal: " + 1 + " " + app.info.packageName);
                }
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[2];
                } else {
                    gids = new int[(permGids.length + 2)];
                    System.arraycopy(permGids, 0, gids, 2, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            }
            checkTime(startTime, "startProcess: building args");
            if (this.mFactoryTest != 0) {
                if (this.mFactoryTest == 1 && this.mTopComponent != null && app.processName.equals(this.mTopComponent.getPackageName())) {
                    uid = 0;
                }
                if (this.mFactoryTest == 2 && (app.info.flags & 16) != 0) {
                    uid = 0;
                }
            }
            int debugFlags = 0;
            if ((app.info.flags & 2) != 0) {
                debugFlags = 1 | 2;
            }
            if ((app.info.privateFlags & 16384) != 0) {
                debugFlags |= 1;
            }
            if ((app.info.flags & 16384) != 0 || this.mSafeMode) {
                debugFlags |= 8;
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.checkjni"))) {
                debugFlags |= 2;
            }
            if ("true".equals(SystemProperties.get("debug.generate-debug-info"))) {
                debugFlags |= 32;
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.jni.logging"))) {
                debugFlags |= 16;
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.assert"))) {
                debugFlags |= 4;
            }
            if (this.mNativeDebuggingApp != null && this.mNativeDebuggingApp.equals(app.processName)) {
                debugFlags = ((debugFlags | 64) | 32) | 128;
                this.mNativeDebuggingApp = null;
            }
            if (abiOverride != null) {
                requiredAbi = abiOverride;
            } else {
                requiredAbi = app.info.primaryCpuAbi;
            }
            if (requiredAbi == null) {
                requiredAbi = Build.SUPPORTED_ABIS[0];
            }
            String instructionSet = null;
            if (app.info.primaryCpuAbi != null) {
                instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
            }
            app.gids = gids;
            app.requiredAbi = requiredAbi;
            app.instructionSet = instructionSet;
            if (app.info.packageName != null && app.userId == OppoMultiAppManager.USER_ID && OppoMultiLauncherUtil.getInstance().isMultiApp(app.info.packageName)) {
                len = gids.length;
                newgids = new int[(len + 1)];
                for (n = 0; n < len; n++) {
                    newgids[n] = gids[n];
                }
                newgids[len] = 1015;
                gids = newgids;
            }
            if (app.userId == 0 && gids != null && gids.length > 0) {
                len = gids.length;
                newgids = new int[(len + 1)];
                for (n = 0; n < len; n++) {
                    newgids[n] = gids[n];
                }
                newgids[len] = 99909997;
                gids = newgids;
            }
            boolean isActivityProcess = entryPoint == null;
            if (entryPoint == null) {
                entryPoint = "android.app.ActivityThread";
            }
            Trace.traceBegin(64, "Start proc: " + app.processName);
            checkTime(startTime, "startProcess: asking zygote to start proc");
            String seInfo = app.info.seinfo;
            if (uid >= 10000 && ((app.info.packageName != null && (seInfo.equals(SEINFO_OPPODCIM) || seInfo.equals(SEINFO_UNTRUSTED))) || seInfo.equals(SEINFO_DEFAULT))) {
                seInfo = OppoListManager.getInstance().isInDCIMProtectAllowList(app.info.packageName) ? SEINFO_OPPODCIM : SEINFO_DEFAULT;
            }
            ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);
            checkTime(startTime, "startProcess: returned from zygote!");
            Trace.traceEnd(64);
            this.mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
            checkTime(startTime, "startProcess: done updating battery stats");
            Object[] objArr2 = new Object[6];
            objArr2[0] = Integer.valueOf(UserHandle.getUserId(uid));
            objArr2[1] = Integer.valueOf(startResult.pid);
            objArr2[2] = Integer.valueOf(uid);
            objArr2[3] = app.processName;
            objArr2[4] = hostingType;
            objArr2[5] = hostingNameStr != null ? hostingNameStr : IElsaManager.EMPTY_PACKAGE;
            EventLog.writeEvent(EventLogTags.AM_PROC_START, objArr2);
            OppoAppStartupManager.getInstance().collectAppStartInfo(app, hostingNameStr, hostingType);
            try {
                AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.info.seinfo, app.info.sourceDir, startResult.pid);
            } catch (RemoteException e) {
            }
            StringBuilder bootbuf = new StringBuilder();
            bootbuf.setLength(0);
            bootbuf.append("AP_Init:[");
            bootbuf.append(hostingType);
            bootbuf.append("]:[");
            bootbuf.append(app.processName);
            if (hostingNameStr != null) {
                bootbuf.append("]:[");
                bootbuf.append(hostingNameStr);
            }
            bootbuf.append("]:pid:");
            bootbuf.append(startResult.pid);
            if (app.persistent) {
                bootbuf.append(":(PersistAP)");
            }
            BootEvent.addBootEvent(bootbuf.toString());
            if (app.persistent) {
                Watchdog.getInstance().processStarted(app.processName, startResult.pid);
            }
            checkTime(startTime, "startProcess: building log message");
            StringBuilder buf = this.mStringBuilder;
            buf.setLength(0);
            buf.append("Start proc ");
            buf.append(startResult.pid);
            buf.append(':');
            buf.append(app.processName);
            buf.append('/');
            UserHandle.formatUid(buf, uid);
            if (!isActivityProcess) {
                buf.append(" [");
                buf.append(entryPoint);
                buf.append("]");
            }
            buf.append(" for ");
            buf.append(hostingType);
            if (hostingNameStr != null) {
                buf.append(" ");
                buf.append(hostingNameStr);
            }
            Slog.i(TAG, buf.toString());
            app.setPid(startResult.pid);
            app.usingWrapper = startResult.usingWrapper;
            app.removed = false;
            app.killed = false;
            app.killedByAm = false;
            checkTime(startTime, "startProcess: starting to update pids map");
            synchronized (this.mPidsSelfLocked) {
                oldApp = (ProcessRecord) this.mPidsSelfLocked.get(startResult.pid);
            }
            if (!(oldApp == null || app.isolated)) {
                Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
                cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
            }
            synchronized (this.mPidsSelfLocked) {
                this.mPidsSelfLocked.put(startResult.pid, app);
                if (isActivityProcess) {
                    Message msg = this.mHandler.obtainMessage(20);
                    msg.obj = app;
                    this.mHandler.sendMessageDelayed(msg, (long) (startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : 10000));
                }
            }
            checkTime(startTime, "startProcess: done updating pids map");
            OppoAbnormalAppManager.getInstance().handleStartAppInfo(app, hostingType);
        } catch (RemoteException e2) {
            throw e2.rethrowAsRuntimeException();
        } catch (RemoteException e22) {
            throw e22.rethrowAsRuntimeException();
        } catch (Throwable e3) {
            Slog.e(TAG, "Failure starting process " + app.processName, e3);
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
        }
    }

    void updateUsageStats(ActivityRecord component, boolean resumed) {
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.d(TAG_SWITCH, "updateUsageStats: comp=" + component + "res=" + resumed);
        }
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        if (resumed) {
            if (this.mUsageStatsService != null) {
                this.mUsageStatsService.reportEvent(component.realActivity, component.userId, 1);
            }
            synchronized (stats) {
                stats.noteActivityResumedLocked(component.app.uid, component.packageName);
            }
        }
        if (this.mUsageStatsService != null) {
            this.mUsageStatsService.reportEvent(component.realActivity, component.userId, 2);
        }
        synchronized (stats) {
            stats.noteActivityPausedLocked(component.app.uid, component.packageName);
        }
    }

    Intent getHomeIntent() {
        Uri uri = null;
        String str = this.mTopAction;
        if (this.mTopData != null) {
            uri = Uri.parse(this.mTopData);
        }
        Intent intent = new Intent(str, uri);
        intent.setComponent(this.mTopComponent);
        intent.addFlags(256);
        if (this.mFactoryTest != 1) {
            intent.addCategory("android.intent.category.HOME");
        }
        return intent;
    }

    boolean startHomeActivityLocked(int userId, String reason) {
        if (this.mFactoryTest == 1 && this.mTopAction == null) {
            return false;
        }
        Intent intent = getHomeIntent();
        ActivityInfo aInfo = resolveActivityInfo(intent, 1024, userId);
        if (aInfo != null) {
            intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
            ActivityInfo aInfo2 = new ActivityInfo(aInfo);
            aInfo2.applicationInfo = getAppInfoForUser(aInfo2.applicationInfo, userId);
            ProcessRecord app = getProcessRecordLocked(aInfo2.processName, aInfo2.applicationInfo.uid, true);
            if (app == null || app.instrumentationClass == null) {
                intent.setFlags(intent.getFlags() | 268435456);
                this.mActivityStarter.startHomeActivityLocked(intent, aInfo2, reason);
            }
            if (this.mStackSupervisor.mLastResumedActivity.packageName == null || this.mStackSupervisor.isUpdatedLastActivityWhenStartHome(aInfo2.packageName, aInfo2.name)) {
                this.mStackSupervisor.mLastResumedActivity.packageName = aInfo2.packageName;
                this.mStackSupervisor.mLastResumedActivity.activityName = aInfo2.name;
                this.mStackSupervisor.mLastResumedActivity.activityType = 1;
                aInfo = aInfo2;
            }
        } else {
            Slog.wtf(TAG, "No home screen found for " + intent, new Throwable());
        }
        return true;
    }

    private ActivityInfo resolveActivityInfo(Intent intent, int flags, int userId) {
        ComponentName comp = intent.getComponent();
        if (comp != null) {
            try {
                return AppGlobals.getPackageManager().getActivityInfo(comp, flags, userId);
            } catch (RemoteException e) {
                return null;
            }
        }
        ResolveInfo info = AppGlobals.getPackageManager().resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), flags, userId);
        if (info != null) {
            return info.activityInfo;
        }
        return null;
    }

    void startSetupActivityLocked() {
        if (!this.mCheckedForSetup) {
            ContentResolver resolver = this.mContext.getContentResolver();
            if (this.mFactoryTest != 1) {
                if (Global.getInt(resolver, "device_provisioned", 0) != 0) {
                    this.mCheckedForSetup = true;
                    Intent intent = new Intent("android.intent.action.UPGRADE_SETUP");
                    List<ResolveInfo> ris = this.mContext.getPackageManager().queryIntentActivities(intent, 1048704);
                    if (!ris.isEmpty()) {
                        String vers;
                        ResolveInfo ri = (ResolveInfo) ris.get(0);
                        if (ri.activityInfo.metaData != null) {
                            vers = ri.activityInfo.metaData.getString("android.SETUP_VERSION");
                        } else {
                            vers = null;
                        }
                        if (vers == null && ri.activityInfo.applicationInfo.metaData != null) {
                            vers = ri.activityInfo.applicationInfo.metaData.getString("android.SETUP_VERSION");
                        }
                        String lastVers = Secure.getString(resolver, "last_setup_shown");
                        if (!(vers == null || vers.equals(lastVers))) {
                            intent.setFlags(268435456);
                            intent.setComponent(new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name));
                            this.mActivityStarter.startActivityLocked(null, intent, null, null, ri.activityInfo, null, null, null, null, null, 0, 0, 0, null, 0, 0, 0, null, false, false, null, null, null);
                        }
                    }
                }
            }
        }
    }

    CompatibilityInfo compatibilityInfoForPackageLocked(ApplicationInfo ai) {
        if (ai.packageName != null) {
            float scale = this.mOppoAppScaleHelper.GetScale(ai.packageName);
            if (scale > OppoBrightUtils.MIN_LUX_LIMITI && scale != 1.0f) {
                ai.setAppScale(scale);
            }
        }
        return this.mCompatModePackages.compatibilityInfoForPackageLocked(ai);
    }

    void enforceNotIsolatedCaller(String caller) {
        if (UserHandle.isIsolated(Binder.getCallingUid())) {
            throw new SecurityException("Isolated process not allowed to call " + caller);
        }
    }

    void enforceShellRestriction(String restriction, int userHandle) {
        if (Binder.getCallingUid() != PENDING_ASSIST_EXTRAS_LONG_TIMEOUT) {
            return;
        }
        if (userHandle < 0 || this.mUserController.hasUserRestriction(restriction, userHandle)) {
            throw new SecurityException("Shell does not have permission to access user " + userHandle);
        }
    }

    public int getFrontActivityScreenCompatMode() {
        int frontActivityScreenCompatModeLocked;
        enforceNotIsolatedCaller("getFrontActivityScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                frontActivityScreenCompatModeLocked = this.mCompatModePackages.getFrontActivityScreenCompatModeLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return frontActivityScreenCompatModeLocked;
    }

    public void setFrontActivityScreenCompatMode(int mode) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setFrontActivityScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setFrontActivityScreenCompatModeLocked(mode);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int getPackageScreenCompatMode(String packageName) {
        int packageScreenCompatModeLocked;
        enforceNotIsolatedCaller("getPackageScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                packageScreenCompatModeLocked = this.mCompatModePackages.getPackageScreenCompatModeLocked(packageName);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return packageScreenCompatModeLocked;
    }

    public void setPackageScreenCompatMode(String packageName, int mode) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setPackageScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setPackageScreenCompatModeLocked(packageName, mode);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean getPackageAskScreenCompat(String packageName) {
        boolean packageAskCompatModeLocked;
        enforceNotIsolatedCaller("getPackageAskScreenCompat");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                packageAskCompatModeLocked = this.mCompatModePackages.getPackageAskCompatModeLocked(packageName);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return packageAskCompatModeLocked;
    }

    public void setPackageAskScreenCompat(String packageName, boolean ask) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setPackageAskScreenCompat");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setPackageAskCompatModeLocked(packageName, ask);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private boolean hasUsageStatsPermission(String callingPackage) {
        boolean z = true;
        int mode = this.mAppOpsService.checkOperation(43, Binder.getCallingUid(), callingPackage);
        if (mode == 3) {
            if (checkCallingPermission("android.permission.PACKAGE_USAGE_STATS") != 0) {
                z = false;
            }
            return z;
        }
        if (mode != 0) {
            z = false;
        }
        return z;
    }

    public int getPackageProcessState(String packageName, String callingPackage) {
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.GET_PACKAGE_IMPORTANCE", "getPackageProcessState");
        }
        int procState = -1;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord proc = (ProcessRecord) this.mLruProcesses.get(i);
                    if (procState == -1 || procState > proc.setProcState) {
                        int j;
                        boolean found = false;
                        for (j = proc.pkgList.size() - 1; j >= 0 && !found; j--) {
                            if (((String) proc.pkgList.keyAt(j)).equals(packageName)) {
                                procState = proc.setProcState;
                                found = true;
                            }
                        }
                        if (proc.pkgDeps != null && !found) {
                            for (j = proc.pkgDeps.size() - 1; j >= 0; j--) {
                                if (((String) proc.pkgDeps.valueAt(j)).equals(packageName)) {
                                    procState = proc.setProcState;
                                    break;
                                }
                            }
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return procState;
    }

    public boolean setProcessMemoryTrimLevel(String process, int userId, int level) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord app = findProcessLocked(process, userId, "setProcessMemoryTrimLevel");
                if (app == null) {
                } else if (app.trimMemoryLevel < level && app.thread != null && (level < 20 || app.curProcState >= 7)) {
                    try {
                        app.thread.scheduleTrimMemory(level);
                        app.trimMemoryLevel = level;
                        resetPriorityAfterLockedSection();
                        return true;
                    } catch (RemoteException e) {
                        resetPriorityAfterLockedSection();
                        return false;
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    private void dispatchProcessesChanged() {
        synchronized (this) {
            try {
                int j;
                boostPriorityForLockedSection();
                int N = this.mPendingProcessChanges.size();
                if (this.mActiveProcessChanges.length < N) {
                    this.mActiveProcessChanges = new ProcessChangeItem[N];
                }
                this.mPendingProcessChanges.toArray(this.mActiveProcessChanges);
                this.mPendingProcessChanges.clear();
                if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Delivering " + N + " process changes");
                }
                int i = this.mProcessObservers.beginBroadcast();
                while (i > 0) {
                    i--;
                    IProcessObserver observer = (IProcessObserver) this.mProcessObservers.getBroadcastItem(i);
                    if (observer != null) {
                        j = 0;
                        while (j < N) {
                            try {
                                ProcessChangeItem item = this.mActiveProcessChanges[j];
                                if ((item.changes & 1) != 0) {
                                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                        Slog.i(TAG_PROCESS_OBSERVERS, "ACTIVITIES CHANGED pid=" + item.pid + " uid=" + item.uid + ": " + item.foregroundActivities);
                                    }
                                    observer.onForegroundActivitiesChanged(item.pid, item.uid, item.foregroundActivities);
                                }
                                if ((item.changes & 2) != 0) {
                                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                        Slog.i(TAG_PROCESS_OBSERVERS, "PROCSTATE CHANGED pid=" + item.pid + " uid=" + item.uid + ": " + item.processState);
                                    }
                                    observer.onProcessStateChanged(item.pid, item.uid, item.processState);
                                }
                                j++;
                            } catch (RemoteException e) {
                            }
                        }
                    }
                }
                this.mProcessObservers.finishBroadcast();
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        for (j = 0; j < N; j++) {
                            this.mAvailProcessChanges.add(this.mActiveProcessChanges[j]);
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void dispatchProcessDied(int pid, int uid) {
        int i = this.mProcessObservers.beginBroadcast();
        while (i > 0) {
            i--;
            IProcessObserver observer = (IProcessObserver) this.mProcessObservers.getBroadcastItem(i);
            if (observer != null) {
                try {
                    observer.onProcessDied(pid, uid);
                } catch (RemoteException e) {
                }
            }
        }
        this.mProcessObservers.finishBroadcast();
    }

    private void dispatchUidsChanged() {
        synchronized (this) {
            try {
                int i;
                int j;
                ChangeItem item;
                boostPriorityForLockedSection();
                int N = this.mPendingUidChanges.size();
                if (this.mActiveUidChanges.length < N) {
                    this.mActiveUidChanges = new ChangeItem[N];
                }
                for (i = 0; i < N; i++) {
                    ChangeItem change = (ChangeItem) this.mPendingUidChanges.get(i);
                    this.mActiveUidChanges[i] = change;
                    if (change.uidRecord != null) {
                        change.uidRecord.pendingChange = null;
                        change.uidRecord = null;
                    }
                }
                this.mPendingUidChanges.clear();
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "*** Delivering " + N + " uid changes");
                }
                if (this.mLocalPowerManager != null) {
                    for (j = 0; j < N; j++) {
                        item = this.mActiveUidChanges[j];
                        if (item.change == 1 || item.change == 2) {
                            this.mLocalPowerManager.uidGone(item.uid);
                        } else {
                            this.mLocalPowerManager.updateUidProcState(item.uid, item.processState);
                        }
                    }
                }
                i = this.mUidObservers.beginBroadcast();
                while (i > 0) {
                    i--;
                    IUidObserver observer = (IUidObserver) this.mUidObservers.getBroadcastItem(i);
                    int which = ((Integer) this.mUidObservers.getBroadcastCookie(i)).intValue();
                    if (observer != null) {
                        j = 0;
                        while (j < N) {
                            try {
                                item = this.mActiveUidChanges[j];
                                int change2 = item.change;
                                UidRecord validateUid = null;
                                if (i == 0) {
                                    validateUid = (UidRecord) this.mValidateUids.get(item.uid);
                                    if (!(validateUid != null || change2 == 1 || change2 == 2)) {
                                        validateUid = new UidRecord(item.uid);
                                        this.mValidateUids.put(item.uid, validateUid);
                                    }
                                }
                                if (change2 == 3 || change2 == 2) {
                                    if ((which & 4) != 0) {
                                        if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                            Slog.i(TAG_UID_OBSERVERS, "UID idle uid=" + item.uid);
                                        }
                                        observer.onUidIdle(item.uid);
                                    }
                                    if (i == 0 && validateUid != null) {
                                        validateUid.idle = true;
                                    }
                                } else if (change2 == 4) {
                                    if ((which & 8) != 0) {
                                        if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                            Slog.i(TAG_UID_OBSERVERS, "UID active uid=" + item.uid);
                                        }
                                        observer.onUidActive(item.uid);
                                    }
                                    if (i == 0) {
                                        validateUid.idle = false;
                                    }
                                }
                                if (change2 == 1 || change2 == 2) {
                                    if ((which & 2) != 0) {
                                        if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                            Slog.i(TAG_UID_OBSERVERS, "UID gone uid=" + item.uid);
                                        }
                                        observer.onUidGone(item.uid);
                                    }
                                    if (i == 0 && validateUid != null) {
                                        this.mValidateUids.remove(item.uid);
                                    }
                                } else {
                                    if ((which & 1) != 0) {
                                        if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                            Slog.i(TAG_UID_OBSERVERS, "UID CHANGED uid=" + item.uid + ": " + item.processState);
                                        }
                                        observer.onUidStateChanged(item.uid, item.processState);
                                    }
                                    if (i == 0) {
                                        int i2 = item.processState;
                                        validateUid.setProcState = i2;
                                        validateUid.curProcState = i2;
                                    }
                                }
                                j++;
                            } catch (RemoteException e) {
                            }
                        }
                    }
                }
                this.mUidObservers.finishBroadcast();
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        for (j = 0; j < N; j++) {
                            this.mAvailUidChanges.add(this.mActiveUidChanges[j]);
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());
    }

    final int startActivity(Intent intent, ActivityContainer container) {
        enforceNotIsolatedCaller("ActivityContainer.startActivity");
        int userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), this.mStackSupervisor.mCurrentUser, false, 2, "ActivityContainer", null);
        String mimeType = intent.getType();
        Uri data = intent.getData();
        if (mimeType == null && data != null && "content".equals(data.getScheme())) {
            mimeType = getProviderMimeType(data, userId);
        }
        container.checkEmbeddedAllowedInner(userId, intent, mimeType);
        intent.addFlags(402718720);
        return this.mActivityStarter.startActivityMayWait(null, -1, null, intent, mimeType, null, null, null, null, 0, 0, null, null, null, null, false, userId, container, null);
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivity");
        return this.mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivity", null), null, null);
    }

    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity, int userId) {
        ActivityRecord sourceRecord;
        int targetUid;
        String targetPackage;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (resultTo == null) {
                    throw new SecurityException("Must be called from an activity");
                }
                sourceRecord = this.mStackSupervisor.isInAnyStackLocked(resultTo);
                if (sourceRecord == null) {
                    throw new SecurityException("Called with bad activity token: " + resultTo);
                } else if (!sourceRecord.info.packageName.equals("android")) {
                    throw new SecurityException("Must be called from an activity that is declared in the android package");
                } else if (sourceRecord.app == null) {
                    throw new SecurityException("Called without a process attached to activity");
                } else if (UserHandle.getAppId(sourceRecord.app.uid) == 1000 || sourceRecord.app.uid == sourceRecord.launchedFromUid) {
                    if (ignoreTargetSecurity) {
                        if (intent.getComponent() == null) {
                            throw new SecurityException("Component must be specified with ignoreTargetSecurity");
                        } else if (intent.getSelector() != null) {
                            throw new SecurityException("Selector not allowed with ignoreTargetSecurity");
                        }
                    }
                    targetUid = sourceRecord.launchedFromUid;
                    targetPackage = sourceRecord.launchedFromPackage;
                } else {
                    throw new SecurityException("Calling activity in uid " + sourceRecord.app.uid + " must be system uid or original calling uid " + sourceRecord.launchedFromUid);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (userId == -10000) {
            userId = UserHandle.getUserId(sourceRecord.app.uid);
        }
        try {
            return this.mActivityStarter.startActivityMayWait(null, targetUid, targetPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, ignoreTargetSecurity, userId, null, null);
        } catch (SecurityException e) {
            throw e;
        }
    }

    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivityAndWait");
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityAndWait", null);
        WaitResult res = new WaitResult();
        this.mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, res, null, bOptions, false, userId, null, null);
        return res;
    }

    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Configuration config, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivityWithConfig");
        return this.mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, config, bOptions, false, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityWithConfig", null), null, null);
    }

    public int startActivityIntentSender(IApplicationThread caller, IntentSender intent, Intent fillInIntent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle bOptions) throws TransactionTooLargeException {
        enforceNotIsolatedCaller("startActivityIntentSender");
        if (fillInIntent == null || !fillInIntent.hasFileDescriptors()) {
            IIntentSender sender = intent.getTarget();
            if (sender instanceof PendingIntentRecord) {
                PendingIntentRecord pir = (PendingIntentRecord) sender;
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        ActivityStack stack = getFocusedStack();
                        if (stack.mResumedActivity != null && stack.mResumedActivity.info.applicationInfo.uid == Binder.getCallingUid()) {
                            this.mAppSwitchesAllowedTime = 0;
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                return pir.sendInner(0, fillInIntent, resolvedType, null, null, resultTo, resultWho, requestCode, flagsMask, flagsValues, bOptions, null);
            }
            throw new IllegalArgumentException("Bad PendingIntent object");
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public int startVoiceActivity(String callingPackage, int callingPid, int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session, IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        if (checkCallingPermission("android.permission.BIND_VOICE_INTERACTION") != 0) {
            String msg = "Permission Denial: startVoiceActivity() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.BIND_VOICE_INTERACTION";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        } else if (session == null || interactor == null) {
            throw new NullPointerException("null session or interactor");
        } else {
            return this.mActivityStarter.startActivityMayWait(null, callingUid, callingPackage, intent, resolvedType, session, interactor, null, null, 0, startFlags, profilerInfo, null, null, bOptions, false, this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 2, "startVoiceActivity", null), null, null);
        }
    }

    public void startLocalVoiceInteraction(IBinder callingActivity, Bundle options) throws RemoteException {
        Slog.i(TAG, "Activity tried to startVoiceInteraction");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord activity = getFocusedStack().topActivity();
                if (ActivityRecord.forTokenLocked(callingActivity) != activity) {
                    throw new SecurityException("Only focused activity can call startVoiceInteraction");
                }
                if (this.mRunningVoice == null && activity.task.voiceSession == null) {
                    if (activity.voiceSession == null) {
                        if (activity.pendingVoiceInteractionStart) {
                            Slog.w(TAG, "Pending start of voice interaction already.");
                            resetPriorityAfterLockedSection();
                            return;
                        }
                        activity.pendingVoiceInteractionStart = true;
                        resetPriorityAfterLockedSection();
                        ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).startLocalVoiceInteraction(callingActivity, options);
                        return;
                    }
                }
                Slog.w(TAG, "Already in a voice interaction, cannot start new voice interaction");
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void stopLocalVoiceInteraction(IBinder callingActivity) throws RemoteException {
        ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).stopLocalVoiceInteraction(callingActivity);
    }

    public boolean supportsLocalVoiceInteraction() throws RemoteException {
        return ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).supportsLocalVoiceInteraction();
    }

    void onLocalVoiceInteractionStartedLocked(IBinder activity, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {
        ActivityRecord activityToCallback = ActivityRecord.forTokenLocked(activity);
        if (activityToCallback != null) {
            activityToCallback.setVoiceSessionLocked(voiceSession);
            long token;
            try {
                activityToCallback.app.thread.scheduleLocalVoiceInteractionStarted(activity, voiceInteractor);
                token = Binder.clearCallingIdentity();
                startRunningVoiceLocked(voiceSession, activityToCallback.appInfo.uid);
                Binder.restoreCallingIdentity(token);
            } catch (RemoteException e) {
                activityToCallback.clearVoiceSessionLocked();
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(token);
            }
        }
    }

    public void setVoiceKeepAwake(IVoiceInteractionSession session, boolean keepAwake) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mRunningVoice != null && this.mRunningVoice.asBinder() == session.asBinder()) {
                    if (keepAwake) {
                        this.mVoiceWakeLock.acquire();
                    } else {
                        this.mVoiceWakeLock.release();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:66:0x0159 A:{SYNTHETIC, Splitter: B:66:0x0159} */
    /* JADX WARNING: Removed duplicated region for block: B:53:0x011d A:{SYNTHETIC, Splitter: B:53:0x011d} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean startNextMatchingActivity(IBinder callingActivity, Intent intent, Bundle bOptions) {
        Throwable th;
        if (intent == null || !intent.hasFileDescriptors()) {
            ActivityOptions options = ActivityOptions.fromBundle(bOptions);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.isInStackLocked(callingActivity);
                    if (r == null) {
                        ActivityOptions.abort(options);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else if (r.app == null || r.app.thread == null) {
                        ActivityOptions.abort(options);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else {
                        Intent intent2 = new Intent(intent);
                        try {
                            intent2.setDataAndType(r.intent.getData(), r.intent.getType());
                            intent2.setComponent(null);
                            boolean debug = (intent2.getFlags() & 8) != 0;
                            ActivityInfo aInfo = null;
                            try {
                                List<ResolveInfo> resolves = AppGlobals.getPackageManager().queryIntentActivities(intent2, r.resolvedType, 66560, UserHandle.getCallingUserId()).getList();
                                int N = resolves != null ? resolves.size() : 0;
                                for (int i = 0; i < N; i++) {
                                    ResolveInfo rInfo = (ResolveInfo) resolves.get(i);
                                    if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
                                        i++;
                                        if (i < N) {
                                            aInfo = ((ResolveInfo) resolves.get(i)).activityInfo;
                                        }
                                        if (debug) {
                                            String str;
                                            Slog.v(TAG, "Next matching activity: found current " + r.packageName + "/" + r.info.name);
                                            String str2 = TAG;
                                            StringBuilder append = new StringBuilder().append("Next matching activity: next is ");
                                            if (aInfo == null) {
                                                str = "null";
                                            } else {
                                                str = aInfo.packageName + "/" + aInfo.name;
                                            }
                                            Slog.v(str2, append.append(str).toString());
                                        }
                                        if (aInfo != null) {
                                            ActivityOptions.abort(options);
                                            if (debug) {
                                                Slog.d(TAG, "Next matching activity: nothing found");
                                            }
                                            resetPriorityAfterLockedSection();
                                            return false;
                                        }
                                        intent2.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
                                        intent2.setFlags(intent2.getFlags() & -503316481);
                                        boolean wasFinishing = r.finishing;
                                        r.finishing = true;
                                        ActivityRecord resultTo = r.resultTo;
                                        String resultWho = r.resultWho;
                                        int requestCode = r.requestCode;
                                        r.resultTo = null;
                                        if (resultTo != null) {
                                            resultTo.removeResultsLocked(r, resultWho, requestCode);
                                        }
                                        long origId = Binder.clearCallingIdentity();
                                        int res = this.mActivityStarter.startActivityLocked(r.app.thread, intent2, null, r.resolvedType, aInfo, null, null, null, resultTo != null ? resultTo.appToken : null, resultWho, requestCode, -1, r.launchedFromUid, r.launchedFromPackage, -1, r.launchedFromUid, 0, options, false, false, null, null, null);
                                        Binder.restoreCallingIdentity(origId);
                                        r.finishing = wasFinishing;
                                        if (res != 0) {
                                            resetPriorityAfterLockedSection();
                                            return false;
                                        }
                                        resetPriorityAfterLockedSection();
                                        return true;
                                    }
                                }
                            } catch (RemoteException e) {
                            }
                            if (aInfo != null) {
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            intent = intent2;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                } catch (Throwable th3) {
                    th = th3;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public final int startActivityFromRecents(int taskId, Bundle bOptions) {
        if (checkCallingPermission("android.permission.START_TASKS_FROM_RECENTS") != 0) {
            String msg = "Permission Denial: startActivityFromRecents called without android.permission.START_TASKS_FROM_RECENTS";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        long origId = Binder.clearCallingIdentity();
        try {
            int startActivityFromRecentsInner;
            synchronized (this) {
                boostPriorityForLockedSection();
                startActivityFromRecentsInner = this.mStackSupervisor.startActivityFromRecentsInner(taskId, bOptions);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(origId);
            return startActivityFromRecentsInner;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    final int startActivityInPackage(int uid, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Bundle bOptions, int userId, IActivityContainer container, TaskRecord inTask) {
        return this.mActivityStarter.startActivityMayWait(null, uid, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, false, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityInPackage", null), container, inTask);
    }

    public final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivities");
        return this.mActivityStarter.startActivities(caller, -1, callingPackage, intents, resolvedTypes, resultTo, bOptions, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivity", null));
    }

    final int startActivitiesInPackage(int uid, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
        return this.mActivityStarter.startActivities(null, uid, callingPackage, intents, resolvedTypes, resultTo, bOptions, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityInPackage", null));
    }

    public void reportActivityFullyDrawn(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                } else {
                    r.reportFullyDrawnLocked();
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: Missing block: B:48:0x00ba, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:49:0x00bd, code:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void setRequestedOrientation(IBinder token, int requestedOrientation) {
        IBinder iBinder = null;
        if (ActivityManagerDebugConfig.DEBUG_AMS) {
            int callingPid = Binder.getCallingPid();
            Slog.v(TAG, "Requested  Orientation call pid " + callingPid + " call Uid " + Binder.getCallingUid());
        }
        boolean enableHypnusBoost = false;
        if (this.mConfiguration.orientation == 1 && (requestedOrientation == 0 || requestedOrientation == 6)) {
            enableHypnusBoost = true;
        }
        if (this.mConfiguration.orientation == 2 && (requestedOrientation == 1 || requestedOrientation == 7)) {
            enableHypnusBoost = true;
        }
        if (enableHypnusBoost) {
            if (this.mHyp == null) {
                this.mHyp = new Hypnus();
            }
            if (this.mHyp != null) {
                this.mHyp.hypnusSetAction(12, 1000);
            }
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                } else {
                    TaskRecord task = r.task;
                    if (task == null || (task.mFullscreen && task.stack.mFullscreen)) {
                        long origId = Binder.clearCallingIdentity();
                        this.mWindowManager.setAppOrientation(r.appToken, requestedOrientation);
                        WindowManagerService windowManagerService = this.mWindowManager;
                        Configuration configuration = this.mConfiguration;
                        if (r.mayFreezeScreenLocked(r.app)) {
                            iBinder = r.appToken;
                        }
                        Configuration config = windowManagerService.updateOrientationFromAppTokens(configuration, iBinder);
                        if (config != null) {
                            r.frozenBeforeDestroy = true;
                            if (!updateConfigurationLocked(config, r, false)) {
                                this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                            }
                        }
                        Binder.restoreCallingIdentity(origId);
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int getRequestedOrientation(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    int appOrientation = this.mWindowManager.getAppOrientation(r.appToken);
                    resetPriorityAfterLockedSection();
                    return appOrientation;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return -1;
    }

    public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, int finishTask) {
        if (resultData == null || !resultData.hasFileDescriptors()) {
            if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                Slog.d(TAG, "ACT-Finishing activity token=" + token + ", result=" + resultCode + ", data=" + resultData + ", fTask=" + finishTask);
            }
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return true;
                }
                TaskRecord tr = r.task;
                ActivityRecord rootR = tr.getRootActivity();
                if (rootR == null) {
                    Slog.w(TAG, "Finishing task with all activities already finished");
                }
                if (tr.mLockTaskAuth != 4 && rootR == r && this.mStackSupervisor.isLastLockedTask(tr)) {
                    Slog.i(TAG, "Not finishing task in lock task mode");
                    this.mStackSupervisor.showLockTaskToast();
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean res;
                try {
                    if (this.mController != null) {
                        ActivityRecord next = r.task.stack.topRunningActivityLocked(token, 0);
                        if (next != null) {
                            boolean resumeOK = true;
                            resumeOK = this.mOppoActivityControlerScheduler != null ? this.mOppoActivityControlerScheduler.scheduleActivityResuming(next.packageName) : this.mController.activityResuming(next.packageName);
                            if (!resumeOK) {
                                Slog.i(TAG, "Not finishing activity because controller resumed");
                                resetPriorityAfterLockedSection();
                                return false;
                            }
                        }
                    }
                } catch (RemoteException e) {
                    this.mController = null;
                    Watchdog.getInstance().setActivityController(null);
                    if (this.mOppoActivityControlerScheduler != null) {
                        this.mOppoActivityControlerScheduler.exitRunningScheduler();
                        this.mOppoActivityControlerScheduler = null;
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
                long origId = Binder.clearCallingIdentity();
                boolean finishWithRootActivity = finishTask == 1;
                if (finishTask == 2 || (finishWithRootActivity && r == rootR)) {
                    res = removeTaskByIdLocked(tr.taskId, false, finishWithRootActivity);
                    if (!res) {
                        Slog.i(TAG, "Removing task failed to finish activity");
                    }
                } else {
                    res = tr.stack.requestFinishActivityLocked(token, resultCode, resultData, "app-request", true);
                    if (!res) {
                        Slog.i(TAG, "Failed to finish by app-request");
                    }
                }
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return res;
            }
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public final void finishHeavyWeightApp() {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: finishHeavyWeightApp() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mHeavyWeightProcess == null) {
                } else {
                    ArrayList<ActivityRecord> activities = new ArrayList(this.mHeavyWeightProcess.activities);
                    for (int i = 0; i < activities.size(); i++) {
                        ActivityRecord r = (ActivityRecord) activities.get(i);
                        if (!r.finishing && r.isInStackLocked()) {
                            r.task.stack.finishActivityLocked(r, 0, null, "finish-heavy", true);
                        }
                    }
                    this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                    this.mHeavyWeightProcess = null;
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void crashApplication(int uid, int initialPid, String packageName, String message) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: crashApplication() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppErrors.scheduleAppCrashLocked(uid, initialPid, packageName, message);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void finishSubActivity(IBinder token, String resultWho, int requestCode) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    r.task.stack.finishSubActivityLocked(r, resultWho, requestCode);
                }
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean finishActivityAffinity(IBinder token) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                TaskRecord task = r.task;
                if (task.mLockTaskAuth != 4 && this.mStackSupervisor.isLastLockedTask(task) && task.getRootActivity() == r) {
                    this.mStackSupervisor.showLockTaskToast();
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean finishActivityAffinityLocked = task.stack.finishActivityAffinityLocked(r);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return finishActivityAffinityLocked;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void finishVoiceTask(IVoiceInteractionSession session) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                this.mStackSupervisor.finishVoiceTask(session);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean releaseActivityInstance(IBinder token) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean safelyDestroyActivityLocked = r.task.stack.safelyDestroyActivityLocked(r, "app-req");
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return safelyDestroyActivityLocked;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void releaseSomeActivities(IApplicationThread appInt) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                this.mStackSupervisor.releaseSomeActivitiesLocked(getRecordForAppLocked(appInt), "low-mem");
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean willActivityBeVisible(IBinder token) {
        boolean willActivityBeVisibleLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    willActivityBeVisibleLocked = stack.willActivityBeVisibleLocked(token);
                } else {
                    resetPriorityAfterLockedSection();
                    return false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return willActivityBeVisibleLocked;
    }

    public void overridePendingTransition(IBinder token, String packageName, int enterAnim, int exitAnim) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord self = ActivityRecord.isInStackLocked(token);
                if (self == null) {
                } else {
                    long origId = Binder.clearCallingIdentity();
                    if (self.state == ActivityState.RESUMED || self.state == ActivityState.PAUSING) {
                        this.mWindowManager.overridePendingAppTransition(packageName, enterAnim, exitAnim, null);
                    }
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) {
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.d(TAG, "handleAppDiedLocked: app = " + app + ", app.pid = " + app.pid);
        }
        int pid = app.pid;
        if (!(cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1, false) || restarting)) {
            removeLruProcessLocked(app);
            if (pid > 0) {
                ProcessList.remove(pid);
            }
        }
        if (this.mProfileProc == app) {
            clearProfilerLocked();
        }
        boolean hasVisibleActivities = this.mStackSupervisor.handleAppDiedLocked(app);
        app.activities.clear();
        if (app.instrumentationClass != null) {
            Slog.w(TAG, "Crash of app " + app.processName + " running instrumentation " + app.instrumentationClass);
            Bundle info = new Bundle();
            info.putString("shortMsg", "Process crashed.");
            finishInstrumentationLocked(app, 0, info);
        }
        if (OppoAbnormalAppManager.getInstance().validRestartProcess(app)) {
            Slog.i(OppoAbnormalAppManager.TAG, "UL restart for activity " + app + " : is R");
            return;
        }
        if (!(restarting || !hasVisibleActivities || this.mStackSupervisor.resumeFocusedStackTopActivityLocked())) {
            this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
        }
    }

    private final int getLRURecordIndexForAppLocked(IApplicationThread thread) {
        IBinder threadBinder = thread.asBinder();
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord rec = (ProcessRecord) this.mLruProcesses.get(i);
            if (rec != null && rec.thread != null && rec.thread.asBinder() == threadBinder) {
                return i;
            }
        }
        return -1;
    }

    final ProcessRecord getRecordForAppLocked(IApplicationThread thread) {
        ProcessRecord processRecord = null;
        if (thread == null) {
            return null;
        }
        int appIndex = getLRURecordIndexForAppLocked(thread);
        if (appIndex >= 0) {
            processRecord = (ProcessRecord) this.mLruProcesses.get(appIndex);
        }
        return processRecord;
    }

    final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) {
        int i;
        ProcessRecord rec;
        boolean haveBg = false;
        for (i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            rec = (ProcessRecord) this.mLruProcesses.get(i);
            if (rec.thread != null && rec.setProcState >= 14) {
                haveBg = true;
                break;
            }
        }
        if (!haveBg) {
            long now;
            boolean doReport = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
            if (doReport) {
                now = SystemClock.uptimeMillis();
                if (now < this.mLastMemUsageReportTime + 300000) {
                    doReport = false;
                } else {
                    this.mLastMemUsageReportTime = now;
                }
            }
            ArrayList memInfos = doReport ? new ArrayList(this.mLruProcesses.size()) : null;
            EventLog.writeEvent(EventLogTags.AM_LOW_MEMORY, this.mLruProcesses.size());
            now = SystemClock.uptimeMillis();
            for (i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                rec = (ProcessRecord) this.mLruProcesses.get(i);
                if (!(rec == dyingProc || rec.thread == null)) {
                    if (doReport) {
                        memInfos.add(new ProcessMemInfo(rec.processName, rec.pid, rec.setAdj, rec.setProcState, rec.adjType, rec.makeAdjReason()));
                    }
                    if (rec.lastLowMemory + 60000 <= now) {
                        if (rec.setAdj <= 400) {
                            rec.lastRequestedGc = 0;
                        } else {
                            rec.lastRequestedGc = rec.lastLowMemory;
                        }
                        rec.reportLowMemory = true;
                        rec.lastLowMemory = now;
                        this.mProcessesToGc.remove(rec);
                        addProcessToGcListLocked(rec);
                    }
                }
            }
            if (doReport) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(33, memInfos));
            }
            scheduleAppGcsLocked();
        }
    }

    final void appDiedLocked(ProcessRecord app) {
        appDiedLocked(app, app.pid, app.thread, false);
    }

    /* JADX WARNING: Missing block: B:9:0x003f, code:
            r3 = r8.mBatteryStatsService.getActiveStatistics();
     */
    /* JADX WARNING: Missing block: B:10:0x0045, code:
            monitor-enter(r3);
     */
    /* JADX WARNING: Missing block: B:12:?, code:
            r3.noteProcessDiedLocked(r9.info.uid, r10);
     */
    /* JADX WARNING: Missing block: B:13:0x004d, code:
            monitor-exit(r3);
     */
    /* JADX WARNING: Missing block: B:15:0x0050, code:
            if (r9.killed != false) goto L_0x005f;
     */
    /* JADX WARNING: Missing block: B:16:0x0052, code:
            if (r12 != false) goto L_0x0057;
     */
    /* JADX WARNING: Missing block: B:17:0x0054, code:
            android.os.Process.killProcessQuiet(r10);
     */
    /* JADX WARNING: Missing block: B:18:0x0057, code:
            killProcessGroup(r9.uid, r10);
            r9.killed = true;
     */
    /* JADX WARNING: Missing block: B:20:0x0061, code:
            if (r9.pid != r10) goto L_0x012a;
     */
    /* JADX WARNING: Missing block: B:22:0x0065, code:
            if (r9.thread == null) goto L_0x012a;
     */
    /* JADX WARNING: Missing block: B:24:0x0071, code:
            if (r9.thread.asBinder() != r11.asBinder()) goto L_0x012a;
     */
    /* JADX WARNING: Missing block: B:26:0x0075, code:
            if (r9.instrumentationClass != null) goto L_0x0122;
     */
    /* JADX WARNING: Missing block: B:27:0x0077, code:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:28:0x0078, code:
            r2 = r1;
     */
    /* JADX WARNING: Missing block: B:29:0x007b, code:
            if (r9.killedByAm != false) goto L_0x0125;
     */
    /* JADX WARNING: Missing block: B:30:0x007d, code:
            android.util.Slog.i(TAG, "Process " + r9.processName + " (pid " + r10 + ") has died");
            r8.mAllowLowerMemLevel = true;
            com.android.server.am.OppoExtraActivityManagerService.setKeyLockModeNormal(r8.mContext, r9.processName, r8.mSystemReady);
     */
    /* JADX WARNING: Missing block: B:31:0x00b6, code:
            r4 = new java.lang.Object[3];
            r4[0] = java.lang.Integer.valueOf(r9.userId);
            r4[1] = java.lang.Integer.valueOf(r9.pid);
            r4[2] = r9.processName;
            android.util.EventLog.writeEvent(com.android.server.am.EventLogTags.AM_PROC_DIED, r4);
     */
    /* JADX WARNING: Missing block: B:32:0x00d7, code:
            if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_CLEANUP == false) goto L_0x010c;
     */
    /* JADX WARNING: Missing block: B:33:0x00d9, code:
            android.util.Slog.v(TAG_CLEANUP, "Dying app: " + r9 + ", pid: " + r10 + ", thread: " + r11.asBinder());
     */
    /* JADX WARNING: Missing block: B:34:0x010c, code:
            handleAppDiedLocked(r9, false, true);
     */
    /* JADX WARNING: Missing block: B:35:0x0111, code:
            if (r2 == false) goto L_0x0116;
     */
    /* JADX WARNING: Missing block: B:36:0x0113, code:
            updateOomAdjLocked();
     */
    /* JADX WARNING: Missing block: B:37:0x0116, code:
            if (r1 == false) goto L_0x011b;
     */
    /* JADX WARNING: Missing block: B:38:0x0118, code:
            doLowMemReportIfNeededLocked(r9);
     */
    /* JADX WARNING: Missing block: B:39:0x011b, code:
            return;
     */
    /* JADX WARNING: Missing block: B:46:0x0122, code:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:47:0x0125, code:
            r8.mAllowLowerMemLevel = false;
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:49:0x012c, code:
            if (r9.pid == r10) goto L_0x0188;
     */
    /* JADX WARNING: Missing block: B:50:0x012e, code:
            android.util.Slog.i(TAG, "Process " + r9.processName + " (pid " + r10 + ") has died and restarted (pid " + r9.pid + ").");
            r4 = new java.lang.Object[3];
            r4[0] = java.lang.Integer.valueOf(r9.userId);
            r4[1] = java.lang.Integer.valueOf(r9.pid);
            r4[2] = r9.processName;
            android.util.EventLog.writeEvent(com.android.server.am.EventLogTags.AM_PROC_DIED, r4);
     */
    /* JADX WARNING: Missing block: B:52:0x018a, code:
            if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_PROCESSES == false) goto L_0x011b;
     */
    /* JADX WARNING: Missing block: B:53:0x018c, code:
            android.util.Slog.d(TAG_PROCESSES, "Received spurious death notification for thread " + r11.asBinder());
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread, boolean fromBinderDied) {
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord curProc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            if (curProc != app) {
                Slog.w(TAG, "Spurious death for " + app + ", curProc for " + pid + ": " + curProc);
            }
        }
    }

    public static File dumpStackTraces(boolean clearTraces, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {
        if (!Watchdog.getInstance().getLastTimeWatchdogHappen() || "watchdog".equals(Thread.currentThread().getName())) {
            String tracesPath = SystemProperties.get("dalvik.vm.stack-trace-file", null);
            if (tracesPath == null || tracesPath.length() == 0) {
                return null;
            }
            Slog.d(TAG, "dumpStackTraces Full Begin:");
            File dumptracesFile = null;
            ANRManager aNRManager = mANRManager;
            if (ANRManager.enableANRDebuggingMechanism() == 0 || isAgingTestVersion) {
                File tracesFile = new File(tracesPath);
                dumptracesFile = tracesFile;
                try {
                    File tracesDir = tracesFile.getParentFile();
                    if (!tracesDir.exists()) {
                        tracesDir.mkdirs();
                        if (!SELinux.restorecon(tracesDir)) {
                            return null;
                        }
                    }
                    FileUtils.setPermissions(tracesDir.getPath(), 509, -1, -1);
                    if (clearTraces && tracesFile.exists()) {
                        tracesFile.delete();
                    }
                    tracesFile.createNewFile();
                    FileUtils.setPermissions(tracesFile.getPath(), 438, -1, -1);
                } catch (IOException e) {
                    Slog.w(TAG, "Unable to prepare ANR traces file: " + tracesPath, e);
                    return null;
                }
            }
            dumpStackTraces(tracesPath, (ArrayList) firstPids, processCpuTracker, (SparseArray) lastPids, nativeProcs);
            aNRManager = mANRManager;
            if (!(ANRManager.enableANRDebuggingMechanism() == 0 || isAgingTestVersion)) {
                dumptracesFile = new File(tracesPath);
                mANRManager.delayRenameTraceFiles(300000);
            }
            Slog.d(TAG, "dumpStackTraces Full End:");
            Slog.d(TAG, "dumptracesFile = " + dumptracesFile);
            return dumptracesFile;
        }
        Slog.i(TAG, "Skip the stacktraces of ANR because watchdog happened");
        return null;
    }

    /* JADX WARNING: Missing block: B:22:0x00a5, code:
            r9 = r9 + 1;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private static void dumpStackTraces(String tracesPath, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {
        int timeout = 0;
        FileObserver observer = new FileObserver(tracesPath, 8) {
            public synchronized void onEvent(int event, String path) {
                notify();
            }
        };
        try {
            int i;
            long sime;
            ANRManager aNRManager;
            int pid;
            observer.startWatching();
            if (firstPids != null) {
                try {
                    int num = firstPids.size();
                    i = 0;
                    while (i < num) {
                        synchronized (observer) {
                            if (ActivityManagerDebugConfig.DEBUG_ANR) {
                                Slog.d(TAG, "Collecting stacks for pid " + firstPids.get(i));
                            }
                            sime = SystemClock.elapsedRealtime();
                            aNRManager = mANRManager;
                            if (ANRManager.enableANRDebuggingMechanism() == 0 || isAgingTestVersion) {
                                Process.sendSignal(((Integer) firstPids.get(i)).intValue(), 3);
                            } else {
                                pid = ((Integer) firstPids.get(i)).intValue();
                                if (mANRManager.isJavaProcess(pid)) {
                                    Slog.i(TAG, "dumpStackTraces process: " + pid + " parent: " + Process.getParentPid(pid) + " zygote: " + Arrays.toString(ANRManager.mZygotePids));
                                    Process.sendSignal(pid, 3);
                                } else if (!mInterestingPids.contains(Integer.valueOf(pid))) {
                                    mInterestingPids.add(Integer.valueOf(pid));
                                }
                            }
                            observer.wait(1000);
                            if (ActivityManagerDebugConfig.DEBUG_ANR) {
                                Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                            }
                        }
                    }
                } catch (InterruptedException e) {
                    Slog.wtf(TAG, e);
                }
            }
            SystemClock.sleep(1000);
            if (processCpuTracker != null) {
                processCpuTracker.init();
                System.gc();
                processCpuTracker.update();
                try {
                    synchronized (processCpuTracker) {
                        processCpuTracker.wait(500);
                    }
                } catch (InterruptedException e2) {
                }
                processCpuTracker.update();
                int N = processCpuTracker.countWorkingStats();
                int numProcs = 0;
                i = 0;
                while (i < N && numProcs < 5) {
                    Stats stats = processCpuTracker.getWorkingStats(i);
                    aNRManager = mANRManager;
                    if (!(ANRManager.enableANRDebuggingMechanism() == 0 || isAgingTestVersion || i >= 3)) {
                        if (!mInterestingPids.contains(Integer.valueOf(stats.pid))) {
                            mInterestingPids.add(Integer.valueOf(stats.pid));
                        }
                    }
                    if (lastPids.indexOfKey(stats.pid) >= 0) {
                        numProcs++;
                        try {
                            synchronized (observer) {
                                if (ActivityManagerDebugConfig.DEBUG_ANR) {
                                    Slog.d(TAG, "Collecting stacks for extra pid " + stats.pid);
                                }
                                long stime = SystemClock.elapsedRealtime();
                                aNRManager = mANRManager;
                                if (ANRManager.enableANRDebuggingMechanism() == 0 || isAgingTestVersion) {
                                    Process.sendSignal(stats.pid, 3);
                                    observer.wait(1000);
                                } else if (mANRManager.isJavaProcess(stats.pid)) {
                                    Slog.i(TAG, "dumpStackTraces stats process: " + stats.pid + " parent: " + Process.getParentPid(stats.pid) + " zygote: " + Arrays.toString(ANRManager.mZygotePids));
                                    Process.sendSignal(stats.pid, 3);
                                    observer.wait(1000);
                                }
                                if (ActivityManagerDebugConfig.DEBUG_ANR) {
                                    Slog.d(TAG, "Done with extra pid " + stats.pid + " in " + (SystemClock.elapsedRealtime() - stime) + "ms");
                                }
                            }
                        } catch (InterruptedException e3) {
                            Slog.wtf(TAG, e3);
                        }
                    } else if (ActivityManagerDebugConfig.DEBUG_ANR) {
                        Slog.d(TAG, "Skipping next CPU consuming process, not a java proc: " + stats.pid);
                    }
                    i++;
                }
            }
            observer.stopWatching();
            aNRManager = mANRManager;
            int[] pids;
            if (2 == ANRManager.enableANRDebuggingMechanism() && !isAgingTestVersion) {
                Slog.d(TAG, "[DumpNative] dumpNativeBacktraceToFile begin:");
                if (nativeProcs != null) {
                    pids = Process.getPidsForCommands(nativeProcs);
                    if (pids != null) {
                        for (int pid2 : pids) {
                            if (!mInterestingPids.contains(Integer.valueOf(pid2))) {
                                mInterestingPids.add(Integer.valueOf(pid2));
                            }
                        }
                    }
                }
                int systemServerIndex = mInterestingPids.indexOf(Integer.valueOf(MY_PID));
                if (systemServerIndex != -1) {
                    try {
                        mInterestingPids.remove(systemServerIndex);
                    } catch (Exception e4) {
                        Slog.i(TAG, "[DumpNative] DumpThread Exception: " + e4);
                    }
                }
                int pidListSize = mInterestingPids.size();
                int[] nativePidList1 = new int[(pidListSize / 2)];
                int[] nativePidList2 = new int[(pidListSize - (pidListSize / 2))];
                for (i = 0; i < pidListSize; i++) {
                    if (i < pidListSize / 2) {
                        nativePidList1[i] = ((Integer) mInterestingPids.get(i)).intValue();
                    } else {
                        nativePidList2[i - (pidListSize / 2)] = ((Integer) mInterestingPids.get(i)).intValue();
                    }
                }
                mInterestingPids.clear();
                aNRManager = mANRManager;
                aNRManager.getClass();
                DumpThread dumpNativeThread1 = new DumpThread(nativePidList1, "/data/anr/native1.txt");
                dumpNativeThread1.setName("dumpnativethread1");
                dumpNativeThread1.start();
                aNRManager = mANRManager;
                aNRManager.getClass();
                DumpThread dumpNativeThread2 = new DumpThread(nativePidList2, "/data/anr/native2.txt");
                dumpNativeThread2.setName("dumpnativethread2");
                dumpNativeThread2.start();
                while (true) {
                    if (dumpNativeThread1.mResult && dumpNativeThread2.mResult) {
                        break;
                    }
                    try {
                        Thread.sleep(200);
                        timeout += 200;
                        if (timeout > 15000) {
                            Slog.d(TAG, "[DumpNative] dumpNativeBacktraceToFile is over 15s");
                            break;
                        }
                    } catch (InterruptedException e5) {
                    }
                }
                Slog.d(TAG, "[DumpNative] dumpNativeBacktraceToFile end:");
            } else if (nativeProcs != null) {
                pids = Process.getPidsForCommands(nativeProcs);
                if (pids != null) {
                    for (int pid22 : pids) {
                        if (ActivityManagerDebugConfig.DEBUG_ANR) {
                            Slog.d(TAG, "Collecting stacks for native pid " + pid22);
                        }
                        sime = SystemClock.elapsedRealtime();
                        Debug.dumpNativeBacktraceToFile(pid22, tracesPath);
                        if (ActivityManagerDebugConfig.DEBUG_ANR) {
                            Slog.d(TAG, "Done with native pid " + pid22 + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                        }
                    }
                }
            }
        } catch (Throwable th) {
            observer.stopWatching();
        }
    }

    final void logAppTooSlow(ProcessRecord app, long startTime, String msg) {
    }

    final void showLaunchWarningLocked(final ActivityRecord cur, final ActivityRecord next) {
        if (!this.mLaunchWarningShown) {
            this.mLaunchWarningShown = true;
            this.mUiHandler.post(new Runnable() {
                public void run() {
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            final Dialog d = new LaunchWarningWindow(ActivityManagerService.this.mContext, cur, next);
                            d.show();
                            ActivityManagerService.this.mUiHandler.postDelayed(new Runnable() {
                                public void run() {
                                    synchronized (ActivityManagerService.this) {
                                        try {
                                            ActivityManagerService.boostPriorityForLockedSection();
                                            d.dismiss();
                                            ActivityManagerService.this.mLaunchWarningShown = false;
                                        } finally {
                                            ActivityManagerService.resetPriorityAfterLockedSection();
                                        }
                                    }
                                }
                            }, 4000);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                }
            });
        }
    }

    /* JADX WARNING: Missing block: B:74:0x01cb, code:
            resetPriorityAfterLockedSection();
            r28 = r32;
            r2 = r23;
            r3 = r32;
            r4 = r31;
     */
    /* JADX WARNING: Missing block: B:76:?, code:
            r25.clearApplicationUserData(r30, new com.android.server.am.ActivityManagerService.AnonymousClass12(r29), r32);
     */
    /* JADX WARNING: Missing block: B:77:0x01ec, code:
            monitor-enter(r29);
     */
    /* JADX WARNING: Missing block: B:79:?, code:
            boostPriorityForLockedSection();
            removeUriPermissionsForPackageLocked(r30, r32, true);
     */
    /* JADX WARNING: Missing block: B:81:?, code:
            monitor-exit(r29);
     */
    /* JADX WARNING: Missing block: B:82:0x01fb, code:
            resetPriorityAfterLockedSection();
            r20 = android.app.NotificationManager.getService();
            r20.removeAutomaticZenRules(r30);
            r20.setNotificationPolicyAccessGranted(r30, false);
     */
    /* JADX WARNING: Missing block: B:88:0x0218, code:
            resetPriorityAfterLockedSection();
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean clearApplicationUserData(String packageName, IPackageDataObserver observer, int userId) {
        IPackageManager pm;
        enforceNotIsolatedCaller("clearApplicationUserData");
        int uid = Binder.getCallingUid();
        if (uid == PENDING_ASSIST_EXTRAS_LONG_TIMEOUT) {
            this.mFileUtils = OppoProcessWhiteListUtils.getInstance();
            if (!this.mFileUtils.isSupportClearSystemAppData()) {
                pm = AppGlobals.getPackageManager();
                try {
                    ApplicationInfo info = pm.getApplicationInfo(packageName, 0, UserHandle.getCallingUserId());
                    boolean isCtsRunning = pm.isFullFunctionMode();
                    if (!(info == null || (info.flags & 1) == 0 || isCtsRunning)) {
                        Slog.d(TAG, "this is system app not support adb clear user data!!!");
                        throw new SecurityException("adb clearing user data is forbidden.");
                    }
                } catch (RemoteException e) {
                }
            }
            if (packageName != null && this.mFileUtils.isClearDataWhiteApp(packageName)) {
                Slog.d(TAG, "this is not support adb clear pkg data: " + packageName);
                throw new SecurityException("adb clearing user data is forbidden.");
            }
        }
        int pid = Binder.getCallingPid();
        userId = this.mUserController.handleIncomingUser(pid, uid, userId, false, 2, "clearApplicationUserData", null);
        long callingId = Binder.clearCallingIdentity();
        try {
            pm = AppGlobals.getPackageManager();
            int pkgUid = -1;
            synchronized (this) {
                boostPriorityForLockedSection();
                if (getPackageManagerInternalLocked().isPackageDataProtected(userId, packageName)) {
                    throw new SecurityException("Cannot clear data for a protected package: " + packageName);
                }
                try {
                    pkgUid = pm.getPackageUid(packageName, DumpState.DUMP_PREFERRED_XML, userId);
                } catch (RemoteException e2) {
                }
                if (pkgUid == -1) {
                    Slog.w(TAG, "Invalid packageName: " + packageName);
                    if (observer != null) {
                        try {
                            observer.onRemoveCompleted(packageName, false);
                        } catch (RemoteException e3) {
                            Slog.i(TAG, "Observer no longer exists.");
                        }
                    }
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                    return false;
                }
                if (uid != pkgUid) {
                    if (checkComponentPermission("android.permission.CLEAR_APP_USER_DATA", pid, uid, -1, true) != 0) {
                        throw new SecurityException("PID " + pid + " does not have permission " + "android.permission.CLEAR_APP_USER_DATA" + " to clear data" + " of package " + packageName);
                    }
                }
                forceStopPackageLocked(packageName, pkgUid, "clear data");
                for (int i = this.mRecentTasks.size() - 1; i >= 0; i--) {
                    TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                    String taskPackageName = tr.getBaseIntent().getComponent().getPackageName();
                    if (tr.userId == userId && taskPackageName.equals(packageName)) {
                        removeTaskByIdLocked(tr.taskId, false, true);
                    }
                }
            }
            Binder.restoreCallingIdentity(callingId);
            return true;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void killBackgroundProcesses(String packageName, int userId) {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") != 0) {
            if (checkCallingPermission("android.permission.RESTART_PACKAGES") != 0) {
                String msg = "Permission Denial: killBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.KILL_BACKGROUND_PROCESSES";
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        String callingPkg = null;
        try {
            callingPkg = pm.getNameForUid(Binder.getCallingUid());
        } catch (RemoteException e) {
        }
        this.mFileUtils = OppoProcessWhiteListUtils.getInstance();
        if (this.mFileUtils.getProcessWhiteList().contains(packageName) && Binder.getCallingUid() != 1000 && !this.mFileUtils.getAuthorizedProcessList().contains(callingPkg)) {
            Slog.v(TAG, packageName + " won't killed by " + callingPkg);
        } else if (!OppoListManager.getInstance().getStageProtectList().contains(packageName) || this.mFileUtils.getAuthorizedProcessList().contains(callingPkg)) {
            if (DEBUG_COLOROS_AMS) {
                Slog.v(TAG, "killBackground: " + packageName + " is called by " + callingPkg);
            }
            userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 2, "killBackgroundProcesses", null);
            long callingId = Binder.clearCallingIdentity();
            try {
                synchronized (this) {
                    boostPriorityForLockedSection();
                    int appId = -1;
                    try {
                        appId = UserHandle.getAppId(pm.getPackageUid(packageName, 268435456, userId));
                    } catch (RemoteException e2) {
                    }
                    if (appId == -1) {
                        Slog.w(TAG, "Invalid packageName: " + packageName);
                        resetPriorityAfterLockedSection();
                        Binder.restoreCallingIdentity(callingId);
                        return;
                    }
                    killPackageProcessesLocked(packageName, appId, userId, 500, false, true, true, false, "kill background");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                }
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
            }
        } else {
            Slog.v(TAG, packageName + " being protected, won't killed by " + callingPkg);
        }
    }

    public void killAllBackgroundProcesses() {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") != 0) {
            String msg = "Permission Denial: killAllBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.KILL_BACKGROUND_PROCESSES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs = new ArrayList();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                        if (!app.persistent) {
                            if (app.removed) {
                                procs.add(app);
                            } else if (app.setAdj >= 900) {
                                app.removed = true;
                                procs.add(app);
                            }
                        }
                    }
                }
                int N = procs.size();
                for (int i = 0; i < N; i++) {
                    removeProcessLocked((ProcessRecord) procs.get(i), false, true, "kill all background");
                }
                this.mAllowLowerMemLevel = true;
                updateOomAdjLocked();
                doLowMemReportIfNeededLocked(null);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(callingId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private void killAllBackgroundProcessesExcept(int minTargetSdk, int maxProcState) {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") != 0) {
            String msg = "Permission Denial: killAllBackgroundProcessesExcept() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.KILL_BACKGROUND_PROCESSES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs = new ArrayList();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                        if (app.removed) {
                            procs.add(app);
                        } else if ((minTargetSdk < 0 || app.info.targetSdkVersion < minTargetSdk) && (maxProcState < 0 || app.setProcState > maxProcState)) {
                            app.removed = true;
                            procs.add(app);
                        }
                    }
                }
                int N = procs.size();
                for (int i = 0; i < N; i++) {
                    removeProcessLocked((ProcessRecord) procs.get(i), false, true, "kill all background except");
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(callingId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void forceStopPackage(String packageName, int userId) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: forceStopPackage() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        } else if (this.mContext.getPackageManager().hasSystemFeature("oppo.customize.function.forbid_stop_app") && (checkWhiteList(packageName) || checkProtectAppList(packageName))) {
            Slog.d(TAG, "current app is not allowed to killed!");
        } else {
            int callingPid = Binder.getCallingPid();
            userId = this.mUserController.handleIncomingUser(callingPid, Binder.getCallingUid(), userId, true, 2, "forceStopPackage", null);
            long callingId = Binder.clearCallingIdentity();
            try {
                IPackageManager pm = AppGlobals.getPackageManager();
                synchronized (this) {
                    boostPriorityForLockedSection();
                    int[] users;
                    if (userId == -1) {
                        users = this.mUserController.getUsers();
                    } else {
                        users = new int[1];
                        users[0] = userId;
                    }
                    for (int user : users) {
                        int pkgUid = -1;
                        try {
                            pkgUid = pm.getPackageUid(packageName, 268435456, user);
                        } catch (RemoteException e) {
                        }
                        if (pkgUid == -1) {
                            Slog.w(TAG, "Invalid packageName: " + packageName);
                        } else {
                            try {
                                pm.setPackageStoppedState(packageName, true, user);
                            } catch (RemoteException e2) {
                            } catch (IllegalArgumentException e3) {
                                Slog.w(TAG, "Failed trying to unstop package " + packageName + ": " + e3);
                            }
                            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                                PackageStoppedStatusChanged eventData = PackageStoppedStatusChanged.createInstance();
                                Object[] objArr = new Object[3];
                                objArr[0] = packageName;
                                objArr[1] = Integer.valueOf(1);
                                objArr[2] = "forceStopPackage";
                                eventData.set(objArr);
                                this.mAMEventHook.hook(Event.AM_PackageStoppedStatusChanged, eventData);
                            }
                            if (this.mUserController.isUserRunningLocked(user, 0)) {
                                forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
                                finishForceStopPackageLocked(packageName, pkgUid);
                            }
                        }
                    }
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
            }
        }
    }

    /* JADX WARNING: Missing block: B:19:0x0037, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:20:0x003a, code:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void addPackageDependency(String packageName) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (Binder.getCallingPid() == Process.myPid()) {
                } else {
                    ProcessRecord proc;
                    synchronized (this.mPidsSelfLocked) {
                        proc = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
                    }
                    if (proc != null) {
                        if (proc.pkgDeps == null) {
                            proc.pkgDeps = new ArraySet(1);
                        }
                        proc.pkgDeps.add(packageName);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void killApplication(String pkg, int appId, int userId, String reason) {
        if (pkg != null) {
            if (appId < 0) {
                Slog.w(TAG, "Invalid appid specified for pkg : " + pkg);
                return;
            }
            int callerUid = Binder.getCallingUid();
            if (UserHandle.getAppId(callerUid) == 1000) {
                Message msg = this.mHandler.obtainMessage(22);
                msg.arg1 = appId;
                msg.arg2 = userId;
                Bundle bundle = new Bundle();
                bundle.putString("pkg", pkg);
                bundle.putString(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY, reason);
                msg.obj = bundle;
                this.mHandler.sendMessage(msg);
                return;
            }
            throw new SecurityException(callerUid + " cannot kill pkg: " + pkg);
        }
    }

    /* JADX WARNING: Missing block: B:17:0x0054, code:
            android.os.Binder.restoreCallingIdentity(r0);
     */
    /* JADX WARNING: Missing block: B:18:0x0057, code:
            return;
     */
    /* JADX WARNING: Missing block: B:30:0x006a, code:
            resetPriorityAfterLockedSection();
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void closeSystemDialogs(String reason) {
        enforceNotIsolatedCaller("closeSystemDialogs");
        int pid = Binder.getCallingPid();
        int uid = Binder.getCallingUid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (uid >= 10000) {
                        ProcessRecord proc;
                        synchronized (this.mPidsSelfLocked) {
                            proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                        }
                        if (proc.curRawAdj > 200) {
                            Slog.w(TAG, "Ignoring closeSystemDialogs " + reason + " from background process " + proc);
                        }
                    }
                    closeSystemDialogsLocked(reason);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    void closeSystemDialogsLocked(String reason) {
        Intent intent = new Intent("android.intent.action.CLOSE_SYSTEM_DIALOGS");
        intent.addFlags(1342177280);
        if (reason != null) {
            intent.putExtra(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY, reason);
        }
        this.mWindowManager.closeSystemDialogs(reason);
        this.mStackSupervisor.closeSystemDialogsLocked();
        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, -1, 1000, -1);
    }

    public MemoryInfo[] getProcessMemoryInfo(int[] pids) {
        enforceNotIsolatedCaller("getProcessMemoryInfo");
        MemoryInfo[] infos = new MemoryInfo[pids.length];
        for (int i = pids.length - 1; i >= 0; i--) {
            synchronized (this) {
                try {
                    ProcessRecord processRecord;
                    boostPriorityForLockedSection();
                    synchronized (this.mPidsSelfLocked) {
                        processRecord = (ProcessRecord) this.mPidsSelfLocked.get(pids[i]);
                        int oomAdj = processRecord != null ? processRecord.setAdj : 0;
                    }
                    infos[i] = new MemoryInfo();
                    Debug.getMemoryInfo(pids[i], infos[i]);
                    if (processRecord != null) {
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                if (processRecord.thread != null && processRecord.setAdj == oomAdj) {
                                    processRecord.baseProcessTracker.addPss((long) infos[i].getTotalPss(), (long) infos[i].getTotalUss(), false, processRecord.pkgList);
                                }
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        return infos;
    }

    public long[] getProcessPss(int[] pids) {
        enforceNotIsolatedCaller("getProcessPss");
        long[] pss = new long[pids.length];
        for (int i = pids.length - 1; i >= 0; i--) {
            synchronized (this) {
                try {
                    ProcessRecord processRecord;
                    boostPriorityForLockedSection();
                    synchronized (this.mPidsSelfLocked) {
                        processRecord = (ProcessRecord) this.mPidsSelfLocked.get(pids[i]);
                        int oomAdj = processRecord != null ? processRecord.setAdj : 0;
                    }
                    long[] tmpUss = new long[1];
                    pss[i] = Debug.getPss(pids[i], tmpUss, null);
                    if (processRecord != null) {
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                if (processRecord.thread != null && processRecord.setAdj == oomAdj) {
                                    processRecord.baseProcessTracker.addPss(pss[i], tmpUss[0], false, processRecord.pkgList);
                                }
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        return pss;
    }

    public long[] getProcessPswap(int[] pids) throws RemoteException {
        enforceNotIsolatedCaller("getProcessPswap");
        long[] pss = new long[pids.length];
        for (int i = pids.length - 1; i >= 0; i--) {
            pss[i] = Debug.getPswap(pids[i]);
        }
        return pss;
    }

    public void killApplicationProcess(String processName, int uid) {
        if (processName != null) {
            int callerUid = Binder.getCallingUid();
            boolean isArmyControler = false;
            String STR_FEATURE_CUSTOMIZE_KILL = "oppo.customize.function.killprocess";
            if (this.mContext.getPackageManager().hasSystemFeature("oppo.customize.function.killprocess")) {
                try {
                    String[] callerPkgs = AppGlobals.getPackageManager().getPackagesForUid(callerUid);
                    if (callerPkgs != null && callerPkgs.length > 0) {
                        for (String pkgName : callerPkgs) {
                            if (checkWhiteList(pkgName)) {
                                isArmyControler = true;
                                break;
                            }
                        }
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, "getPackagesForUid failed for uid:" + callerUid, e);
                }
            }
            if (callerUid == 1000 || isArmyControler) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        ProcessRecord app = getProcessRecordLocked(processName, uid, true);
                        if (app == null || app.thread == null) {
                            Slog.w(TAG, "Process/uid not found attempting kill of " + processName + " / " + uid);
                        } else {
                            try {
                                app.thread.scheduleSuicide();
                            } catch (RemoteException e2) {
                            }
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                return;
            }
            throw new SecurityException(callerUid + " cannot kill app process: " + processName);
        }
    }

    private void forceStopPackageLocked(String packageName, int uid, String reason) {
        forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false, false, true, false, false, UserHandle.getUserId(uid), reason);
    }

    private void finishForceStopPackageLocked(String packageName, int uid) {
        Intent intent = new Intent("android.intent.action.PACKAGE_RESTARTED", Uri.fromParts("package", packageName, null));
        if (!this.mProcessesReady) {
            intent.addFlags(1342177280);
        }
        intent.putExtra("android.intent.extra.UID", uid);
        intent.putExtra("android.intent.extra.user_handle", UserHandle.getUserId(uid));
        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, UserHandle.getUserId(uid));
    }

    private final boolean killPackageProcessesLocked(String packageName, int appId, int userId, int minOomAdj, boolean callerWillRestart, boolean allowRestart, boolean doit, boolean evenPersistent, String reason) {
        ArrayList<ProcessRecord> procs = new ArrayList();
        int NP = this.mProcessNames.getMap().size();
        if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.d(TAG, "ACT-killPackageProcessesLocked NP=" + NP + " name=" + packageName);
        }
        for (int ip = 0; ip < NP; ip++) {
            SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
            int NA = apps.size();
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                Slog.d(TAG, "ACT-killPackageProcessesLocked NA=" + NA);
            }
            for (int ia = 0; ia < NA; ia++) {
                ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.d(TAG, "ACT-killPackageProcessesLocked check process=" + app.toString());
                }
                if (!app.persistent || evenPersistent) {
                    if (app.removed) {
                        if (doit) {
                            procs.add(app);
                        }
                        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                            Slog.d(TAG, "ACT-killPackageProcessesLocked ignore removed process " + app.processName);
                        }
                    } else if (app.setAdj >= minOomAdj) {
                        if (packageName != null) {
                            boolean isDep;
                            if (app.pkgDeps != null) {
                                isDep = app.pkgDeps.contains(packageName);
                            } else {
                                isDep = false;
                            }
                            if (isDep && isColorSpecial(app) && UserHandle.getAppId(app.uid) != appId) {
                                Slog.v(TAG, "processName = " + app.processName + " isDep = " + isDep + " packageName = " + packageName);
                            } else if (isDep || UserHandle.getAppId(app.uid) == appId) {
                                if (userId == -1 || app.userId == userId) {
                                    if (!(app.pkgList.containsKey(packageName) || isDep)) {
                                        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                                            Slog.d(TAG, "ACT-killPackageProcessesLocked ignore, pkgList didn't contain " + packageName + " isDep=" + isDep + "pkgDeps=" + app.pkgDeps);
                                        }
                                    }
                                } else if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                                    Slog.d(TAG, "ACT-killPackageProcessesLocked ignore app.userId=" + app.userId + " userId=" + userId);
                                }
                            } else if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                                Slog.d(TAG, "ACT-killPackageProcessesLocked ignore getAppId=" + UserHandle.getAppId(app.uid) + " appId=" + appId + " isDep=" + isDep + "pkgDeps=" + app.pkgDeps);
                            }
                        } else if (userId == -1 || app.userId == userId) {
                            if (appId >= 0 && UserHandle.getAppId(app.uid) != appId) {
                                if (isChooserProcessFromUid(app, UserHandle.getUid(userId, appId))) {
                                    Slog.d(TAG, "ACT-killPackageProcessesLocked isChooserProcessFromUid userId=" + userId + " appId=" + appId + " process=" + app.toString());
                                } else if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                                    Slog.d(TAG, "ACT-killPackageProcessesLocked ignore getAppId=" + UserHandle.getAppId(app.uid) + " appId=" + appId);
                                }
                            }
                        } else if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                            Slog.d(TAG, "ACT-killPackageProcessesLocked ignore app.userId=" + app.userId + " userId=" + userId);
                        }
                        if (!doit) {
                            return true;
                        }
                        app.removed = true;
                        procs.add(app);
                        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                            Slog.d(TAG, "ACT-killPackageProcessesLocked procs add " + app.processName + " to kill list");
                        }
                    } else if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                        Slog.d(TAG, "ACT-killPackageProcessesLocked ignore process " + app.processName + " setAdj=" + app.setAdj + " minOomAdj=" + minOomAdj);
                    }
                } else if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.d(TAG, "ACT-killPackageProcessesLocked ignore persistent process " + app.persistent + " " + evenPersistent);
                }
            }
        }
        int N = procs.size();
        for (int i = 0; i < N; i++) {
            removeProcessLocked((ProcessRecord) procs.get(i), callerWillRestart, allowRestart, reason);
        }
        updateOomAdjLocked();
        return N > 0;
    }

    private boolean isColorSpecial(ProcessRecord app) {
        if ((app.info.flags & 1) != 0) {
            return true;
        }
        return false;
    }

    private void cleanupDisabledPackageComponentsLocked(String packageName, int userId, boolean killProcess, String[] changedClasses) {
        Set<String> disabledClasses = null;
        boolean packageDisabled = false;
        IPackageManager pm = AppGlobals.getPackageManager();
        if (changedClasses != null) {
            int i;
            Set disabledClasses2;
            for (i = changedClasses.length - 1; i >= 0; i--) {
                String changedClass = changedClasses[i];
                int enabled;
                if (changedClass.equals(packageName)) {
                    try {
                        enabled = pm.getApplicationEnabledSetting(packageName, userId != -1 ? userId : 0);
                        packageDisabled = enabled != 1 ? enabled != 0 : false;
                        if (packageDisabled) {
                            disabledClasses2 = null;
                            break;
                        }
                    } catch (Exception e) {
                        return;
                    }
                }
                try {
                    enabled = pm.getComponentEnabledSetting(new ComponentName(packageName, changedClass), userId != -1 ? userId : 0);
                    if (!(enabled == 1 || enabled == 0)) {
                        if (disabledClasses == null) {
                            disabledClasses = new ArraySet(changedClasses.length);
                        }
                        disabledClasses.add(changedClass);
                    }
                } catch (Exception e2) {
                    return;
                }
            }
            if (packageDisabled || disabledClasses2 != null) {
                if (this.mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, disabledClasses2, true, false, userId) && this.mBooted) {
                    this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                    this.mStackSupervisor.scheduleIdleLocked();
                }
                cleanupDisabledPackageTasksLocked(packageName, disabledClasses2, userId);
                this.mServices.bringDownDisabledPackageServicesLocked(packageName, disabledClasses2, userId, false, killProcess, true);
                ArrayList providers = new ArrayList();
                this.mProviderMap.collectPackageProvidersLocked(packageName, disabledClasses2, true, false, userId, providers);
                for (i = providers.size() - 1; i >= 0; i--) {
                    removeDyingProviderLocked(null, (ContentProviderRecord) providers.get(i), true);
                }
                for (i = this.mBroadcastQueues.length - 1; i >= 0; i--) {
                    this.mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, disabledClasses2, userId, true);
                }
            }
        }
    }

    final boolean clearBroadcastQueueForUserLocked(int userId) {
        boolean didSomething = false;
        for (int i = this.mBroadcastQueues.length - 1; i >= 0; i--) {
            didSomething |= this.mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(null, null, userId, true);
        }
        return didSomething;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "Jun.Zhang@Plf.Framework, add for oppo input policy exceptionZhiYong.Lin@Plf.Framework, add for clean the residual process", property = OppoRomType.ROM)
    final boolean forceStopPackageLocked(String packageName, int appId, boolean callerWillRestart, boolean purgeCache, boolean doit, boolean evenPersistent, boolean uninstalling, int userId, String reason) {
        int i;
        if (userId == -1 && packageName == null) {
            Slog.w(TAG, "Can't force stop all processes of all users, that is insane!");
        }
        if (appId < 0 && packageName != null) {
            try {
                appId = UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(packageName, 268435456, 0));
            } catch (RemoteException e) {
            }
        }
        if (doit) {
            if (packageName != null) {
                Slog.i(TAG, "Force stopping " + packageName + " appid=" + appId + " user=" + userId + ": " + reason);
            } else {
                Slog.i(TAG, "Force stopping u" + userId + ": " + reason);
            }
            OppoExtraActivityManagerService.setKeyLockModeNormal(this.mContext, packageName, this.mSystemReady);
            this.mAppErrors.resetProcessCrashTimeLocked(packageName == null, appId, userId);
        }
        boolean didSomething = killPackageProcessesLocked(packageName, appId, userId, -10000, callerWillRestart, true, doit, evenPersistent, packageName == null ? "stop user " + userId : "stop " + packageName);
        if (this.mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, null, doit, evenPersistent, userId)) {
            if (!doit) {
                return true;
            }
            didSomething = true;
        }
        if (this.mServices.bringDownDisabledPackageServicesLocked(packageName, null, userId, evenPersistent, true, doit)) {
            if (!doit) {
                return true;
            }
            didSomething = true;
        }
        if (packageName == null) {
            this.mStickyBroadcasts.remove(userId);
        }
        ArrayList providers = new ArrayList();
        if (this.mProviderMap.collectPackageProvidersLocked(packageName, null, doit, evenPersistent, userId, providers)) {
            if (!doit) {
                return true;
            }
            didSomething = true;
        }
        for (i = providers.size() - 1; i >= 0; i--) {
            removeDyingProviderLocked(null, (ContentProviderRecord) providers.get(i), true);
        }
        removeUriPermissionsForPackageLocked(packageName, userId, false);
        if (doit) {
            for (i = this.mBroadcastQueues.length - 1; i >= 0; i--) {
                didSomething |= this.mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, null, userId, doit);
            }
        }
        if ((packageName == null || uninstalling) && this.mIntentSenderRecords.size() > 0) {
            Iterator<WeakReference<PendingIntentRecord>> it = this.mIntentSenderRecords.values().iterator();
            while (it.hasNext()) {
                WeakReference<PendingIntentRecord> wpir = (WeakReference) it.next();
                if (wpir == null) {
                    it.remove();
                } else {
                    PendingIntentRecord pir = (PendingIntentRecord) wpir.get();
                    if (pir == null) {
                        it.remove();
                    } else {
                        if (packageName == null) {
                            if (pir.key.userId != userId) {
                                continue;
                            }
                        } else if (UserHandle.getAppId(pir.uid) == appId && (userId == -1 || pir.key.userId == userId)) {
                            if (!pir.key.packageName.equals(packageName)) {
                            }
                        }
                        if (!doit) {
                            return true;
                        }
                        int didSomething2 = 1;
                        it.remove();
                        pir.canceled = true;
                        if (!(pir.key.activity == null || pir.key.activity.pendingResults == null)) {
                            pir.key.activity.pendingResults.remove(pir.ref);
                        }
                    }
                }
            }
        }
        if (doit) {
            if (purgeCache && packageName != null) {
                AttributeCache ac = AttributeCache.instance();
                if (ac != null) {
                    ac.removePackage(packageName);
                }
            }
            if (this.mBooted) {
                this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                this.mStackSupervisor.scheduleIdleLocked();
            }
        }
        return didSomething;
    }

    private final ProcessRecord removeProcessNameLocked(String name, int uid) {
        ProcessRecord old = (ProcessRecord) this.mProcessNames.remove(name, uid);
        if (old != null) {
            UidRecord uidRecord = old.uidRecord;
            uidRecord.numProcs--;
            if (old.uidRecord.numProcs == 0) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "No more processes in " + old.uidRecord);
                }
                enqueueUidChangeLocked(old.uidRecord, -1, 1);
                this.mActiveUids.remove(uid);
                noteUidProcessState(uid, -1);
            }
            old.uidRecord = null;
        }
        this.mIsolatedProcesses.remove(uid);
        return old;
    }

    private final void addProcessNameLocked(ProcessRecord proc) {
        ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid);
        if (old == proc && proc.persistent) {
            Slog.w(TAG, "Re-adding persistent process " + proc);
        } else if (old != null) {
            Slog.w(TAG, "Already have existing proc " + old + " when adding " + proc);
        }
        UidRecord uidRec = (UidRecord) this.mActiveUids.get(proc.uid);
        if (uidRec == null) {
            uidRec = new UidRecord(proc.uid);
            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                Slog.i(TAG_UID_OBSERVERS, "Creating new process uid: " + uidRec);
            }
            this.mActiveUids.put(proc.uid, uidRec);
            noteUidProcessState(uidRec.uid, uidRec.curProcState);
            enqueueUidChangeLocked(uidRec, -1, 4);
        }
        proc.uidRecord = uidRec;
        proc.renderThreadTid = 0;
        uidRec.numProcs++;
        this.mProcessNames.put(proc.processName, proc.uid, proc);
        if (proc.isolated) {
            this.mIsolatedProcesses.put(proc.uid, proc);
        }
    }

    boolean removeProcessLocked(ProcessRecord app, boolean callerWillRestart, boolean allowRestart, String reason) {
        String name = app.processName;
        int uid = app.uid;
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.d(TAG_PROCESSES, "Force removing proc " + app.toShortString() + " (" + name + "/" + uid + ")");
        }
        if (((ProcessRecord) this.mProcessNames.get(name, uid)) != app) {
            Slog.w(TAG, "Ignoring remove of inactive process: " + app);
            return false;
        }
        removeProcessNameLocked(name, uid);
        if (this.mHeavyWeightProcess == app) {
            this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
            this.mHeavyWeightProcess = null;
        }
        boolean needRestart = false;
        if (app.pid <= 0 || app.pid == MY_PID) {
            this.mRemovedProcesses.add(app);
        } else {
            int pid = app.pid;
            synchronized (this.mPidsSelfLocked) {
                this.mPidsSelfLocked.remove(pid);
                this.mHandler.removeMessages(20, app);
            }
            this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
            if (app.isolated) {
                this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
            }
            boolean willRestart = false;
            if (app.persistent && !app.isolated) {
                if (callerWillRestart) {
                    needRestart = true;
                } else {
                    willRestart = true;
                }
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("oppo.clear.running", "0"))) {
                app.oppoClearProcess(reason, true);
            } else {
                app.kill(reason, true);
            }
            handleAppDiedLocked(app, willRestart, allowRestart);
            if (willRestart) {
                removeLruProcessLocked(app);
                addAppLocked(app.info, false, null);
            }
        }
        return needRestart;
    }

    private final void processContentProviderPublishTimedOutLocked(ProcessRecord app) {
        cleanupAppInLaunchingProvidersLocked(app, true);
        removeProcessLocked(app, false, true, "timeout publishing content providers");
    }

    private final void processStartTimedOutLocked(ProcessRecord app) {
        int pid = app.pid;
        boolean gone = false;
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord knownApp = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            if (knownApp != null && knownApp.thread == null) {
                this.mPidsSelfLocked.remove(pid);
                gone = true;
            }
        }
        if (gone) {
            Slog.w(TAG, "Process " + app + " failed to attach");
            Object[] objArr = new Object[4];
            objArr[0] = Integer.valueOf(app.userId);
            objArr[1] = Integer.valueOf(pid);
            objArr[2] = Integer.valueOf(app.uid);
            objArr[3] = app.processName;
            EventLog.writeEvent(EventLogTags.AM_PROCESS_START_TIMEOUT, objArr);
            removeProcessNameLocked(app.processName, app.uid);
            if (this.mHeavyWeightProcess == app) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                this.mHeavyWeightProcess = null;
            }
            this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
            if (app.isolated) {
                this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
            }
            cleanupAppInLaunchingProvidersLocked(app, true);
            this.mServices.processStartTimedOutLocked(app);
            app.kill("start timeout", true);
            removeLruProcessLocked(app);
            if (this.mBackupTarget != null && this.mBackupTarget.app.pid == pid) {
                Slog.w(TAG, "Unattached app died before backup, skipping");
                try {
                    IBackupManager.Stub.asInterface(ServiceManager.getService("backup")).agentDisconnected(app.info.packageName);
                } catch (RemoteException e) {
                }
            }
            if (isPendingBroadcastProcessLocked(pid)) {
                Slog.w(TAG, "Unattached app died before broadcast acknowledged, skipping");
                skipPendingBroadcastLocked(pid);
            }
            restartAfterStartTimeout(app.processName);
            return;
        }
        Slog.w(TAG, "Spurious process start timeout - pid not known for " + app);
    }

    private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
        ProcessRecord app;
        if (pid == MY_PID || pid < 0) {
            app = null;
        } else {
            synchronized (this.mPidsSelfLocked) {
                app = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            }
        }
        if (app == null) {
            Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
            EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
            if (pid <= 0 || pid == MY_PID) {
                try {
                    thread.scheduleExit();
                } catch (Exception e) {
                }
            } else {
                Process.killProcessQuiet(pid);
            }
            return false;
        }
        if (app.thread != null) {
            handleAppDiedLocked(app, true, true);
        }
        if (ActivityManagerDebugConfig.DEBUG_ALL) {
            Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
        }
        String processName = app.processName;
        try {
            AppDeathRecipient appDeathRecipient = new AppDeathRecipient(app, pid, thread);
            thread.asBinder().linkToDeath(appDeathRecipient, 0);
            app.deathRecipient = appDeathRecipient;
            Object[] objArr = new Object[3];
            objArr[0] = Integer.valueOf(app.userId);
            objArr[1] = Integer.valueOf(app.pid);
            objArr[2] = app.processName;
            EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, objArr);
            app.makeActive(thread, this.mProcessStats);
            app.verifiedAdj = -10000;
            app.setAdj = -10000;
            app.curAdj = -10000;
            app.setSchedGroup = 1;
            app.curSchedGroup = 1;
            app.forcingToForeground = null;
            updateProcessForegroundLocked(app, false, false);
            app.hasShownUi = false;
            app.debugging = false;
            app.cached = false;
            app.killedByAm = false;
            app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
            this.mHandler.removeMessages(20, app);
            boolean normalMode = !this.mProcessesReady ? isAllowedWhileBooting(app.info) : true;
            List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
            if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
                Message msg = this.mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
                app.isLaunchingProvider = true;
                msg.obj = app;
                this.mHandler.sendMessageDelayed(msg, 10000);
            }
            if (!normalMode) {
                Slog.i(TAG, "Launching preboot mode app: " + app);
            }
            if (ActivityManagerDebugConfig.DEBUG_ALL) {
                Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
            }
            int testMode = 0;
            try {
                ProfilerInfo profilerInfo;
                if (this.mDebugApp != null && this.mDebugApp.equals(processName)) {
                    if (this.mWaitForDebugger) {
                        testMode = 2;
                    } else {
                        testMode = 1;
                    }
                    app.debugging = true;
                    if (this.mDebugTransient) {
                        this.mDebugApp = this.mOrigDebugApp;
                        this.mWaitForDebugger = this.mOrigWaitForDebugger;
                    }
                }
                String profileFile = app.instrumentationProfileFile;
                ParcelFileDescriptor profileFd = null;
                int samplingInterval = 0;
                boolean profileAutoStop = false;
                if (this.mProfileApp != null && this.mProfileApp.equals(processName)) {
                    this.mProfileProc = app;
                    profileFile = this.mProfileFile;
                    profileFd = this.mProfileFd;
                    samplingInterval = this.mSamplingInterval;
                    profileAutoStop = this.mAutoStopProfiler;
                }
                boolean enableTrackAllocation = false;
                if (this.mTrackAllocationApp != null && this.mTrackAllocationApp.equals(processName)) {
                    enableTrackAllocation = true;
                    this.mTrackAllocationApp = null;
                }
                boolean isRestrictedBackupMode = false;
                if (this.mBackupTarget != null && this.mBackupAppName.equals(processName)) {
                    isRestrictedBackupMode = this.mBackupTarget.appInfo.uid >= 10000 ? (this.mBackupTarget.backupMode == 2 || this.mBackupTarget.backupMode == 3) ? true : this.mBackupTarget.backupMode == 1 : false;
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                        Slog.d(TAG_PROVIDER, "isRestrictedBackupMode " + isRestrictedBackupMode + " processName " + processName);
                    }
                }
                if (app.instrumentationClass != null) {
                    notifyPackageUse(app.instrumentationClass.getPackageName(), 7);
                }
                if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                    Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + this.mConfiguration);
                }
                ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info;
                app.compat = compatibilityInfoForPackageLocked(appInfo);
                if (profileFd != null) {
                    profileFd = profileFd.dup();
                }
                if (profileFile == null) {
                    profilerInfo = null;
                } else {
                    profilerInfo = new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);
                }
                ComponentName componentName = app.instrumentationClass;
                Bundle bundle = app.instrumentationArguments;
                IInstrumentationWatcher iInstrumentationWatcher = app.instrumentationWatcher;
                IUiAutomationConnection iUiAutomationConnection = app.instrumentationUiAutomationConnection;
                boolean z = this.mBinderTransactionTrackingEnabled;
                boolean z2 = isRestrictedBackupMode || !normalMode;
                thread.bindApplication(processName, appInfo, providers, componentName, profilerInfo, bundle, iInstrumentationWatcher, iUiAutomationConnection, testMode, z, enableTrackAllocation, z2, app.persistent, new Configuration(this.mConfiguration), app.compat, getCommonServicesLocked(app.isolated), this.mCoreSettingsObserver.getCoreSettingsLocked());
                updateLruProcessLocked(app, false, null);
                long uptimeMillis = SystemClock.uptimeMillis();
                app.lastLowMemory = uptimeMillis;
                app.lastRequestedGc = uptimeMillis;
                if (isImportantPersistProc(processName)) {
                    Slog.i(TAG, "attachApplicationLocked for proc:" + processName + " with pid:" + app.pid);
                }
                this.mPersistentStartingProcesses.remove(app);
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES && this.mProcessesOnHold.contains(app)) {
                    Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
                }
                this.mProcessesOnHold.remove(app);
                boolean badApp = false;
                int didSomething = false;
                if (normalMode) {
                    try {
                        if (this.mStackSupervisor.attachApplicationLocked(app)) {
                            didSomething = true;
                        }
                    } catch (Throwable e2) {
                        Slog.wtf(TAG, "Exception thrown launching activities in " + app, e2);
                        badApp = true;
                    }
                }
                if (!badApp) {
                    try {
                        if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
                            Slog.v(TAG, "mServices.attachApplicationLocked app " + app + " thread=" + thread.asBinder() + " pid=" + pid);
                        }
                        didSomething |= this.mServices.attachApplicationLocked(app, processName);
                    } catch (Throwable e22) {
                        Slog.wtf(TAG, "Exception thrown starting services in " + app, e22);
                        badApp = true;
                    }
                }
                if (!badApp && isPendingBroadcastProcessLocked(pid)) {
                    try {
                        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                            Slog.v(TAG, "sendPendingBroadcastsLocked app " + app + " thread=" + thread.asBinder() + " pid=" + pid);
                        }
                        didSomething |= sendPendingBroadcastsLocked(app);
                    } catch (Throwable e222) {
                        Slog.v(TAG, "Exception thrown dispatching broadcasts in " + app, e222);
                        badApp = true;
                    }
                }
                if (!(badApp || this.mBackupTarget == null || this.mBackupTarget.appInfo.uid != app.uid)) {
                    if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                        Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
                    }
                    notifyPackageUse(this.mBackupTarget.appInfo.packageName, 5);
                    try {
                        thread.scheduleCreateBackupAgent(this.mBackupTarget.appInfo, compatibilityInfoForPackageLocked(this.mBackupTarget.appInfo), this.mBackupTarget.backupMode);
                    } catch (Throwable e2222) {
                        Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e2222);
                        badApp = true;
                    }
                }
                if (badApp) {
                    app.kill("error during init", true);
                    handleAppDiedLocked(app, false, true);
                    return false;
                }
                if (didSomething == 0) {
                    updateOomAdjLocked();
                }
                return true;
            } catch (Throwable e22222) {
                Slog.wtf(TAG, "Exception thrown during bind of " + app, e22222);
                app.resetPackageList(this.mProcessStats);
                app.unlinkDeathRecipient();
                return false;
            }
        } catch (RemoteException e3) {
            app.resetPackageList(this.mProcessStats);
            startProcessLocked(app, "link fail", processName);
            return false;
        }
    }

    public final void attachApplication(IApplicationThread thread) {
        if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.d(TAG, "ACT-attachApplication pid " + Binder.getCallingPid() + " to thread " + thread);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingPid = Binder.getCallingPid();
                long origId = Binder.clearCallingIdentity();
                attachApplicationLocked(thread, callingPid);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {
        long origId = Binder.clearCallingIdentity();
        Intent idleIntent = null;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityRecord.getStackLocked(token) != null) {
                    ActivityRecord r = this.mStackSupervisor.activityIdleInternalLocked(token, false, config);
                    if (stopProfiling && this.mProfileProc == r.app && this.mProfileFd != null) {
                        try {
                            this.mProfileFd.close();
                        } catch (IOException e) {
                        }
                        clearProfilerLocked();
                    }
                    if (this.mStackSupervisor.isInAnyStackLocked(token) != null) {
                        idleIntent = r.intent;
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
        EndOfActivityIdle eventData = EndOfActivityIdle.createInstance();
        Object[] objArr = new Object[2];
        objArr[0] = this.mContext;
        objArr[1] = idleIntent;
        eventData.set(objArr);
        this.mAMEventHook.hook(Event.AM_EndOfActivityIdle, eventData);
    }

    void postFinishBooting(boolean finishBooting, boolean enableScreen) {
        int i;
        int i2 = 1;
        MainHandler mainHandler = this.mHandler;
        MainHandler mainHandler2 = this.mHandler;
        if (finishBooting) {
            i = 1;
        } else {
            i = 0;
        }
        if (!enableScreen) {
            i2 = 0;
        }
        mainHandler.sendMessage(mainHandler2.obtainMessage(45, i, i2));
    }

    void enableScreenAfterBoot() {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN, SystemClock.uptimeMillis());
        BootEvent.addBootEvent("AMS:ENABLE_SCREEN");
        this.mWindowManager.enableScreenAfterBoot();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                updateEventDispatchingLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void showBootMessage(CharSequence msg, boolean always) {
        if (Binder.getCallingUid() != Process.myUid()) {
            throw new SecurityException();
        } else if (this.mWindowManager != null) {
            this.mWindowManager.showBootMessage(msg, always);
        }
    }

    public void keyguardWaitingForActivityDrawn() {
        enforceNotIsolatedCaller("keyguardWaitingForActivityDrawn");
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_LOCKSCREEN) {
                    logLockScreen(IElsaManager.EMPTY_PACKAGE);
                }
                this.mWindowManager.keyguardWaitingForActivityDrawn();
                if (this.mLockScreenShown == 2) {
                    this.mLockScreenShown = 1;
                    updateSleepIfNeededLocked();
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(token);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(token);
        }
    }

    public void keyguardGoingAway(int flags) {
        enforceNotIsolatedCaller("keyguardGoingAway");
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_LOCKSCREEN) {
                    logLockScreen(IElsaManager.EMPTY_PACKAGE);
                }
                this.mWindowManager.keyguardGoingAway(flags);
                if (this.mLockScreenShown == 2) {
                    this.mLockScreenShown = 0;
                    updateSleepIfNeededLocked();
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    applyVrModeIfNeededLocked(this.mFocusedActivity, true);
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(token);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(token);
        }
    }

    /* JADX WARNING: Missing block: B:11:0x001a, code:
            resetPriorityAfterLockedSection();
            r4 = new android.util.ArraySet();
            r15 = android.os.Build.SUPPORTED_ABIS;
            r14 = 0;
            r16 = r15.length;
     */
    /* JADX WARNING: Missing block: B:13:0x002a, code:
            if (r14 >= r16) goto L_0x0087;
     */
    /* JADX WARNING: Missing block: B:14:0x002c, code:
            r3 = r15[r14];
            android.os.Process.establishZygoteConnectionForAbi(r3);
            r9 = dalvik.system.VMRuntime.getInstructionSet(r3);
     */
    /* JADX WARNING: Missing block: B:15:0x0039, code:
            if (r4.contains(r9) != false) goto L_0x004b;
     */
    /* JADX WARNING: Missing block: B:17:?, code:
            r20.mInstaller.markBootComplete(dalvik.system.VMRuntime.getInstructionSet(r3));
     */
    /* JADX WARNING: Missing block: B:22:0x0054, code:
            r6 = move-exception;
     */
    /* JADX WARNING: Missing block: B:23:0x0055, code:
            android.util.Slog.w(TAG, "Unable to mark boot complete for abi: " + r3 + " (" + r6.getMessage() + ")");
     */
    /* JADX WARNING: Missing block: B:24:0x0087, code:
            r12 = new android.content.IntentFilter();
            r12.addAction("android.intent.action.QUERY_PACKAGE_RESTART");
            r12.addDataScheme("package");
            r20.mContext.registerReceiver(new com.android.server.am.ActivityManagerService.AnonymousClass13(r20), r12);
            r5 = new android.content.IntentFilter();
            r5.addAction("com.android.server.am.DELETE_DUMPHEAP");
            r20.mContext.registerReceiver(new com.android.server.am.ActivityManagerService.AnonymousClass14(r20), r5);
            r20.mSystemServiceManager.startBootPhase(1000);
            com.mediatek.server.am.BootEvent.setEnabled(false);
     */
    /* JADX WARNING: Missing block: B:25:0x00cc, code:
            monitor-enter(r20);
     */
    /* JADX WARNING: Missing block: B:27:?, code:
            boostPriorityForLockedSection();
            r2 = r20.mProcessesOnHold.size();
     */
    /* JADX WARNING: Missing block: B:28:0x00d8, code:
            if (r2 <= 0) goto L_0x011c;
     */
    /* JADX WARNING: Missing block: B:29:0x00da, code:
            r13 = new java.util.ArrayList(r20.mProcessesOnHold);
            r10 = 0;
     */
    /* JADX WARNING: Missing block: B:30:0x00e4, code:
            if (r10 >= r2) goto L_0x011c;
     */
    /* JADX WARNING: Missing block: B:32:0x00e8, code:
            if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_PROCESSES == false) goto L_0x0107;
     */
    /* JADX WARNING: Missing block: B:33:0x00ea, code:
            android.util.Slog.v(TAG_PROCESSES, "Starting process on hold: " + r13.get(r10));
     */
    /* JADX WARNING: Missing block: B:34:0x0107, code:
            startProcessLocked((com.android.server.am.ProcessRecord) r13.get(r10), "on-hold", null);
            r10 = r10 + 1;
     */
    /* JADX WARNING: Missing block: B:36:0x0121, code:
            if (r20.mFactoryTest == 1) goto L_0x01a1;
     */
    /* JADX WARNING: Missing block: B:37:0x0123, code:
            r20.mHandler.sendMessageDelayed(r20.mHandler.obtainMessage(27), (long) POWER_CHECK_DELAY);
     */
    /* JADX WARNING: Missing block: B:38:0x014f, code:
            if (com.mediatek.am.AMEventHookResult.hasAction(r20.mAMEventHook.hook(com.mediatek.server.am.AMEventHook.Event.AM_BeforeSendBootCompleted, com.mediatek.am.AMEventHookData.BeforeSendBootCompleted.createInstance()), com.mediatek.am.AMEventHookAction.AM_Interrupt) == false) goto L_0x0156;
     */
    /* JADX WARNING: Missing block: B:39:0x0151, code:
            monitor-exit(r20);
     */
    /* JADX WARNING: Missing block: B:42:?, code:
            android.util.Slog.v(TAG, "broadcast BOOT_COMPLETED intent");
            android.os.SystemProperties.set("sys.boot_completed", com.android.server.LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON);
     */
    /* JADX WARNING: Missing block: B:43:0x0175, code:
            if ("trigger_restart_min_framework".equals(android.os.SystemProperties.get("vold.decrypt")) == false) goto L_0x0187;
     */
    /* JADX WARNING: Missing block: B:45:0x0185, code:
            if (com.android.server.oppo.IElsaManager.EMPTY_PACKAGE.equals(android.os.SystemProperties.get("vold.encrypt_progress")) == false) goto L_0x0190;
     */
    /* JADX WARNING: Missing block: B:46:0x0187, code:
            android.os.SystemProperties.set("dev.bootcomplete", com.android.server.LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON);
     */
    /* JADX WARNING: Missing block: B:47:0x0190, code:
            r20.mUserController.sendBootCompletedLocked(new com.android.server.am.ActivityManagerService.AnonymousClass15(r20));
            scheduleStartProfilesLocked();
     */
    /* JADX WARNING: Missing block: B:48:0x01a1, code:
            monitor-exit(r20);
     */
    /* JADX WARNING: Missing block: B:49:0x01a2, code:
            resetPriorityAfterLockedSection();
            mANRManager.writeEvent(com.mediatek.anrmanager.ANRManager.EVENT_BOOT_COMPLETED);
     */
    /* JADX WARNING: Missing block: B:50:0x01ac, code:
            return;
     */
    /* JADX WARNING: Missing block: B:52:0x01af, code:
            resetPriorityAfterLockedSection();
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void finishBooting() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mBootAnimationComplete) {
                    this.mCallFinishBooting = false;
                } else {
                    this.mCallFinishBooting = true;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return;
        return;
        completedIsas.add(instructionSet);
        int i++;
    }

    private void noticeHypnusBootCompleted() {
        if (this.mHyp == null) {
            this.mHyp = new Hypnus();
        }
        if (this.mHyp != null) {
            this.mHyp.hypnusSendBootComplete();
            this.mHyp.hypnusSetAction(12, OppoBrightUtils.HIGH_BRIGHTNESS_MAX_LUX);
        }
    }

    public void bootAnimationComplete() {
        boolean callFinishBooting;
        uploadBootTime();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.d(TAG, "bootAnimationComplete() mCallFinishBooting = " + this.mCallFinishBooting);
                }
                callFinishBooting = this.mCallFinishBooting;
                this.mBootAnimationComplete = true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (callFinishBooting) {
            Trace.traceBegin(64, "FinishBooting");
            finishBooting();
            Trace.traceEnd(64);
        }
    }

    private void uploadBootTime() {
        HashMap<String, String> map = new HashMap();
        map.put("bootTime", String.valueOf(SystemClock.elapsedRealtime()));
        OppoStatistics.onCommon(this.mContext, DcsFingerprintStatisticsUtil.SYSTEM_APP_TAG, "boot_time", map, false);
    }

    private boolean isDoingDexopt(int uid) {
        if (uid <= 0) {
            return false;
        }
        boolean isDoingDexoptLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                isDoingDexoptLocked = isDoingDexoptLocked(uid);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return isDoingDexoptLocked;
    }

    private boolean isDoingDexoptLocked(int uid) {
        if (this.mDexOptTimeMap == null || !this.mDexOptTimeMap.containsKey(Integer.valueOf(uid))) {
            return false;
        }
        long lastDexoptTime = ((Long) this.mDexOptTimeMap.get(Integer.valueOf(uid))).longValue();
        long tmp = System.currentTimeMillis() - lastDexoptTime;
        Slog.w(TAG, "isDoingDexoptLocked, lastDexoptTime = " + lastDexoptTime + ", cost = " + tmp + " ms");
        if (tmp < APP_DEXOPT_TIMEOUT) {
            return true;
        }
        return false;
    }

    public void appDexOpt(boolean start) {
        int uid = Binder.getCallingUid();
        if (Binder.getCallingUid() >= 10000) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (start) {
                        appDexOptAddLocked(uid);
                    } else {
                        appDexOptRemoveLocked(uid);
                    }
                    if (this.mHyp == null) {
                        this.mHyp = new Hypnus();
                    }
                    if (start) {
                        this.dexStart = true;
                        this.mHyp.hypnusSetAction(15, 20000);
                    } else if (this.dexStart) {
                        this.dexStart = false;
                        this.mHyp.hypnusSetAction(15, 0);
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
    }

    private void appDexOptRemoveLocked(int uid) {
        if (this.mDexOptTimeMap != null && this.mDexOptTimeMap.containsKey(Integer.valueOf(uid))) {
            this.mDexOptTimeMap.remove(Integer.valueOf(uid));
            if (ActivityManagerDebugConfig.DEBUG_AMS) {
                Slog.w(TAG, "Finish dexopt: " + uid);
            }
        }
    }

    private void appDexOptAddLocked(int uid) {
        if (this.mDexOptTimeMap != null) {
            this.mDexOptTimeMap.remove(Integer.valueOf(uid));
            if (ActivityManagerDebugConfig.DEBUG_AMS) {
                Slog.w(TAG, "Start dexopt: " + uid);
            }
            this.mDexOptTimeMap.put(Integer.valueOf(uid), Long.valueOf(System.currentTimeMillis()));
        }
    }

    public void reportJunkFromApp(String type, String packageName, String content, boolean forcePersist) {
        if (forcePersist) {
            OppoJunkRecorder.getInstance().forcePersist(System.currentTimeMillis());
        } else {
            OppoJunkRecorder.getInstance().reportJunkEvent(type, packageName, content);
        }
    }

    final void ensureBootCompleted() {
        boolean booting;
        boolean enableScreen;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                booting = this.mBooting;
                this.mBooting = false;
                enableScreen = !this.mBooted;
                this.mBooted = true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (booting) {
            Trace.traceBegin(64, "FinishBooting");
            finishBooting();
            Trace.traceEnd(64);
        }
        if (enableScreen) {
            enableScreenAfterBoot();
        }
    }

    public final void activityResumed(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.activityResumedLocked(token);
                    ActivityRecord ar = ActivityRecord.forTokenLocked(token);
                    if (!(ar == null || ar.app == null || ar.app.info == null)) {
                        OppoAppStartInfo crashCount = (OppoAppStartInfo) OppoCrashClearManager.getInstance().mProcessCrashCount.get(ar.app.info.processName);
                        if (crashCount != null) {
                            crashCount.setFirstStartTime(-1);
                        }
                    }
                    if (SystemProperties.get("ro.mtk_aws_support").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON) && AWSManager.getInstance() != null) {
                        this.mBgHandler.sendEmptyMessage(2);
                        this.mBgHandler.sendEmptyMessageDelayed(2, 5000);
                    }
                    if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                        ActivityRecord r = ActivityRecord.forTokenLocked(token);
                        ActivityThreadResumedDone eventData = ActivityThreadResumedDone.createInstance();
                        Object[] objArr = new Object[1];
                        objArr[0] = r.info.packageName;
                        eventData.set(objArr);
                        this.mAMEventHook.hook(Event.AM_ActivityThreadResumedDone, eventData);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    public final void activityPaused(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.activityPausedLocked(token, false);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    public final void activityStopped(IBinder token, Bundle icicle, PersistableBundle persistentState, CharSequence description) {
        if (ActivityManagerDebugConfig.DEBUG_ALL) {
            Slog.v(TAG, "Activity stopped: token=" + token);
        }
        if (icicle == null || !icicle.hasFileDescriptors()) {
            long origId = Binder.clearCallingIdentity();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.isInStackLocked(token);
                    if (r != null) {
                        r.task.stack.activityStoppedLocked(r, icicle, persistentState, description);
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            trimApplications();
            Binder.restoreCallingIdentity(origId);
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Bundle");
    }

    public final void activityDestroyed(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.v(TAG_SWITCH, "ACTIVITY DESTROYED: " + token);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.activityDestroyedLocked(token, "activityDestroyed");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void activityRelaunched(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mStackSupervisor.activityRelaunchedLocked(token);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    public void reportSizeConfigurations(IBinder token, int[] horizontalSizeConfiguration, int[] verticalSizeConfigurations, int[] smallestSizeConfigurations) {
        if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
            Slog.v(TAG, "Report configuration: " + token + " " + horizontalSizeConfiguration + " " + verticalSizeConfigurations);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord record = ActivityRecord.isInStackLocked(token);
                if (record == null) {
                    throw new IllegalArgumentException("reportSizeConfigurations: ActivityRecord not found for: " + token);
                }
                record.setSizeConfigurations(horizontalSizeConfiguration, verticalSizeConfigurations, smallestSizeConfigurations);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void backgroundResourcesReleased(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.backgroundResourcesReleased();
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(origId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public final void notifyLaunchTaskBehindComplete(IBinder token) {
        this.mStackSupervisor.scheduleLaunchTaskBehindComplete(token);
    }

    public final void notifyEnterAnimationComplete(IBinder token) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(44, token));
    }

    public String getCallingPackage(IBinder token) {
        String str = null;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getCallingRecordLocked(token);
                if (r != null) {
                    str = r.info.packageName;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return str;
    }

    public ComponentName getCallingActivity(IBinder token) {
        ComponentName componentName = null;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getCallingRecordLocked(token);
                if (r != null) {
                    componentName = r.intent.getComponent();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return componentName;
    }

    private ActivityRecord getCallingRecordLocked(IBinder token) {
        ActivityRecord r = ActivityRecord.isInStackLocked(token);
        if (r == null) {
            return null;
        }
        return r.resultTo;
    }

    public ComponentName getActivityClassForToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                } else {
                    ComponentName component = r.intent.getComponent();
                    resetPriorityAfterLockedSection();
                    return component;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    public String getPackageForToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                } else {
                    String str = r.packageName;
                    resetPriorityAfterLockedSection();
                    return str;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    public boolean isRootVoiceInteraction(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    boolean z = r.rootVoiceInteraction;
                    resetPriorityAfterLockedSection();
                    return z;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    public IIntentSender getIntentSender(int type, String packageName, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("getIntentSender");
        if (intents != null) {
            if (intents.length < 1) {
                throw new IllegalArgumentException("Intents array length must be >= 1");
            }
            for (int i = 0; i < intents.length; i++) {
                Intent intent = intents[i];
                if (intent != null) {
                    if (intent.hasFileDescriptors()) {
                        throw new IllegalArgumentException("File descriptors passed in Intent");
                    } else if (type != 1 || (intent.getFlags() & 33554432) == 0) {
                        intents[i] = new Intent(intent);
                    } else {
                        throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
                    }
                }
            }
            if (!(resolvedTypes == null || resolvedTypes.length == intents.length)) {
                throw new IllegalArgumentException("Intent array length does not match resolvedTypes length");
            }
        }
        if (bOptions == null || !bOptions.hasFileDescriptors()) {
            IIntentSender intentSenderLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    int callingUid = Binder.getCallingUid();
                    int origUserId = userId;
                    userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, type == 1, 0, "getIntentSender", null);
                    if (origUserId == -2) {
                        userId = -2;
                    }
                    if (!(callingUid == 0 || callingUid == 1000)) {
                        int uid = AppGlobals.getPackageManager().getPackageUid(packageName, 268435456, UserHandle.getUserId(callingUid));
                        if (!UserHandle.isSameApp(callingUid, uid)) {
                            String msg = "Permission Denial: getIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + ", (need uid=" + uid + ")" + " is not allowed to send as package " + packageName;
                            Slog.w(TAG, msg);
                            throw new SecurityException(msg);
                        }
                    }
                    intentSenderLocked = getIntentSenderLocked(type, packageName, callingUid, userId, token, resultWho, requestCode, intents, resolvedTypes, flags, bOptions);
                } catch (Throwable e) {
                    throw new SecurityException(e);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
            return intentSenderLocked;
        }
        throw new IllegalArgumentException("File descriptors passed in options");
    }

    IIntentSender getIntentSenderLocked(int type, String packageName, int callingUid, int userId, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions) {
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
        }
        ActivityRecord activity = null;
        if (type == 3) {
            activity = ActivityRecord.isInStackLocked(token);
            if (activity == null) {
                Slog.w(TAG, "Failed createPendingResult: activity " + token + " not in any stack");
                return null;
            } else if (activity.finishing) {
                Slog.w(TAG, "Failed createPendingResult: activity " + activity + " is finishing");
                return null;
            }
        }
        if (intents != null) {
            for (Intent defusable : intents) {
                defusable.setDefusable(true);
            }
        }
        Bundle.setDefusable(bOptions, true);
        boolean noCreate = (536870912 & flags) != 0;
        boolean cancelCurrent = (268435456 & flags) != 0;
        boolean updateCurrent = (134217728 & flags) != 0;
        Key key = new Key(type, packageName, activity, resultWho, requestCode, intents, resolvedTypes, flags & -939524097, bOptions, userId);
        WeakReference<PendingIntentRecord> ref = (WeakReference) this.mIntentSenderRecords.get(key);
        PendingIntentRecord rec = ref != null ? (PendingIntentRecord) ref.get() : null;
        if (rec != null) {
            if (cancelCurrent) {
                rec.canceled = true;
                this.mIntentSenderRecords.remove(key);
            } else {
                if (updateCurrent) {
                    if (rec.key.requestIntent != null) {
                        rec.key.requestIntent.replaceExtras(intents != null ? intents[intents.length - 1] : null);
                    }
                    if (intents != null) {
                        intents[intents.length - 1] = rec.key.requestIntent;
                        rec.key.allIntents = intents;
                        rec.key.allResolvedTypes = resolvedTypes;
                    } else {
                        rec.key.allIntents = null;
                        rec.key.allResolvedTypes = null;
                    }
                }
                return rec;
            }
        }
        if (noCreate) {
            return rec;
        }
        PendingIntentRecord pendingIntentRecord = new PendingIntentRecord(this, key, callingUid);
        this.mIntentSenderRecords.put(key, pendingIntentRecord.ref);
        if (type == 3) {
            if (activity.pendingResults == null) {
                activity.pendingResults = new HashSet();
            }
            activity.pendingResults.add(pendingIntentRecord.ref);
        }
        return pendingIntentRecord;
    }

    public int sendIntentSender(IIntentSender target, int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {
        if (target instanceof PendingIntentRecord) {
            return ((PendingIntentRecord) target).sendWithResult(code, intent, resolvedType, finishedReceiver, requiredPermission, options);
        }
        if (intent == null) {
            Slog.wtf(TAG, "Can't use null intent with direct IIntentSender call");
            intent = new Intent("android.intent.action.MAIN");
        }
        try {
            target.send(code, intent, resolvedType, null, requiredPermission, options);
        } catch (RemoteException e) {
        }
        if (finishedReceiver != null) {
            try {
                finishedReceiver.performReceive(intent, 0, null, null, false, false, UserHandle.getCallingUserId());
            } catch (RemoteException e2) {
            }
        }
        return 0;
    }

    /* JADX WARNING: Missing block: B:18:0x00a1, code:
            return;
     */
    /* JADX WARNING: Missing block: B:20:0x00a3, code:
            r8 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Missing block: B:22:?, code:
            r10.mLocalDeviceIdleController.addPowerSaveTempWhitelistAppDirect(r13, r14, true, "pe from uid:" + r12);
     */
    /* JADX WARNING: Missing block: B:28:0x00cb, code:
            android.os.Binder.restoreCallingIdentity(r8);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void tempWhitelistAppForPowerSave(int callerPid, int callerUid, int targetUid, long duration) {
        if (ActivityManagerDebugConfig.DEBUG_WHITELISTS) {
            Slog.d(TAG, "tempWhitelistAppForPowerSave(" + callerPid + ", " + callerUid + ", " + targetUid + ", " + duration + ")");
        }
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(callerPid);
            if (pr == null) {
                Slog.w(TAG, "tempWhitelistAppForPowerSave() no ProcessRecord for pid " + callerPid);
            } else if (!pr.whitelistManager) {
                if (ActivityManagerDebugConfig.DEBUG_WHITELISTS) {
                    Slog.d(TAG, "tempWhitelistAppForPowerSave() for target " + targetUid + ": pid " + callerPid + " is not allowed");
                }
            }
        }
    }

    public void cancelIntentSender(IIntentSender sender) {
        if (sender instanceof PendingIntentRecord) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    PendingIntentRecord rec = (PendingIntentRecord) sender;
                    if (UserHandle.isSameApp(AppGlobals.getPackageManager().getPackageUid(rec.key.packageName, 268435456, UserHandle.getCallingUserId()), Binder.getCallingUid())) {
                        cancelIntentSenderLocked(rec, true);
                    } else {
                        String msg = "Permission Denial: cancelIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " is not allowed to cancel packges " + rec.key.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                } catch (RemoteException e) {
                    throw new SecurityException(e);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
        }
    }

    void cancelIntentSenderLocked(PendingIntentRecord rec, boolean cleanActivity) {
        rec.canceled = true;
        this.mIntentSenderRecords.remove(rec.key);
        if (cleanActivity && rec.key.activity != null) {
            rec.key.activity.pendingResults.remove(rec.ref);
        }
    }

    public String getPackageForIntentSender(IIntentSender pendingResult) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return null;
        }
        try {
            return ((PendingIntentRecord) pendingResult).key.packageName;
        } catch (ClassCastException e) {
            return null;
        }
    }

    public int getUidForIntentSender(IIntentSender sender) {
        if (sender instanceof PendingIntentRecord) {
            try {
                return ((PendingIntentRecord) sender).uid;
            } catch (ClassCastException e) {
            }
        }
        return -1;
    }

    public boolean isIntentSenderTargetedToPackage(IIntentSender pendingResult) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return false;
        }
        try {
            PendingIntentRecord res = (PendingIntentRecord) pendingResult;
            if (res.key.allIntents == null) {
                return false;
            }
            for (Intent intent : res.key.allIntents) {
                if (intent.getPackage() != null && intent.getComponent() != null) {
                    return false;
                }
            }
            return true;
        } catch (ClassCastException e) {
            return false;
        }
    }

    public boolean isIntentSenderAnActivity(IIntentSender pendingResult) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return false;
        }
        try {
            if (((PendingIntentRecord) pendingResult).key.type == 2) {
                return true;
            }
            return false;
        } catch (ClassCastException e) {
            return false;
        }
    }

    public Intent getIntentForIntentSender(IIntentSender pendingResult) {
        enforceCallingPermission("android.permission.GET_INTENT_SENDER_INTENT", "getIntentForIntentSender()");
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return null;
        }
        try {
            PendingIntentRecord res = (PendingIntentRecord) pendingResult;
            return res.key.requestIntent != null ? new Intent(res.key.requestIntent) : null;
        } catch (ClassCastException e) {
            return null;
        }
    }

    public String getTagForIntentSender(IIntentSender pendingResult, String prefix) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return null;
        }
        try {
            String tagForIntentSenderLocked;
            PendingIntentRecord res = (PendingIntentRecord) pendingResult;
            synchronized (this) {
                boostPriorityForLockedSection();
                tagForIntentSenderLocked = getTagForIntentSenderLocked(res, prefix);
            }
            resetPriorityAfterLockedSection();
            return tagForIntentSenderLocked;
        } catch (ClassCastException e) {
            return null;
        } catch (Throwable th) {
            resetPriorityAfterLockedSection();
        }
    }

    String getTagForIntentSenderLocked(PendingIntentRecord res, String prefix) {
        Intent intent = res.key.requestIntent;
        if (intent == null) {
            return null;
        }
        if (res.lastTag != null && res.lastTagPrefix == prefix && (res.lastTagPrefix == null || res.lastTagPrefix.equals(prefix))) {
            return res.lastTag;
        }
        res.lastTagPrefix = prefix;
        StringBuilder sb = new StringBuilder(128);
        if (prefix != null) {
            sb.append(prefix);
        }
        if (intent.getAction() != null) {
            sb.append(intent.getAction());
        } else if (intent.getComponent() != null) {
            intent.getComponent().appendShortString(sb);
        } else {
            sb.append("?");
        }
        String stringBuilder = sb.toString();
        res.lastTag = stringBuilder;
        return stringBuilder;
    }

    public void setProcessLimit(int max) {
        enforceCallingPermission("android.permission.SET_PROCESS_LIMIT", "setProcessLimit()");
        synchronized (this) {
            try {
                int i;
                boostPriorityForLockedSection();
                if (max < 0) {
                    i = 32;
                } else {
                    i = max;
                }
                this.mProcessLimit = i;
                this.mProcessLimitOverride = max;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        trimApplications();
    }

    public int getProcessLimit() {
        int i;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                i = this.mProcessLimitOverride;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    void foregroundTokenDied(ForegroundToken token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    if (((ForegroundToken) this.mForegroundProcesses.get(token.pid)) == token) {
                        this.mForegroundProcesses.remove(token.pid);
                        ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(token.pid);
                        if (pr == null) {
                            resetPriorityAfterLockedSection();
                            return;
                        }
                        pr.forcingToForeground = null;
                        updateProcessForegroundLocked(pr, false, false);
                        updateOomAdjLocked();
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: Missing block: B:30:0x0071, code:
            if (r0 == false) goto L_0x0076;
     */
    /* JADX WARNING: Missing block: B:31:0x0073, code:
            updateOomAdjLocked();
     */
    /* JADX WARNING: Missing block: B:33:0x0077, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:34:0x007a, code:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void setProcessForeground(IBinder token, int pid, boolean isForeground) {
        enforceCallingPermission("android.permission.SET_PROCESS_LIMIT", "setProcessForeground()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean changed = false;
                synchronized (this.mPidsSelfLocked) {
                    ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                    if (pr == null && isForeground) {
                        Slog.w(TAG, "setProcessForeground called on unknown pid: " + pid);
                    } else {
                        ForegroundToken oldToken = (ForegroundToken) this.mForegroundProcesses.get(pid);
                        if (oldToken != null) {
                            oldToken.token.unlinkToDeath(oldToken, 0);
                            this.mForegroundProcesses.remove(pid);
                            if (pr != null) {
                                pr.forcingToForeground = null;
                            }
                            changed = true;
                        }
                        if (isForeground && token != null) {
                            ForegroundToken newToken = new ForegroundToken(this) {
                                public void binderDied() {
                                    this.foregroundTokenDied(this);
                                }
                            };
                            newToken.pid = pid;
                            newToken.token = token;
                            try {
                                token.linkToDeath(newToken, 0);
                                this.mForegroundProcesses.put(pid, newToken);
                                pr.forcingToForeground = token;
                                changed = true;
                            } catch (RemoteException e) {
                            }
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: Missing block: B:15:0x001f, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:16:0x0022, code:
            return r1;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isAppForeground(int uid) throws RemoteException {
        boolean z = false;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
                if (uidRec == null || uidRec.idle) {
                } else if (uidRec.curProcState <= 6) {
                    z = true;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    int getUidState(int uid) {
        int i;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
                i = uidRec == null ? -1 : uidRec.curProcState;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    public boolean isInMultiWindowMode(IBinder token) {
        boolean z = false;
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
                if (!r.task.mFullscreen) {
                    z = true;
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return z;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean isInPictureInPictureMode(IBinder token) {
        boolean z = false;
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
                if (stack.mStackId == 4) {
                    z = true;
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return z;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void enterPictureInPictureMode(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (this.mSupportsPictureInPicture) {
                    ActivityRecord r = ActivityRecord.forTokenLocked(token);
                    if (r == null) {
                        throw new IllegalStateException("enterPictureInPictureMode: Can't find activity for token=" + token);
                    } else if (r.supportsPictureInPicture()) {
                        ActivityStack pinnedStack = this.mStackSupervisor.getStack(4);
                        this.mStackSupervisor.moveActivityToPinnedStackLocked(r, "enterPictureInPictureMode", pinnedStack != null ? pinnedStack.mBounds : this.mDefaultPinnedStackBounds);
                    } else {
                        throw new IllegalArgumentException("enterPictureInPictureMode: Picture-In-Picture not supported for r=" + r);
                    }
                }
                throw new IllegalStateException("enterPictureInPictureMode: Device doesn't support picture-in-picture mode.");
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(origId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void getProcessStatesAndOomScoresForPIDs(int[] pids, int[] states, int[] scores) {
        if (scores != null) {
            enforceCallingPermission("android.permission.GET_PROCESS_STATE_AND_OOM_SCORE", "getProcessStatesAndOomScoresForPIDs()");
        }
        if (pids == null) {
            throw new NullPointerException("pids");
        } else if (states == null) {
            throw new NullPointerException("states");
        } else if (pids.length != states.length) {
            throw new IllegalArgumentException("pids and states arrays have different lengths!");
        } else if (scores == null || pids.length == scores.length) {
            synchronized (this.mPidsSelfLocked) {
                for (int i = 0; i < pids.length; i++) {
                    int i2;
                    ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(pids[i]);
                    if (pr == null) {
                        i2 = -1;
                    } else {
                        i2 = pr.curProcState;
                    }
                    states[i] = i2;
                    if (scores != null) {
                        if (pr == null) {
                            i2 = -10000;
                        } else {
                            i2 = pr.curAdj;
                        }
                        scores[i] = i2;
                    }
                }
            }
        } else {
            throw new IllegalArgumentException("pids and scores arrays have different lengths!");
        }
    }

    int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) {
        if (pid == MY_PID) {
            if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                Slog.d(TAG, "checkComponentPermission: " + permission + ", " + pid + ", " + uid + ", " + owningUid + ", " + exported);
            }
            return 0;
        }
        if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
            Slog.d(TAG, "checkComponentPermission: " + permission + ", " + pid + ", " + uid + ", " + owningUid + ", " + exported + ", " + UserHandle.getAppId(uid) + ", " + UserHandle.isIsolated(uid) + ", " + UserHandle.isSameApp(uid, owningUid));
        }
        return ActivityManager.checkComponentPermission(permission, uid, owningUid, exported);
    }

    public int checkPermission(String permission, int pid, int uid) {
        if (permission != null) {
            return checkComponentPermission(permission, pid, uid, -1, true);
        }
        if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
            Slog.d(TAG, "checkPermission: permission == null, " + pid + ", " + uid);
        }
        return -1;
    }

    public int checkPermissionWithToken(String permission, int pid, int uid, IBinder callerToken) {
        if (permission == null) {
            if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                Slog.d(TAG, "checkPermissionWithToken: permission == null, " + pid + ", " + uid);
            }
            return -1;
        }
        Identity tlsIdentity = (Identity) sCallerIdentity.get();
        if (tlsIdentity != null && tlsIdentity.token == callerToken) {
            Slog.d(TAG, "checkComponentPermission() adjusting {pid,uid} to {" + tlsIdentity.pid + "," + tlsIdentity.uid + "}");
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }
        return checkComponentPermission(permission, pid, uid, -1, true);
    }

    int checkCallingPermission(String permission) {
        return checkPermission(permission, Binder.getCallingPid(), UserHandle.getAppId(Binder.getCallingUid()));
    }

    void enforceCallingPermission(String permission, String func) {
        if (checkCallingPermission(permission) != 0) {
            String msg = "Permission Denial: " + func + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + permission;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
    }

    private final boolean checkHoldingPermissionsLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, int modeFlags) {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "checkHoldingPermissionsLocked: uri=" + grantUri + " uid=" + uid);
        }
        if (UserHandle.getUserId(uid) == grantUri.sourceUserId || ActivityManager.checkComponentPermission("android.permission.INTERACT_ACROSS_USERS", uid, -1, true) == 0) {
            return checkHoldingPermissionsInternalLocked(pm, pi, grantUri, uid, modeFlags, true);
        }
        return false;
    }

    private final boolean checkHoldingPermissionsInternalLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, int modeFlags, boolean considerUidPermissions) {
        if (pi.applicationInfo.uid == uid) {
            return true;
        }
        if (!pi.exported) {
            return false;
        }
        boolean readMet = (modeFlags & 1) == 0;
        boolean writeMet = (modeFlags & 2) == 0;
        if (!readMet) {
            try {
                if (pi.readPermission != null && considerUidPermissions) {
                    if (pm.checkUidPermission(pi.readPermission, uid) == 0) {
                        readMet = true;
                    }
                }
            } catch (RemoteException e) {
                return false;
            }
        }
        if (!(writeMet || pi.writePermission == null || !considerUidPermissions)) {
            if (pm.checkUidPermission(pi.writePermission, uid) == 0) {
                writeMet = true;
            }
        }
        boolean allowDefaultRead = pi.readPermission == null;
        boolean allowDefaultWrite = pi.writePermission == null;
        PathPermission[] pps = pi.pathPermissions;
        if (pps != null) {
            String path = grantUri.uri.getPath();
            int i = pps.length;
            while (i > 0 && (!readMet || !writeMet)) {
                i--;
                PathPermission pp = pps[i];
                if (pp.match(path)) {
                    if (!readMet) {
                        String pprperm = pp.getReadPermission();
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Checking read perm for " + pprperm + " for " + pp.getPath() + ": match=" + pp.match(path) + " check=" + pm.checkUidPermission(pprperm, uid));
                        }
                        if (pprperm != null) {
                            if (considerUidPermissions && pm.checkUidPermission(pprperm, uid) == 0) {
                                readMet = true;
                            } else {
                                allowDefaultRead = false;
                            }
                        }
                    }
                    if (!writeMet) {
                        String ppwperm = pp.getWritePermission();
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Checking write perm " + ppwperm + " for " + pp.getPath() + ": match=" + pp.match(path) + " check=" + pm.checkUidPermission(ppwperm, uid));
                        }
                        if (ppwperm != null) {
                            if (considerUidPermissions && pm.checkUidPermission(ppwperm, uid) == 0) {
                                writeMet = true;
                            } else {
                                allowDefaultWrite = false;
                            }
                        }
                    }
                }
            }
        }
        if (allowDefaultRead) {
            readMet = true;
        }
        if (allowDefaultWrite) {
            writeMet = true;
        }
        if (!readMet) {
            writeMet = false;
        }
        return writeMet;
    }

    public int getAppStartMode(int uid, String packageName) {
        int checkAllowBackgroundLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                checkAllowBackgroundLocked = checkAllowBackgroundLocked(uid, packageName, -1, true);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return checkAllowBackgroundLocked;
    }

    int checkAllowBackgroundLocked(int uid, String packageName, int callingPid, boolean allowWhenForeground) {
        UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
        if (this.mLenientBackgroundCheck) {
            if (uidRec == null || uidRec.idle) {
                if (callingPid >= 0) {
                    ProcessRecord proc;
                    synchronized (this.mPidsSelfLocked) {
                        proc = (ProcessRecord) this.mPidsSelfLocked.get(callingPid);
                    }
                    if (proc != null && proc.curProcState < 11) {
                        return 0;
                    }
                }
                if (this.mAppOpsService.noteOperation(63, uid, packageName) != 0) {
                    return 1;
                }
            }
        } else if ((!allowWhenForeground || uidRec == null || uidRec.curProcState >= 7) && this.mAppOpsService.noteOperation(63, uid, packageName) != 0) {
            return 1;
        }
        return 0;
    }

    private ProviderInfo getProviderInfoLocked(String authority, int userHandle, int pmFlags) {
        ProviderInfo pi = null;
        ContentProviderRecord cpr = this.mProviderMap.getProviderByName(authority, userHandle);
        if (cpr != null) {
            return cpr.info;
        }
        try {
            return AppGlobals.getPackageManager().resolveContentProvider(authority, pmFlags | 2048, userHandle);
        } catch (RemoteException e) {
            return pi;
        }
    }

    private UriPermission findUriPermissionLocked(int targetUid, GrantUri grantUri) {
        ArrayMap<GrantUri, UriPermission> targetUris = (ArrayMap) this.mGrantedUriPermissions.get(targetUid);
        if (targetUris != null) {
            return (UriPermission) targetUris.get(grantUri);
        }
        return null;
    }

    private UriPermission findOrCreateUriPermissionLocked(String sourcePkg, String targetPkg, int targetUid, GrantUri grantUri) {
        ArrayMap<GrantUri, UriPermission> targetUris = (ArrayMap) this.mGrantedUriPermissions.get(targetUid);
        if (targetUris == null) {
            targetUris = Maps.newArrayMap();
            this.mGrantedUriPermissions.put(targetUid, targetUris);
        }
        UriPermission perm = (UriPermission) targetUris.get(grantUri);
        if (perm != null) {
            return perm;
        }
        perm = new UriPermission(sourcePkg, targetPkg, targetUid, grantUri);
        targetUris.put(grantUri, perm);
        return perm;
    }

    private final boolean checkUriPermissionLocked(GrantUri grantUri, int uid, int modeFlags) {
        boolean persistable;
        if ((modeFlags & 64) != 0) {
            persistable = true;
        } else {
            persistable = false;
        }
        int minStrength;
        if (persistable) {
            minStrength = 3;
        } else {
            minStrength = 1;
        }
        if (uid == 0) {
            return true;
        }
        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(uid);
        if (perms == null) {
            return false;
        }
        UriPermission exactPerm = (UriPermission) perms.get(grantUri);
        if (exactPerm != null && exactPerm.getStrength(modeFlags) >= minStrength) {
            return true;
        }
        int N = perms.size();
        for (int i = 0; i < N; i++) {
            UriPermission perm = (UriPermission) perms.valueAt(i);
            if (perm.uri.prefix && grantUri.uri.isPathPrefixMatch(perm.uri.uri) && perm.getStrength(modeFlags) >= minStrength) {
                return true;
            }
        }
        return false;
    }

    public int checkUriPermission(Uri uri, int pid, int uid, int modeFlags, int userId, IBinder callerToken) {
        int i = 0;
        enforceNotIsolatedCaller("checkUriPermission");
        Identity tlsIdentity = (Identity) sCallerIdentity.get();
        if (tlsIdentity != null && tlsIdentity.token == callerToken) {
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }
        if (pid == MY_PID) {
            return 0;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!checkUriPermissionLocked(new GrantUri(userId, uri, false), uid, modeFlags)) {
                    i = -1;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    int checkGrantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, int modeFlags, int lastTargetUid) {
        if (!Intent.isAccessUriMode(modeFlags)) {
            return -1;
        }
        if (targetPkg != null && ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "Checking grant " + targetPkg + " permission to " + grantUri);
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        if ("content".equals(grantUri.uri.getScheme())) {
            ProviderInfo pi = getProviderInfoLocked(grantUri.uri.getAuthority(), grantUri.sourceUserId, 268435456);
            if (pi == null) {
                Slog.w(TAG, "No content provider found for permission check: " + grantUri.uri.toSafeString());
                return -1;
            }
            boolean allowed;
            boolean specialCrossUserGrant;
            int targetUid = lastTargetUid;
            if (lastTargetUid < 0 && targetPkg != null) {
                try {
                    targetUid = pm.getPackageUid(targetPkg, 268435456, UserHandle.getUserId(callingUid));
                    if (targetUid < 0) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission no uid for: " + targetPkg);
                        }
                        return -1;
                    }
                } catch (RemoteException e) {
                    return -1;
                }
            }
            if (targetUid < 0) {
                allowed = pi.exported;
                if (!((modeFlags & 1) == 0 || pi.readPermission == null)) {
                    allowed = false;
                }
                if (!((modeFlags & 2) == 0 || pi.writePermission == null)) {
                    allowed = false;
                }
                if (allowed) {
                    return -1;
                }
            } else if (checkHoldingPermissionsLocked(pm, pi, grantUri, targetUid, modeFlags)) {
                if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                    Slog.v(TAG_URI_PERMISSION, "Target " + targetPkg + " already has full permission to " + grantUri);
                }
                return -1;
            }
            if (UserHandle.getUserId(targetUid) != grantUri.sourceUserId) {
                specialCrossUserGrant = checkHoldingPermissionsInternalLocked(pm, pi, grantUri, callingUid, modeFlags, false);
            } else {
                specialCrossUserGrant = false;
            }
            if (!specialCrossUserGrant) {
                if (!pi.grantUriPermissions) {
                    throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of Uri permissions (uri " + grantUri + ")");
                } else if (pi.uriPermissionPatterns != null) {
                    int N = pi.uriPermissionPatterns.length;
                    allowed = false;
                    int i = 0;
                    while (i < N) {
                        if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(grantUri.uri.getPath())) {
                            allowed = true;
                            break;
                        }
                        i++;
                    }
                    if (!allowed) {
                        throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of permission to path of Uri " + grantUri);
                    }
                }
            }
            if (UserHandle.getAppId(callingUid) == 1000 || checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags) || checkUriPermissionLocked(grantUri, callingUid, modeFlags)) {
                return targetUid;
            }
            throw new SecurityException("Uid " + callingUid + " does not have permission to uri " + grantUri);
        }
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission for non-content URI: " + grantUri);
        }
        return -1;
    }

    public int checkGrantUriPermission(int callingUid, String targetPkg, Uri uri, int modeFlags, int userId) {
        int checkGrantUriPermissionLocked;
        enforceNotIsolatedCaller("checkGrantUriPermission");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                checkGrantUriPermissionLocked = checkGrantUriPermissionLocked(callingUid, targetPkg, new GrantUri(userId, uri, false), modeFlags, -1);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return checkGrantUriPermissionLocked;
    }

    void grantUriPermissionUncheckedLocked(int targetUid, String targetPkg, GrantUri grantUri, int modeFlags, UriPermissionOwner owner) {
        if (Intent.isAccessUriMode(modeFlags)) {
            if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                Slog.v(TAG_URI_PERMISSION, "Granting " + targetPkg + "/" + targetUid + " permission to " + grantUri);
            }
            ProviderInfo pi = getProviderInfoLocked(grantUri.uri.getAuthority(), grantUri.sourceUserId, 268435456);
            if (pi == null) {
                Slog.w(TAG, "No content provider found for grant: " + grantUri.toSafeString());
                return;
            }
            if ((modeFlags & 128) != 0) {
                grantUri.prefix = true;
            }
            findOrCreateUriPermissionLocked(pi.packageName, targetPkg, targetUid, grantUri).grantModes(modeFlags, owner);
        }
    }

    void grantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, int modeFlags, UriPermissionOwner owner, int targetUserId) {
        if (targetPkg == null) {
            throw new NullPointerException(ATTR_TARGET_PKG);
        }
        try {
            int targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, modeFlags, AppGlobals.getPackageManager().getPackageUid(targetPkg, 268435456, targetUserId));
            if (targetUid >= 0) {
                grantUriPermissionUncheckedLocked(targetUid, targetPkg, grantUri, modeFlags, owner);
            }
        } catch (RemoteException e) {
        }
    }

    NeededUriGrants checkGrantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, int mode, NeededUriGrants needed, int targetUserId) {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "Checking URI perm to data=" + (intent != null ? intent.getData() : null) + " clip=" + (intent != null ? intent.getClipData() : null) + " from " + intent + "; flags=0x" + Integer.toHexString(intent != null ? intent.getFlags() : 0));
        }
        if (targetPkg == null) {
            throw new NullPointerException(ATTR_TARGET_PKG);
        } else if (intent == null) {
            return null;
        } else {
            Uri data = intent.getData();
            ClipData clip = intent.getClipData();
            if (data == null && clip == null) {
                return null;
            }
            int targetUid;
            GrantUri grantUri;
            NeededUriGrants neededUriGrants;
            int contentUserHint = intent.getContentUserHint();
            if (contentUserHint == -2) {
                contentUserHint = UserHandle.getUserId(callingUid);
            }
            IPackageManager pm = AppGlobals.getPackageManager();
            if (needed != null) {
                targetUid = needed.targetUid;
            } else {
                try {
                    targetUid = pm.getPackageUid(targetPkg, 268435456, targetUserId);
                    if (targetUid < 0) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission no uid for: " + targetPkg + " on user " + targetUserId);
                        }
                        return null;
                    }
                } catch (RemoteException e) {
                    return null;
                }
            }
            if (data != null) {
                grantUri = GrantUri.resolve(contentUserHint, data);
                targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid);
                if (targetUid > 0) {
                    if (needed == null) {
                        neededUriGrants = new NeededUriGrants(targetPkg, targetUid, mode);
                    }
                    needed.add(grantUri);
                }
            }
            if (clip != null) {
                for (int i = 0; i < clip.getItemCount(); i++) {
                    Uri uri = clip.getItemAt(i).getUri();
                    if (uri != null) {
                        boolean isViber = false;
                        if (UserHandle.getUserId(callingUid) == OppoMultiAppManager.USER_ID) {
                            try {
                                String packageName = pm.getNameForUid(callingUid);
                                String authority = uri.getAuthority();
                                if (packageName != null && "com.viber.voip".equals(packageName) && "com.google.android.gm".equals(targetPkg) && authority != null && OppoProcessManager.RESUME_REASON_MEDIA_STR.equals(authority)) {
                                    isViber = true;
                                }
                            } catch (Exception e2) {
                            }
                        }
                        if (isViber) {
                            grantUri = GrantUri.resolve(0, uri);
                        } else {
                            grantUri = GrantUri.resolve(contentUserHint, uri);
                            targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid);
                        }
                        if (targetUid > 0) {
                            if (needed == null) {
                                neededUriGrants = new NeededUriGrants(targetPkg, targetUid, mode);
                            }
                            needed.add(grantUri);
                        }
                    } else {
                        Intent clipIntent = clip.getItemAt(i).getIntent();
                        if (clipIntent != null) {
                            NeededUriGrants newNeeded = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg, clipIntent, mode, needed, targetUserId);
                            if (newNeeded != null) {
                                needed = newNeeded;
                            }
                        }
                    }
                }
            }
            return needed;
        }
    }

    void grantUriPermissionUncheckedFromIntentLocked(NeededUriGrants needed, UriPermissionOwner owner) {
        if (needed != null) {
            for (int i = 0; i < needed.size(); i++) {
                grantUriPermissionUncheckedLocked(needed.targetUid, needed.targetPkg, (GrantUri) needed.get(i), needed.flags, owner);
            }
        }
    }

    void grantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, UriPermissionOwner owner, int targetUserId) {
        NeededUriGrants needed = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg, intent, intent != null ? intent.getFlags() : 0, null, targetUserId);
        if (needed != null) {
            grantUriPermissionUncheckedFromIntentLocked(needed, owner);
        }
    }

    public void grantUriPermission(IApplicationThread caller, String targetPkg, Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("grantUriPermission");
        GrantUri grantUri = new GrantUri(userId, uri, false);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord r = getRecordForAppLocked(caller);
                if (r == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " when granting permission to uri " + grantUri);
                } else if (targetPkg == null) {
                    throw new IllegalArgumentException("null target");
                } else if (grantUri == null) {
                    throw new IllegalArgumentException("null uri");
                } else {
                    Preconditions.checkFlagsArgument(modeFlags, HdmiCecKeycode.UI_SOUND_PRESENTATION_TREBLE_STEP_MINUS);
                    grantUriPermissionLocked(r.uid, targetPkg, grantUri, modeFlags, null, UserHandle.getUserId(r.uid));
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void removeUriPermissionIfNeededLocked(UriPermission perm) {
        if (perm.modeFlags == 0) {
            ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(perm.targetUid);
            if (perms != null) {
                if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                    Slog.v(TAG_URI_PERMISSION, "Removing " + perm.targetUid + " permission to " + perm.uri);
                }
                perms.remove(perm.uri);
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(perm.targetUid);
                }
            }
        }
    }

    private void revokeUriPermissionLocked(int callingUid, GrantUri grantUri, int modeFlags) {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "Revoking all granted permissions to " + grantUri);
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        ProviderInfo pi = getProviderInfoLocked(grantUri.uri.getAuthority(), grantUri.sourceUserId, 786432);
        ArrayMap<GrantUri, UriPermission> perms;
        Iterator<UriPermission> it;
        UriPermission perm;
        if (pi == null) {
            Slog.w(TAG, "No content provider found for permission revoke: " + grantUri.toSafeString());
        } else if (checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
            boolean persistChanged = false;
            int N = this.mGrantedUriPermissions.size();
            int i = 0;
            while (i < N) {
                int targetUid = this.mGrantedUriPermissions.keyAt(i);
                perms = (ArrayMap) this.mGrantedUriPermissions.valueAt(i);
                it = perms.values().iterator();
                while (it.hasNext()) {
                    perm = (UriPermission) it.next();
                    if (perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Revoking " + perm.targetUid + " permission to " + perm.uri);
                        }
                        persistChanged |= perm.revokeModes(modeFlags | 64, true);
                        if (perm.modeFlags == 0) {
                            it.remove();
                        }
                    }
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(targetUid);
                    N--;
                    i--;
                }
                i++;
            }
            if (persistChanged) {
                schedulePersistUriGrants();
            }
        } else {
            perms = (ArrayMap) this.mGrantedUriPermissions.get(callingUid);
            if (perms != null) {
                int persistChanged2 = 0;
                it = perms.values().iterator();
                while (it.hasNext()) {
                    perm = (UriPermission) it.next();
                    if (perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Revoking non-owned " + perm.targetUid + " permission to " + perm.uri);
                        }
                        persistChanged2 |= perm.revokeModes(modeFlags | 64, false);
                        if (perm.modeFlags == 0) {
                            it.remove();
                        }
                    }
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(callingUid);
                }
                if (persistChanged2 != 0) {
                    schedulePersistUriGrants();
                }
            }
        }
    }

    public void revokeUriPermission(IApplicationThread caller, Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("revokeUriPermission");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord r = getRecordForAppLocked(caller);
                if (r == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " when revoking permission to uri " + uri);
                } else if (uri == null) {
                    Slog.w(TAG, "revokeUriPermission: null uri");
                } else if (!Intent.isAccessUriMode(modeFlags)) {
                    resetPriorityAfterLockedSection();
                } else if (getProviderInfoLocked(uri.getAuthority(), userId, 786432) == null) {
                    Slog.w(TAG, "No content provider found for permission revoke: " + uri.toSafeString());
                    resetPriorityAfterLockedSection();
                } else {
                    revokeUriPermissionLocked(r.uid, new GrantUri(userId, uri, false), modeFlags);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void removeUriPermissionsForPackageLocked(String packageName, int userHandle, boolean persistable) {
        if (userHandle == -1 && packageName == null) {
            throw new IllegalArgumentException("Must narrow by either package or user");
        }
        int persistChanged = 0;
        int N = this.mGrantedUriPermissions.size();
        int i = 0;
        while (i < N) {
            int targetUid = this.mGrantedUriPermissions.keyAt(i);
            ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.valueAt(i);
            if (userHandle == -1 || userHandle == UserHandle.getUserId(targetUid)) {
                Iterator<UriPermission> it = perms.values().iterator();
                while (it.hasNext()) {
                    UriPermission perm = (UriPermission) it.next();
                    if ((packageName == null || perm.sourcePkg.equals(packageName) || perm.targetPkg.equals(packageName)) && (!"downloads".equals(perm.uri.uri.getAuthority()) || persistable)) {
                        int i2;
                        if (persistable) {
                            i2 = -1;
                        } else {
                            i2 = -65;
                        }
                        persistChanged |= perm.revokeModes(i2, true);
                        if (perm.modeFlags == 0) {
                            it.remove();
                        }
                    }
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(targetUid);
                    N--;
                    i--;
                }
            }
            i++;
        }
        if (persistChanged != 0) {
            schedulePersistUriGrants();
        }
    }

    public IBinder newUriPermissionOwner(String name) {
        IBinder externalTokenLocked;
        enforceNotIsolatedCaller("newUriPermissionOwner");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                externalTokenLocked = new UriPermissionOwner(this, name).getExternalTokenLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return externalTokenLocked;
    }

    public IBinder getUriPermissionOwnerForActivity(IBinder activityToken) {
        IBinder externalTokenLocked;
        enforceNotIsolatedCaller("getUriPermissionOwnerForActivity");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
                if (r == null) {
                    throw new IllegalArgumentException("Activity does not exist; token=" + activityToken);
                }
                externalTokenLocked = r.getUriPermissionsLocked().getExternalTokenLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return externalTokenLocked;
    }

    public void grantUriPermissionFromOwner(IBinder token, int fromUid, String targetPkg, Uri uri, int modeFlags, int sourceUserId, int targetUserId) {
        targetUserId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), targetUserId, false, 2, "grantUriPermissionFromOwner", null);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
                if (owner == null) {
                    throw new IllegalArgumentException("Unknown owner: " + token);
                } else if (fromUid != Binder.getCallingUid() && Binder.getCallingUid() != Process.myUid()) {
                    throw new SecurityException("nice try");
                } else if (targetPkg == null) {
                    throw new IllegalArgumentException("null target");
                } else if (uri == null) {
                    throw new IllegalArgumentException("null uri");
                } else {
                    grantUriPermissionLocked(fromUid, targetPkg, new GrantUri(sourceUserId, uri, false), modeFlags, owner, targetUserId);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void revokeUriPermissionFromOwner(IBinder token, Uri uri, int mode, int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
                if (owner == null) {
                    throw new IllegalArgumentException("Unknown owner: " + token);
                }
                if (uri == null) {
                    owner.removeUriPermissionsLocked(mode);
                } else {
                    owner.removeUriPermissionLocked(new GrantUri(userId, uri, (mode & 128) != 0), mode);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void schedulePersistUriGrants() {
        if (!this.mHandler.hasMessages(38)) {
            this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(38), 10000);
        }
    }

    private void writeGrantedUriPermissions() {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "writeGrantedUriPermissions()");
        }
        ArrayList<Snapshot> persist = Lists.newArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int size = this.mGrantedUriPermissions.size();
                for (int i = 0; i < size; i++) {
                    for (UriPermission perm : ((ArrayMap) this.mGrantedUriPermissions.valueAt(i)).values()) {
                        if (perm.persistedModeFlags != 0) {
                            persist.add(perm.snapshot());
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        FileOutputStream fos = null;
        try {
            fos = this.mGrantFile.startWrite();
            XmlSerializer out = new FastXmlSerializer();
            out.setOutput(fos, StandardCharsets.UTF_8.name());
            out.startDocument(null, Boolean.valueOf(true));
            out.startTag(null, TAG_URI_GRANTS);
            for (Snapshot perm2 : persist) {
                out.startTag(null, TAG_URI_GRANT);
                XmlUtils.writeIntAttribute(out, ATTR_SOURCE_USER_ID, perm2.uri.sourceUserId);
                XmlUtils.writeIntAttribute(out, ATTR_TARGET_USER_ID, perm2.targetUserId);
                out.attribute(null, ATTR_SOURCE_PKG, perm2.sourcePkg);
                out.attribute(null, ATTR_TARGET_PKG, perm2.targetPkg);
                out.attribute(null, ATTR_URI, String.valueOf(perm2.uri.uri));
                XmlUtils.writeBooleanAttribute(out, ATTR_PREFIX, perm2.uri.prefix);
                XmlUtils.writeIntAttribute(out, ATTR_MODE_FLAGS, perm2.persistedModeFlags);
                XmlUtils.writeLongAttribute(out, ATTR_CREATED_TIME, perm2.persistedCreateTime);
                out.endTag(null, TAG_URI_GRANT);
            }
            out.endTag(null, TAG_URI_GRANTS);
            out.endDocument();
            this.mGrantFile.finishWrite(fos);
        } catch (IOException e) {
            if (fos != null) {
                this.mGrantFile.failWrite(fos);
            }
        }
    }

    private void readGrantedUriPermissionsLocked() {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "readGrantedUriPermissions()");
        }
        long now = System.currentTimeMillis();
        AutoCloseable autoCloseable = null;
        try {
            autoCloseable = this.mGrantFile.openRead();
            XmlPullParser in = Xml.newPullParser();
            in.setInput(autoCloseable, StandardCharsets.UTF_8.name());
            loop0:
            while (true) {
                int type = in.next();
                if (type == 1) {
                    break loop0;
                }
                String tag = in.getName();
                if (type == 2 && TAG_URI_GRANT.equals(tag)) {
                    int sourceUserId;
                    int targetUserId;
                    int userHandle = XmlUtils.readIntAttribute(in, ATTR_USER_HANDLE, -10000);
                    if (userHandle != -10000) {
                        sourceUserId = userHandle;
                        targetUserId = userHandle;
                    } else {
                        sourceUserId = XmlUtils.readIntAttribute(in, ATTR_SOURCE_USER_ID);
                        targetUserId = XmlUtils.readIntAttribute(in, ATTR_TARGET_USER_ID);
                    }
                    String sourcePkg = in.getAttributeValue(null, ATTR_SOURCE_PKG);
                    String targetPkg = in.getAttributeValue(null, ATTR_TARGET_PKG);
                    Uri uri = Uri.parse(in.getAttributeValue(null, ATTR_URI));
                    boolean prefix = XmlUtils.readBooleanAttribute(in, ATTR_PREFIX);
                    int modeFlags = XmlUtils.readIntAttribute(in, ATTR_MODE_FLAGS);
                    long createdTime = XmlUtils.readLongAttribute(in, ATTR_CREATED_TIME, now);
                    ProviderInfo pi = getProviderInfoLocked(uri.getAuthority(), sourceUserId, 786432);
                    if (pi != null) {
                        if (sourcePkg.equals(pi.packageName)) {
                            int targetUid = -1;
                            try {
                                targetUid = AppGlobals.getPackageManager().getPackageUid(targetPkg, DumpState.DUMP_PREFERRED_XML, targetUserId);
                            } catch (RemoteException e) {
                            }
                            if (targetUid != -1) {
                                findOrCreateUriPermissionLocked(sourcePkg, targetPkg, targetUid, new GrantUri(sourceUserId, uri, prefix)).initPersistedModes(modeFlags, createdTime);
                            } else {
                                continue;
                            }
                        }
                    }
                    Slog.w(TAG, "Persisted grant for " + uri + " had source " + sourcePkg + " but instead found " + pi);
                }
            }
        } catch (FileNotFoundException e2) {
        } catch (IOException e3) {
            Slog.wtf(TAG, "Failed reading Uri grants", e3);
        } catch (XmlPullParserException e4) {
            Slog.wtf(TAG, "Failed reading Uri grants", e4);
        } finally {
            IoUtils.closeQuietly(autoCloseable);
        }
    }

    public void takePersistableUriPermission(Uri uri, int modeFlags, int userId) {
        boolean z = true;
        enforceNotIsolatedCaller("takePersistableUriPermission");
        Preconditions.checkFlagsArgument(modeFlags, 3);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingUid = Binder.getCallingUid();
                boolean persistChanged = false;
                GrantUri grantUri = new GrantUri(userId, uri, false);
                UriPermission exactPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, false));
                UriPermission prefixPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, true));
                boolean exactValid = exactPerm != null ? (exactPerm.persistableModeFlags & modeFlags) == modeFlags : false;
                boolean prefixValid = prefixPerm != null ? (prefixPerm.persistableModeFlags & modeFlags) == modeFlags : false;
                if (!exactValid) {
                    z = prefixValid;
                }
                if (z) {
                    if (exactValid) {
                        persistChanged = exactPerm.takePersistableModes(modeFlags);
                    }
                    if (prefixValid) {
                        persistChanged |= prefixPerm.takePersistableModes(modeFlags);
                    }
                    if (persistChanged | maybePrunePersistedUriGrantsLocked(callingUid)) {
                        schedulePersistUriGrants();
                    }
                } else {
                    throw new SecurityException("No persistable permission grants found for UID " + callingUid + " and Uri " + grantUri.toSafeString());
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void releasePersistableUriPermission(Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("releasePersistableUriPermission");
        Preconditions.checkFlagsArgument(modeFlags, 3);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingUid = Binder.getCallingUid();
                boolean persistChanged = false;
                UriPermission exactPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, false));
                UriPermission prefixPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, true));
                if (exactPerm == null && prefixPerm == null) {
                    throw new SecurityException("No permission grants found for UID " + callingUid + " and Uri " + uri.toSafeString());
                }
                if (exactPerm != null) {
                    persistChanged = exactPerm.releasePersistableModes(modeFlags);
                    removeUriPermissionIfNeededLocked(exactPerm);
                }
                if (prefixPerm != null) {
                    persistChanged |= prefixPerm.releasePersistableModes(modeFlags);
                    removeUriPermissionIfNeededLocked(prefixPerm);
                }
                if (persistChanged) {
                    schedulePersistUriGrants();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private boolean maybePrunePersistedUriGrantsLocked(int uid) {
        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(uid);
        if (perms == null || perms.size() < 128) {
            return false;
        }
        UriPermission perm;
        ArrayList<UriPermission> persisted = Lists.newArrayList();
        for (UriPermission perm2 : perms.values()) {
            if (perm2.persistedModeFlags != 0) {
                persisted.add(perm2);
            }
        }
        int trimCount = persisted.size() - 128;
        if (trimCount <= 0) {
            return false;
        }
        Collections.sort(persisted, new PersistedTimeComparator());
        for (int i = 0; i < trimCount; i++) {
            perm2 = (UriPermission) persisted.get(i);
            if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                Slog.v(TAG_URI_PERMISSION, "Trimming grant created at " + perm2.persistedCreateTime);
            }
            perm2.releasePersistableModes(-1);
            removeUriPermissionIfNeededLocked(perm2);
        }
        return true;
    }

    public ParceledListSlice<UriPermission> getPersistedUriPermissions(String packageName, boolean incoming) {
        enforceNotIsolatedCaller("getPersistedUriPermissions");
        Preconditions.checkNotNull(packageName, "packageName");
        int callingUid = Binder.getCallingUid();
        try {
            if (AppGlobals.getPackageManager().getPackageUid(packageName, 786432, UserHandle.getUserId(callingUid)) != callingUid) {
                throw new SecurityException("Package " + packageName + " does not belong to calling UID " + callingUid);
            }
            ArrayList<UriPermission> result = Lists.newArrayList();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (incoming) {
                        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(callingUid);
                        if (perms == null) {
                            Slog.w(TAG, "No permission grants found for " + packageName);
                        } else {
                            for (UriPermission perm : perms.values()) {
                                if (packageName.equals(perm.targetPkg) && perm.persistedModeFlags != 0) {
                                    result.add(perm.buildPersistedPublicApiObject());
                                }
                            }
                        }
                    } else {
                        int size = this.mGrantedUriPermissions.size();
                        for (int i = 0; i < size; i++) {
                            for (UriPermission perm2 : ((ArrayMap) this.mGrantedUriPermissions.valueAt(i)).values()) {
                                if (packageName.equals(perm2.sourcePkg) && perm2.persistedModeFlags != 0) {
                                    result.add(perm2.buildPersistedPublicApiObject());
                                }
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return new ParceledListSlice(result);
        } catch (RemoteException e) {
            throw new SecurityException("Failed to verify package name ownership");
        }
    }

    public ParceledListSlice<UriPermission> getGrantedUriPermissions(String packageName, int userId) {
        enforceCallingPermission("android.permission.GET_APP_GRANTED_URI_PERMISSIONS", "getGrantedUriPermissions");
        ArrayList<UriPermission> result = Lists.newArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int size = this.mGrantedUriPermissions.size();
                for (int i = 0; i < size; i++) {
                    for (UriPermission perm : ((ArrayMap) this.mGrantedUriPermissions.valueAt(i)).values()) {
                        if (packageName.equals(perm.targetPkg) && perm.targetUserId == userId && perm.persistedModeFlags != 0) {
                            result.add(perm.buildPersistedPublicApiObject());
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return new ParceledListSlice(result);
    }

    public void clearGrantedUriPermissions(String packageName, int userId) {
        enforceCallingPermission("android.permission.CLEAR_APP_GRANTED_URI_PERMISSIONS", "clearGrantedUriPermissions");
        removeUriPermissionsForPackageLocked(packageName, userId, true);
    }

    public void showWaitingForDebugger(IApplicationThread who, boolean waiting) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                Object app = who != null ? getRecordForAppLocked(who) : null;
                if (app == null) {
                } else {
                    Message msg = Message.obtain();
                    msg.what = 6;
                    msg.obj = app;
                    msg.arg1 = waiting ? 1 : 0;
                    this.mUiHandler.sendMessage(msg);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void getMemoryInfo(ActivityManager.MemoryInfo outInfo) {
        boolean z;
        long homeAppMem = this.mProcessList.getMemLevel(600);
        long cachedAppMem = this.mProcessList.getMemLevel(900);
        outInfo.availMem = Process.getFreeMemory();
        outInfo.totalMem = Process.getTotalMemory();
        outInfo.threshold = homeAppMem;
        if (outInfo.availMem < ((cachedAppMem - homeAppMem) / 2) + homeAppMem) {
            z = true;
        } else {
            z = false;
        }
        outInfo.lowMemory = z;
        outInfo.hiddenAppThreshold = cachedAppMem;
        outInfo.secondaryServerThreshold = this.mProcessList.getMemLevel(500);
        outInfo.visibleAppThreshold = this.mProcessList.getMemLevel(100);
        outInfo.foregroundAppThreshold = this.mProcessList.getMemLevel(0);
    }

    public List<IAppTask> getAppTasks(String callingPackage) {
        ArrayList<IAppTask> list;
        int callingUid = Binder.getCallingUid();
        long ident = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                list = new ArrayList();
                if (ActivityManagerDebugConfig.DEBUG_ALL) {
                    Slog.v(TAG, "getAppTasks");
                }
                int N = this.mRecentTasks.size();
                for (int i = 0; i < N; i++) {
                    TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                    if (tr.effectiveUid == callingUid) {
                        Intent intent = tr.getBaseIntent();
                        if (intent != null && callingPackage.equals(intent.getComponent().getPackageName())) {
                            list.add(new AppTaskImpl(createRecentTaskInfoFromTaskRecord(tr).persistentId, callingUid));
                        }
                    }
                }
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return list;
    }

    public List<RunningTaskInfo> getTasks(int maxNum, int flags) {
        int callingUid = Binder.getCallingUid();
        ArrayList<RunningTaskInfo> list = new ArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_ALL) {
                    Slog.v(TAG, "getTasks: max=" + maxNum + ", flags=" + flags);
                }
                this.mStackSupervisor.getTasksLocked(maxNum, list, callingUid, isGetTasksAllowed("getTasks", Binder.getCallingPid(), callingUid));
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return list;
    }

    public boolean isTopRunningTaskDockable() {
        boolean z = false;
        try {
            ActivityStack mainStack = this.mStackSupervisor.getFocusedStack();
            if (mainStack == null) {
                return false;
            }
            TaskRecord tr = mainStack.topRunningTask();
            if (tr != null) {
                z = tr.canGoInDockedStack();
            }
            return z;
        } catch (Exception e) {
            Slog.e(TAG, "error in isTopRunningTaskDockable error : " + e.toString());
            return false;
        }
    }

    private RecentTaskInfo createRecentTaskInfoFromTaskRecord(TaskRecord tr) {
        ComponentName component;
        int i = -1;
        ComponentName componentName = null;
        tr.updateTaskDescription();
        RecentTaskInfo rti = new RecentTaskInfo();
        rti.id = tr.getTopActivity() == null ? -1 : tr.taskId;
        rti.persistentId = tr.taskId;
        rti.baseIntent = new Intent(tr.getBaseIntent());
        rti.origActivity = tr.origActivity;
        rti.realActivity = tr.realActivity;
        rti.description = tr.lastDescription;
        if (tr.stack != null) {
            i = tr.stack.mStackId;
        }
        rti.stackId = i;
        rti.userId = tr.userId;
        rti.taskDescription = new TaskDescription(tr.lastTaskDescription);
        rti.firstActiveTime = tr.firstActiveTime;
        rti.lastActiveTime = tr.lastActiveTime;
        rti.affiliatedTaskId = tr.mAffiliatedTaskId;
        rti.affiliatedTaskColor = tr.mAffiliatedTaskColor;
        rti.numActivities = 0;
        if (tr.mBounds != null) {
            rti.bounds = new Rect(tr.mBounds);
        }
        rti.isDockable = tr.canGoInDockedStack();
        rti.resizeMode = tr.mResizeMode;
        ActivityRecord base = null;
        ActivityRecord top = null;
        for (int i2 = tr.mActivities.size() - 1; i2 >= 0; i2--) {
            ActivityRecord tmp = (ActivityRecord) tr.mActivities.get(i2);
            if (!tmp.finishing) {
                base = tmp;
                if (top == null || top.state == ActivityState.INITIALIZING) {
                    top = tmp;
                }
                rti.numActivities++;
            }
        }
        if (base != null) {
            component = base.intent.getComponent();
        } else {
            component = null;
        }
        rti.baseActivity = component;
        if (top != null) {
            componentName = top.intent.getComponent();
        }
        rti.topActivity = componentName;
        return rti;
    }

    private boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {
        boolean allowed = false;
        if (checkPermission("android.permission.REAL_GET_TASKS", callingPid, callingUid) == 0) {
            allowed = true;
        }
        if (!allowed && checkPermission("android.permission.GET_TASKS", callingPid, callingUid) == 0) {
            try {
                if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) {
                    allowed = true;
                    if (ActivityManagerDebugConfig.DEBUG_TASKS) {
                        Slog.w(TAG, caller + ": caller " + callingUid + " is using old GET_TASKS but privileged; allowing");
                    }
                }
            } catch (RemoteException e) {
            }
        }
        if (!allowed && ActivityManagerDebugConfig.DEBUG_TASKS) {
            Slog.w(TAG, caller + ": caller " + callingUid + " does not hold REAL_GET_TASKS; limiting output");
        }
        return allowed;
    }

    public ParceledListSlice<RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
        ParceledListSlice<RecentTaskInfo> parceledListSlice;
        int callingUid = Binder.getCallingUid();
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, 2, "getRecentTasks", null);
        boolean includeProfiles = (flags & 4) != 0;
        boolean withExcluded = (flags & 1) != 0;
        if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
            Slog.d(TAG_RECENTS, "includeProfiles: " + includeProfiles + " withExcluded " + withExcluded + " maxNum " + maxNum + " userId " + userId + " " + Debug.getCallers(4));
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean allowed = isGetTasksAllowed("getRecentTasks", Binder.getCallingPid(), callingUid);
                boolean detailed = checkCallingPermission("android.permission.GET_DETAILED_TASKS") == 0;
                if (isUserRunning(userId, 4)) {
                    int i;
                    Set<Integer> includedUsers;
                    this.mRecentTasks.loadUserRecentsLocked(userId);
                    int recentsCount = this.mRecentTasks.size();
                    if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                        Slog.d(TAG_RECENTS, "allowed: " + allowed + " detailed " + detailed + " recentsCount " + recentsCount);
                    }
                    if (maxNum < recentsCount) {
                        i = maxNum;
                    } else {
                        i = recentsCount;
                    }
                    ArrayList<RecentTaskInfo> arrayList = new ArrayList(i);
                    if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                        Slog.d(TAG_RECENTS, "getRecentTasks recentsCount = " + recentsCount + " maxNum = " + maxNum + " flags = " + flags + " userId = " + userId);
                    }
                    if (includeProfiles) {
                        includedUsers = this.mUserController.getProfileIds(userId);
                    } else {
                        includedUsers = new HashSet();
                    }
                    includedUsers.add(Integer.valueOf(userId));
                    OppoMultiAppManager.getInstance().inRecentTask(includedUsers);
                    for (int i2 = 0; i2 < recentsCount && maxNum > 0; i2++) {
                        TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i2);
                        if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                            Slog.d(TAG_RECENTS, "getRecentTasks tr = " + tr);
                        }
                        if (includedUsers.contains(Integer.valueOf(tr.userId))) {
                            if (!tr.realActivitySuspended) {
                                if (!(i2 == 0 || withExcluded)) {
                                    if (!(tr.intent == null || (tr.intent.getFlags() & 8388608) == 0)) {
                                    }
                                }
                                if (allowed || tr.isHomeTask() || tr.effectiveUid == callingUid) {
                                    if ((flags & 8) == 0 || tr.stack == null || !tr.stack.isHomeStack()) {
                                        if ((flags & 16) != 0) {
                                            ActivityStack stack = tr.stack;
                                            if (stack != null && stack.isDockedStack() && stack.topTask() == tr) {
                                                if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                    Slog.d(TAG_RECENTS, "Skipping, top task in docked stack: " + tr);
                                                }
                                            }
                                        }
                                        if ((flags & 32) == 0 || tr.stack == null || !tr.stack.isPinnedStack()) {
                                            if (tr.autoRemoveRecents && tr.getTopActivity() == null) {
                                                if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                    Slog.d(TAG_RECENTS, "Skipping, auto-remove without activity: " + tr);
                                                }
                                            } else if ((flags & 2) == 0 || tr.isAvailable) {
                                                if (tr.mUserSetupComplete || tr.userId == OppoMultiAppManager.USER_ID) {
                                                    if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                        Slog.d(TAG_RECENTS, "after skip id: " + tr.taskId + " tr " + tr);
                                                    }
                                                    RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);
                                                    if (!detailed) {
                                                        rti.baseIntent.replaceExtras((Bundle) null);
                                                    }
                                                    arrayList.add(rti);
                                                    maxNum--;
                                                } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                    Slog.d(TAG_RECENTS, "Skipping, user setup not complete: " + tr);
                                                }
                                            } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                Slog.d(TAG_RECENTS, "Skipping, unavail real act: " + tr);
                                            }
                                        } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                            Slog.d(TAG_RECENTS, "Skipping, pinned stack task: " + tr);
                                        }
                                    } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                        Slog.d(TAG_RECENTS, "Skipping, home stack task: " + tr);
                                    }
                                } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                    Slog.d(TAG_RECENTS, "Skipping, not allowed: " + tr);
                                }
                            } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                Slog.d(TAG_RECENTS, "Skipping, activity suspended: " + tr);
                            }
                        } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                            Slog.d(TAG_RECENTS, "Skipping, not user: " + tr);
                        }
                    }
                    parceledListSlice = new ParceledListSlice(arrayList);
                    resetPriorityAfterLockedSection();
                    return parceledListSlice;
                }
                Slog.i(TAG, "user " + userId + " is still locked. Cannot load recents");
                parceledListSlice = ParceledListSlice.emptyList();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return parceledListSlice;
    }

    public TaskThumbnail getTaskThumbnail(int id) {
        TaskThumbnail taskThumbnailLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                enforceCallingPermission("android.permission.READ_FRAME_BUFFER", "getTaskThumbnail()");
                TaskRecord tr = this.mStackSupervisor.anyTaskForIdLocked(id, false, -1);
                if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                    Slog.d(TAG_RECENTS, "getTaskThumbnail id: " + id + " tr " + tr + " " + Debug.getCallers(4));
                }
                if (tr != null) {
                    taskThumbnailLocked = tr.getTaskThumbnailLocked();
                } else {
                    resetPriorityAfterLockedSection();
                    return null;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return taskThumbnailLocked;
    }

    public int addAppTask(IBinder activityToken, Intent intent, TaskDescription description, Bitmap thumbnail) throws RemoteException {
        int callingUid = Binder.getCallingUid();
        long callingIdent = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
                if (r == null) {
                    throw new IllegalArgumentException("Activity does not exist; token=" + activityToken);
                }
                ComponentName comp = intent.getComponent();
                if (comp == null) {
                    throw new IllegalArgumentException("Intent " + intent + " must specify explicit component");
                } else if (thumbnail.getWidth() == this.mThumbnailWidth && thumbnail.getHeight() == this.mThumbnailHeight) {
                    if (intent.getSelector() != null) {
                        intent.setSelector(null);
                    }
                    if (intent.getSourceBounds() != null) {
                        intent.setSourceBounds(null);
                    }
                    if ((intent.getFlags() & DumpState.DUMP_FROZEN) != 0 && (intent.getFlags() & DumpState.DUMP_PREFERRED_XML) == 0) {
                        intent.addFlags(DumpState.DUMP_PREFERRED_XML);
                    }
                    if (!(comp.equals(this.mLastAddedTaskComponent) && callingUid == this.mLastAddedTaskUid)) {
                        this.mLastAddedTaskActivity = null;
                    }
                    ActivityInfo ainfo = this.mLastAddedTaskActivity;
                    if (ainfo == null) {
                        ainfo = AppGlobals.getPackageManager().getActivityInfo(comp, 0, UserHandle.getUserId(callingUid));
                        this.mLastAddedTaskActivity = ainfo;
                        if (ainfo.applicationInfo.uid != callingUid) {
                            throw new SecurityException("Can't add task for another application: target uid=" + ainfo.applicationInfo.uid + ", calling uid=" + callingUid);
                        }
                    }
                    Point displaySize = new Point();
                    TaskThumbnailInfo thumbnailInfo = new TaskThumbnailInfo();
                    r.task.stack.getDisplaySize(displaySize);
                    thumbnailInfo.taskWidth = displaySize.x;
                    thumbnailInfo.taskHeight = displaySize.y;
                    thumbnailInfo.screenOrientation = this.mConfiguration.orientation;
                    TaskRecord task = new TaskRecord(this, this.mStackSupervisor.getNextTaskIdForUserLocked(r.userId), ainfo, intent, description, thumbnailInfo);
                    if (this.mRecentTasks.trimForTaskLocked(task, false) >= 0) {
                        resetPriorityAfterLockedSection();
                        Binder.restoreCallingIdentity(callingIdent);
                        return -1;
                    }
                    int N = this.mRecentTasks.size();
                    if (N >= ActivityManager.getMaxRecentTasksStatic() - 1) {
                        ((TaskRecord) this.mRecentTasks.remove(N - 1)).removedFromRecents();
                    }
                    task.inRecents = true;
                    this.mRecentTasks.add(task);
                    r.task.stack.addTask(task, false, "addAppTask");
                    task.setLastThumbnailLocked(thumbnail);
                    task.freeLastThumbnail();
                    int i = task.taskId;
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingIdent);
                    return i;
                } else {
                    throw new IllegalArgumentException("Bad thumbnail size: got " + thumbnail.getWidth() + "x" + thumbnail.getHeight() + ", require " + this.mThumbnailWidth + "x" + this.mThumbnailHeight);
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingIdent);
        }
    }

    public Point getAppTaskThumbnailSize() {
        Point point;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                point = new Point(this.mThumbnailWidth, this.mThumbnailHeight);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return point;
    }

    public void setTaskDescription(IBinder token, TaskDescription td) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    r.setTaskDescription(td);
                    r.task.updateTaskDescription();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: Missing block: B:12:0x004c, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:13:0x004f, code:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void setTaskResizeable(int taskId, int resizeableMode) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, false, -1);
                if (task == null) {
                    Slog.w(TAG, "setTaskResizeable: taskId=" + taskId + " not found");
                } else if (task.mResizeMode != resizeableMode) {
                    task.mResizeMode = resizeableMode;
                    this.mWindowManager.setTaskResizeable(taskId, resizeableMode);
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void resizeTask(int taskId, Rect bounds, int resizeMode) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeTask()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w(TAG, "resizeTask: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return;
                }
                int stackId = task.stack.mStackId;
                if (bounds != null && task.inCropWindowsResizeMode() && this.mStackSupervisor.isStackDockedInEffect(stackId)) {
                    this.mWindowManager.scrollTask(task.taskId, bounds);
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                } else if (StackId.isTaskResizeAllowed(stackId)) {
                    if (bounds == null && stackId == 2) {
                        stackId = 1;
                    } else if (!(bounds == null || stackId == 2)) {
                        stackId = 2;
                    }
                    boolean preserveWindow = (resizeMode & 1) != 0;
                    if (stackId != task.stack.mStackId) {
                        this.mStackSupervisor.moveTaskToStackUncheckedLocked(task, stackId, true, false, "resizeTask");
                        preserveWindow = false;
                    }
                    this.mStackSupervisor.resizeTaskLocked(task, bounds, resizeMode, preserveWindow, false);
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                } else {
                    throw new IllegalArgumentException("resizeTask not allowed on task=" + task);
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public Rect getTaskBounds(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getTaskBounds()");
        long ident = Binder.clearCallingIdentity();
        Rect rect = new Rect();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, false, -1);
                if (task == null) {
                    Slog.w(TAG, "getTaskBounds: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return rect;
                }
                if (task.stack != null) {
                    this.mWindowManager.getTaskBounds(task.taskId, rect);
                } else if (task.mBounds != null) {
                    rect.set(task.mBounds);
                } else if (task.mLastNonFullscreenBounds != null) {
                    rect.set(task.mLastNonFullscreenBounds);
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(ident);
                return rect;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public Bitmap getTaskDescriptionIcon(String filePath, int userId) {
        if (userId != UserHandle.getCallingUserId()) {
            enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getTaskDescriptionIcon");
        }
        if (new File(TaskPersister.getUserImagesDir(userId), new File(filePath).getName()).getPath().equals(filePath) && filePath.contains("_activity_icon_")) {
            return this.mRecentTasks.getTaskDescriptionIcon(filePath);
        }
        throw new IllegalArgumentException("Bad file path: " + filePath + " passed for userId " + userId);
    }

    public void startInPlaceAnimationOnFrontMostApplication(ActivityOptions opts) throws RemoteException {
        if (opts.getAnimationType() != 10 || opts.getCustomInPlaceResId() == 0) {
            throw new IllegalArgumentException("Expected in-place ActivityOption with valid animation");
        }
        this.mWindowManager.prepareAppTransition(17, false);
        this.mWindowManager.overridePendingAppTransitionInPlace(opts.getPackageName(), opts.getCustomInPlaceResId());
        this.mWindowManager.executeAppTransition();
    }

    private void cleanUpRemovedTaskLocked(TaskRecord tr, boolean killProcess, boolean removeFromRecents) {
        if (ActivityManagerDebugConfig.DEBUG_TASKS) {
            Slog.i(TAG, "cleanUpRemovedTaskLocked " + tr + " killProcess" + killProcess);
        }
        if (removeFromRecents) {
            this.mRecentTasks.remove(tr);
            tr.removedFromRecents();
        }
        ComponentName component = tr.getBaseIntent().getComponent();
        if (component == null) {
            Slog.w(TAG, "No component for base intent of task: " + tr);
            return;
        }
        this.mServices.cleanUpRemovedTaskLocked(tr, component, new Intent(tr.getBaseIntent()));
        if (killProcess) {
            int i;
            String pkg = component.getPackageName();
            ArrayList<ProcessRecord> procsToKill = new ArrayList();
            ArrayMap<String, SparseArray<ProcessRecord>> pmap = this.mProcessNames.getMap();
            for (i = 0; i < pmap.size(); i++) {
                SparseArray<ProcessRecord> uids = (SparseArray) pmap.valueAt(i);
                for (int j = 0; j < uids.size(); j++) {
                    ProcessRecord proc = (ProcessRecord) uids.valueAt(j);
                    if (proc.userId == tr.userId && proc != this.mHomeProcess && proc.pkgList.containsKey(pkg)) {
                        int k = 0;
                        while (k < proc.activities.size()) {
                            TaskRecord otherTask = ((ActivityRecord) proc.activities.get(k)).task;
                            if (tr.taskId == otherTask.taskId || !otherTask.inRecents) {
                                k++;
                            } else {
                                return;
                            }
                        }
                        if (!proc.foregroundServices) {
                            if (!(proc.processName == null || proc.info == null || proc.info.packageName == null)) {
                                ArrayList<String> filterList = OppoListManager.getInstance().getRemoveTaskFilterPkgList(this.mContext);
                                if (!(filterList == null || filterList.isEmpty())) {
                                    for (String str : filterList) {
                                        if (str != null && proc.info.packageName.equals(str)) {
                                            Slog.d(TAG, "remove task filter pkg process " + proc.processName);
                                            return;
                                        }
                                    }
                                }
                                ArrayList<String> stageProtectList = OppoListManager.getInstance().getStageProtectList();
                                if (!(stageProtectList == null || stageProtectList.isEmpty())) {
                                    for (String str2 : stageProtectList) {
                                        if (str2 != null && proc.info.packageName.equals(str2)) {
                                            Slog.d(TAG, "remove task filter process for stage protect " + proc.processName);
                                            return;
                                        }
                                    }
                                }
                                ArrayList<String> proFilterList = OppoListManager.getInstance().getRemoveTaskFilterProcessList(this.mContext);
                                if (proFilterList != null && proFilterList.contains(proc.processName)) {
                                    Slog.d(TAG, "remove task filter process " + proc.processName);
                                }
                            }
                            procsToKill.add(proc);
                        } else {
                            return;
                        }
                    }
                }
            }
            for (i = 0; i < procsToKill.size(); i++) {
                ProcessRecord pr = (ProcessRecord) procsToKill.get(i);
                if (pr.setSchedGroup != 0 || pr.curReceiver != null) {
                    pr.waitingToKill = "remove task";
                } else if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("oppo.clear.running", "0"))) {
                    pr.oppoClearProcess("remove task", true);
                } else {
                    pr.kill("remove task", true);
                }
            }
        }
    }

    private void removeTasksByPackageNameLocked(String packageName, int userId) {
        for (int i = this.mRecentTasks.size() - 1; i >= 0; i--) {
            TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
            if (tr.userId == userId) {
                ComponentName cn = tr.intent.getComponent();
                if (cn != null && cn.getPackageName().equals(packageName)) {
                    removeTaskByIdLocked(tr.taskId, true, true);
                }
            }
        }
    }

    private void cleanupDisabledPackageTasksLocked(String packageName, Set<String> filterByClasses, int userId) {
        for (int i = this.mRecentTasks.size() - 1; i >= 0; i--) {
            TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
            if (userId == -1 || tr.userId == userId) {
                ComponentName cn = tr.intent.getComponent();
                boolean sameComponent = (cn == null || !cn.getPackageName().equals(packageName)) ? false : filterByClasses != null ? filterByClasses.contains(cn.getClassName()) : true;
                if (sameComponent) {
                    removeTaskByIdLocked(tr.taskId, false, true);
                }
            }
        }
    }

    private boolean removeTaskByIdLocked(int taskId, boolean killProcess, boolean removeFromRecents) {
        TaskRecord tr = this.mStackSupervisor.anyTaskForIdLocked(taskId, false, -1);
        if (tr != null) {
            tr.removeTaskActivitiesLocked();
            if (ActivityManagerDebugConfig.DEBUG_TASKS && killProcess) {
                int callerPid = Binder.getCallingPid();
                Slog.d(TAG, "kill proc from removeTask, callerPid:" + callerPid + ", callerUid:" + Binder.getCallingUid() + Debug.getCallers(5));
            }
            cleanUpRemovedTaskLocked(tr, killProcess, removeFromRecents);
            if (tr.isPersistable) {
                notifyTaskPersisterLocked(null, true);
            }
            return true;
        }
        Slog.w(TAG, "Request to remove task ignored for non-existent task " + taskId);
        return false;
    }

    public void removeStack(int stackId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "removeStack()");
        if (stackId == 0) {
            throw new IllegalArgumentException("Removing home stack is not allowed.");
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                ActivityStack stack = this.mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                    return;
                }
                ArrayList<TaskRecord> tasks = stack.getAllTasks();
                for (int i = tasks.size() - 1; i >= 0; i--) {
                    removeTaskByIdLocked(((TaskRecord) tasks.get(i)).taskId, true, true);
                }
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean removeTask(int taskId) {
        boolean z = true;
        enforceCallingPermission("android.permission.REMOVE_TASKS", "removeTask()");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (taskId == -1) {
                    if (this.mRecentTasks != null) {
                        List<String> protectList = new ArrayList();
                        int N = this.mRecentTasks.size();
                        int num = N > 2 ? 2 : N;
                        for (int i = 0; i < num; i++) {
                            TaskRecord record = (TaskRecord) this.mRecentTasks.get(i);
                            if (!(record == null || record.getBaseIntent() == null || record.getBaseIntent().getComponent() == null)) {
                                String pkgName = record.getBaseIntent().getComponent().getPackageName();
                                if (!(pkgName == null || pkgName.equals("com.coloros.recents"))) {
                                    protectList.add(pkgName);
                                }
                            }
                        }
                        if (forceTrimMemory(80, protectList) != 0) {
                            z = false;
                        }
                        Binder.restoreCallingIdentity(ident);
                        resetPriorityAfterLockedSection();
                        return z;
                    }
                }
                z = removeTaskByIdLocked(taskId, true, true);
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
                return z;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void moveTaskToFront(int taskId, int flags, Bundle bOptions) {
        enforceCallingPermission("android.permission.REORDER_TASKS", "moveTaskToFront()");
        if (ActivityManagerDebugConfig.DEBUG_STACK) {
            Slog.d(TAG_STACK, "moveTaskToFront: moving taskId=" + taskId);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                moveTaskToFrontLocked(taskId, flags, bOptions);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void moveTaskToFrontLocked(int taskId, int flags, Bundle bOptions) {
        ActivityOptions options = ActivityOptions.fromBundle(bOptions);
        if (checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task to front")) {
            long origId = Binder.clearCallingIdentity();
            try {
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.d(TAG, "Could not find task for id: " + taskId);
                } else if (this.mStackSupervisor.isLockTaskModeViolation(task)) {
                    this.mStackSupervisor.showLockTaskToast();
                    Slog.e(TAG, "moveTaskToFront: Attempt to violate Lock Task Mode");
                    Binder.restoreCallingIdentity(origId);
                } else {
                    ActivityRecord prev = this.mStackSupervisor.topRunningActivityLocked();
                    if (prev != null && prev.isRecentsActivity()) {
                        task.setTaskToReturnTo(2);
                    }
                    this.mStackSupervisor.findTaskToMoveToFrontLocked(task, flags, options, "moveTaskToFront", false);
                    Binder.restoreCallingIdentity(origId);
                    ActivityOptions.abort(options);
                }
            } finally {
                Binder.restoreCallingIdentity(origId);
            }
        } else {
            ActivityOptions.abort(options);
        }
    }

    public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {
        enforceNotIsolatedCaller("moveActivityTaskToBack");
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                int taskId = ActivityRecord.getTaskForActivityLocked(token, !nonRoot);
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                } else if (this.mStackSupervisor.isLockedTask(task)) {
                    this.mStackSupervisor.showLockTaskToast();
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                } else {
                    if (this.mFocusedActivity != null && OppoSplitWindowAppReader.isInTwoSecond()) {
                        Slog.d(TAG, "back_key movetask: " + this.mFocusedActivity.packageName + " userId " + this.mFocusedActivity.userId);
                        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(START_FORCESTOP_MSG, this.mFocusedActivity.userId, -1, this.mFocusedActivity.packageName), 1000);
                    }
                    boolean moveTaskToBackLocked = ActivityRecord.getStackLocked(token).moveTaskToBackLocked(taskId);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return moveTaskToBackLocked;
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void moveTaskBackwards(int task) {
        enforceCallingPermission("android.permission.REORDER_TASKS", "moveTaskBackwards()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task backwards")) {
                    long origId = Binder.clearCallingIdentity();
                    moveTaskBackwardsLocked(task);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private final void moveTaskBackwardsLocked(int task) {
        Slog.e(TAG, "moveTaskBackwards not yet implemented!");
    }

    public IActivityContainer createVirtualActivityContainer(IBinder parentActivityToken, IActivityContainerCallback callback) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "createActivityContainer()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (parentActivityToken == null) {
                    throw new IllegalArgumentException("parent token must not be null");
                }
                ActivityRecord r = ActivityRecord.forTokenLocked(parentActivityToken);
                if (r == null) {
                } else if (callback == null) {
                    throw new IllegalArgumentException("callback must not be null");
                } else {
                    IActivityContainer createVirtualActivityContainer = this.mStackSupervisor.createVirtualActivityContainer(r, callback);
                    resetPriorityAfterLockedSection();
                    return createVirtualActivityContainer;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    public void deleteActivityContainer(IActivityContainer container) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "deleteActivityContainer()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mStackSupervisor.deleteActivityContainer(container);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public IActivityContainer createStackOnDisplay(int displayId) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "createStackOnDisplay()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = this.mStackSupervisor.createStackOnDisplay(this.mStackSupervisor.getNextStackId(), displayId, true);
                if (stack == null) {
                } else {
                    IActivityContainer iActivityContainer = stack.mActivityContainer;
                    resetPriorityAfterLockedSection();
                    return iActivityContainer;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    public int getActivityDisplayId(IBinder activityToken) throws RemoteException {
        int displayId;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(activityToken);
                if (stack == null || !stack.mActivityContainer.isAttachedLocked()) {
                    resetPriorityAfterLockedSection();
                    return 0;
                }
                displayId = stack.mActivityContainer.getDisplayId();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return displayId;
    }

    public int getActivityStackId(IBinder token) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    int i = stack.mStackId;
                    resetPriorityAfterLockedSection();
                    return i;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return -1;
    }

    public void exitFreeformMode(IBinder token) throws RemoteException {
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException("exitFreeformMode: No activity record matching token=" + token);
                }
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack == null || stack.mStackId != 2) {
                    throw new IllegalStateException("exitFreeformMode: You can only go fullscreen from freeform.");
                }
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "exitFreeformMode: " + r);
                }
                this.mStackSupervisor.moveTaskToStackLocked(r.task.taskId, 1, true, false, "exitFreeformMode", true);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void moveTaskToStack(int taskId, int stackId, boolean toTop) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTaskToStack()");
        if (stackId == 0) {
            throw new IllegalArgumentException("moveTaskToStack: Attempt to move task " + taskId + " to home stack");
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "moveTaskToStack: moving task=" + taskId + " to stackId=" + stackId + " toTop=" + toTop);
                }
                if (stackId == 3) {
                    this.mWindowManager.setDockedStackCreateState(0, null);
                }
                if (this.mStackSupervisor.moveTaskToStackLocked(taskId, stackId, toTop, false, "moveTaskToStack", true) && stackId == 3) {
                    this.mStackSupervisor.moveHomeStackTaskToTop(2, "moveTaskToDockedStack");
                }
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void swapDockedAndFullscreenStack() throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "swapDockedAndFullscreenStack()");
        synchronized (this) {
            long ident;
            try {
                TaskRecord topTask;
                ArrayList tasks;
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                ActivityStack fullscreenStack = this.mStackSupervisor.getStack(1);
                if (fullscreenStack != null) {
                    topTask = fullscreenStack.topTask();
                } else {
                    topTask = null;
                }
                ActivityStack dockedStack = this.mStackSupervisor.getStack(3);
                if (dockedStack != null) {
                    tasks = dockedStack.getAllTasks();
                } else {
                    tasks = null;
                }
                if (!(topTask == null || tasks == null)) {
                    if (tasks.size() != 0) {
                        this.mWindowManager.startFreezingScreen(0, 0);
                        this.mWindowManager.prepareAppTransition(18, false);
                        this.mStackSupervisor.moveTaskToStackLocked(topTask.taskId, 3, false, false, "swapDockedAndFullscreenStack", true, true);
                        int size = tasks.size();
                        for (int i = 0; i < size; i++) {
                            int id = ((TaskRecord) tasks.get(i)).taskId;
                            if (id != topTask.taskId) {
                                this.mStackSupervisor.moveTaskToStackLocked(id, 1, true, false, "swapDockedAndFullscreenStack", true, true);
                            }
                        }
                        this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                        this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                        this.mWindowManager.executeAppTransition();
                        this.mWindowManager.stopFreezingScreen();
                        Binder.restoreCallingIdentity(ident);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                }
                Slog.w(TAG, "Unable to swap tasks, either docked or fullscreen stack is empty.");
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean moveTaskToDockedStack(int taskId, int createMode, boolean toTop, boolean animate, Rect initialBounds, boolean moveHomeStackFront) {
        boolean moved;
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTaskToDockedStack()");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "moveTaskToDockedStack: moving task=" + taskId + " to createMode=" + createMode + " toTop=" + toTop);
                }
                this.mWindowManager.setDockedStackCreateState(createMode, initialBounds);
                moved = this.mStackSupervisor.moveTaskToStackLocked(taskId, 3, toTop, false, "moveTaskToDockedStack", animate, true);
                if (moved) {
                    if (moveHomeStackFront) {
                        this.mStackSupervisor.moveHomeStackToFront("moveTaskToDockedStack");
                    }
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                }
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return moved;
    }

    public boolean moveTopActivityToPinnedStack(int stackId, Rect bounds) {
        boolean moveTopStackActivityToPinnedStackLocked;
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTopActivityToPinnedStack()");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                if (this.mSupportsPictureInPicture) {
                    ident = Binder.clearCallingIdentity();
                    moveTopStackActivityToPinnedStackLocked = this.mStackSupervisor.moveTopStackActivityToPinnedStackLocked(stackId, bounds);
                    Binder.restoreCallingIdentity(ident);
                } else {
                    throw new IllegalStateException("moveTopActivityToPinnedStack:Device doesn't support picture-in-pciture mode");
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return moveTopStackActivityToPinnedStackLocked;
    }

    public void resizeStack(int stackId, Rect bounds, boolean allowResizeInDockedMode, boolean preserveWindows, boolean animate, int animationDuration) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (!animate) {
                    this.mStackSupervisor.resizeStackLocked(stackId, bounds, null, null, preserveWindows, allowResizeInDockedMode, false);
                } else if (stackId == 4) {
                    this.mWindowManager.animateResizePinnedStack(bounds, animationDuration);
                } else {
                    throw new IllegalArgumentException("Stack: " + stackId + " doesn't support animated resize.");
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void resizeDockedStack(Rect dockedBounds, Rect tempDockedTaskBounds, Rect tempDockedTaskInsetBounds, Rect tempOtherTaskBounds, Rect tempOtherTaskInsetBounds) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeDockedStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mStackSupervisor.resizeDockedStackLocked(dockedBounds, tempDockedTaskBounds, tempDockedTaskInsetBounds, tempOtherTaskBounds, tempOtherTaskInsetBounds, true);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void resizePinnedStack(Rect pinnedBounds, Rect tempPinnedTaskBounds) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizePinnedStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mStackSupervisor.resizePinnedStackLocked(pinnedBounds, tempPinnedTaskBounds);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void positionTaskInStack(int taskId, int stackId, int position) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "positionTaskInStack()");
        if (stackId == 0) {
            throw new IllegalArgumentException("positionTaskInStack: Attempt to change the position of task " + taskId + " in/to home stack");
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "positionTaskInStack: positioning task=" + taskId + " in stackId=" + stackId + " at position=" + position);
                }
                this.mStackSupervisor.positionTaskInStackLocked(taskId, stackId, position);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public List<StackInfo> getAllStackInfos() {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getAllStackInfos()");
        long ident = Binder.clearCallingIdentity();
        try {
            List allStackInfosLocked;
            synchronized (this) {
                boostPriorityForLockedSection();
                allStackInfosLocked = this.mStackSupervisor.getAllStackInfosLocked();
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
            return allStackInfosLocked;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public StackInfo getStackInfo(int stackId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getStackInfo()");
        long ident = Binder.clearCallingIdentity();
        try {
            StackInfo stackInfoLocked;
            synchronized (this) {
                boostPriorityForLockedSection();
                stackInfoLocked = this.mStackSupervisor.getStackInfoLocked(stackId);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
            return stackInfoLocked;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public boolean isInHomeStack(int taskId) {
        boolean z = false;
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getStackInfo()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord tr = this.mStackSupervisor.anyTaskForIdLocked(taskId, false, -1);
                if (!(tr == null || tr.stack == null)) {
                    z = tr.stack.isHomeStack();
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
            return z;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public int getTaskForActivity(IBinder token, boolean onlyRoot) {
        int taskForActivityLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                taskForActivityLocked = ActivityRecord.getTaskForActivityLocked(token, onlyRoot);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return taskForActivityLocked;
    }

    public void updateDeviceOwner(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    this.mDeviceOwnerName = packageName;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new SecurityException("updateDeviceOwner called from non-system process");
    }

    public void updateLockTaskPackages(int userId, String[] packages) {
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 0 || callingUid == 1000)) {
            enforceCallingPermission("android.permission.UPDATE_LOCK_TASK_PACKAGES", "updateLockTaskPackages()");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                    Slog.w(TAG_LOCKTASK, "Whitelisting " + userId + ":" + Arrays.toString(packages));
                }
                this.mLockTaskPackages.put(userId, packages);
                this.mStackSupervisor.onLockTaskPackagesUpdatedLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void startLockTaskModeLocked(TaskRecord task) {
        int i = 1;
        if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
            Slog.w(TAG_LOCKTASK, "startLockTaskModeLocked: " + task);
        }
        if (task.mLockTaskAuth != 0) {
            int callingUid = Binder.getCallingUid();
            boolean isSystemInitiated = callingUid == 1000;
            long ident = Binder.clearCallingIdentity();
            try {
                String pkg;
                synchronized (this) {
                    boostPriorityForLockedSection();
                    pkg = task.intent.getComponent().getPackageName();
                }
                resetPriorityAfterLockedSection();
                if (pkg != null && pkg.equals("com.android.cts.verifier")) {
                    Slog.v(TAG, "let the com.android.cts.verifier pass this!");
                } else if (!isSystemInitiated) {
                    task.mLockTaskUid = callingUid;
                    if (task.mLockTaskAuth == 1) {
                        if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                            Slog.w(TAG_LOCKTASK, "Mode default, asking user");
                        }
                        StatusBarManagerInternal statusBarManager = (StatusBarManagerInternal) LocalServices.getService(StatusBarManagerInternal.class);
                        if (statusBarManager != null) {
                            statusBarManager.showScreenPinningRequest(task.taskId);
                        }
                        Binder.restoreCallingIdentity(ident);
                        return;
                    }
                    ActivityStack stack = this.mStackSupervisor.getFocusedStack();
                    if (stack == null || task != stack.topTask()) {
                        throw new IllegalArgumentException("Invalid task, not in foreground");
                    }
                }
                if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                    String str;
                    String str2 = TAG_LOCKTASK;
                    if (isSystemInitiated) {
                        str = "Locking pinned";
                    } else {
                        str = "Locking fully";
                    }
                    Slog.w(str2, str);
                }
                ActivityStackSupervisor activityStackSupervisor = this.mStackSupervisor;
                if (isSystemInitiated) {
                    i = 2;
                }
                activityStackSupervisor.setLockTaskModeLocked(task, i, "startLockTask", true);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }

    public void startLockTaskMode(int taskId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task != null) {
                    startLockTaskModeLocked(task);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: Missing block: B:11:0x0017, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:12:0x001a, code:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void startLockTaskMode(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                } else {
                    TaskRecord task = r.task;
                    if (task != null) {
                        startLockTaskModeLocked(task);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void startSystemLockTaskMode(int taskId) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "startSystemLockTaskMode");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                startLockTaskMode(taskId);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:21:0x005a A:{Catch:{ all -> 0x00ba, all -> 0x00c0 }} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void stopLockTaskMode() {
        TaskRecord lockTask = this.mStackSupervisor.getLockedTaskLocked();
        if (lockTask != null) {
            long ident;
            TelecomManager tm;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    String pkg = lockTask.intent.getComponent().getPackageName();
                    if (pkg == null || !pkg.equals("com.android.cts.verifier")) {
                        int callingUid = Binder.getCallingUid();
                        int lockTaskUid = lockTask.mLockTaskUid;
                        if (this.mStackSupervisor.getLockTaskModeState() != 0) {
                            if (!(checkCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS") == 0 || callingUid == lockTaskUid || (lockTaskUid == 0 && callingUid == lockTask.effectiveUid))) {
                                throw new SecurityException("Invalid uid, expected " + lockTaskUid + " callingUid=" + callingUid + " effectiveUid=" + lockTask.effectiveUid);
                            }
                        }
                        return;
                    }
                    Slog.v(TAG, "let the com.android.cts.verifier pass this!");
                    ident = Binder.clearCallingIdentity();
                    try {
                        Log.d(TAG, "stopLockTaskMode");
                        synchronized (this) {
                            boostPriorityForLockedSection();
                            this.mStackSupervisor.setLockTaskModeLocked(null, 0, "stopLockTask", true);
                        }
                        resetPriorityAfterLockedSection();
                        tm = (TelecomManager) this.mContext.getSystemService("telecom");
                        if (tm != null) {
                            tm.showInCallScreen(false);
                        }
                        Binder.restoreCallingIdentity(ident);
                    } catch (Throwable th) {
                        Binder.restoreCallingIdentity(ident);
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
            tm = (TelecomManager) this.mContext.getSystemService("telecom");
            if (tm != null) {
            }
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void stopSystemLockTaskMode() throws RemoteException {
        if (this.mStackSupervisor.getLockTaskModeState() == 2) {
            stopLockTaskMode();
        } else {
            this.mStackSupervisor.showLockTaskToast();
        }
    }

    public boolean isInLockTaskMode() {
        return getLockTaskModeState() != 0;
    }

    public int getLockTaskModeState() {
        int lockTaskModeState;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                lockTaskModeState = this.mStackSupervisor.getLockTaskModeState();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return lockTaskModeState;
    }

    public void showLockTaskEscapeMessage(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                } else {
                    this.mStackSupervisor.showLockTaskEscapeMessageLocked(r.task);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private final List<ProviderInfo> generateApplicationProvidersLocked(ProcessRecord app) {
        List<ProviderInfo> providers = null;
        try {
            providers = AppGlobals.getPackageManager().queryContentProviders(app.processName, app.uid, 268438528).getList();
        } catch (RemoteException e) {
        }
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "generateApplicationProvidersLocked, app.info.uid = " + app.uid);
        }
        int userId = app.userId;
        if (providers != null) {
            int N = providers.size();
            app.pubProviders.ensureCapacity(app.pubProviders.size() + N);
            int i = 0;
            while (i < N) {
                ProviderInfo cpi = (ProviderInfo) providers.get(i);
                boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags);
                if (!singleton || UserHandle.getUserId(app.uid) == 0) {
                    ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
                    ContentProviderRecord cpr = this.mProviderMap.getProviderByClass(comp, userId);
                    if (cpr == null) {
                        cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton);
                        this.mProviderMap.putProviderByClass(comp, cpr);
                    }
                    if (ActivityManagerDebugConfig.DEBUG_MU) {
                        Slog.v(TAG_MU, "generateApplicationProvidersLocked, cpi.uid = " + cpr.uid);
                    }
                    app.pubProviders.put(cpi.name, cpr);
                    if (!(cpi.multiprocess && "android".equals(cpi.packageName))) {
                        app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode, this.mProcessStats);
                    }
                    notifyPackageUse(cpi.applicationInfo.packageName, 4);
                } else {
                    providers.remove(i);
                    N--;
                    i--;
                }
                i++;
            }
        }
        return providers;
    }

    public String checkContentProviderAccess(String authority, int userId) {
        if (userId == -1) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", TAG);
            userId = UserHandle.getCallingUserId();
        }
        ProviderInfo cpi = null;
        try {
            cpi = AppGlobals.getPackageManager().resolveContentProvider(authority, 789504, userId);
        } catch (RemoteException e) {
        }
        if (cpi == null) {
            return null;
        }
        ProcessRecord r;
        synchronized (this.mPidsSelfLocked) {
            r = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
        }
        if (r == null) {
            return "Failed to find PID " + Binder.getCallingPid();
        }
        String checkContentProviderPermissionLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                checkContentProviderPermissionLocked = checkContentProviderPermissionLocked(cpi, r, userId, true);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return checkContentProviderPermissionLocked;
    }

    private final String checkContentProviderPermissionLocked(ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) {
        int callingPid = r != null ? r.pid : Binder.getCallingPid();
        int callingUid = r != null ? r.uid : Binder.getCallingUid();
        boolean checkedGrants = false;
        if (checkUser) {
            int tmpTargetUserId = this.mUserController.unsafeConvertIncomingUserLocked(userId);
            if (tmpTargetUserId != UserHandle.getUserId(callingUid)) {
                if (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) {
                    return null;
                }
                checkedGrants = true;
            }
            userId = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 0, "checkContentProviderPermissionLocked " + cpi.authority, null);
            if (userId != tmpTargetUserId) {
                checkedGrants = false;
            }
        }
        if (checkComponentPermission(cpi.readPermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
            return null;
        }
        if (checkComponentPermission(cpi.writePermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
            return null;
        }
        PathPermission[] pps = cpi.pathPermissions;
        if (pps != null) {
            int i = pps.length;
            while (i > 0) {
                i--;
                PathPermission pp = pps[i];
                String pprperm = pp.getReadPermission();
                if (pprperm != null) {
                    if (checkComponentPermission(pprperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
                        return null;
                    }
                }
                String ppwperm = pp.getWritePermission();
                if (ppwperm != null) {
                    if (checkComponentPermission(ppwperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
                        return null;
                    }
                }
            }
        }
        if (!checkedGrants && checkAuthorityGrants(callingUid, cpi, userId, checkUser)) {
            return null;
        }
        String msg;
        StringBuilder append;
        if (cpi.exported) {
            append = new StringBuilder().append("Permission Denial: opening provider ").append(cpi.name).append(" from ");
            if (r == null) {
                r = "(null)";
            }
            msg = append.append(r).append(" (pid=").append(callingPid).append(", uid=").append(callingUid).append(") requires ").append(cpi.readPermission).append(" or ").append(cpi.writePermission).toString();
        } else {
            append = new StringBuilder().append("Permission Denial: opening provider ").append(cpi.name).append(" from ");
            if (r == null) {
                r = "(null)";
            }
            msg = append.append(r).append(" (pid=").append(callingPid).append(", uid=").append(callingUid).append(") that is not exported from uid ").append(cpi.applicationInfo.uid).toString();
        }
        Slog.w(TAG, msg);
        return msg;
    }

    boolean checkAuthorityGrants(int callingUid, ProviderInfo cpi, int userId, boolean checkUser) {
        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(callingUid);
        if (perms != null) {
            for (int i = perms.size() - 1; i >= 0; i--) {
                GrantUri grantUri = (GrantUri) perms.keyAt(i);
                if ((grantUri.sourceUserId == userId || !checkUser) && matchesProvider(grantUri.uri, cpi)) {
                    return true;
                }
            }
        }
        return false;
    }

    boolean matchesProvider(Uri uri, ProviderInfo cpi) {
        String uriAuth = uri.getAuthority();
        String cpiAuth = cpi.authority;
        if (cpiAuth.indexOf(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG) == -1) {
            return cpiAuth.equals(uriAuth);
        }
        for (String equals : cpiAuth.split(";")) {
            if (equals.equals(uriAuth)) {
                return true;
            }
        }
        return false;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    ContentProviderConnection incProviderCountLocked(ProcessRecord r, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
        if (r != null) {
            ContentProviderConnection conn;
            for (int i = 0; i < r.conProviders.size(); i++) {
                conn = (ContentProviderConnection) r.conProviders.get(i);
                if (conn.provider == cpr) {
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                        Slog.v(TAG_PROVIDER, "Adding provider requested by " + r.processName + " from process " + cpr.info.processName + ": " + cpr.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
                    }
                    OppoProcessManagerHelper.resumeProvider(cpr);
                    if (stable) {
                        conn.stableCount++;
                        conn.numStableIncs++;
                    } else {
                        conn.unstableCount++;
                        conn.numUnstableIncs++;
                    }
                    return conn;
                }
            }
            conn = new ContentProviderConnection(cpr, r);
            if (stable) {
                conn.stableCount = 1;
                conn.numStableIncs = 1;
            } else {
                conn.unstableCount = 1;
                conn.numUnstableIncs = 1;
            }
            cpr.connections.add(conn);
            r.conProviders.add(conn);
            startAssociationLocked(r.uid, r.processName, r.curProcState, cpr.uid, cpr.name, cpr.info.processName);
            return conn;
        }
        cpr.addExternalProcessHandleLocked(externalProcessToken);
        return null;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    boolean decProviderCountLocked(ContentProviderConnection conn, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
        if (conn != null) {
            cpr = conn.provider;
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                Slog.v(TAG_PROVIDER, "Removing provider requested by " + conn.client.processName + " from process " + cpr.info.processName + ": " + cpr.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
            }
            OppoProcessManagerHelper.resumeProvider(cpr);
            if (stable) {
                conn.stableCount--;
            } else {
                conn.unstableCount--;
            }
            if (conn.stableCount != 0 || conn.unstableCount != 0) {
                return false;
            }
            cpr.connections.remove(conn);
            conn.client.conProviders.remove(conn);
            if (conn.client.setProcState < 13 && cpr.proc != null) {
                cpr.proc.lastProviderTime = SystemClock.uptimeMillis();
            }
            stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid, cpr.name);
            return true;
        }
        cpr.removeExternalProcessHandleLocked(externalProcessToken);
        return false;
    }

    private void checkTime(long startTime, String where) {
        long now = SystemClock.uptimeMillis();
        if (now - startTime > 50) {
            Slog.w(TAG, "Slow operation: " + (now - startTime) + "ms so far, now at " + where);
        }
    }

    boolean isProcessAliveLocked(ProcessRecord proc) {
        boolean z = false;
        if (proc.procStatFile == null) {
            proc.procStatFile = "/proc/" + proc.pid + "/stat";
        }
        this.mProcessStateStatsLongs[0] = 0;
        if (Process.readProcFile(proc.procStatFile, PROCESS_STATE_STATS_FORMAT, null, this.mProcessStateStatsLongs, null)) {
            long state = this.mProcessStateStatsLongs[0];
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.d(TAG, "RETRIEVED STATE FOR " + proc.procStatFile + ": " + ((char) ((int) state)));
            }
            if (!(state == 90 || state == 88 || state == 120 || state == 75)) {
                z = true;
            }
            return z;
        }
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG, "UNABLE TO RETRIEVE STATE FOR " + proc.procStatFile);
        }
        return false;
    }

    /* JADX WARNING: Removed duplicated region for block: B:307:0x0992  */
    /* JADX WARNING: Removed duplicated region for block: B:261:0x07ae A:{Catch:{ RemoteException -> 0x078c, all -> 0x0793, all -> 0x004d }} */
    /* JADX WARNING: Removed duplicated region for block: B:270:0x0811 A:{Catch:{ RemoteException -> 0x078c, all -> 0x0793, all -> 0x004d }} */
    /* JADX WARNING: Removed duplicated region for block: B:341:0x0a7c A:{Catch:{ RemoteException -> 0x078c, all -> 0x0793, all -> 0x004d }} */
    /* JADX WARNING: Removed duplicated region for block: B:344:0x0a9a A:{Catch:{ RemoteException -> 0x078c, all -> 0x0793, all -> 0x004d }} */
    /* JADX WARNING: Removed duplicated region for block: B:466:0x0dcd  */
    /* JADX WARNING: Removed duplicated region for block: B:493:0x0e48  */
    /* JADX WARNING: Removed duplicated region for block: B:468:0x0de8  */
    /* JADX WARNING: Missing block: B:31:0x00f6, code:
            if (r60.contains("safecenter") != false) goto L_0x00f8;
     */
    /* JADX WARNING: Missing block: B:81:0x027c, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:82:0x027f, code:
            return r37;
     */
    /* JADX WARNING: Missing block: B:347:0x0aaa, code:
            resetPriorityAfterLockedSection();
            r21 = false;
     */
    /* JADX WARNING: Missing block: B:348:0x0aaf, code:
            monitor-enter(r4);
     */
    /* JADX WARNING: Missing block: B:351:0x0ab2, code:
            if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_PROVIDER != false) goto L_0x0ab8;
     */
    /* JADX WARNING: Missing block: B:353:0x0ab6, code:
            if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_AMS == false) goto L_0x0ae0;
     */
    /* JADX WARNING: Missing block: B:354:0x0ab8, code:
            android.util.Slog.v(TAG_MU, "cpr.provider " + r4.provider + " launchingApp= " + r4.launchingApp);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) {
        ContentProviderRecord cpr;
        long ident;
        Object[] objArr;
        Throwable th;
        Throwable e;
        ContentProviderConnection conn = null;
        ProviderInfo cpi = null;
        synchronized (this) {
            String msg;
            long origId;
            ReadyToGetProvider eventData;
            ArrayList<String> arrayList;
            boostPriorityForLockedSection();
            long startTime = SystemClock.uptimeMillis();
            ProcessRecord processRecord = null;
            if (caller != null) {
                processRecord = getRecordForAppLocked(caller);
                if (processRecord == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when getting content provider " + name);
                }
            }
            boolean checkCrossUser = true;
            checkTime(startTime, "getContentProviderImpl: getProviderByName");
            cpr = this.mProviderMap.getProviderByName(name, userId);
            if (cpr != null && userId == 999) {
                String cprPkgName = IElsaManager.EMPTY_PACKAGE;
                if (cpr.appInfo != null) {
                    cprPkgName = cpr.appInfo.packageName;
                }
                if (!OppoMultiLauncherUtil.getInstance().isMultiApp(cprPkgName)) {
                    if (DEBUG_COLOROS_AMS) {
                        Slog.v(TAG, "multi app getContentProviderImpl: cpr = " + cpr + "  name = " + name + "  userId = " + userId + "  cprPkgName = " + cprPkgName);
                    }
                    userId = 0;
                    cpr = this.mProviderMap.getProviderByName(name, 0);
                }
            }
            boolean openTraceLog = ActivityManagerDebugConfig.DEBUG_AMS;
            if (name != null) {
                if (!name.contains("SafeProvider")) {
                }
                openTraceLog = true;
            }
            if (openTraceLog) {
                Slog.d(TAG, "getContentProviderImpl, cpr:" + cpr + ", name:" + name);
            }
            if (cpr == null && userId != 0) {
                cpr = this.mProviderMap.getProviderByName(name, 0);
                if (cpr != null) {
                    cpi = cpr.info;
                    if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags)) {
                        if (isValidSingletonCall(processRecord.uid, cpi.applicationInfo.uid)) {
                            userId = 0;
                            checkCrossUser = false;
                        }
                    }
                    cpr = null;
                    cpi = null;
                }
            }
            if (openTraceLog) {
                Slog.d(TAG, "getContentProviderImpl 02, cpr:" + cpr);
            }
            boolean providerRunning = (cpr == null || cpr.proc == null || cpr.proc.killed) ? false : true;
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                Slog.v(TAG_MU, "providerRunning " + providerRunning + " cpr.proc " + (cpr != null ? cpr.proc : null));
            }
            if (providerRunning) {
                cpi = cpr.info;
                checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
                msg = checkContentProviderPermissionLocked(cpi, processRecord, userId, checkCrossUser);
                if (msg != null) {
                    throw new SecurityException(msg);
                }
                checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
                if (processRecord == null || !cpr.canRunHere(processRecord)) {
                    try {
                        origId = Binder.clearCallingIdentity();
                        checkTime(startTime, "getContentProviderImpl: incProviderCountLocked");
                        if (processRecord != null || cpr == null || cpr.proc == null || !Process.isProcessSuspend(cpr.proc.pid)) {
                            conn = incProviderCountLocked(processRecord, cpr, token, stable);
                            if (conn != null && conn.stableCount + conn.unstableCount == 1 && cpr.proc != null && processRecord.setAdj <= 200) {
                                checkTime(startTime, "getContentProviderImpl: before updateLruProcess");
                                updateLruProcessLocked(cpr.proc, false, null);
                                checkTime(startTime, "getContentProviderImpl: after updateLruProcess");
                            }
                            checkTime(startTime, "getContentProviderImpl: before updateOomAdj");
                            int verifiedAdj = cpr.proc.verifiedAdj;
                            boolean success = updateOomAdjLocked(cpr.proc);
                            if (success && verifiedAdj != cpr.proc.setAdj) {
                                if (!isProcessAliveLocked(cpr.proc)) {
                                    success = false;
                                }
                            }
                            maybeUpdateProviderUsageStatsLocked(processRecord, cpr.info.packageName, name);
                            checkTime(startTime, "getContentProviderImpl: after updateOomAdj");
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                Slog.i(TAG_PROVIDER, "Adjust success: " + success);
                            }
                            if (success) {
                                cpr.proc.verifiedAdj = cpr.proc.setAdj;
                            } else {
                                Slog.i(TAG, "Existing provider " + cpr.name.flattenToShortString() + " is crashing; detaching " + processRecord);
                                boolean lastRef = decProviderCountLocked(conn, cpr, token, stable);
                                checkTime(startTime, "getContentProviderImpl: before appDied");
                                appDiedLocked(cpr.proc);
                                checkTime(startTime, "getContentProviderImpl: after appDied");
                                if (lastRef) {
                                    providerRunning = false;
                                    conn = null;
                                } else {
                                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                        Slog.i(TAG_PROVIDER, " !lastRef return null");
                                    }
                                    resetPriorityAfterLockedSection();
                                    return null;
                                }
                            }
                            if (success) {
                                for (int provi = cpr.proc.conProviders.size() - 1; provi >= 0; provi--) {
                                    ContentProviderConnection proviConn = (ContentProviderConnection) cpr.proc.conProviders.get(provi);
                                    if (!(proviConn.stableCount <= 0 || proviConn.provider.proc == null || proviConn.provider.proc.processName.equals("system"))) {
                                        Slog.e(TAG, "getContentProviderImpl: Update provider " + cpr.proc + " conProviers's adj." + " conProviders.provider.proc = " + proviConn.provider.proc + " stableCount = " + proviConn.stableCount);
                                        updateOomAdjLocked(proviConn.provider.proc);
                                    }
                                }
                            }
                            Binder.restoreCallingIdentity(origId);
                        } else {
                            if (DEBUG_COLOROS_AMS) {
                                Log.i(TAG, "skip for suspend app cpr = " + cpr);
                            }
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    } catch (RemoteException e2) {
                        Binder.restoreCallingIdentity(ident);
                    } catch (Throwable th2) {
                        resetPriorityAfterLockedSection();
                    }
                }
                ContentProviderHolder holder = cpr.newHolder(null);
                holder.provider = null;
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                    eventData = ReadyToGetProvider.createInstance();
                    arrayList = new ArrayList(processRecord.pkgList.keySet());
                    objArr = new Object[3];
                    objArr[0] = cpi.applicationInfo.packageName;
                    objArr[1] = arrayList;
                    objArr[2] = Integer.valueOf(processRecord.uid);
                    eventData.set(objArr);
                    this.mAMEventHook.hook(Event.AM_ReadyToGetProvider, eventData);
                }
                if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                    Slog.i(TAG_PROVIDER, " cpr.canRunHere  " + holder);
                }
            }
            if (!providerRunning) {
                try {
                    checkTime(startTime, "getContentProviderImpl: before resolveContentProvider");
                    cpi = AppGlobals.getPackageManager().resolveContentProvider(name, 3072, userId);
                    if (openTraceLog) {
                        Slog.d(TAG, "getContentProviderImpl 03, cpi:" + cpi);
                    }
                    if (cpi != null && userId == 999) {
                        String cpiPkgName = IElsaManager.EMPTY_PACKAGE;
                        if (cpi.applicationInfo != null) {
                            cpiPkgName = cpi.applicationInfo.packageName;
                        }
                        if (!OppoMultiLauncherUtil.getInstance().isMultiApp(cpiPkgName)) {
                            if (DEBUG_COLOROS_AMS || openTraceLog) {
                                Slog.v(TAG, "multi app getContentProviderImpl: cpi = " + cpi + "  name = " + name + "  userId = " + userId + "  cpiPkgName = " + cpiPkgName);
                            }
                            userId = 0;
                            cpi = AppGlobals.getPackageManager().resolveContentProvider(name, 3072, 0);
                        }
                    }
                    checkTime(startTime, "getContentProviderImpl: after resolveContentProvider");
                } catch (RemoteException e3) {
                }
                if (cpi == null) {
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                        Slog.i(TAG_PROVIDER, " resolveContentProvider return null ");
                    }
                    resetPriorityAfterLockedSection();
                    return null;
                }
                boolean singleton;
                if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags)) {
                    singleton = isValidSingletonCall(processRecord.uid, cpi.applicationInfo.uid);
                } else {
                    singleton = false;
                }
                if (singleton) {
                    userId = 0;
                }
                cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);
                checkTime(startTime, "getContentProviderImpl: got app info for user");
                if (openTraceLog) {
                    Slog.d(TAG, "getContentProviderImpl 04, singleton:" + singleton + ", for cpi:" + cpi);
                }
                checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
                msg = checkContentProviderPermissionLocked(cpi, processRecord, userId, !singleton);
                if (msg != null) {
                    throw new SecurityException(msg);
                }
                checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
                if (!this.mProcessesReady && !cpi.processName.equals("system")) {
                    throw new IllegalArgumentException("Attempt to launch content provider before system ready");
                } else if (this.mUserController.isUserRunningLocked(userId, 0)) {
                    int N;
                    int i;
                    ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
                    checkTime(startTime, "getContentProviderImpl: before getProviderByClass");
                    ContentProviderRecord cpr2 = this.mProviderMap.getProviderByClass(comp, userId);
                    checkTime(startTime, "getContentProviderImpl: after getProviderByClass");
                    boolean firstClass = cpr2 == null;
                    if (firstClass) {
                        ident = Binder.clearCallingIdentity();
                        if (!Build.isPermissionReviewRequired() || requestTargetProviderPermissionsReviewIfNeededLocked(cpi, processRecord, userId)) {
                            checkTime(startTime, "getContentProviderImpl: before getApplicationInfo");
                            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName, 1024, userId);
                            checkTime(startTime, "getContentProviderImpl: after getApplicationInfo");
                            if (ai == null) {
                                Slog.w(TAG, "No package info for content provider " + cpi.name);
                                Binder.restoreCallingIdentity(ident);
                                resetPriorityAfterLockedSection();
                                return null;
                            }
                            cpr = new ContentProviderRecord(this, cpi, getAppInfoForUser(ai, userId), comp, singleton);
                            Binder.restoreCallingIdentity(ident);
                            checkTime(startTime, "getContentProviderImpl: now have ContentProviderRecord");
                            if (processRecord == null && cpr.canRunHere(processRecord)) {
                                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                                    eventData = ReadyToGetProvider.createInstance();
                                    arrayList = new ArrayList(processRecord.pkgList.keySet());
                                    objArr = new Object[3];
                                    objArr[0] = cpi.applicationInfo.packageName;
                                    objArr[1] = arrayList;
                                    objArr[2] = Integer.valueOf(processRecord.uid);
                                    eventData.set(objArr);
                                    this.mAMEventHook.hook(Event.AM_ReadyToGetProvider, eventData);
                                }
                                if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                    Slog.i(TAG_PROVIDER, " this is a multiprocess provider " + cpr);
                                }
                                ContentProviderHolder newHolder = cpr.newHolder(null);
                                resetPriorityAfterLockedSection();
                                return newHolder;
                            }
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER || openTraceLog) {
                                Slog.w(TAG_PROVIDER, "LAUNCHING REMOTE PROVIDER (myuid " + (processRecord == null ? Integer.valueOf(processRecord.uid) : null) + " pruid " + cpr.appInfo.uid + "): " + cpr.info.name + " callers=" + Debug.getCallers(6));
                            }
                            N = this.mLaunchingProviders.size();
                            i = 0;
                            while (i < N && this.mLaunchingProviders.get(i) != cpr) {
                                i++;
                            }
                            if (i >= N) {
                                int callerUid = Binder.getCallingUid();
                                origId = Binder.clearCallingIdentity();
                                try {
                                    checkTime(startTime, "getContentProviderImpl: before set stopped state");
                                    AppGlobals.getPackageManager().setPackageStoppedState(cpr.appInfo.packageName, false, userId);
                                    checkTime(startTime, "getContentProviderImpl: after set stopped state");
                                } catch (RemoteException e4) {
                                } catch (IllegalArgumentException e5) {
                                    Slog.w(TAG, "Failed trying to unstop package " + cpr.appInfo.packageName + ": " + e5);
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                                    PackageStoppedStatusChanged eventData1 = PackageStoppedStatusChanged.createInstance();
                                    objArr = new Object[3];
                                    objArr[0] = cpr.appInfo.packageName;
                                    objArr[1] = Integer.valueOf(0);
                                    objArr[2] = "getContentProviderImpl";
                                    eventData1.set(objArr);
                                    this.mAMEventHook.hook(Event.AM_PackageStoppedStatusChanged, eventData1);
                                }
                                checkTime(startTime, "getContentProviderImpl: looking for process record");
                                ProcessRecord proc = getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, false);
                                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                                    eventData = ReadyToGetProvider.createInstance();
                                    if (processRecord != null) {
                                        arrayList = new ArrayList(processRecord.pkgList.keySet());
                                        objArr = new Object[3];
                                        objArr[0] = cpi.applicationInfo.packageName;
                                        objArr[1] = arrayList;
                                        objArr[2] = Integer.valueOf(processRecord.uid);
                                        eventData.set(objArr);
                                    } else {
                                        objArr = new Object[3];
                                        objArr[0] = cpi.applicationInfo.packageName;
                                        objArr[1] = null;
                                        objArr[2] = Integer.valueOf(callerUid);
                                        eventData.set(objArr);
                                    }
                                    this.mAMEventHook.hook(Event.AM_ReadyToGetProvider, eventData);
                                }
                                if (openTraceLog) {
                                    boolean isThreadNull = (proc == null || proc.thread == null) ? false : true;
                                    Slog.d(TAG, "getContentProviderImpl 05, proc for:" + cpi.processName + ", isThreadNull:" + isThreadNull + ", cprUid:" + cpr.appInfo.uid + ", proc:" + proc);
                                }
                                if (proc != null && proc.thread != null && !proc.killed) {
                                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                        Slog.d(TAG_PROVIDER, "Installing in existing process " + proc);
                                    }
                                    if (!proc.pubProviders.containsKey(cpi.name)) {
                                        checkTime(startTime, "getContentProviderImpl: scheduling install");
                                        proc.pubProviders.put(cpi.name, cpr);
                                        try {
                                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                                Slog.d(TAG_PROVIDER, "Installing provider " + proc + " cpr " + cpr);
                                            }
                                            proc.thread.scheduleInstallProvider(cpi);
                                        } catch (RemoteException e6) {
                                        }
                                    }
                                } else if (OppoAbnormalAppManager.getInstance().validStartProvider(cpr)) {
                                    Slog.i(OppoAbnormalAppManager.TAG, "UL for provider " + cpr + " : is R");
                                    Binder.restoreCallingIdentity(origId);
                                    resetPriorityAfterLockedSection();
                                    return null;
                                } else if (OppoAppStartupManager.getInstance().handleStartProvider(cpr, processRecord)) {
                                    Slog.i(TAG, "not allowed to start " + cpr + " caller is " + processRecord);
                                    Binder.restoreCallingIdentity(origId);
                                    resetPriorityAfterLockedSection();
                                    return null;
                                } else {
                                    if (cpr != null) {
                                        if (!OppoAppStartupManager.getInstance().isAllowStartFromProvider(processRecord, cpr, cpi.applicationInfo)) {
                                            Binder.restoreCallingIdentity(origId);
                                            resetPriorityAfterLockedSection();
                                            return null;
                                        }
                                    }
                                    checkTime(startTime, "getContentProviderImpl: before start process");
                                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                        Slog.d(TAG_PROVIDER, "Start process " + cpi.processName + " for " + name);
                                    }
                                    proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, "content provider", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false);
                                    checkTime(startTime, "getContentProviderImpl: after start process");
                                    if (proc == null) {
                                        Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": process is bad");
                                        Binder.restoreCallingIdentity(origId);
                                        resetPriorityAfterLockedSection();
                                        return null;
                                    } else if (!firstClass) {
                                        cpr = this.mProviderMap.getProviderByClass(comp, userId);
                                        if (cpr == null) {
                                            if (!Build.isPermissionReviewRequired() || requestTargetProviderPermissionsReviewIfNeededLocked(cpi, processRecord, userId)) {
                                                try {
                                                    checkTime(startTime, "getContentProviderImpl: before getApplicationInfo 2");
                                                    ai = AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName, 1024, userId);
                                                    checkTime(startTime, "getContentProviderImpl: after getApplicationInfo 2 ");
                                                    if (ai == null) {
                                                        Slog.w(TAG, "No package info for content provider 2 " + cpi.name);
                                                        Binder.restoreCallingIdentity(origId);
                                                        resetPriorityAfterLockedSection();
                                                        return null;
                                                    }
                                                    cpr2 = new ContentProviderRecord(this, cpi, getAppInfoForUser(ai, userId), comp, singleton);
                                                    try {
                                                        this.mProviderMap.putProviderByClass(comp, cpr2);
                                                        if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                                            Slog.d(TAG_PROVIDER, "new ContentProviderRecord " + cpr2 + " comp " + comp);
                                                        }
                                                        cpr = cpr2;
                                                    } catch (Exception e7) {
                                                        e = e7;
                                                        cpr = cpr2;
                                                        Slog.e(TAG, "Exception in cpr " + cpr, e);
                                                        Binder.restoreCallingIdentity(origId);
                                                        resetPriorityAfterLockedSection();
                                                        return null;
                                                    } catch (Throwable th4) {
                                                        th = th4;
                                                        cpr = cpr2;
                                                        Binder.restoreCallingIdentity(origId);
                                                        throw th;
                                                    }
                                                } catch (Exception e8) {
                                                    e = e8;
                                                    Slog.e(TAG, "Exception in cpr " + cpr, e);
                                                    Binder.restoreCallingIdentity(origId);
                                                    resetPriorityAfterLockedSection();
                                                    return null;
                                                }
                                            }
                                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                                Slog.i(TAG_PROVIDER, "!requestTargetProviderPermissionsReviewIfNeededLocked null");
                                            }
                                            Binder.restoreCallingIdentity(origId);
                                            resetPriorityAfterLockedSection();
                                            return null;
                                        }
                                    }
                                }
                                cpr.launchingApp = proc;
                                this.mLaunchingProviders.add(cpr);
                                Binder.restoreCallingIdentity(origId);
                            }
                            checkTime(startTime, "getContentProviderImpl: updating data structures");
                            if (firstClass) {
                                this.mProviderMap.putProviderByClass(comp, cpr);
                            }
                            this.mProviderMap.putProviderByName(name, cpr);
                            conn = incProviderCountLocked(processRecord, cpr, token, stable);
                            if (conn != null) {
                                conn.waiting = true;
                            }
                        } else {
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                Slog.i(TAG_PROVIDER, "!requestTargetProviderPermissionsReviewIfNeededLocked null");
                            }
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    }
                    cpr = cpr2;
                    checkTime(startTime, "getContentProviderImpl: now have ContentProviderRecord");
                    if (processRecord == null) {
                    }
                    if (processRecord == null) {
                    }
                    Slog.w(TAG_PROVIDER, "LAUNCHING REMOTE PROVIDER (myuid " + (processRecord == null ? Integer.valueOf(processRecord.uid) : null) + " pruid " + cpr.appInfo.uid + "): " + cpr.info.name + " callers=" + Debug.getCallers(6));
                    N = this.mLaunchingProviders.size();
                    i = 0;
                    while (i < N) {
                        i++;
                    }
                    if (i >= N) {
                    }
                    checkTime(startTime, "getContentProviderImpl: updating data structures");
                    if (firstClass) {
                    }
                    this.mProviderMap.putProviderByName(name, cpr);
                    conn = incProviderCountLocked(processRecord, cpr, token, stable);
                    if (conn != null) {
                    }
                } else {
                    Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": user " + userId + " is stopped");
                    resetPriorityAfterLockedSection();
                    return null;
                }
            }
            checkTime(startTime, "getContentProviderImpl: done!");
        }
        boolean bPublishTimeout;
        while (cpr.provider == null) {
            if (cpr.launchingApp == null) {
                Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": launching app became null");
                objArr = new Object[4];
                objArr[0] = Integer.valueOf(UserHandle.getUserId(cpi.applicationInfo.uid));
                objArr[1] = cpi.applicationInfo.packageName;
                objArr[2] = Integer.valueOf(cpi.applicationInfo.uid);
                objArr[3] = name;
                EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS, objArr);
                return null;
            }
            try {
                if (ActivityManagerDebugConfig.DEBUG_MU) {
                    Slog.v(TAG_MU, "Waiting to start provider " + cpr + " launchingApp=" + cpr.launchingApp);
                }
                if (conn != null) {
                    conn.waiting = true;
                }
                long timeCprWaitBegin = SystemClock.elapsedRealtime();
                if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                    Slog.v(TAG_MU, "cpr.wait " + cpr + " launchingApp= " + cpr.launchingApp);
                }
                cpr.wait(APP_DEXOPT_TIMEOUT);
                bPublishTimeout = SystemClock.elapsedRealtime() - timeCprWaitBegin >= APP_DEXOPT_TIMEOUT;
                if (bPublishTimeout) {
                    if (conn != null) {
                        conn.waiting = false;
                    }
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                        Slog.i(TAG_PROVIDER, " end return " + cpr);
                    }
                    if (bPublishTimeout) {
                        return cpr != null ? cpr.newHolder(conn) : null;
                    }
                    Slog.w(TAG_MU, "getContentProviderImpl wait publish timeout, we clean it, cpr:" + cpr + " launchingApp=" + cpr.launchingApp);
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            cleanupAppInLaunchingProvidersLocked(cpr.launchingApp, true);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    return null;
                } else if (conn != null) {
                    conn.waiting = false;
                } else {
                    continue;
                }
            } catch (InterruptedException e9) {
                if (conn != null) {
                    conn.waiting = false;
                } else {
                    continue;
                }
            } catch (Throwable th5) {
                if (conn != null) {
                    conn.waiting = false;
                }
            }
        }
        if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
        }
        if (bPublishTimeout) {
        }
        return null;
    }

    private boolean requestTargetProviderPermissionsReviewIfNeededLocked(ProviderInfo cpi, ProcessRecord r, int userId) {
        boolean callerForeground = true;
        if (!getPackageManagerInternalLocked().isPermissionsReviewRequired(cpi.packageName, userId)) {
            return true;
        }
        if (r != null && r.setSchedGroup == 0) {
            callerForeground = false;
        }
        if (callerForeground) {
            final Intent intent = new Intent("android.intent.action.REVIEW_PERMISSIONS");
            intent.addFlags(276824064);
            intent.putExtra("android.intent.extra.PACKAGE_NAME", cpi.packageName);
            if (ActivityManagerDebugConfig.DEBUG_PERMISSIONS_REVIEW || !IS_USER_BUILD) {
                Slog.i(TAG, "u" + userId + " Launching permission review " + "for package " + cpi.packageName);
            }
            final UserHandle userHandle = new UserHandle(userId);
            this.mHandler.post(new Runnable() {
                public void run() {
                    ActivityManagerService.this.mContext.startActivityAsUser(intent, userHandle);
                }
            });
            return false;
        }
        Slog.w(TAG, "u" + userId + " Instantiating a provider in package" + cpi.packageName + " requires a permissions review");
        return false;
    }

    PackageManagerInternal getPackageManagerInternalLocked() {
        if (this.mPackageManagerInt == null) {
            this.mPackageManagerInt = (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class);
        }
        return this.mPackageManagerInt;
    }

    public final ContentProviderHolder getContentProvider(IApplicationThread caller, String name, int userId, boolean stable) {
        enforceNotIsolatedCaller("getContentProvider");
        if (caller != null) {
            return getContentProviderImpl(caller, name, null, stable, userId);
        }
        String msg = "null IApplicationThread when getting content provider " + name;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }

    public ContentProviderHolder getContentProviderExternal(String name, int userId, IBinder token) {
        enforceCallingPermission("android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY", "Do not have permission in call getContentProviderExternal()");
        return getContentProviderExternalUnchecked(name, token, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "getContentProvider", null));
    }

    private ContentProviderHolder getContentProviderExternalUnchecked(String name, IBinder token, int userId) {
        return getContentProviderImpl(null, name, token, true, userId);
    }

    public void removeContentProvider(IBinder connection, boolean stable) {
        enforceNotIsolatedCaller("removeContentProvider");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ContentProviderConnection conn = (ContentProviderConnection) connection;
                if (conn == null) {
                    throw new NullPointerException("connection is null");
                }
                if (decProviderCountLocked(conn, null, null, stable)) {
                    updateOomAdjLocked();
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (ClassCastException e) {
            String msg = "removeContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w(TAG, msg);
            throw new IllegalArgumentException(msg);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void removeContentProviderExternal(String name, IBinder token) {
        enforceCallingPermission("android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY", "Do not have permission in call removeContentProviderExternal()");
        int userId = UserHandle.getCallingUserId();
        long ident = Binder.clearCallingIdentity();
        try {
            removeContentProviderExternalUnchecked(name, token, userId);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    /* JADX WARNING: Missing block: B:16:0x0051, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:17:0x0054, code:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void removeContentProviderExternalUnchecked(String name, IBinder token, int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ContentProviderRecord cpr = this.mProviderMap.getProviderByName(name, userId);
                if (cpr != null) {
                    ContentProviderRecord localCpr = this.mProviderMap.getProviderByClass(new ComponentName(cpr.info.packageName, cpr.info.name), userId);
                    if (!localCpr.hasExternalProcessHandles()) {
                        Slog.e(TAG, "Attmpt to remove content provider: " + localCpr + " with no external references.");
                    } else if (localCpr.removeExternalProcessHandleLocked(token)) {
                        updateOomAdjLocked();
                    } else {
                        Slog.e(TAG, "Attmpt to remove content provider " + localCpr + " with no external reference for token: " + token + ".");
                    }
                } else if (ActivityManagerDebugConfig.DEBUG_ALL) {
                    Slog.v(TAG, name + " content provider not found in providers list");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void publishContentProviders(IApplicationThread caller, List<ContentProviderHolder> providers) {
        if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
            Slog.d(TAG_PROVIDER, "publishContentProviders providers " + providers);
        }
        if (providers != null) {
            enforceNotIsolatedCaller("publishContentProviders");
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord r = getRecordForAppLocked(caller);
                    if (ActivityManagerDebugConfig.DEBUG_MU && r != null) {
                        Slog.v(TAG_MU, "ProcessRecord uid = " + r.uid);
                    }
                    if (r == null) {
                        throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when publishing content providers");
                    }
                    long origId = Binder.clearCallingIdentity();
                    int N = providers.size();
                    for (int i = 0; i < N; i++) {
                        ContentProviderHolder src = (ContentProviderHolder) providers.get(i);
                        if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                            Slog.d(TAG_PROVIDER, "src " + src + " src.info " + (src != null ? src.info : null) + " src.provider " + (src != null ? src.provider : null));
                        }
                        if (!(src == null || src.info == null || src.provider == null)) {
                            ContentProviderRecord dst = (ContentProviderRecord) r.pubProviders.get(src.info.name);
                            if (ActivityManagerDebugConfig.DEBUG_MU) {
                                if (dst != null) {
                                    Slog.v(TAG_MU, "ContentProviderRecord uid = " + dst.uid);
                                } else {
                                    Slog.v(TAG_MU, "ContentProviderRecord dst == null");
                                }
                            }
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                Slog.d(TAG_PROVIDER, "ContentProviderRecord " + dst + " src.info " + src.info + " src.info.name " + src.info.name);
                            }
                            if (dst != null) {
                                this.mProviderMap.putProviderByClass(new ComponentName(dst.info.packageName, dst.info.name), dst);
                                String[] names = dst.info.authority.split(";");
                                for (String putProviderByName : names) {
                                    this.mProviderMap.putProviderByName(putProviderByName, dst);
                                }
                                int launchingCount = this.mLaunchingProviders.size();
                                boolean wasInLaunchingProviders = false;
                                int j = 0;
                                while (j < launchingCount) {
                                    if (this.mLaunchingProviders.get(j) == dst) {
                                        this.mLaunchingProviders.remove(j);
                                        wasInLaunchingProviders = true;
                                        j--;
                                        launchingCount--;
                                    }
                                    j++;
                                }
                                if (wasInLaunchingProviders || r.isLaunchingProvider) {
                                    r.isLaunchingProvider = false;
                                    this.mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);
                                }
                                synchronized (dst) {
                                    dst.provider = src.provider;
                                    dst.proc = r;
                                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                        Slog.v(TAG_MU, "dst = " + dst + " dst.proc " + dst.proc + " dst.provider " + dst.provider);
                                    }
                                    dst.notifyAll();
                                }
                                updateOomAdjLocked(r);
                                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority);
                            } else {
                                continue;
                            }
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
        }
    }

    public boolean refContentProvider(IBinder connection, int stable, int unstable) {
        boolean z = false;
        try {
            ContentProviderConnection conn = (ContentProviderConnection) connection;
            if (conn == null) {
                throw new NullPointerException("connection is null");
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (stable > 0) {
                        conn.numStableIncs += stable;
                    }
                    stable += conn.stableCount;
                    if (stable < 0) {
                        throw new IllegalStateException("stableCount < 0: " + stable);
                    }
                    if (unstable > 0) {
                        conn.numUnstableIncs += unstable;
                    }
                    unstable += conn.unstableCount;
                    if (unstable < 0) {
                        throw new IllegalStateException("unstableCount < 0: " + unstable);
                    } else if (stable + unstable <= 0) {
                        throw new IllegalStateException("ref counts can't go to zero here: stable=" + stable + " unstable=" + unstable);
                    } else {
                        conn.stableCount = stable;
                        conn.unstableCount = unstable;
                        if (!conn.dead) {
                            z = true;
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return z;
        } catch (ClassCastException e) {
            String msg = "refContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w(TAG, msg);
            throw new IllegalArgumentException(msg);
        }
    }

    /* JADX WARNING: Missing block: B:38:0x00ad, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:39:0x00b0, code:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void unstableProviderDied(IBinder connection) {
        try {
            IContentProvider provider;
            ContentProviderConnection conn = (ContentProviderConnection) connection;
            if (conn == null) {
                throw new NullPointerException("connection is null");
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    provider = conn.provider.provider;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            if (provider != null) {
                if (provider.asBinder().pingBinder()) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            Slog.w(TAG, "unstableProviderDied: caller " + Binder.getCallingUid() + " says " + conn + " died, but we don't agree");
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                }
                synchronized (this) {
                    long ident;
                    try {
                        boostPriorityForLockedSection();
                        if (conn.provider.provider != provider) {
                            resetPriorityAfterLockedSection();
                            return;
                        }
                        ProcessRecord proc = conn.provider.proc;
                        if (proc == null || proc.thread == null) {
                        } else {
                            Slog.i(TAG, "Process " + proc.processName + " (pid " + proc.pid + ") early provider death");
                            ident = Binder.clearCallingIdentity();
                            appDiedLocked(proc);
                            Binder.restoreCallingIdentity(ident);
                            resetPriorityAfterLockedSection();
                        }
                    } catch (Throwable th) {
                        resetPriorityAfterLockedSection();
                    }
                }
            }
        } catch (ClassCastException e) {
            String msg = "refContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w(TAG, msg);
            throw new IllegalArgumentException(msg);
        }
    }

    public void appNotRespondingViaProvider(IBinder connection) {
        enforceCallingPermission("android.permission.REMOVE_TASKS", "appNotRespondingViaProvider()");
        ContentProviderConnection conn = (ContentProviderConnection) connection;
        if (conn == null) {
            Slog.w(TAG, "ContentProviderConnection is null");
            return;
        }
        final ProcessRecord host = conn.provider.proc;
        if (host == null) {
            Slog.w(TAG, "Failed to find hosting ProcessRecord");
        } else {
            this.mHandler.post(new Runnable() {
                public void run() {
                    ActivityManagerService.this.mAppErrors.appNotResponding(host, null, null, false, "ContentProvider not responding");
                }
            });
        }
    }

    public final void installSystemProviders() {
        List<ProviderInfo> providers;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                providers = generateApplicationProvidersLocked((ProcessRecord) this.mProcessNames.get("system", 1000));
                if (providers != null) {
                    for (int i = providers.size() - 1; i >= 0; i--) {
                        ProviderInfo pi = (ProviderInfo) providers.get(i);
                        if ((pi.applicationInfo.flags & 1) == 0) {
                            Slog.w(TAG, "Not installing system proc provider " + pi.name + ": not system .apk");
                            providers.remove(i);
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (providers != null) {
            this.mSystemThread.installSystemProviders(providers);
        }
        this.mCoreSettingsObserver = new CoreSettingsObserver(this);
        this.mFontScaleSettingObserver = new FontScaleSettingObserver();
    }

    private void startPersistentApps(int matchFlags) {
        if (this.mFactoryTest != 1) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    try {
                        for (ApplicationInfo app : AppGlobals.getPackageManager().getPersistentApplications(matchFlags | 1024).getList()) {
                            if (!"android".equals(app.packageName)) {
                                addAppLocked(app, false, null);
                            }
                        }
                    } catch (RemoteException e) {
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
    }

    private void installEncryptionUnawareProviders(int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                        if (!(app.userId != userId || app.thread == null || app.unlocked)) {
                            int NG = app.pkgList.size();
                            for (int ig = 0; ig < NG; ig++) {
                                try {
                                    PackageInfo pkgInfo = AppGlobals.getPackageManager().getPackageInfo((String) app.pkgList.keyAt(ig), 262152, userId);
                                    if (!(pkgInfo == null || ArrayUtils.isEmpty(pkgInfo.providers))) {
                                        for (ProviderInfo pi : pkgInfo.providers) {
                                            boolean processMatch;
                                            if (Objects.equals(pi.processName, app.processName)) {
                                                processMatch = true;
                                            } else {
                                                processMatch = pi.multiprocess;
                                            }
                                            boolean userMatch = !isSingleton(pi.processName, pi.applicationInfo, pi.name, pi.flags) || app.userId == 0;
                                            if (processMatch && userMatch) {
                                                Log.v(TAG, "Installing " + pi);
                                                app.thread.scheduleInstallProvider(pi);
                                            } else {
                                                Log.v(TAG, "Skipping " + pi);
                                            }
                                        }
                                    }
                                } catch (RemoteException e) {
                                }
                            }
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public String getProviderMimeType(Uri uri, int userId) {
        enforceNotIsolatedCaller("getProviderMimeType");
        String name = uri.getAuthority();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        long ident = 0;
        boolean clearedIdentity = false;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                userId = this.mUserController.unsafeConvertIncomingUserLocked(userId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (canClearIdentity(callingPid, callingUid, userId)) {
            clearedIdentity = true;
            ident = Binder.clearCallingIdentity();
        }
        try {
            ContentProviderHolder holder = getContentProviderExternalUnchecked(name, null, userId);
            if (holder != null) {
                String type = holder.provider.getType(uri);
                if (!clearedIdentity) {
                    ident = Binder.clearCallingIdentity();
                }
                if (holder != null) {
                    try {
                        removeContentProviderExternalUnchecked(name, null, userId);
                    } catch (Throwable th2) {
                        Binder.restoreCallingIdentity(ident);
                        throw th2;
                    }
                }
                Binder.restoreCallingIdentity(ident);
                return type;
            }
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (holder != null) {
                try {
                    removeContentProviderExternalUnchecked(name, null, userId);
                } catch (Throwable th22) {
                    Binder.restoreCallingIdentity(ident);
                    throw th22;
                }
            }
            Binder.restoreCallingIdentity(ident);
            return null;
        } catch (RemoteException e) {
            Log.w(TAG, "Content provider dead retrieving " + uri, e);
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (null != null) {
                removeContentProviderExternalUnchecked(name, null, userId);
            }
            Binder.restoreCallingIdentity(ident);
            return null;
        } catch (Exception e2) {
            Log.w(TAG, "Exception while determining type of " + uri, e2);
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (null != null) {
                removeContentProviderExternalUnchecked(name, null, userId);
            }
            Binder.restoreCallingIdentity(ident);
            return null;
        } catch (Throwable th222) {
            Binder.restoreCallingIdentity(ident);
            throw th222;
        }
    }

    private boolean canClearIdentity(int callingPid, int callingUid, int userId) {
        if (UserHandle.getUserId(callingUid) == userId) {
            return true;
        }
        if (checkComponentPermission("android.permission.INTERACT_ACROSS_USERS", callingPid, callingUid, -1, true) != 0) {
            return checkComponentPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingPid, callingUid, -1, true) == 0;
        }
    }

    final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) {
        String proc = customProcess != null ? customProcess : info.processName;
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        int userId = UserHandle.getUserId(info.uid);
        int uid = info.uid;
        if (isolated) {
            if (isolatedUid == 0) {
                int stepsLeft = 1000;
                do {
                    if (this.mNextIsolatedProcessUid < 99000 || this.mNextIsolatedProcessUid > 99999) {
                        this.mNextIsolatedProcessUid = 99000;
                    }
                    uid = UserHandle.getUid(userId, this.mNextIsolatedProcessUid);
                    this.mNextIsolatedProcessUid++;
                    if (this.mIsolatedProcesses.indexOfKey(uid) >= 0) {
                        stepsLeft--;
                    }
                } while (stepsLeft > 0);
                return null;
            }
            uid = isolatedUid;
            this.mBatteryStatsService.addIsolatedUid(uid, info.uid);
        }
        ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
        if (!this.mBooted && !this.mBooting && userId == 0 && (info.flags & 9) == 9) {
            r.persistent = true;
        } else if ((info.flags & 9) == 9 && KEYGUARD_PROC_NAME.equals(proc) && userId == 0) {
            r.persistent = true;
        }
        addProcessNameLocked(r);
        return r;
    }

    final ProcessRecord addAppLocked(ApplicationInfo info, boolean isolated, String abiOverride) {
        ProcessRecord app;
        if (isolated) {
            app = null;
        } else {
            app = getProcessRecordLocked(info.processName, info.uid, true);
        }
        if (app == null) {
            app = newProcessRecordLocked(info, null, isolated, 0);
            updateLruProcessLocked(app, false, null);
            updateOomAdjLocked();
        }
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(info.packageName, false, UserHandle.getUserId(app.uid));
        } catch (RemoteException e) {
        } catch (IllegalArgumentException e2) {
            Slog.w(TAG, "Failed trying to unstop package " + info.packageName + ": " + e2);
        }
        if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
            PackageStoppedStatusChanged eventData = PackageStoppedStatusChanged.createInstance();
            Object[] objArr = new Object[3];
            objArr[0] = info.packageName;
            objArr[1] = Integer.valueOf(0);
            objArr[2] = "addAppLocked";
            eventData.set(objArr);
            this.mAMEventHook.hook(Event.AM_PackageStoppedStatusChanged, eventData);
        }
        if ((info.flags & 9) == 9) {
            app.persistent = true;
            if ("system".equals(app.processName)) {
                app.maxAdj = -900;
            } else {
                app.maxAdj = -800;
            }
        }
        boolean isImportantPersistProc = isImportantPersistProc(app.processName);
        if (app.thread == null && this.mPersistentStartingProcesses.indexOf(app) < 0) {
            if (isImportantPersistProc) {
                Slog.i(TAG, "addAppLocked will start proc " + app.processName);
            }
            this.mPersistentStartingProcesses.add(app);
            startProcessLocked(app, "added application", app.processName, abiOverride, null, null);
        } else if (isImportantPersistProc) {
            int appIndex = this.mPersistentStartingProcesses.indexOf(app);
            boolean appThreadIsNull = app.thread == null;
            Slog.i(TAG, "addAppLocked, proc " + app.processName + ", appIndex:" + appIndex + ", app.thread is null ? " + appThreadIsNull);
            if (appThreadIsNull && appIndex >= 0) {
                Slog.i(TAG, "addAppLocked, proc " + app.processName + " need to start for attach failed ?");
            }
        }
        return app;
    }

    public void unhandledBack() {
        enforceCallingPermission("android.permission.FORCE_BACK", "unhandledBack()");
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                getFocusedStack().unhandledBackLocked();
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public ParcelFileDescriptor openContentUri(Uri uri) throws RemoteException {
        enforceNotIsolatedCaller("openContentUri");
        int userId = UserHandle.getCallingUserId();
        String name = uri.getAuthority();
        ContentProviderHolder cph = getContentProviderExternalUnchecked(name, null, userId);
        ParcelFileDescriptor pfd = null;
        if (cph != null) {
            Binder token = new Binder();
            sCallerIdentity.set(new Identity(token, Binder.getCallingPid(), Binder.getCallingUid()));
            try {
                pfd = cph.provider.openFile(null, uri, "r", null, token);
            } catch (FileNotFoundException e) {
            } finally {
                sCallerIdentity.remove();
                removeContentProviderExternalUnchecked(name, null, userId);
            }
        } else {
            Slog.d(TAG, "Failed to get provider for authority '" + name + "'");
        }
        return pfd;
    }

    boolean isSleepingOrShuttingDownLocked() {
        return !isSleepingLocked() ? this.mShuttingDown : true;
    }

    boolean isShuttingDownLocked() {
        return this.mShuttingDown;
    }

    boolean isSleepingLocked() {
        return this.mSleeping;
    }

    void onWakefulnessChanged(int wakefulness) {
        if (ActivityManagerDebugConfig.DEBUG_PAUSE || DEBUG_COLOROS_AMS) {
            Slog.d(TAG, "onWakefulnessChanged: wake = " + wakefulness);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                    WakefulnessChanged eventData = WakefulnessChanged.createInstance();
                    Object[] objArr = new Object[1];
                    objArr[0] = Integer.valueOf(wakefulness);
                    eventData.set(objArr);
                    this.mAMEventHook.hook(Event.AM_WakefulnessChanged, eventData);
                }
                this.mWakefulness = wakefulness;
                updateSleepIfNeededLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void finishRunningVoiceLocked() {
        if (this.mRunningVoice != null) {
            this.mRunningVoice = null;
            this.mVoiceWakeLock.release();
            updateSleepIfNeededLocked();
        }
    }

    void startTimeTrackingFocusedActivityLocked() {
        if (!this.mSleeping && this.mCurAppTimeTracker != null && this.mFocusedActivity != null) {
            this.mCurAppTimeTracker.start(this.mFocusedActivity.packageName);
        }
    }

    void updateSleepIfNeededLocked() {
        boolean sleeping = this.mSleeping;
        if (this.mSleeping && !shouldSleepLocked()) {
            if (ActivityManagerDebugConfig.DEBUG_PAUSE || DEBUG_COLOROS_AMS) {
                Slog.d(TAG, "updateSleepIfNeededLocked: comeOutOfSleep");
            }
            this.mSleeping = false;
            startTimeTrackingFocusedActivityLocked();
            this.mTopProcessState = 2;
            this.mStackSupervisor.comeOutOfSleepIfNeededLocked();
            updateOomAdjLocked();
        } else if (!this.mSleeping && shouldSleepLocked()) {
            if (ActivityManagerDebugConfig.DEBUG_PAUSE || DEBUG_COLOROS_AMS) {
                Slog.d(TAG, "updateSleepIfNeededLocked: goingToSleep");
            }
            this.mSleeping = true;
            if (this.mCurAppTimeTracker != null) {
                this.mCurAppTimeTracker.stop();
            }
            this.mTopProcessState = 5;
            this.mStackSupervisor.goingToSleepLocked();
            updateOomAdjLocked();
            this.mHandler.removeMessages(401);
            this.mHandler.sendMessage(this.mHandler.obtainMessage(401));
            this.mHandler.removeMessages(27);
            this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(27), (long) POWER_CHECK_DELAY);
        }
        UpdateSleep eventData = UpdateSleep.createInstance();
        Object[] objArr = new Object[2];
        objArr[0] = Boolean.valueOf(sleeping);
        objArr[1] = Boolean.valueOf(this.mSleeping);
        eventData.set(objArr);
        this.mAMEventHook.hook(Event.AM_UpdateSleep, eventData);
    }

    private boolean shouldSleepLocked() {
        boolean z = true;
        if (this.mRunningVoice != null) {
            return false;
        }
        switch (this.mWakefulness) {
            case 1:
            case 2:
                if (!(!ActivityManagerDebugConfig.DEBUG_PAUSE || this.mSleeping || this.mLockScreenShown == 0)) {
                    Slog.d(TAG, "shouldSleepLocked: skip keyguard show check");
                }
                if (this.mFocusedActivity != null && this.mActivitiesResumeBehindKeyguardList.contains(this.mFocusedActivity.shortComponentName) && this.mIgnoreSleepCheckLater) {
                    if ((!this.mSleeping || this.mLockScreenShown == 0) && this.mSleepTokens.isEmpty()) {
                        z = false;
                    }
                    return z;
                }
            case 3:
                break;
            default:
                return true;
        }
        if (this.mLockScreenShown == 0 && this.mSleepTokens.isEmpty()) {
            z = false;
        }
        return z;
    }

    void notifyTaskPersisterLocked(TaskRecord task, boolean flush) {
        this.mRecentTasks.notifyTaskPersisterLocked(task, flush);
    }

    void notifyTaskStackChangedLocked() {
        this.mHandler.sendEmptyMessage(LOG_STACK_STATE);
        this.mHandler.removeMessages(49);
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(49), 100);
    }

    void notifyActivityPinnedLocked() {
        this.mHandler.removeMessages(64);
        this.mHandler.obtainMessage(64).sendToTarget();
    }

    void notifyPinnedActivityRestartAttemptLocked() {
        this.mHandler.removeMessages(65);
        this.mHandler.obtainMessage(65).sendToTarget();
    }

    public void notifyPinnedStackAnimationEnded() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mHandler.removeMessages(66);
                this.mHandler.obtainMessage(66).sendToTarget();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void notifyCleartextNetwork(int uid, byte[] firstPacket) {
        this.mHandler.obtainMessage(50, uid, 0, firstPacket).sendToTarget();
    }

    public boolean shutdown(int timeout) {
        if (checkCallingPermission("android.permission.SHUTDOWN") != 0) {
            throw new SecurityException("Requires permission android.permission.SHUTDOWN");
        }
        boolean timedout = false;
        OppoJunkRecorder.getInstance().forcePersist(System.currentTimeMillis());
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mShuttingDown = true;
                updateEventDispatchingLocked();
                timedout = this.mStackSupervisor.shutdownLocked(timeout);
                this.mAppOpsService.shutdown();
                if (this.mUsageStatsService != null) {
                    this.mUsageStatsService.prepareShutdown();
                }
                this.mBatteryStatsService.shutdown();
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        this.mProcessStats.shutdownLocked();
                        notifyTaskPersisterLocked(null, true);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                return timedout;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return timedout;
    }

    public final void activitySlept(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_ALL) {
            Slog.v(TAG, "Activity slept: token=" + token);
        }
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    this.mStackSupervisor.activitySleptLocked(r);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    private String lockScreenShownToString() {
        switch (this.mLockScreenShown) {
            case 0:
                return "LOCK_SCREEN_HIDDEN";
            case 1:
                return "LOCK_SCREEN_LEAVING";
            case 2:
                return "LOCK_SCREEN_SHOWN";
            default:
                return "Unknown=" + this.mLockScreenShown;
        }
    }

    void logLockScreen(String msg) {
        if (ActivityManagerDebugConfig.DEBUG_LOCKSCREEN) {
            Slog.d(TAG_LOCKSCREEN, Debug.getCallers(2) + ":" + msg + " mLockScreenShown=" + lockScreenShownToString() + " mWakefulness=" + PowerManagerInternal.wakefulnessToString(this.mWakefulness) + " mSleeping=" + this.mSleeping);
        }
    }

    void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {
        Slog.d(TAG, "<<<  startRunningVoiceLocked()");
        this.mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
        if (this.mRunningVoice == null || this.mRunningVoice.asBinder() != session.asBinder()) {
            boolean wasRunningVoice = this.mRunningVoice != null;
            this.mRunningVoice = session;
            if (!wasRunningVoice) {
                this.mVoiceWakeLock.acquire();
                updateSleepIfNeededLocked();
            }
        }
    }

    private void updateEventDispatchingLocked() {
        boolean z = false;
        WindowManagerService windowManagerService = this.mWindowManager;
        if (this.mBooted && !this.mShuttingDown) {
            z = true;
        }
        windowManagerService.setEventDispatching(z);
    }

    public void setLockScreenShown(boolean showing, boolean occluded) {
        boolean z = false;
        if (checkCallingPermission("android.permission.DEVICE_POWER") != 0) {
            throw new SecurityException("Requires permission android.permission.DEVICE_POWER");
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_LOCKSCREEN) {
                    logLockScreen(" showing=" + showing + " occluded=" + occluded);
                }
                int i = (!showing || occluded) ? 0 : 2;
                this.mLockScreenShown = i;
                if (showing && occluded) {
                    ActivityStackSupervisor activityStackSupervisor = this.mStackSupervisor;
                    if (this.mStackSupervisor.mFocusedStack.getStackId() == 3) {
                        z = true;
                    }
                    activityStackSupervisor.moveTasksToFullscreenStackLocked(3, z);
                }
                updateSleepIfNeededLocked();
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void notifyLockedProfile(int userId) {
        try {
            if (AppGlobals.getPackageManager().isUidPrivileged(Binder.getCallingUid())) {
                synchronized (this) {
                    long ident;
                    try {
                        boostPriorityForLockedSection();
                        if (this.mStackSupervisor.isUserLockedProfile(userId)) {
                            ident = Binder.clearCallingIdentity();
                            int currentUserId = this.mUserController.getCurrentUserIdLocked();
                            this.mStackSupervisor.moveProfileTasksFromFreeformToFullscreenStackLocked(userId);
                            if (this.mUserController.isLockScreenDisabled(currentUserId)) {
                                this.mActivityStarter.showConfirmDeviceCredential(userId);
                            } else {
                                startHomeActivityLocked(currentUserId, "notifyLockedProfile");
                            }
                            Binder.restoreCallingIdentity(ident);
                        }
                    } catch (Throwable th) {
                        resetPriorityAfterLockedSection();
                    }
                }
                resetPriorityAfterLockedSection();
                return;
            }
            throw new SecurityException("Only privileged app can call notifyLockedProfile");
        } catch (RemoteException ex) {
            throw new SecurityException("Fail to check is caller a privileged app", ex);
        }
    }

    public void startConfirmDeviceCredentialIntent(Intent intent) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "startConfirmDeviceCredentialIntent");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                this.mActivityStarter.startConfirmCredentialIntent(intent);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void stopAppSwitches() {
        if (checkCallingPermission("android.permission.STOP_APP_SWITCHES") != 0) {
            throw new SecurityException("viewquires permission android.permission.STOP_APP_SWITCHES");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + 5000;
                this.mDidAppSwitch = false;
                this.mHandler.removeMessages(21);
                this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(21), 5000);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void resumeAppSwitches() {
        if (checkCallingPermission("android.permission.STOP_APP_SWITCHES") != 0) {
            throw new SecurityException("Requires permission android.permission.STOP_APP_SWITCHES");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppSwitchesAllowedTime = 0;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid, int callingPid, int callingUid, String name) {
        if (this.mAppSwitchesAllowedTime < SystemClock.uptimeMillis()) {
            return true;
        }
        if (checkComponentPermission("android.permission.STOP_APP_SWITCHES", sourcePid, sourceUid, -1, true) == 0) {
            return true;
        }
        if (!(callingUid == -1 || callingUid == sourceUid)) {
            if (checkComponentPermission("android.permission.STOP_APP_SWITCHES", callingPid, callingUid, -1, true) == 0) {
                return true;
            }
        }
        Slog.w(TAG, name + " request from " + sourceUid + " stopped");
        return false;
    }

    public void setDebugApp(String packageName, boolean waitForDebugger, boolean persistent) {
        enforceCallingPermission("android.permission.SET_DEBUG_APP", "setDebugApp()");
        long ident = Binder.clearCallingIdentity();
        if (persistent) {
            try {
                ContentResolver resolver = this.mContext.getContentResolver();
                Global.putString(resolver, "debug_app", packageName);
                Global.putInt(resolver, "wait_for_debugger", waitForDebugger ? 1 : 0);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(ident);
            }
        }
        synchronized (this) {
            boostPriorityForLockedSection();
            if (!persistent) {
                this.mOrigDebugApp = this.mDebugApp;
                this.mOrigWaitForDebugger = this.mWaitForDebugger;
            }
            this.mDebugApp = packageName;
            this.mWaitForDebugger = waitForDebugger;
            this.mDebugTransient = !persistent;
            if (packageName != null) {
                forceStopPackageLocked(packageName, -1, false, false, true, true, false, -1, "set debug app");
            }
        }
        resetPriorityAfterLockedSection();
        Binder.restoreCallingIdentity(ident);
    }

    void setTrackAllocationApp(ApplicationInfo app, String processName) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (app.flags & 2) != 0) {
                    this.mTrackAllocationApp = processName;
                } else {
                    throw new SecurityException("Process not debuggable: " + app.packageName);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void setProfileApp(ApplicationInfo app, String processName, ProfilerInfo profilerInfo) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (app.flags & 2) != 0) {
                    this.mProfileApp = processName;
                    this.mProfileFile = profilerInfo.profileFile;
                    if (this.mProfileFd != null) {
                        try {
                            this.mProfileFd.close();
                        } catch (IOException e) {
                        }
                        this.mProfileFd = null;
                    }
                    this.mProfileFd = profilerInfo.profileFd;
                    this.mSamplingInterval = profilerInfo.samplingInterval;
                    this.mAutoStopProfiler = profilerInfo.autoStopProfiler;
                    this.mProfileType = 0;
                } else {
                    throw new SecurityException("Process not debuggable: " + app.packageName);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void setNativeDebuggingAppLocked(ApplicationInfo app, String processName) {
        if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (app.flags & 2) != 0) {
            this.mNativeDebuggingApp = processName;
            return;
        }
        throw new SecurityException("Process not debuggable: " + app.packageName);
    }

    public void setAlwaysFinish(boolean enabled) {
        enforceCallingPermission("android.permission.SET_ALWAYS_FINISH", "setAlwaysFinish()");
        long ident = Binder.clearCallingIdentity();
        try {
            Global.putInt(this.mContext.getContentResolver(), "always_finish_activities", enabled ? 1 : 0);
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mAlwaysFinishActivities = enabled;
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void setLenientBackgroundCheck(boolean enabled) {
        enforceCallingPermission("android.permission.SET_PROCESS_LIMIT", "setLenientBackgroundCheck()");
        long ident = Binder.clearCallingIdentity();
        try {
            Global.putInt(this.mContext.getContentResolver(), "lenient_background_check", enabled ? 1 : 0);
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mLenientBackgroundCheck = enabled;
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for secure protect", property = OppoRomType.ROM)
    public void setActivityController(IActivityController controller, boolean imAMonkey) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "setActivityController()");
        if (SystemProperties.getBoolean("oppo.app.secure.enable", false)) {
            Slog.i(TAG, "can't setActivityController because safe");
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                OppoSecureProtectUtils.setMonkeyControllerLocked(this, controller);
                this.mControllerIsAMonkey = imAMonkey;
                if (this.mOppoActivityControlerScheduler != null) {
                    this.mOppoActivityControlerScheduler.exitRunningScheduler();
                }
                if (this.mController != null) {
                    this.mOppoActivityControlerScheduler = new OppoActivityControlerScheduler(this.mController);
                } else {
                    this.mOppoActivityControlerScheduler = null;
                }
                Watchdog.getInstance().setActivityController(controller);
                if (controller == null) {
                    OppoSecureProtectUtils.nofityMonkeyFinish(this);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setOppoKinectActivityController(IOppoKinectActivityController controller) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "setActivityController()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mOppoKinectController = controller;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setUserIsMonkey(boolean userIsMonkey) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int callingPid = Binder.getCallingPid();
                    ProcessRecord precessRecord = (ProcessRecord) this.mPidsSelfLocked.get(callingPid);
                    if (precessRecord == null) {
                        throw new SecurityException("Unknown process: " + callingPid);
                    } else if (precessRecord.instrumentationUiAutomationConnection == null) {
                        throw new SecurityException("Only an instrumentation process with a UiAutomation can call setUserIsMonkey");
                    }
                }
                this.mUserIsMonkey = userIsMonkey;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for secure protect", property = OppoRomType.ROM)
    public boolean isUserAMonkey() {
        boolean isMonkeyController;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                isMonkeyController = !this.mUserIsMonkey ? this.mController != null ? OppoSecureProtectUtils.isMonkeyController(this) : false : true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return isMonkeyController;
    }

    public void requestBugReport(int bugreportType) {
        String service = null;
        switch (bugreportType) {
            case 0:
                service = "bugreport";
                break;
            case 1:
                service = "bugreportplus";
                break;
            case 2:
                service = "bugreportremote";
                break;
            case 3:
                service = "bugreportwear";
                break;
        }
        if (service == null) {
            throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
        }
        enforceCallingPermission("android.permission.DUMP", "requestBugReport");
        SystemProperties.set("ctl.start", service);
    }

    public static long getInputDispatchingTimeoutLocked(ActivityRecord r) {
        return r != null ? getInputDispatchingTimeoutLocked(r.app) : 8000;
    }

    public static long getInputDispatchingTimeoutLocked(ProcessRecord r) {
        if (r == null || (r.instrumentationClass == null && !r.usingWrapper)) {
            return 8000;
        }
        return 60000;
    }

    /* JADX WARNING: Missing block: B:26:0x003d, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:27:0x0048, code:
            if (inputDispatchingTimedOut(r1, null, null, r10, r11) != false) goto L_0x004d;
     */
    /* JADX WARNING: Missing block: B:29:0x004c, code:
            return -1;
     */
    /* JADX WARNING: Missing block: B:30:0x004d, code:
            return r6;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "liumei@Plf.Framework, 2013/10/23: Add for permission intercept", property = OppoRomType.ROM)
    public long inputDispatchingTimedOut(int pid, boolean aboveSystem, String reason) {
        long j = null;
        if (checkCallingPermission("android.permission.FILTER_EVENTS") != 0) {
            throw new SecurityException("Requires permission android.permission.FILTER_EVENTS");
        }
        synchronized (this) {
            try {
                ProcessRecord proc;
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                }
                if (proc.isWaitingPermissionChoice) {
                    j = 60000;
                } else {
                    long timeout = getInputDispatchingTimeoutLocked(proc);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return j;
    }

    /* JADX WARNING: Missing block: B:51:0x00ee, code:
            resetPriorityAfterLockedSection();
            android.util.Slog.d(TAG, " ANR post Runnable for " + r15 + " to deal with anr happend at " + r12);
            android.util.Slog.d(TAG, " ANR caller(2) = " + android.os.Debug.getCallers(8));
            r4 = r15;
            r5 = r16;
            r6 = r17;
            r7 = r18;
            r14.mHandler.post(new com.android.server.am.ActivityManagerService.AnonymousClass19(r14));
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean inputDispatchingTimedOut(ProcessRecord proc, ActivityRecord activity, ActivityRecord parent, boolean aboveSystem, String reason) {
        int currentPid;
        if (checkCallingPermission("android.permission.FILTER_EVENTS") != 0) {
            throw new SecurityException("Requires permission android.permission.FILTER_EVENTS");
        }
        String separator = "@#@";
        currentPid = -1;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (proc != null) {
                    currentPid = proc.pid;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        String annotation;
        String suffix = SystemClock.uptimeMillis() + "@#@" + currentPid;
        if (reason == null) {
            annotation = "Input dispatching timed out, happend at time " + suffix;
        } else {
            annotation = "Input dispatching timed out (" + reason + "), happend at time = " + suffix;
        }
        if (proc != null) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (!proc.debugging) {
                        if (mANRManager.isAnrDeferrable()) {
                            Slog.i(TAG, "Skipping keyDispatchingTimedOut ANR: " + proc);
                            this.mDidDexOpt = true;
                        }
                        if (this.mDidDexOpt) {
                            this.mDidDexOpt = false;
                            resetPriorityAfterLockedSection();
                            return false;
                        } else if (isDoingDexopt(proc.uid)) {
                            resetPriorityAfterLockedSection();
                            return false;
                        } else if (proc.instrumentationClass != null) {
                            Bundle info = new Bundle();
                            info.putString("shortMsg", "keyDispatchingTimedOut");
                            info.putString("longMsg", annotation);
                            finishInstrumentationLocked(proc, 0, info);
                            resetPriorityAfterLockedSection();
                            return true;
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        return true;
        return false;
    }

    public Bundle getAssistContextExtras(int requestType) {
        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null, null, null, true, true, UserHandle.getCallingUserId(), null, 500);
        if (pae == null) {
            return null;
        }
        synchronized (pae) {
            while (!pae.haveResult) {
                try {
                    pae.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                buildAssistBundleLocked(pae, pae.result);
                this.mPendingAssistExtras.remove(pae);
                this.mUiHandler.removeCallbacks(pae);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return pae.extras;
    }

    /* JADX WARNING: Missing block: B:10:0x001f, code:
            resetPriorityAfterLockedSection();
            r1 = (android.app.admin.DevicePolicyManager) r8.mContext.getSystemService("device_policy");
     */
    /* JADX WARNING: Missing block: B:11:0x002d, code:
            if (r1 == null) goto L_0x0036;
     */
    /* JADX WARNING: Missing block: B:13:0x0033, code:
            if (r1.getScreenCaptureDisabled(null, r2) == false) goto L_0x0036;
     */
    /* JADX WARNING: Missing block: B:14:0x0035, code:
            r3 = false;
     */
    /* JADX WARNING: Missing block: B:15:0x0036, code:
            return r3;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isAssistDataAllowedOnCurrentActivity() {
        boolean z = true;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int userId = this.mUserController.getCurrentUserIdLocked();
                ActivityRecord activity = getFocusedStack().topActivity();
                if (activity == null) {
                } else {
                    userId = activity.userId;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    public boolean showAssistFromActivity(IBinder token, Bundle args) {
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord caller = ActivityRecord.forTokenLocked(token);
                ActivityRecord top = getFocusedStack().topActivity();
                if (top != caller) {
                    Slog.w(TAG, "showAssistFromActivity failed: caller " + caller + " is not current top " + top);
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return false;
                } else if (top.nowVisible) {
                    resetPriorityAfterLockedSection();
                    boolean showSessionForActiveService = new AssistUtils(this.mContext).showSessionForActiveService(args, 8, null, token);
                    Binder.restoreCallingIdentity(ident);
                    return showSessionForActiveService;
                } else {
                    Slog.w(TAG, "showAssistFromActivity failed: caller " + caller + " is not visible");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return false;
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public boolean requestAssistContextExtras(int requestType, IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId) {
        return enqueueAssistContext(requestType, null, null, receiver, receiverExtras, activityToken, focused, newSessionId, UserHandle.getCallingUserId(), null, 2000) != null;
    }

    private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint, IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId, int userHandle, Bundle args, long timeout) {
        PendingAssistExtras pendingAssistExtras;
        PendingAssistExtras pae;
        enforceCallingPermission("android.permission.GET_TOP_ACTIVITY_INFO", "enqueueAssistContext()");
        synchronized (this) {
            ActivityRecord activity;
            try {
                boostPriorityForLockedSection();
                activity = getFocusedStack().topActivity();
                if (activity == null) {
                    Slog.w(TAG, "getAssistContextExtras failed: no top activity");
                    pendingAssistExtras = null;
                } else if (activity.app == null || activity.app.thread == null) {
                    Slog.w(TAG, "getAssistContextExtras failed: no process for " + activity);
                    resetPriorityAfterLockedSection();
                    return null;
                } else {
                    if (!focused) {
                        activity = ActivityRecord.forTokenLocked(activityToken);
                        if (activity == null) {
                            Slog.w(TAG, "enqueueAssistContext failed: activity for token=" + activityToken + " couldn't be found");
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    } else if (activityToken != null) {
                        ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);
                        if (activity != caller) {
                            Slog.w(TAG, "enqueueAssistContext failed: caller " + caller + " is not current top " + activity);
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    }
                    Bundle extras = new Bundle();
                    if (args != null) {
                        extras.putAll(args);
                    }
                    extras.putString("android.intent.extra.ASSIST_PACKAGE", activity.packageName);
                    extras.putInt("android.intent.extra.ASSIST_UID", activity.app.uid);
                    pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, receiverExtras, userHandle);
                    if (newSessionId) {
                        this.mViSessionId++;
                    }
                    activity.app.thread.requestAssistContextExtras(activity.appToken, pae, requestType, this.mViSessionId);
                    this.mPendingAssistExtras.add(pae);
                    pendingAssistExtras = this.mUiHandler;
                    pendingAssistExtras.postDelayed(pae, timeout);
                }
            } catch (RemoteException e) {
                Slog.w(TAG, "getAssistContextExtras failed: crash calling " + activity);
                pendingAssistExtras = null;
                return pendingAssistExtras;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return pae;
        return pendingAssistExtras;
    }

    void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {
        IResultReceiver receiver;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mPendingAssistExtras.remove(pae);
                receiver = pae.receiver;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (receiver != null) {
            Bundle sendBundle = new Bundle();
            sendBundle.putBundle("receiverExtras", pae.receiverExtras);
            try {
                pae.receiver.send(0, sendBundle);
            } catch (RemoteException e) {
            }
        }
    }

    private void buildAssistBundleLocked(PendingAssistExtras pae, Bundle result) {
        if (result != null) {
            pae.extras.putBundle("android.intent.extra.ASSIST_CONTEXT", result);
        }
        if (pae.hint != null) {
            pae.extras.putBoolean(pae.hint, true);
        }
    }

    /* JADX WARNING: Missing block: B:13:0x002e, code:
            r8 = null;
     */
    /* JADX WARNING: Missing block: B:14:0x0030, code:
            monitor-enter(r15);
     */
    /* JADX WARNING: Missing block: B:16:?, code:
            boostPriorityForLockedSection();
            buildAssistBundleLocked(r5, r17);
            r4 = r15.mPendingAssistExtras.remove(r5);
            r15.mUiHandler.removeCallbacks(r5);
     */
    /* JADX WARNING: Missing block: B:17:0x0044, code:
            if (r4 != false) goto L_0x004e;
     */
    /* JADX WARNING: Missing block: B:18:0x0046, code:
            monitor-exit(r15);
     */
    /* JADX WARNING: Missing block: B:19:0x0047, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:20:0x004a, code:
            return;
     */
    /* JADX WARNING: Missing block: B:25:?, code:
            r10 = r5.receiver;
     */
    /* JADX WARNING: Missing block: B:26:0x0050, code:
            if (r10 == null) goto L_0x0078;
     */
    /* JADX WARNING: Missing block: B:27:0x0052, code:
            r9 = new android.os.Bundle();
     */
    /* JADX WARNING: Missing block: B:29:?, code:
            r9.putBundle("data", r5.extras);
            r9.putParcelable("structure", r5.structure);
            r9.putParcelable("content", r5.content);
            r9.putBundle("receiverExtras", r5.receiverExtras);
     */
    /* JADX WARNING: Missing block: B:30:0x0077, code:
            r8 = r9;
     */
    /* JADX WARNING: Missing block: B:31:0x0078, code:
            monitor-exit(r15);
     */
    /* JADX WARNING: Missing block: B:32:0x0079, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:33:0x007c, code:
            if (r10 == null) goto L_0x008b;
     */
    /* JADX WARNING: Missing block: B:36:?, code:
            r10.send(0, r8);
     */
    /* JADX WARNING: Missing block: B:38:0x0083, code:
            r11 = th;
     */
    /* JADX WARNING: Missing block: B:39:0x0084, code:
            monitor-exit(r15);
     */
    /* JADX WARNING: Missing block: B:40:0x0085, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:41:0x0088, code:
            throw r11;
     */
    /* JADX WARNING: Missing block: B:43:0x008b, code:
            r6 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Missing block: B:45:?, code:
            r5.intent.replaceExtras(r5.extras);
            r5.intent.setFlags(872415232);
            closeSystemDialogs(com.android.server.policy.PhoneWindowManager.SYSTEM_DIALOG_REASON_ASSIST);
     */
    /* JADX WARNING: Missing block: B:47:?, code:
            r15.mContext.startActivityAsUser(r5.intent, new android.os.UserHandle(r5.userHandle));
     */
    /* JADX WARNING: Missing block: B:50:0x00b5, code:
            r2 = move-exception;
     */
    /* JADX WARNING: Missing block: B:52:?, code:
            android.util.Slog.w(TAG, "No activity to handle assist action.", r2);
     */
    /* JADX WARNING: Missing block: B:54:0x00c0, code:
            android.os.Binder.restoreCallingIdentity(r6);
     */
    /* JADX WARNING: Missing block: B:56:0x00c4, code:
            r11 = th;
     */
    /* JADX WARNING: Missing block: B:57:0x00c5, code:
            r8 = r9;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void reportAssistContextExtras(IBinder token, Bundle extras, AssistStructure structure, AssistContent content, Uri referrer) {
        PendingAssistExtras pae = (PendingAssistExtras) token;
        synchronized (pae) {
            pae.result = extras;
            pae.structure = structure;
            pae.content = content;
            if (referrer != null) {
                pae.extras.putParcelable("android.intent.extra.REFERRER", referrer);
            }
            pae.haveResult = true;
            pae.notifyAll();
            if (pae.intent == null && pae.receiver == null) {
                return;
            }
        }
        Binder.restoreCallingIdentity(ident);
    }

    public boolean launchAssistIntent(Intent intent, int requestType, String hint, int userHandle, Bundle args) {
        return enqueueAssistContext(requestType, intent, hint, null, null, null, true, true, userHandle, args, 500) != null;
    }

    public void registerProcessObserver(IProcessObserver observer) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "registerProcessObserver()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mProcessObservers.register(observer);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void unregisterProcessObserver(IProcessObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mProcessObservers.unregister(observer);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void registerUidObserver(IUidObserver observer, int which) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "registerUidObserver()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mUidObservers.register(observer, Integer.valueOf(which));
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void unregisterUidObserver(IUidObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mUidObservers.unregister(observer);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean convertFromTranslucent(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null || "com.netease.cloudmusic/.activity.LockScreenActivity".equals(r.shortComponentName)) {
                    if (ActivityManagerDebugConfig.DEBUG_AMS || ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
                        Slog.w(TAG, "convertFromTranslucent return false,r " + r);
                    }
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
                boolean translucentChanged = r.changeWindowTranslucency(true);
                if (translucentChanged) {
                    r.task.stack.releaseBackgroundResources(r);
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                }
                this.mWindowManager.setAppFullscreen(token, true);
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return translucentChanged;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean convertToTranslucent(IBinder token, ActivityOptions options) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
                int index = r.task.mActivities.lastIndexOf(r);
                if (index > 0) {
                    ((ActivityRecord) r.task.mActivities.get(index - 1)).returningOptions = options;
                }
                boolean translucentChanged = r.changeWindowTranslucency(false);
                if (translucentChanged) {
                    r.task.stack.convertActivityToTranslucent(r);
                }
                this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                this.mWindowManager.setAppFullscreen(token, false);
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return translucentChanged;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean requestVisibleBehind(IBinder token, boolean visible) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    boolean requestVisibleBehindLocked = this.mStackSupervisor.requestVisibleBehindLocked(r, visible);
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return requestVisibleBehindLocked;
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return false;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean isBackgroundVisibleBehind(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            boolean visible;
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                visible = stack == null ? false : stack.hasVisibleBehindActivity();
                if (ActivityManagerDebugConfig.DEBUG_VISIBLE_BEHIND) {
                    Slog.d(TAG_VISIBLE_BEHIND, "isBackgroundVisibleBehind: stack=" + stack + " visible=" + visible);
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(origId);
            return visible;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public ActivityOptions getActivityOptions(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    ActivityOptions activityOptions = r.pendingOptions;
                    r.pendingOptions = null;
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return activityOptions;
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return null;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void setImmersive(IBinder token, boolean immersive) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                r.immersive = immersive;
                if (r == this.mFocusedActivity) {
                    if (ActivityManagerDebugConfig.DEBUG_IMMERSIVE) {
                        Slog.d(TAG_IMMERSIVE, "Frontmost changed immersion: " + r);
                    }
                    applyUpdateLockStateLocked(r);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean isImmersive(IBinder token) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                z = r.immersive;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    public void setVrThread(int tid) {
        if (this.mContext.getPackageManager().hasSystemFeature("android.software.vr.mode")) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    synchronized (this.mPidsSelfLocked) {
                        int pid = Binder.getCallingPid();
                        ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                        if (proc != null && this.mInVrMode && tid >= 0) {
                            if (Process.isThreadInProcess(pid, tid)) {
                                if (proc.vrThreadTid != 0 && Process.isThreadInProcess(pid, proc.vrThreadTid)) {
                                    try {
                                        Process.setThreadScheduler(proc.vrThreadTid, 0, 0);
                                    } catch (IllegalArgumentException e) {
                                    }
                                }
                                proc.vrThreadTid = tid;
                                try {
                                    if (proc.curSchedGroup == 2 && proc.vrThreadTid > 0) {
                                        Process.setThreadScheduler(proc.vrThreadTid, 1073741825, 1);
                                    }
                                } catch (IllegalArgumentException e2) {
                                    Slog.e(TAG, "Failed to set scheduling policy, thread does not exist:\n" + e2);
                                }
                            } else {
                                throw new IllegalArgumentException("VR thread does not belong to process");
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new UnsupportedOperationException("VR mode not supported on this device!");
    }

    public void setRenderThread(int tid) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int pid = Binder.getCallingPid();
                    ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                    if (proc == null || proc.renderThreadTid != 0 || tid <= 0) {
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            Slog.d("UI_FIFO", "Didn't set thread from setRenderThread? PID: " + pid + ", TID: " + tid + " FIFO: " + this.mUseFifoUiScheduling);
                        }
                    } else if (Process.isThreadInProcess(pid, tid)) {
                        proc.renderThreadTid = tid;
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            Slog.d("UI_FIFO", "Set RenderThread tid " + tid + " for pid " + pid);
                        }
                        if (proc.curSchedGroup == 2) {
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.d("UI_FIFO", "Promoting " + tid + "out of band");
                            }
                            if (this.mUseFifoUiScheduling) {
                                Process.setThreadScheduler(proc.renderThreadTid, 1073741825, 1);
                            } else {
                                Process.setThreadPriority(proc.renderThreadTid, -10);
                            }
                        }
                    } else {
                        throw new IllegalArgumentException("Render thread does not belong to process");
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int setVrMode(IBinder token, boolean enabled, ComponentName packageName) {
        if (this.mContext.getPackageManager().hasSystemFeature("android.software.vr.mode")) {
            VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.isInStackLocked(token);
                    if (r == null) {
                        throw new IllegalArgumentException();
                    }
                    int err = vrService.hasVrPackage(packageName, r.userId);
                    if (err != 0) {
                        return err;
                    }
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            if (!enabled) {
                                packageName = null;
                            }
                            r.requestedVrComponent = packageName;
                            if (r == this.mFocusedActivity) {
                                applyUpdateVrModeLocked(r);
                            }
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    return 0;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return 0;
        }
        throw new UnsupportedOperationException("VR mode not supported on this device!");
    }

    public boolean isVrModePackageEnabled(ComponentName packageName) {
        if (!this.mContext.getPackageManager().hasSystemFeature("android.software.vr.mode")) {
            throw new UnsupportedOperationException("VR mode not supported on this device!");
        } else if (((VrManagerInternal) LocalServices.getService(VrManagerInternal.class)).hasVrPackage(packageName, UserHandle.getCallingUserId()) == 0) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isTopActivityImmersive() {
        boolean z;
        enforceNotIsolatedCaller("startActivity");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getFocusedStack().topRunningActivityLocked();
                z = r != null ? r.immersive : false;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    public boolean isTopOfTask(IBinder token) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                if (r.task.getTopActivity() == r) {
                    z = true;
                } else {
                    z = false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    /* JADX WARNING: Missing block: B:18:0x0081, code:
            android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Missing block: B:19:0x0084, code:
            return;
     */
    /* JADX WARNING: Missing block: B:27:0x00b1, code:
            if (r0 == false) goto L_0x00b6;
     */
    /* JADX WARNING: Missing block: B:28:0x00b3, code:
            updateOomAdjLocked(r5);
     */
    /* JADX WARNING: Missing block: B:31:0x00b7, code:
            resetPriorityAfterLockedSection();
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void setHasTopUi(boolean hasTopUi) throws RemoteException {
        if (checkCallingPermission("android.permission.INTERNAL_SYSTEM_WINDOW") != 0) {
            String msg = "Permission Denial: setHasTopUi() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.INTERNAL_SYSTEM_WINDOW";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        int pid = Binder.getCallingPid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    boolean changed = false;
                    synchronized (this.mPidsSelfLocked) {
                        ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                        if (pr == null) {
                            Slog.w(TAG, "setHasTopUi called on unknown pid: " + pid);
                        } else if (pr.hasTopUi != hasTopUi) {
                            Slog.i(TAG, "Setting hasTopUi=" + hasTopUi + " for pid=" + pid);
                            pr.hasTopUi = hasTopUi;
                            changed = true;
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public final void enterSafeMode() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mSystemReady) {
                    try {
                        AppGlobals.getPackageManager().enterSafeMode();
                    } catch (RemoteException e) {
                    }
                }
                this.mSafeMode = true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void showSafeModeOverlay() {
        View v = LayoutInflater.from(this.mContext).inflate(17367243, null);
        LayoutParams lp = new LayoutParams();
        lp.type = 2015;
        lp.width = -2;
        lp.height = -2;
        lp.gravity = 8388691;
        lp.format = v.getBackground().getOpacity();
        lp.flags = 24;
        lp.privateFlags |= 16;
        ((WindowManager) this.mContext.getSystemService("window")).addView(v, lp);
    }

    public void noteWakeupAlarm(IIntentSender sender, int sourceUid, String sourcePkg, String tag) {
        if (sender == null || (sender instanceof PendingIntentRecord)) {
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                if (this.mBatteryStatsService.isOnBattery()) {
                    this.mBatteryStatsService.enforceCallingPermission();
                    int uid = sender == null ? sourceUid : rec.uid == Binder.getCallingUid() ? 1000 : rec.uid;
                    if (sourceUid < 0) {
                        sourceUid = uid;
                    }
                    if (sourcePkg == null) {
                        sourcePkg = rec.key.packageName;
                    }
                    stats.getPackageStatsLocked(sourceUid, sourcePkg).noteWakeupAlarmLocked(tag);
                }
            }
        }
    }

    public void noteAlarmStart(IIntentSender sender, int sourceUid, String tag) {
        if (sender == null || (sender instanceof PendingIntentRecord)) {
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            synchronized (this.mBatteryStatsService.getActiveStatistics()) {
                this.mBatteryStatsService.enforceCallingPermission();
                int uid = sender == null ? sourceUid : rec.uid == Binder.getCallingUid() ? 1000 : rec.uid;
                BatteryStatsService batteryStatsService = this.mBatteryStatsService;
                if (sourceUid < 0) {
                    sourceUid = uid;
                }
                batteryStatsService.noteAlarmStart(tag, sourceUid);
            }
        }
    }

    public void noteAlarmFinish(IIntentSender sender, int sourceUid, String tag) {
        if (sender == null || (sender instanceof PendingIntentRecord)) {
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            synchronized (this.mBatteryStatsService.getActiveStatistics()) {
                this.mBatteryStatsService.enforceCallingPermission();
                int uid = sender == null ? sourceUid : rec.uid == Binder.getCallingUid() ? 1000 : rec.uid;
                BatteryStatsService batteryStatsService = this.mBatteryStatsService;
                if (sourceUid < 0) {
                    sourceUid = uid;
                }
                batteryStatsService.noteAlarmFinish(tag, sourceUid);
            }
        }
    }

    public boolean killPids(int[] pids, String pReason, boolean secure) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("killPids only available to the system");
        }
        String reason = pReason == null ? "Unknown" : pReason;
        boolean killed = false;
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord proc;
            int worstType = 0;
            for (int i : pids) {
                proc = (ProcessRecord) this.mPidsSelfLocked.get(i);
                if (proc != null) {
                    int type = proc.setAdj;
                    if (type > worstType) {
                        worstType = type;
                    }
                }
            }
            if (worstType < 906 && worstType > 900) {
                worstType = 900;
            }
            if (!secure && worstType < 500) {
                worstType = 500;
            }
            Slog.w(TAG, "Killing processes " + reason + " at adjustment " + worstType);
            for (int i2 : pids) {
                proc = (ProcessRecord) this.mPidsSelfLocked.get(i2);
                if (!(proc == null || proc.setAdj < worstType || proc.killedByAm)) {
                    proc.kill(reason, true);
                    killed = true;
                }
            }
        }
        return killed;
    }

    public void killUid(int appId, int userId, String reason) {
        enforceCallingPermission("android.permission.KILL_UID", "killUid");
        synchronized (this) {
            long identity;
            try {
                boostPriorityForLockedSection();
                identity = Binder.clearCallingIdentity();
                killPackageProcessesLocked(null, appId, userId, -800, false, true, true, true, reason != null ? reason : "kill uid");
                Binder.restoreCallingIdentity(identity);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean killProcessesBelowForeground(String reason) {
        if (Binder.getCallingUid() == 1000) {
            return killProcessesBelowAdj(0, reason);
        }
        throw new SecurityException("killProcessesBelowForeground() only available to system");
    }

    private boolean killProcessesBelowAdj(int belowAdj, String reason) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("killProcessesBelowAdj() only available to system");
        }
        boolean killed = false;
        synchronized (this.mPidsSelfLocked) {
            int size = this.mPidsSelfLocked.size();
            for (int i = 0; i < size; i++) {
                int pid = this.mPidsSelfLocked.keyAt(i);
                ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.valueAt(i);
                if (!(proc == null || proc.setAdj <= belowAdj || proc.killedByAm)) {
                    proc.kill(reason, true);
                    killed = true;
                }
            }
        }
        return killed;
    }

    public void hang(IBinder who, boolean allowRestart) {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        DeathRecipient death = new DeathRecipient() {
            public void binderDied() {
                synchronized (this) {
                    notifyAll();
                }
            }
        };
        try {
            who.linkToDeath(death, 0);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    Watchdog.getInstance().setAllowRestart(allowRestart);
                    Slog.i(TAG, "Hanging system process at request of pid " + Binder.getCallingPid());
                    synchronized (death) {
                        while (who.isBinderAlive()) {
                            try {
                                death.wait();
                            } catch (InterruptedException e) {
                            }
                        }
                    }
                    Watchdog.getInstance().setAllowRestart(true);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } catch (RemoteException e2) {
            Slog.w(TAG, "hang: given caller IBinder is already dead.");
        }
    }

    public void restart() {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        Log.i(TAG, "Sending shutdown broadcast...");
        BroadcastReceiver br = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                Log.i(ActivityManagerService.TAG, "Shutting down activity manager...");
                ActivityManagerService.this.shutdown(10000);
                Log.i(ActivityManagerService.TAG, "Shutdown complete, restarting!");
                Process.killProcess(Process.myPid());
                System.exit(10);
            }
        };
        Intent intent = new Intent("android.intent.action.ACTION_SHUTDOWN");
        intent.addFlags(268435456);
        intent.putExtra("android.intent.extra.SHUTDOWN_USERSPACE_ONLY", true);
        br.onReceive(this.mContext, intent);
    }

    private long getLowRamTimeSinceIdle(long now) {
        long j = 0;
        long j2 = this.mLowRamTimeSinceLastIdle;
        if (this.mLowRamStartTime > 0) {
            j = now - this.mLowRamStartTime;
        }
        return j + j2;
    }

    public void performIdleMaintenance() {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long now = SystemClock.uptimeMillis();
                long timeSinceLastIdle = now - this.mLastIdleTime;
                long lowRamSinceLastIdle = getLowRamTimeSinceIdle(now);
                this.mLastIdleTime = now;
                this.mLowRamTimeSinceLastIdle = 0;
                if (this.mLowRamStartTime != 0) {
                    this.mLowRamStartTime = now;
                }
                StringBuilder sb = new StringBuilder(128);
                sb.append("Idle maintenance over ");
                TimeUtils.formatDuration(timeSinceLastIdle, sb);
                sb.append(" low RAM for ");
                TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
                Slog.i(TAG, sb.toString());
                boolean doKilling = lowRamSinceLastIdle > timeSinceLastIdle / 3;
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord proc = (ProcessRecord) this.mLruProcesses.get(i);
                    if (proc.notCachedSinceIdle) {
                        if (proc.setProcState != 5 && proc.setProcState >= 4 && proc.setProcState <= 10 && doKilling && proc.initialIdlePss != 0 && proc.lastPss > (proc.initialIdlePss * 3) / 2) {
                            sb = new StringBuilder(128);
                            sb.append("Kill");
                            sb.append(proc.processName);
                            sb.append(" in idle maint: pss=");
                            sb.append(proc.lastPss);
                            sb.append(", swapPss=");
                            sb.append(proc.lastSwapPss);
                            sb.append(", initialPss=");
                            sb.append(proc.initialIdlePss);
                            sb.append(", period=");
                            TimeUtils.formatDuration(timeSinceLastIdle, sb);
                            sb.append(", lowRamPeriod=");
                            TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
                            if (ActivityManagerDebugConfig.DEBUG_FSTRIM) {
                                Slog.wtfQuiet(TAG, sb.toString());
                            } else {
                                Slog.w(TAG, sb.toString());
                            }
                            proc.kill("idle maint (pss " + proc.lastPss + " from " + proc.initialIdlePss + ")", true);
                        }
                    } else if (proc.setProcState < 12 && proc.setProcState > -1) {
                        proc.notCachedSinceIdle = true;
                        proc.initialIdlePss = 0;
                        proc.nextPssTime = ProcessList.computeNextPssTime(proc.setProcState, true, this.mTestPssMode, isSleepingLocked(), now);
                    }
                }
                this.mHandler.removeMessages(39);
                this.mHandler.sendEmptyMessageDelayed(39, JobStatus.DEFAULT_TRIGGER_MAX_DELAY);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void sendIdleJobTrigger() {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        long ident = Binder.clearCallingIdentity();
        try {
            broadcastIntent(null, new Intent(ACTION_TRIGGER_IDLE).setPackage("android").addFlags(1073741824), null, null, 0, null, null, null, -1, null, true, false, -1);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    private void retrieveSettings() {
        boolean freeformWindowManagement;
        ContentResolver resolver = this.mContext.getContentResolver();
        if (this.mContext.getPackageManager().hasSystemFeature("android.software.freeform_window_management") || Global.getInt(resolver, "enable_freeform_support", 0) != 0) {
            freeformWindowManagement = true;
        } else {
            freeformWindowManagement = MultiWindowManager.isSupported();
        }
        boolean supportsPictureInPicture = this.mContext.getPackageManager().hasSystemFeature("android.software.picture_in_picture");
        boolean supportsMultiWindow = ActivityManager.supportsMultiWindow();
        String debugApp = Global.getString(resolver, "debug_app");
        boolean waitForDebugger = Global.getInt(resolver, "wait_for_debugger", 0) != 0;
        boolean alwaysFinishActivities = Global.getInt(resolver, "always_finish_activities", 0) != 0;
        boolean lenientBackgroundCheck = Global.getInt(resolver, "lenient_background_check", 0) != 0;
        boolean forceRtl = Global.getInt(resolver, "debug.force_rtl", 0) != 0;
        boolean forceResizable = Global.getInt(resolver, "force_resizable_activities", 0) != 0;
        boolean supportsLeanbackOnly = this.mContext.getPackageManager().hasSystemFeature("android.software.leanback_only");
        SystemProperties.set("debug.force_rtl", forceRtl ? LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON : "0");
        Configuration configuration = new Configuration();
        System.getConfiguration(resolver, configuration);
        if (forceRtl) {
            configuration.setLayoutDirection(configuration.locale);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mOrigDebugApp = debugApp;
                this.mDebugApp = debugApp;
                this.mOrigWaitForDebugger = waitForDebugger;
                this.mWaitForDebugger = waitForDebugger;
                this.mAlwaysFinishActivities = alwaysFinishActivities;
                this.mLenientBackgroundCheck = lenientBackgroundCheck;
                this.mSupportsLeanbackOnly = supportsLeanbackOnly;
                this.mForceResizableActivities = forceResizable;
                this.mWindowManager.setForceResizableTasks(this.mForceResizableActivities);
                if (supportsMultiWindow || forceResizable) {
                    this.mSupportsMultiWindow = true;
                    this.mSupportsFreeformWindowManagement = !freeformWindowManagement ? forceResizable : true;
                    if (supportsPictureInPicture) {
                        forceResizable = true;
                    }
                    this.mSupportsPictureInPicture = forceResizable;
                } else {
                    this.mSupportsMultiWindow = false;
                    this.mSupportsFreeformWindowManagement = false;
                    this.mSupportsPictureInPicture = false;
                }
                updateConfigurationLocked(configuration, null, true);
                if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                    Slog.v(TAG_CONFIGURATION, "Initial config: " + this.mConfiguration);
                }
                Resources res = this.mContext.getResources();
                this.mHasRecents = res.getBoolean(17956999);
                this.mThumbnailWidth = res.getDimensionPixelSize(17104898);
                this.mThumbnailHeight = res.getDimensionPixelSize(17104897);
                this.mDefaultPinnedStackBounds = Rect.unflattenFromString(res.getString(17039471));
                this.mAppErrors.loadAppsNotReportingCrashesFromConfigLocked(res.getString(17039472));
                if ((this.mConfiguration.uiMode & 4) == 4) {
                    this.mFullscreenThumbnailScale = ((float) res.getInteger(17694895)) / ((float) this.mConfiguration.screenWidthDp);
                } else {
                    this.mFullscreenThumbnailScale = res.getFraction(18022404, 1, 1);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean testIsSystemReady() {
        return this.mSystemReady;
    }

    /* JADX WARNING: Removed duplicated region for block: B:113:0x04cc A:{Catch:{ RemoteException -> 0x0535, all -> 0x053b }} */
    /* JADX WARNING: Missing block: B:8:0x0046, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:9:0x0049, code:
            return;
     */
    /* JADX WARNING: Missing block: B:46:0x013c, code:
            monitor-enter(r63);
     */
    /* JADX WARNING: Missing block: B:48:?, code:
            boostPriorityForLockedSection();
     */
    /* JADX WARNING: Missing block: B:49:0x0140, code:
            if (r59 == null) goto L_0x0181;
     */
    /* JADX WARNING: Missing block: B:50:0x0142, code:
            r49 = r59.size() - 1;
     */
    /* JADX WARNING: Missing block: B:51:0x0148, code:
            if (r49 < 0) goto L_0x0181;
     */
    /* JADX WARNING: Missing block: B:52:0x014a, code:
            r57 = (com.android.server.am.ProcessRecord) r59.get(r49);
            android.util.Slog.i(TAG, "Removing system update proc: " + r57);
            removeProcessLocked(r57, true, false, "system update done");
     */
    /* JADX WARNING: Missing block: B:53:0x017b, code:
            r49 = r49 - 1;
     */
    /* JADX WARNING: Missing block: B:59:?, code:
            r63.mProcessesReady = true;
     */
    /* JADX WARNING: Missing block: B:60:0x0186, code:
            monitor-exit(r63);
     */
    /* JADX WARNING: Missing block: B:61:0x0187, code:
            resetPriorityAfterLockedSection();
            android.util.Slog.i(TAG, "System now ready");
            r63.mHandler.postDelayed(r63.mCreateDataReserveFile, APP_DEXOPT_TIMEOUT);
            com.color.util.ColorAccidentallyTouchUtils.getInstance().init();
            com.color.util.ColorSecureKeyboardUtils.getInstance().init(r63.mContext);
            com.color.util.ColorDisplayOptimizationUtils.getInstance().init(r63.mContext);
            com.color.util.ColorDisplayCompatUtils.getInstance().init(r63.mContext);
            com.android.server.am.OppoAutostartManager.getInstance().initBootList(false);
            com.android.server.am.OppoMultiAppManager.getInstance().setAms(r63);
            com.android.server.am.OppoMultiAppManagerUtil.getInstance().initMultiAppFiles();
            com.android.server.am.OppoProtectEyeManagerService.getInstance().init(r63.mContext);
            com.android.server.am.OppoAbnormalAppManager.getInstance().setAms(r63);
            com.android.server.coloros.OppoListManager.getInstance().init();
            com.android.server.coloros.OppoListManager.getInstance().initCtx(r63.mContext);
            com.android.server.am.OppoCrashClearManager.getInstance().init(r63.mContext);
            r55 = com.android.server.am.OppoBroadcastManager.getInstance(r63);
            r55.systemReady();
            com.android.server.am.OppoAppStartupManager.getInstance().init(r63);
            r63.mLmkObserver.startObserving("LMK=LOWMEM");
            com.android.server.am.OppoGameSpaceManager.getInstance().init(r63);
            com.android.server.am.OppoProcessManager.getInstance().updateGlobalWhiteList();
            com.android.server.coloros.OppoTransactCodeGenerator.getInstance().generate();
            r63.mOppoAppScaleHelper.initUpdateBroadcastReceiver();
            android.util.EventLog.writeEvent(com.android.server.am.EventLogTags.BOOT_PROGRESS_AMS_READY, android.os.SystemClock.uptimeMillis());
            com.mediatek.server.am.BootEvent.addBootEvent("AMS:AMS_READY");
            r47 = com.mediatek.am.AMEventHookData.SystemReady.createInstance();
            r2 = new java.lang.Object[3];
            r2[0] = java.lang.Integer.valueOf(200);
            r2[1] = r63.mContext;
            r2[2] = r63;
            r47.set(r2);
            r63.mAMEventHook.hook(com.mediatek.server.am.AMEventHook.Event.AM_SystemReady, r47);
            com.android.server.am.OppoAmsUtils.getInstance(r63).systemReady();
            com.android.server.am.OppoSplitWindowAppReader.getInstance();
     */
    /* JADX WARNING: Missing block: B:62:0x028b, code:
            monitor-enter(r63);
     */
    /* JADX WARNING: Missing block: B:64:?, code:
            boostPriorityForLockedSection();
     */
    /* JADX WARNING: Missing block: B:65:0x0294, code:
            if (r63.mFactoryTest != 1) goto L_0x0310;
     */
    /* JADX WARNING: Missing block: B:66:0x0296, code:
            r60 = r63.mContext.getPackageManager().resolveActivity(new android.content.Intent("android.intent.action.FACTORY_TEST"), 1024);
            r46 = null;
     */
    /* JADX WARNING: Missing block: B:67:0x02ae, code:
            if (r60 == null) goto L_0x0518;
     */
    /* JADX WARNING: Missing block: B:68:0x02b0, code:
            r37 = r60.activityInfo;
            r38 = r37.applicationInfo;
     */
    /* JADX WARNING: Missing block: B:69:0x02c2, code:
            if ((r38.flags & 1) == 0) goto L_0x0507;
     */
    /* JADX WARNING: Missing block: B:70:0x02c4, code:
            r63.mTopAction = "android.intent.action.FACTORY_TEST";
            r63.mTopData = null;
            r63.mTopComponent = new android.content.ComponentName(r38.packageName, r37.name);
     */
    /* JADX WARNING: Missing block: B:71:0x02e1, code:
            if (r46 == null) goto L_0x0310;
     */
    /* JADX WARNING: Missing block: B:72:0x02e3, code:
            r63.mTopAction = null;
            r63.mTopData = null;
            r63.mTopComponent = null;
            r54 = android.os.Message.obtain();
            r54.what = 3;
            r54.getData().putCharSequence("msg", r46);
            r63.mUiHandler.sendMessage(r54);
     */
    /* JADX WARNING: Missing block: B:73:0x0310, code:
            monitor-exit(r63);
     */
    /* JADX WARNING: Missing block: B:74:0x0311, code:
            resetPriorityAfterLockedSection();
            retrieveSettings();
     */
    /* JADX WARNING: Missing block: B:75:0x0317, code:
            monitor-enter(r63);
     */
    /* JADX WARNING: Missing block: B:77:?, code:
            boostPriorityForLockedSection();
            r18 = r63.mUserController.getCurrentUserIdLocked();
            readGrantedUriPermissionsLocked();
     */
    /* JADX WARNING: Missing block: B:78:0x0326, code:
            monitor-exit(r63);
     */
    /* JADX WARNING: Missing block: B:79:0x0327, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:80:0x032a, code:
            if (r64 == null) goto L_0x032f;
     */
    /* JADX WARNING: Missing block: B:81:0x032c, code:
            r64.run();
     */
    /* JADX WARNING: Missing block: B:82:0x032f, code:
            r63.mBatteryStatsService.noteEvent(32775, java.lang.Integer.toString(r18), r18);
            r63.mBatteryStatsService.noteEvent(32776, java.lang.Integer.toString(r18), r18);
            r63.mSystemServiceManager.startUser(r18);
     */
    /* JADX WARNING: Missing block: B:83:0x0358, code:
            monitor-enter(r63);
     */
    /* JADX WARNING: Missing block: B:85:?, code:
            boostPriorityForLockedSection();
            startPersistentApps(com.android.server.pm.PackageManagerService.DumpState.DUMP_FROZEN);
            r63.mBooting = true;
     */
    /* JADX WARNING: Missing block: B:86:0x036c, code:
            if (android.os.UserManager.isSplitSystemUser() == false) goto L_0x0387;
     */
    /* JADX WARNING: Missing block: B:89:?, code:
            android.app.AppGlobals.getPackageManager().setComponentEnabledSetting(new android.content.ComponentName(r63.mContext, com.android.internal.app.SystemUserHomeActivity.class), 1, 0, 0);
     */
    /* JADX WARNING: Missing block: B:90:0x0387, code:
            r61 = false;
     */
    /* JADX WARNING: Missing block: B:92:?, code:
            r47 = com.mediatek.am.AMEventHookData.SystemReady.createInstance();
            r2 = new java.lang.Object[3];
            r2[0] = java.lang.Integer.valueOf(300);
            r2[1] = r63.mContext;
            r2[2] = r63;
            r47.set(r2);
     */
    /* JADX WARNING: Missing block: B:93:0x03bc, code:
            if (com.mediatek.am.AMEventHookResult.hasAction(r63.mAMEventHook.hook(com.mediatek.server.am.AMEventHook.Event.AM_SystemReady, r47), com.mediatek.am.AMEventHookAction.AM_SkipHomeActivityLaunching) == false) goto L_0x03c0;
     */
    /* JADX WARNING: Missing block: B:94:0x03be, code:
            r61 = true;
     */
    /* JADX WARNING: Missing block: B:95:0x03c0, code:
            if (r61 != false) goto L_0x03cc;
     */
    /* JADX WARNING: Missing block: B:96:0x03c2, code:
            startHomeActivityLocked(r18, "systemReady");
     */
    /* JADX WARNING: Missing block: B:97:0x03cc, code:
            r56 = com.android.server.am.OppoBootCompleteBroadcast.getInstance(r63, r63.mUserController);
            r63.mUserController.setOppoBroadcastManager(r55);
            r56.triggerOppoBootcompleteBroadcast();
     */
    /* JADX WARNING: Missing block: B:100:0x03ea, code:
            if (android.app.AppGlobals.getPackageManager().hasSystemUidErrors() == false) goto L_0x0401;
     */
    /* JADX WARNING: Missing block: B:101:0x03ec, code:
            android.util.Slog.e(TAG, "UIDs on the system are inconsistent, you need to wipe your data partition or your device will be unstable.");
            r63.mUiHandler.obtainMessage(14).sendToTarget();
     */
    /* JADX WARNING: Missing block: B:118:0x0501, code:
            r2 = move-exception;
     */
    /* JADX WARNING: Missing block: B:120:0x0503, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:121:0x0506, code:
            throw r2;
     */
    /* JADX WARNING: Missing block: B:123:?, code:
            r46 = r63.mContext.getResources().getText(17040108);
     */
    /* JADX WARNING: Missing block: B:124:0x0518, code:
            r46 = r63.mContext.getResources().getText(17040109);
     */
    /* JADX WARNING: Missing block: B:125:0x0529, code:
            r2 = move-exception;
     */
    /* JADX WARNING: Missing block: B:127:0x052b, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:128:0x052e, code:
            throw r2;
     */
    /* JADX WARNING: Missing block: B:129:0x052f, code:
            r2 = move-exception;
     */
    /* JADX WARNING: Missing block: B:131:0x0531, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:132:0x0534, code:
            throw r2;
     */
    /* JADX WARNING: Missing block: B:133:0x0535, code:
            r44 = move-exception;
     */
    /* JADX WARNING: Missing block: B:136:0x053a, code:
            throw r44.rethrowAsRuntimeException();
     */
    /* JADX WARNING: Missing block: B:137:0x053b, code:
            r2 = move-exception;
     */
    /* JADX WARNING: Missing block: B:139:0x053d, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:140:0x0540, code:
            throw r2;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for permission intercept", property = OppoRomType.OPPO)
    public void systemReady(Runnable goingCallback) {
        Throwable th;
        BootEvent.addBootEvent("AMS:systemReady");
        initOnSystemReady();
        SystemReady eventData = SystemReady.createInstance();
        Object[] objArr = new Object[3];
        objArr[0] = Integer.valueOf(0);
        objArr[1] = this.mContext;
        objArr[2] = this;
        eventData.set(objArr);
        this.mAMEventHook.hook(Event.AM_SystemReady, eventData);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mSystemReady) {
                    this.mLocalDeviceIdleController = (com.android.server.DeviceIdleController.LocalService) LocalServices.getService(com.android.server.DeviceIdleController.LocalService.class);
                    if (SystemProperties.getBoolean("persist.sys.remove.task", false)) {
                        this.mRecentTasks.clearTasksWhileRebooting();
                        SystemProperties.set("persist.sys.remove.task", IElsaManager.EMPTY_PACKAGE);
                    }
                    this.mUserController.onSystemReady();
                    this.mRecentTasks.onSystemReadyLocked();
                    permissionInterceptPolicyReady();
                    this.mAppOpsService.systemReady();
                    this.mSystemReady = true;
                    if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.lovelyfonts_support", "0"))) {
                        Class class1 = Class.forName("com.android.lovelyfonts.LovelyFontsManagerNative");
                        AccessibleObject[] constructors = class1.getDeclaredConstructors();
                        AccessibleObject.setAccessible(constructors, true);
                        for (Constructor con : constructors) {
                            if (con.isAccessible()) {
                                Object classObject = con.newInstance(new Object[0]);
                                Class[] clsArr = new Class[1];
                                clsArr[0] = Context.class;
                                Method method = class1.getMethod("initialize", clsArr);
                                Object[] objArr2 = new Object[1];
                                objArr2[0] = this.mContext;
                                method.invoke(classObject, objArr2);
                            }
                        }
                    }
                } else if (goingCallback != null) {
                    goingCallback.run();
                }
            } catch (Exception e) {
                e.printStackTrace();
            } catch (Throwable th2) {
                resetPriorityAfterLockedSection();
                throw th2;
            }
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            this.mUiHandler.obtainMessage(15).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent("android.intent.action.USER_STARTED");
            intent.addFlags(1342177280);
            intent.putExtra("android.intent.extra.user_handle", currentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, currentUserId);
            intent = new Intent("android.intent.action.USER_STARTING");
            intent.addFlags(1073741824);
            intent.putExtra("android.intent.extra.user_handle", currentUserId);
            IIntentReceiver anonymousClass22 = new IIntentReceiver.Stub() {
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            };
            String[] strArr = new String[1];
            strArr[0] = "android.permission.INTERACT_ACROSS_USERS";
            broadcastIntentLocked(null, null, intent, null, anonymousClass22, 0, null, null, strArr, -1, null, true, false, MY_PID, 1000, -1);
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th22) {
            Binder.restoreCallingIdentity(ident);
            throw th22;
        }
        eventData = SystemReady.createInstance();
        objArr = new Object[3];
        objArr[0] = Integer.valueOf(400);
        objArr[1] = this.mContext;
        objArr[2] = this;
        eventData.set(objArr);
        if (AMEventHookResult.hasAction(this.mAMEventHook.hook(Event.AM_SystemReady, eventData), AMEventHookAction.AM_PostEnableScreenAfterBoot)) {
        }
        this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
        this.mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId);
        resetPriorityAfterLockedSection();
        if (this.isDiskEncrypted) {
        }
        this.mUiHandler.sendMessageDelayed(this.mUiHandler.obtainMessage(SHOW_SYSTEM_SERVICE_CRASH_MSG), 8000);
        SystemProperties.set("persist.zygote.crash", "false");
        return;
        resetPriorityAfterLockedSection();
        synchronized (this.mPidsSelfLocked) {
            try {
                int i = this.mPidsSelfLocked.size() - 1;
                ArrayList<ProcessRecord> procsToKill = null;
                while (i >= 0) {
                    ArrayList<ProcessRecord> procsToKill2;
                    try {
                        ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.valueAt(i);
                        if (isAllowedWhileBooting(proc.info)) {
                            procsToKill2 = procsToKill;
                        } else {
                            if (procsToKill == null) {
                                procsToKill2 = new ArrayList();
                            } else {
                                procsToKill2 = procsToKill;
                            }
                            procsToKill2.add(proc);
                        }
                        i--;
                        procsToKill = procsToKill2;
                    } catch (Throwable th3) {
                        th22 = th3;
                        procsToKill2 = procsToKill;
                        throw th22;
                    }
                }
            } catch (Throwable th4) {
                th22 = th4;
            }
        }
    }

    private void reportLowmemStats(ArrayList<ProcessMemInfo> memInfos) {
        int i;
        ProcessMemInfo mi;
        SparseArray<ProcessMemInfo> sparseArray = new SparseArray(memInfos.size());
        int N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            sparseArray.put(mi.pid, mi);
        }
        updateCpuStatsNow();
        long[] memtrackTmp = new long[1];
        synchronized (this.mProcessCpuTracker) {
            N = this.mProcessCpuTracker.countStats();
            for (i = 0; i < N; i++) {
                Stats st = this.mProcessCpuTracker.getStats(i);
                if (st.vsize > 0) {
                    long pss = Debug.getPss(st.pid, null, memtrackTmp);
                    if (pss > 0) {
                        if (sparseArray.indexOfKey(st.pid) < 0) {
                            mi = new ProcessMemInfo(st.name, st.pid, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, "native", null);
                            mi.pss = pss;
                            mi.memtrack = memtrackTmp[0];
                            memInfos.add(mi);
                        }
                    }
                }
            }
        }
        long totalPss = 0;
        long totalMemtrack = 0;
        N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.pss == 0) {
                mi.pss = Debug.getPss(mi.pid, null, memtrackTmp);
                mi.memtrack = memtrackTmp[0];
            }
            totalPss += mi.pss;
            totalMemtrack += mi.memtrack;
        }
        Collections.sort(memInfos, new Comparator<ProcessMemInfo>() {
            public int compare(ProcessMemInfo lhs, ProcessMemInfo rhs) {
                int i = 1;
                int i2 = -1;
                if (lhs.oomAdj != rhs.oomAdj) {
                    if (lhs.oomAdj >= rhs.oomAdj) {
                        i2 = 1;
                    }
                    return i2;
                } else if (lhs.pss == rhs.pss) {
                    return 0;
                } else {
                    if (lhs.pss >= rhs.pss) {
                        i = -1;
                    }
                    return i;
                }
            }
        });
        StringBuilder stringBuilder = new StringBuilder(128);
        stringBuilder.append("Low on memory maybe memleak ");
        stringBuilder = new StringBuilder(1024);
        StringBuilder shortNativeBuilder = new StringBuilder(1024);
        stringBuilder = new StringBuilder(1024);
        long extraNativeRam = 0;
        long extraNativeMemtrack = 0;
        long cachedPss = 0;
        N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.oomAdj >= 900) {
                cachedPss += mi.pss;
            }
            appendMemInfo(stringBuilder, mi);
            if (mi.oomAdj != JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE) {
                if (extraNativeRam > 0) {
                    appendBasicMemEntry(shortNativeBuilder, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, extraNativeRam, extraNativeMemtrack, "(Other native)");
                    shortNativeBuilder.append(10);
                    extraNativeRam = 0;
                }
                appendMemInfo(stringBuilder, mi);
            } else if (mi.pss >= 512) {
                appendMemInfo(shortNativeBuilder, mi);
            } else {
                extraNativeRam += mi.pss;
                extraNativeMemtrack += mi.memtrack;
            }
        }
        stringBuilder.append("           ");
        ProcessList.appendRamKb(stringBuilder, totalPss);
        stringBuilder.append(" kB: TOTAL");
        if (totalMemtrack > 0) {
            stringBuilder.append(" (");
            stringBuilder.append(totalMemtrack);
            stringBuilder.append(" kB memtrack)");
        }
        stringBuilder.append("\n");
        MemInfoReader memInfo = new MemInfoReader();
        memInfo.readMemInfo();
        long[] infos = memInfo.getRawInfo();
        stringBuilder = new StringBuilder(1024);
        stringBuilder.append("  MemInfo: ");
        stringBuilder.append(infos[5]).append(" kB slab, ");
        stringBuilder.append(infos[4]).append(" kB shmem, ");
        stringBuilder.append(infos[10]).append(" kB vm alloc, ");
        stringBuilder.append(infos[11]).append(" kB page tables ");
        stringBuilder.append(infos[12]).append(" kB kernel stack\n");
        stringBuilder.append("           ");
        stringBuilder.append(infos[2]).append(" kB buffers, ");
        stringBuilder.append(infos[3]).append(" kB cached, ");
        stringBuilder.append(infos[9]).append(" kB mapped, ");
        stringBuilder.append(infos[1]).append(" kB free\n");
        if (infos[8] != 0) {
            stringBuilder.append("  ZRAM: ");
            stringBuilder.append(infos[8]);
            stringBuilder.append(" kB RAM, ");
            stringBuilder.append(infos[6]);
            stringBuilder.append(" kB swap total, ");
            stringBuilder.append(infos[7]);
            stringBuilder.append(" kB swap free\n");
        }
        long[] ksm = getKsmInfo();
        if (!(ksm[1] == 0 && ksm[0] == 0 && ksm[2] == 0 && ksm[3] == 0)) {
            stringBuilder.append("  KSM: ");
            stringBuilder.append(ksm[1]);
            stringBuilder.append(" kB saved from shared ");
            stringBuilder.append(ksm[0]);
            stringBuilder.append(" kB\n");
            stringBuilder.append("       ");
            stringBuilder.append(ksm[2]);
            stringBuilder.append(" kB unshared; ");
            stringBuilder.append(ksm[3]);
            stringBuilder.append(" kB volatile\n");
        }
        stringBuilder.append("  Free RAM: ");
        stringBuilder.append((memInfo.getCachedSizeKb() + cachedPss) + memInfo.getFreeSizeKb());
        stringBuilder.append(" kB\n");
        stringBuilder.append("  Used RAM: ");
        stringBuilder.append((totalPss - cachedPss) + memInfo.getKernelUsedSizeKb());
        stringBuilder.append(" kB\n");
        stringBuilder.append("  Lost RAM: ");
        stringBuilder.append((((memInfo.getTotalSizeKb() - totalPss) - memInfo.getFreeSizeKb()) - memInfo.getCachedSizeKb()) - memInfo.getKernelUsedSizeKb());
        stringBuilder.append(" kB\n");
        stringBuilder.append("  ExtraMemInfo: \n");
        if (infos[13] != 0) {
            stringBuilder.append("           ");
            stringBuilder.append(infos[13] * 4).append(" kB ion cached\n");
        }
        if (infos[18] != 0) {
            stringBuilder.append("           ");
            stringBuilder.append(infos[18]).append(" kB ion orphaned\n");
            String[] ionOrphaned = new String[50];
            Debug.getIonOrphanedProcess(ionOrphaned);
            i = 0;
            while (i < 50 && !ionOrphaned[i].equals("null")) {
                stringBuilder.append("           ");
                stringBuilder.append(ionOrphaned[i]);
                i++;
            }
            stringBuilder.append("\n");
        }
        Slog.i(TAG, "Low on memory:");
        Slog.i(TAG, shortNativeBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        stringBuilder = new StringBuilder(1024);
        stringBuilder.append("Low on memory:");
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        addErrorToDropBox("lmk_uevent", null, "lowmmeorykiller", null, null, stringBuilder.toString(), stringBuilder.toString(), null, null);
    }

    private boolean isBootFromRecovery() {
        Slog.d(TAG, "check /cache/recovery/intent");
        if (!new File("/cache/recovery/intent").exists()) {
            return false;
        }
        Slog.i(TAG, "/cache/recovery/intent file is exist!!!");
        return true;
    }

    void killAppAtUsersRequest(ProcessRecord app, Dialog fromDialog) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (app.pid > 0 && app.pid != MY_PID) {
                    OppoExtraActivityManagerService.setKeyLockModeNormal(this.mContext, app.processName, this.mSystemReady);
                }
                this.mAppErrors.killAppAtUserRequestLocked(app, fromDialog);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void skipCurrentReceiverLocked(ProcessRecord app) {
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                Slog.d(TAG_BROADCAST, "mBroadcastQueues: " + queue + " app = " + app);
            }
            queue.skipCurrentReceiverLocked(app);
        }
    }

    public void handleApplicationCrash(IBinder app, CrashInfo crashInfo) {
        ProcessRecord r = findAppProcess(app, "Crash");
        String processName = app == null ? "system_server" : r == null ? "unknown" : r.processName;
        if (app == null) {
            AgingCriticalEvent instance = AgingCriticalEvent.getInstance();
            String str = AgingCriticalEvent.EVENT_SYSTEMSERVER_JAVA_CRASH;
            String[] strArr = new String[1];
            strArr[0] = "systemserver pid:" + Process.myPid();
            instance.writeEvent(str, strArr);
        }
        handleApplicationCrashInner("crash", r, processName, crashInfo);
    }

    void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, CrashInfo crashInfo) {
        Object[] objArr = new Object[8];
        objArr[0] = Integer.valueOf(Binder.getCallingPid());
        objArr[1] = Integer.valueOf(UserHandle.getUserId(Binder.getCallingUid()));
        objArr[2] = processName;
        objArr[3] = Integer.valueOf(r == null ? -1 : r.info.flags);
        objArr[4] = crashInfo.exceptionClassName;
        objArr[5] = crashInfo.exceptionMessage;
        objArr[6] = crashInfo.throwFileName;
        objArr[7] = Integer.valueOf(crashInfo.throwLineNumber);
        EventLog.writeEvent(EventLogTags.AM_CRASH, objArr);
        addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);
        this.mAppErrors.crashApplication(r, crashInfo);
    }

    public void handleApplicationStrictModeViolation(IBinder app, int violationMask, ViolationInfo info) {
        ProcessRecord r = findAppProcess(app, "StrictMode");
        if (r != null) {
            if ((DumpState.DUMP_COMPILER_STATS & violationMask) != 0) {
                Integer stackFingerprint = Integer.valueOf(info.hashCode());
                boolean logIt = true;
                synchronized (this.mAlreadyLoggedViolatedStacks) {
                    if (this.mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
                        logIt = false;
                    } else {
                        if (this.mAlreadyLoggedViolatedStacks.size() >= 5000) {
                            this.mAlreadyLoggedViolatedStacks.clear();
                        }
                        this.mAlreadyLoggedViolatedStacks.add(stackFingerprint);
                    }
                }
                if (logIt) {
                    logStrictModeViolationToDropBox(r, info);
                }
            }
            if ((DumpState.DUMP_INTENT_FILTER_VERIFIERS & violationMask) != 0) {
                AppErrorResult result = new AppErrorResult();
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        long origId = Binder.clearCallingIdentity();
                        Message msg = Message.obtain();
                        msg.what = 26;
                        HashMap<String, Object> data = new HashMap();
                        data.put("result", result);
                        data.put("app", r);
                        data.put("violationMask", Integer.valueOf(violationMask));
                        data.put("info", info);
                        msg.obj = data;
                        this.mUiHandler.sendMessage(msg);
                        Binder.restoreCallingIdentity(origId);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Slog.w(TAG, "handleApplicationStrictModeViolation; res=" + result.get());
            }
        }
    }

    private void logStrictModeViolationToDropBox(ProcessRecord process, ViolationInfo info) {
        if (info != null) {
            boolean isSystemApp = process != null ? (process.info.flags & 129) != 0 : true;
            String processName = process == null ? "unknown" : process.processName;
            final String dropboxTag = isSystemApp ? "system_app_strictmode" : "data_app_strictmode";
            final DropBoxManager dbox = (DropBoxManager) this.mContext.getSystemService("dropbox");
            if (dbox != null && dbox.isTagEnabled(dropboxTag)) {
                boolean bufferWasEmpty;
                final StringBuilder sb = isSystemApp ? this.mStrictModeBuffer : new StringBuilder(1024);
                synchronized (sb) {
                    bufferWasEmpty = sb.length() == 0;
                    appendDropBoxProcessHeaders(process, processName, sb);
                    sb.append("Build: ").append(Build.FINGERPRINT).append("\n");
                    sb.append("System-App: ").append(isSystemApp).append("\n");
                    sb.append("Uptime-Millis: ").append(info.violationUptimeMillis).append("\n");
                    if (info.violationNumThisLoop != 0) {
                        sb.append("Loop-Violation-Number: ").append(info.violationNumThisLoop).append("\n");
                    }
                    if (info.numAnimationsRunning != 0) {
                        sb.append("Animations-Running: ").append(info.numAnimationsRunning).append("\n");
                    }
                    if (info.broadcastIntentAction != null) {
                        sb.append("Broadcast-Intent-Action: ").append(info.broadcastIntentAction).append("\n");
                    }
                    if (info.durationMillis != -1) {
                        sb.append("Duration-Millis: ").append(info.durationMillis).append("\n");
                    }
                    if (info.numInstances != -1) {
                        sb.append("Instance-Count: ").append(info.numInstances).append("\n");
                    }
                    if (info.tags != null) {
                        for (String tag : info.tags) {
                            sb.append("Span-Tag: ").append(tag).append("\n");
                        }
                    }
                    sb.append("\n");
                    if (!(info.crashInfo == null || info.crashInfo.stackTrace == null)) {
                        sb.append(info.crashInfo.stackTrace);
                        sb.append("\n");
                    }
                    if (info.message != null) {
                        sb.append(info.message);
                        sb.append("\n");
                    }
                    boolean needsFlush = sb.length() > DumpState.DUMP_INSTALLS;
                }
                if (!isSystemApp || needsFlush) {
                    new Thread("Error dump: " + dropboxTag) {
                        public void run() {
                            String report;
                            synchronized (sb) {
                                report = sb.toString();
                                sb.delete(0, sb.length());
                                sb.trimToSize();
                            }
                            if (report.length() != 0) {
                                dbox.addText(dropboxTag, report);
                            }
                        }
                    }.start();
                } else if (bufferWasEmpty) {
                    new Thread("Error dump: " + dropboxTag) {
                        public void run() {
                            try {
                                Thread.sleep(5000);
                            } catch (InterruptedException e) {
                            }
                            synchronized (ActivityManagerService.this.mStrictModeBuffer) {
                                String errorReport = ActivityManagerService.this.mStrictModeBuffer.toString();
                                if (errorReport.length() == 0) {
                                    return;
                                }
                                ActivityManagerService.this.mStrictModeBuffer.delete(0, ActivityManagerService.this.mStrictModeBuffer.length());
                                ActivityManagerService.this.mStrictModeBuffer.trimToSize();
                                dbox.addText(dropboxTag, errorReport);
                            }
                        }
                    }.start();
                }
            }
        }
    }

    public boolean handleApplicationWtf(IBinder app, String tag, boolean system, CrashInfo crashInfo) {
        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();
        if (system) {
            final IBinder iBinder = app;
            final String str = tag;
            final CrashInfo crashInfo2 = crashInfo;
            this.mHandler.post(new Runnable() {
                public void run() {
                    ActivityManagerService.this.handleApplicationWtfInner(callingUid, callingPid, iBinder, str, crashInfo2);
                }
            });
            return false;
        }
        ProcessRecord r = handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
        if (r == null || r.pid == Process.myPid() || Global.getInt(this.mContext.getContentResolver(), "wtf_is_fatal", 0) == 0) {
            return false;
        }
        this.mAppErrors.crashApplication(r, crashInfo);
        return true;
    }

    ProcessRecord handleApplicationWtfInner(int callingUid, int callingPid, IBinder app, String tag, CrashInfo crashInfo) {
        ProcessRecord r = findAppProcess(app, "WTF");
        String processName = app == null ? "system_server" : r == null ? "unknown" : r.processName;
        Object[] objArr = new Object[6];
        objArr[0] = Integer.valueOf(UserHandle.getUserId(callingUid));
        objArr[1] = Integer.valueOf(callingPid);
        objArr[2] = processName;
        objArr[3] = Integer.valueOf(r == null ? -1 : r.info.flags);
        objArr[4] = tag;
        objArr[5] = crashInfo.exceptionMessage;
        EventLog.writeEvent(EventLogTags.AM_WTF, objArr);
        addErrorToDropBox("wtf", r, processName, null, null, tag, null, null, crashInfo);
        return r;
    }

    private ProcessRecord findAppProcess(IBinder app, String reason) {
        ProcessRecord p;
        if (app == null) {
            return null;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    int ia = 0;
                    while (ia < NA) {
                        p = (ProcessRecord) apps.valueAt(ia);
                        if (p.thread == null || p.thread.asBinder() != app) {
                            ia++;
                        }
                    }
                }
                Slog.w(TAG, "Can't find mystery application for " + reason + " from pid=" + Binder.getCallingPid() + " uid=" + Binder.getCallingUid() + ": " + app);
                resetPriorityAfterLockedSection();
                return null;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return p;
    }

    private void appendDropBoxProcessHeaders(ProcessRecord process, String processName, StringBuilder sb) {
        if (process == null) {
            sb.append("Process: ").append(processName).append("\n");
            return;
        }
        synchronized (this) {
            String pkg;
            try {
                boostPriorityForLockedSection();
                sb.append("Process: ").append(processName).append("\n");
                this.mErrorTime = System.currentTimeMillis();
                sb.append("Time: ").append(this.mErrorTime).append("\n");
                int flags = process.info.flags;
                IPackageManager pm = AppGlobals.getPackageManager();
                sb.append("Flags: 0x").append(Integer.toHexString(flags)).append("\n");
                for (int ip = 0; ip < process.pkgList.size(); ip++) {
                    pkg = (String) process.pkgList.keyAt(ip);
                    sb.append("Package: ").append(pkg);
                    this.mErrorPkgName = pkg;
                    PackageInfo pi = pm.getPackageInfo(pkg, 0, UserHandle.getCallingUserId());
                    if (pi != null) {
                        sb.append(" v").append(pi.versionCode);
                        if (pi.versionName != null) {
                            sb.append(" (").append(pi.versionName).append(")");
                        }
                    }
                    sb.append("\n");
                }
                sb.append("PID: ").append(process.pid).append("\n");
            } catch (RemoteException e) {
                Slog.e(TAG, "Error getting package info: " + pkg, e);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    private static String processClass(ProcessRecord process) {
        if (process == null || process.pid == MY_PID) {
            return "system_server";
        }
        if ((process.info.flags & 1) != 0) {
            return "system_app";
        }
        return "data_app";
    }

    public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, String report, File dataFile, CrashInfo crashInfo) {
        String dropboxTag = processClass(process) + LocationManagerService.OPPO_FAKE_LOCATION_SPLIT + eventType;
        final DropBoxManager dbox = (DropBoxManager) this.mContext.getSystemService("dropbox");
        if (dbox != null && dbox.isTagEnabled(dropboxTag)) {
            if (eventType != null && "wtf".equals(eventType)) {
                long now = SystemClock.elapsedRealtime();
                if (now - this.mWtfClusterStart > 10000) {
                    this.mWtfClusterStart = now;
                    this.mWtfClusterCount = 1;
                } else {
                    int i = this.mWtfClusterCount;
                    this.mWtfClusterCount = i + 1;
                    if (i >= 5) {
                        return;
                    }
                }
            }
            StringBuilder stringBuilder = new StringBuilder(1024);
            appendDropBoxProcessHeaders(process, processName, stringBuilder);
            collectErrorInfo(dropboxTag, eventType, process, processName, activity, subject, crashInfo);
            if (process != null) {
                stringBuilder.append("Foreground: ").append(process.isInterestingToUserLocked() ? "Yes" : "No").append("\n");
            }
            final String spid = getProcessPid(process);
            if (activity != null) {
                stringBuilder.append("Activity: ").append(activity.shortComponentName).append("\n");
            }
            if (parent != null) {
                try {
                    if (!(parent.app == null || parent.app.pid == process.pid)) {
                        stringBuilder.append("Parent-Process: ").append(parent.app.processName).append("\n");
                    }
                } catch (Throwable e) {
                    Slog.e(TAG, "Exception when append parent app processName!", e);
                }
            }
            if (!(parent == null || parent == activity)) {
                stringBuilder.append("Parent-Activity: ").append(parent.shortComponentName).append("\n");
            }
            if (subject != null) {
                stringBuilder.append("Subject: ").append(subject).append("\n");
            }
            stringBuilder.append("Build: ").append(Build.FINGERPRINT).append("\n");
            if (Debug.isDebuggerConnected()) {
                stringBuilder.append("Debugger: Connected\n");
            }
            stringBuilder.append("\n");
            final String str = report;
            final StringBuilder stringBuilder2 = stringBuilder;
            final String str2 = dropboxTag;
            final File file = dataFile;
            final CrashInfo crashInfo2 = crashInfo;
            final String str3 = eventType;
            Thread worker = new Thread("Error dump: " + dropboxTag) {
                /* JADX WARNING: Removed duplicated region for block: B:50:0x0192 A:{SYNTHETIC, Splitter: B:50:0x0192} */
                /* Code decompiled incorrectly, please refer to instructions dump. */
                public void run() {
                    IOException e;
                    EndOfErrorDumpThread eventData;
                    Object[] objArr;
                    Throwable th;
                    if (str != null) {
                        stringBuilder2.append(str);
                    }
                    int lines = Global.getInt(ActivityManagerService.this.mContext.getContentResolver(), "logcat_for_" + str2, 0);
                    int maxDataFileSize = (ActivityManagerService.DROPBOX_MAX_SIZE - stringBuilder2.length()) - (lines * 100);
                    if (file != null) {
                        if (maxDataFileSize < 0) {
                            maxDataFileSize = -maxDataFileSize;
                        }
                        try {
                            stringBuilder2.append(FileUtils.readTextFile(file, maxDataFileSize, "\n\n[[TRUNCATED]]"));
                        } catch (IOException e2) {
                            Slog.e(ActivityManagerService.TAG, "Error reading " + file, e2);
                        }
                    }
                    if (!(crashInfo2 == null || crashInfo2.stackTrace == null)) {
                        stringBuilder2.append(crashInfo2.stackTrace);
                    }
                    ActivityManagerService.this.appendCpuInfo(stringBuilder2, str3);
                    if (lines > 0) {
                        stringBuilder2.append("\n");
                        InputStreamReader input = null;
                        try {
                            String[] strArr = new String[17];
                            strArr[0] = "/system/bin/timeout";
                            strArr[1] = "-k";
                            strArr[2] = "15s";
                            strArr[3] = "10s";
                            strArr[4] = "/system/bin/logcat";
                            strArr[5] = "-v";
                            strArr[6] = "threadtime";
                            strArr[7] = "-b";
                            strArr[8] = "events";
                            strArr[9] = "-b";
                            strArr[10] = "system";
                            strArr[11] = "-b";
                            strArr[12] = "main";
                            strArr[13] = "-b";
                            strArr[14] = "crash";
                            strArr[15] = "-t";
                            strArr[16] = String.valueOf(lines);
                            Process logcat = new ProcessBuilder(strArr).redirectErrorStream(true).start();
                            try {
                                logcat.getOutputStream().close();
                            } catch (IOException e3) {
                            }
                            try {
                                logcat.getErrorStream().close();
                            } catch (IOException e4) {
                            }
                            InputStreamReader input2 = new InputStreamReader(logcat.getInputStream());
                            try {
                                char[] buf = new char[DumpState.DUMP_PREFERRED_XML];
                                while (true) {
                                    int num = input2.read(buf);
                                    if (num <= 0) {
                                        break;
                                    }
                                    stringBuilder2.append(buf, 0, num);
                                }
                                if (input2 != null) {
                                    try {
                                        input2.close();
                                    } catch (IOException e5) {
                                    }
                                }
                            } catch (IOException e6) {
                                e2 = e6;
                                input = input2;
                                try {
                                    Slog.e(ActivityManagerService.TAG, "Error running logcat", e2);
                                    if (input != null) {
                                        try {
                                            input.close();
                                        } catch (IOException e7) {
                                        }
                                    }
                                    dbox.addText(str2, stringBuilder2.toString());
                                    eventData = EndOfErrorDumpThread.createInstance();
                                    objArr = new Object[3];
                                    objArr[0] = str2;
                                    objArr[1] = stringBuilder2.toString();
                                    objArr[2] = spid;
                                    eventData.set(objArr);
                                    ActivityManagerService.this.mAMEventHook.hook(Event.AM_EndOfErrorDumpThread, eventData);
                                } catch (Throwable th2) {
                                    th = th2;
                                    if (input != null) {
                                    }
                                    throw th;
                                }
                            } catch (Throwable th3) {
                                th = th3;
                                input = input2;
                                if (input != null) {
                                    try {
                                        input.close();
                                    } catch (IOException e8) {
                                    }
                                }
                                throw th;
                            }
                        } catch (IOException e9) {
                            e2 = e9;
                        }
                    }
                    dbox.addText(str2, stringBuilder2.toString());
                    eventData = EndOfErrorDumpThread.createInstance();
                    objArr = new Object[3];
                    objArr[0] = str2;
                    objArr[1] = stringBuilder2.toString();
                    objArr[2] = spid;
                    eventData.set(objArr);
                    ActivityManagerService.this.mAMEventHook.hook(Event.AM_EndOfErrorDumpThread, eventData);
                }
            };
            if (process == null) {
                worker.run();
            } else {
                worker.start();
            }
            if (processClass(process).equals("system_server")) {
                if (!eventType.equals("wtf")) {
                    if (!eventType.equals("lowmem")) {
                        if (MONITOR_THREAD_CPU_USAGE) {
                            ASSERT.copyBinderInfo();
                        }
                    }
                }
            }
            if (eventType.equals("anr") && MONITOR_THREAD_CPU_USAGE) {
                ASSERT.copyBinderInfo();
            }
        }
    }

    public List<ProcessErrorStateInfo> getProcessesInErrorState() {
        Throwable th;
        enforceNotIsolatedCaller("getProcessesInErrorState");
        boolean allUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", Binder.getCallingUid()) == 0;
        int userId = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int i = this.mLruProcesses.size() - 1;
                List<ProcessErrorStateInfo> errList = null;
                while (i >= 0) {
                    List<ProcessErrorStateInfo> errList2;
                    try {
                        ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                        if (!allUsers && app.userId != userId) {
                            errList2 = errList;
                        } else if (app.thread == null) {
                            errList2 = errList;
                        } else if (app.crashing || app.notResponding) {
                            Object report = null;
                            if (app.crashing) {
                                report = app.crashingReport;
                            } else if (app.notResponding) {
                                report = app.notRespondingReport;
                            }
                            if (report != null) {
                                if (errList == null) {
                                    errList2 = new ArrayList(1);
                                } else {
                                    errList2 = errList;
                                }
                                errList2.add(report);
                            } else {
                                Slog.w(TAG, "Missing app error report, app = " + app.processName + " crashing = " + app.crashing + " notResponding = " + app.notResponding);
                                errList2 = errList;
                            }
                        } else {
                            errList2 = errList;
                        }
                        i--;
                        errList = errList2;
                    } catch (Throwable th2) {
                        th = th2;
                        errList2 = errList;
                        resetPriorityAfterLockedSection();
                        throw th;
                    }
                }
                resetPriorityAfterLockedSection();
                return errList;
            } catch (Throwable th3) {
                th = th3;
            }
        }
    }

    static int procStateToImportance(int procState, int memAdj, RunningAppProcessInfo currApp) {
        int imp = RunningAppProcessInfo.procStateToImportance(procState);
        if (imp == 400) {
            currApp.lru = memAdj;
        } else {
            currApp.lru = 0;
        }
        return imp;
    }

    private void fillInProcMemInfo(ProcessRecord app, RunningAppProcessInfo outInfo) {
        outInfo.pid = app.pid;
        outInfo.uid = app.info.uid;
        if (this.mHeavyWeightProcess == app) {
            outInfo.flags |= 1;
        }
        if (app.persistent) {
            outInfo.flags |= 2;
        }
        if (app.activities.size() > 0) {
            outInfo.flags |= 4;
        }
        outInfo.lastTrimLevel = app.trimMemoryLevel;
        outInfo.importance = procStateToImportance(app.curProcState, app.curAdj, outInfo);
        outInfo.importanceReasonCode = app.adjTypeCode;
        outInfo.processState = app.curProcState;
    }

    public List<RunningAppProcessInfo> getRunningAppProcesses() {
        Throwable th;
        enforceNotIsolatedCaller("getRunningAppProcesses");
        int callingUid = Binder.getCallingUid();
        boolean allUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingUid) == 0;
        int userId = UserHandle.getUserId(callingUid);
        boolean allUids = isGetTasksAllowed("getRunningAppProcesses", Binder.getCallingPid(), callingUid);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int i = this.mLruProcesses.size() - 1;
                List<RunningAppProcessInfo> runList = null;
                while (i >= 0) {
                    List<RunningAppProcessInfo> runList2;
                    try {
                        ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                        if ((!allUsers && app.userId != userId) || (!allUids && app.uid != callingUid)) {
                            runList2 = runList;
                        } else if (this.mCtmFlag && app.processName.equals(this.mCtmName)) {
                            runList2 = runList;
                        } else if (app.thread == null || app.crashing || app.notResponding) {
                            runList2 = runList;
                        } else {
                            RunningAppProcessInfo currApp = new RunningAppProcessInfo(app.processName, app.pid, app.getPackageList());
                            fillInProcMemInfo(app, currApp);
                            if (app.adjSource instanceof ProcessRecord) {
                                currApp.importanceReasonPid = ((ProcessRecord) app.adjSource).pid;
                                currApp.importanceReasonImportance = RunningAppProcessInfo.procStateToImportance(app.adjSourceProcState);
                            } else if (app.adjSource instanceof ActivityRecord) {
                                ActivityRecord r = app.adjSource;
                                if (r.app != null) {
                                    currApp.importanceReasonPid = r.app.pid;
                                }
                            }
                            if (app.adjTarget instanceof ComponentName) {
                                currApp.importanceReasonComponent = (ComponentName) app.adjTarget;
                            }
                            if (runList == null) {
                                runList2 = new ArrayList();
                            } else {
                                runList2 = runList;
                            }
                            runList2.add(currApp);
                        }
                        i--;
                        runList = runList2;
                    } catch (Throwable th2) {
                        th = th2;
                        runList2 = runList;
                        resetPriorityAfterLockedSection();
                        throw th;
                    }
                }
                resetPriorityAfterLockedSection();
                return runList;
            } catch (Throwable th3) {
                th = th3;
            }
        }
    }

    public List<ApplicationInfo> getRunningExternalApplications() {
        enforceNotIsolatedCaller("getRunningExternalApplications");
        List<RunningAppProcessInfo> runningApps = getRunningAppProcesses();
        List<ApplicationInfo> retList = new ArrayList();
        if (runningApps != null && runningApps.size() > 0) {
            Set<String> extList = new HashSet();
            for (RunningAppProcessInfo app : runningApps) {
                if (app.pkgList != null) {
                    for (String pkg : app.pkgList) {
                        extList.add(pkg);
                    }
                }
            }
            IPackageManager pm = AppGlobals.getPackageManager();
            for (String pkg2 : extList) {
                try {
                    ApplicationInfo info = pm.getApplicationInfo(pkg2, 0, UserHandle.getCallingUserId());
                    if ((info.flags & DumpState.DUMP_DOMAIN_PREFERRED) != 0) {
                        retList.add(info);
                    }
                } catch (RemoteException e) {
                }
            }
        }
        return retList;
    }

    public void getMyMemoryState(RunningAppProcessInfo outInfo) {
        enforceNotIsolatedCaller("getMyMemoryState");
        synchronized (this) {
            try {
                ProcessRecord proc;
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    proc = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
                }
                fillInProcMemInfo(proc, outInfo);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int getMemoryTrimLevel() {
        int i;
        enforceNotIsolatedCaller("getMyMemoryState");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                i = this.mLastMemoryLevel;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ResultReceiver resultReceiver) {
        new ActivityManagerShellCommand(this, false).exec(this, in, out, err, args, resultReceiver);
    }

    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (checkCallingPermission("android.permission.DUMP") != 0) {
            pw.println("Permission Denial: can't dump ActivityManager from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + "android.permission.DUMP");
            return;
        }
        boolean dumpAll = false;
        boolean dumpClient = false;
        boolean dumpCheckin = false;
        boolean dumpCheckinFormat = false;
        String dumpPackage = null;
        int opti = 0;
        while (opti < args.length) {
            String opt = args[opti];
            if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
                break;
            }
            opti++;
            if ("-a".equals(opt)) {
                dumpAll = true;
            } else if ("-c".equals(opt)) {
                dumpClient = true;
            } else if ("-p".equals(opt)) {
                if (opti < args.length) {
                    dumpPackage = args[opti];
                    opti++;
                    dumpClient = true;
                } else {
                    pw.println("Error: -p option requires package argument");
                    return;
                }
            } else if ("--checkin".equals(opt)) {
                dumpCheckinFormat = true;
                dumpCheckin = true;
            } else if ("-C".equals(opt)) {
                dumpCheckinFormat = true;
            } else if ("-h".equals(opt)) {
                ActivityManagerShellCommand.dumpHelp(pw, true);
                return;
            } else {
                pw.println("Unknown argument: " + opt + "; use -h for help");
            }
        }
        long origId = Binder.clearCallingIdentity();
        boolean more = false;
        if (opti < args.length) {
            String cmd = args[opti];
            opti++;
            String[] newArgs;
            Object newArgs2;
            String name;
            if ("activities".equals(cmd) || "a".equals(cmd)) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpActivitiesLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("recents".equals(cmd) || "r".equals(cmd)) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpRecentsLocked(fd, pw, args, opti, true, dumpPackage);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
                if (opti >= args.length) {
                    newArgs = EMPTY_STRING_ARRAY;
                } else {
                    dumpPackage = args[opti];
                    opti++;
                    newArgs2 = new String[(args.length - opti)];
                    if (args.length > 2) {
                        System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                    }
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpBroadcastsLocked(fd, pw, args, opti, true, dumpPackage);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("broadcast-stats".equals(cmd)) {
                if (opti >= args.length) {
                    newArgs = EMPTY_STRING_ARRAY;
                } else {
                    dumpPackage = args[opti];
                    opti++;
                    newArgs2 = new String[(args.length - opti)];
                    if (args.length > 2) {
                        System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                    }
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        if (dumpCheckinFormat) {
                            dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
                        } else {
                            dumpBroadcastStatsLocked(fd, pw, args, opti, true, dumpPackage);
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("intents".equals(cmd) || "i".equals(cmd)) {
                if (opti >= args.length) {
                    newArgs = EMPTY_STRING_ARRAY;
                } else {
                    dumpPackage = args[opti];
                    opti++;
                    newArgs2 = new String[(args.length - opti)];
                    if (args.length > 2) {
                        System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                    }
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpPendingIntentsLocked(fd, pw, args, opti, true, dumpPackage);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("processes".equals(cmd) || OppoCrashClearManager.CRASH_CLEAR_NAME.equals(cmd)) {
                if (opti >= args.length) {
                    newArgs = EMPTY_STRING_ARRAY;
                } else {
                    dumpPackage = args[opti];
                    opti++;
                    newArgs2 = new String[(args.length - opti)];
                    if (args.length > 2) {
                        System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                    }
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpProcessesLocked(fd, pw, args, opti, true, dumpPackage);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("oom".equals(cmd) || OppoCrashClearManager.CRASH_TIMEOUT.equals(cmd)) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpOomLocked(fd, pw, args, opti, true);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("permissions".equals(cmd) || "perm".equals(cmd)) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpPermissionsLocked(fd, pw, args, opti, true, null);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if (OppoProcessManager.RESUME_REASON_PROVIDER_STR.equals(cmd)) {
                if (opti >= args.length) {
                    name = null;
                    newArgs = EMPTY_STRING_ARRAY;
                } else {
                    name = args[opti];
                    opti++;
                    newArgs2 = new String[(args.length - opti)];
                    if (args.length > 2) {
                        System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                    }
                }
                if (!dumpProvider(fd, pw, name, newArgs, 0, dumpAll)) {
                    pw.println("No providers match: " + name);
                    pw.println("Use -h for help.");
                }
            } else if ("providers".equals(cmd) || "prov".equals(cmd)) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpProvidersLocked(fd, pw, args, opti, true, null);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if (OppoProcessManager.RESUME_REASON_SERVICE_STR.equals(cmd)) {
                if (opti >= args.length) {
                    name = null;
                    newArgs = EMPTY_STRING_ARRAY;
                } else {
                    name = args[opti];
                    opti++;
                    newArgs2 = new String[(args.length - opti)];
                    if (args.length > 2) {
                        System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                    }
                }
                if (!this.mServices.dumpService(fd, pw, name, newArgs, 0, dumpAll)) {
                    pw.println("No services match: " + name);
                    pw.println("Use -h for help.");
                }
            } else if ("package".equals(cmd)) {
                if (opti >= args.length) {
                    pw.println("package: no package name specified");
                    pw.println("Use -h for help.");
                } else {
                    dumpPackage = args[opti];
                    opti++;
                    newArgs2 = new String[(args.length - opti)];
                    if (args.length > 2) {
                        System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                    }
                    Object args2 = newArgs2;
                    opti = 0;
                    more = true;
                }
            } else if ("associations".equals(cmd) || "as".equals(cmd)) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        dumpAssociationsLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("services".equals(cmd) || "s".equals(cmd)) {
                if (dumpClient) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            ServiceDumper dumper = this.mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage);
                            dumper.dumpWithClient();
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        this.mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage).dumpLocked();
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Binder.restoreCallingIdentity(origId);
            } else if ("oppo-log".equals(cmd)) {
                dynamicallyConfigLogTag(pw, args, opti);
            } else if ("get_value".equals(cmd)) {
                dynamicGetValue(pw, args);
                return;
            } else if ("debug_switch".equals(cmd)) {
                dumpDynamicallyLogSwitch(pw, args, opti);
            } else if ("locks".equals(cmd)) {
                LockGuard.dump(fd, pw, args);
            } else if ("coloros-log".equals(cmd)) {
                OppoDynamicLogManager.getInstance().handleOppoDynamicLog(pw, args, opti);
                return;
            } else if ("log".equals(cmd)) {
                configLogTag(pw, args, opti);
            } else if ("alog".equals(cmd)) {
                configActivityLogTag(pw, args, opti);
            } else if ("aal".equals(cmd)) {
                opti = AalUtils.getInstance(true).dump(pw, args, opti);
            } else if ("force_persist_junk_event".equals(cmd)) {
                if (opti == args.length) {
                    OppoJunkRecorder.getInstance().forcePersist(System.currentTimeMillis());
                    pw.println("All junk events persisted.");
                } else if ("resetEnable".equals(args[opti])) {
                    OppoJunkRecorder.getInstance().resetEnable();
                    pw.println("OppoJunkRecorder isEnable: " + OppoJunkRecorder.getInstance().isEnable());
                }
                return;
            } else if (!dumpActivity(fd, pw, cmd, args, opti, dumpAll)) {
                if (new ActivityManagerShellCommand(this, true).exec(this, null, fd, null, args, new ResultReceiver(null)) < 0) {
                    pw.println("Bad activity command, or no activities match: " + cmd);
                    pw.println("Use -h for help.");
                }
            }
            if (!more) {
                Binder.restoreCallingIdentity(origId);
                return;
            }
        }
        if (dumpCheckinFormat) {
            dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
        } else if (dumpClient) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    if (dumpAll || dumpPackage != null) {
                        dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                    }
                    dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    ServiceDumper sdumper = this.mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    sdumper.dumpWithClient();
                    pw.println();
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            if (dumpAll) {
                                pw.println("-------------------------------------------------------------------------------");
                            }
                            dumpRecentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                            pw.println();
                            if (dumpAll) {
                                pw.println("-------------------------------------------------------------------------------");
                            }
                            dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                            if (this.mAssociations.size() > 0) {
                                pw.println();
                                if (dumpAll) {
                                    pw.println("-------------------------------------------------------------------------------");
                                }
                                dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                            }
                            pw.println();
                            if (dumpAll) {
                                pw.println("-------------------------------------------------------------------------------");
                            }
                            dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } else {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    if (dumpAll || dumpPackage != null) {
                        dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                    }
                    dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    this.mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage).dumpLocked();
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    dumpRecentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                    if (this.mAssociations.size() > 0) {
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                    }
                    pw.println();
                    if (dumpAll) {
                        pw.println("-------------------------------------------------------------------------------");
                    }
                    dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
        pw.println("ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)");
        boolean printedAnything = this.mStackSupervisor.dumpActivitiesLocked(fd, pw, dumpAll, dumpClient, dumpPackage);
        boolean needSep = printedAnything;
        if (ActivityStackSupervisor.printThisActivity(pw, this.mFocusedActivity, dumpPackage, printedAnything, "  mFocusedActivity: ")) {
            printedAnything = true;
            needSep = false;
        }
        if (dumpPackage == null) {
            if (needSep) {
                pw.println();
            }
            printedAnything = true;
            this.mStackSupervisor.dump(pw, "  ");
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpRecentsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        pw.println("ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)");
        boolean printedAnything = false;
        if (this.mRecentTasks != null && this.mRecentTasks.size() > 0) {
            boolean printedHeader = false;
            int N = this.mRecentTasks.size();
            for (int i = 0; i < N; i++) {
                TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                if (dumpPackage == null || (tr.realActivity != null && dumpPackage.equals(tr.realActivity))) {
                    if (!printedHeader) {
                        pw.println("  Recent tasks:");
                        printedHeader = true;
                        printedAnything = true;
                    }
                    pw.print("  * Recent #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(tr);
                    if (dumpAll) {
                        ((TaskRecord) this.mRecentTasks.get(i)).dump(pw, "    ");
                    }
                }
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpAssociationsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
        pw.println("ACTIVITY MANAGER ASSOCIATIONS (dumpsys activity associations)");
        int dumpUid = 0;
        if (dumpPackage != null) {
            try {
                dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage, DumpState.DUMP_PREFERRED_XML, 0);
            } catch (RemoteException e) {
            }
        }
        boolean printedAnything = false;
        long now = SystemClock.uptimeMillis();
        int N1 = this.mAssociations.size();
        for (int i1 = 0; i1 < N1; i1++) {
            ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents = (ArrayMap) this.mAssociations.valueAt(i1);
            int N2 = targetComponents.size();
            for (int i2 = 0; i2 < N2; i2++) {
                SparseArray<ArrayMap<String, Association>> sourceUids = (SparseArray) targetComponents.valueAt(i2);
                int N3 = sourceUids.size();
                for (int i3 = 0; i3 < N3; i3++) {
                    ArrayMap<String, Association> sourceProcesses = (ArrayMap) sourceUids.valueAt(i3);
                    int N4 = sourceProcesses.size();
                    for (int i4 = 0; i4 < N4; i4++) {
                        Association ass = (Association) sourceProcesses.valueAt(i4);
                        if (dumpPackage == null || ass.mTargetComponent.getPackageName().equals(dumpPackage) || UserHandle.getAppId(ass.mSourceUid) == dumpUid) {
                            printedAnything = true;
                            pw.print("  ");
                            pw.print(ass.mTargetProcess);
                            pw.print("/");
                            UserHandle.formatUid(pw, ass.mTargetUid);
                            pw.print(" <- ");
                            pw.print(ass.mSourceProcess);
                            pw.print("/");
                            UserHandle.formatUid(pw, ass.mSourceUid);
                            pw.println();
                            pw.print("    via ");
                            pw.print(ass.mTargetComponent.flattenToShortString());
                            pw.println();
                            pw.print("    ");
                            long dur = ass.mTime;
                            if (ass.mNesting > 0) {
                                dur += now - ass.mStartTime;
                            }
                            TimeUtils.formatDuration(dur, pw);
                            pw.print(" (");
                            pw.print(ass.mCount);
                            pw.print(" times)");
                            pw.print("  ");
                            for (int i = 0; i < ass.mStateTimes.length; i++) {
                                long amt = ass.mStateTimes[i];
                                if (ass.mLastState + 1 == i) {
                                    amt += now - ass.mLastStateUptime;
                                }
                                if (amt != 0) {
                                    pw.print(" ");
                                    pw.print(ProcessList.makeProcStateString(i - 1));
                                    pw.print("=");
                                    TimeUtils.formatDuration(amt, pw);
                                    if (ass.mLastState + 1 == i) {
                                        pw.print("*");
                                    }
                                }
                            }
                            pw.println();
                            if (ass.mNesting > 0) {
                                pw.print("    Currently active: ");
                                TimeUtils.formatDuration(now - ass.mStartTime, pw);
                                pw.println();
                            }
                        }
                    }
                }
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    boolean dumpUids(PrintWriter pw, String dumpPackage, SparseArray<UidRecord> uids, String header, boolean needSep) {
        boolean printed = false;
        int whichAppId = -1;
        if (dumpPackage != null) {
            try {
                whichAppId = UserHandle.getAppId(this.mContext.getPackageManager().getApplicationInfo(dumpPackage, 0).uid);
            } catch (NameNotFoundException e) {
                e.printStackTrace();
            }
        }
        for (int i = 0; i < uids.size(); i++) {
            UidRecord uidRec = (UidRecord) uids.valueAt(i);
            if (dumpPackage == null || UserHandle.getAppId(uidRec.uid) == whichAppId) {
                if (!printed) {
                    printed = true;
                    if (needSep) {
                        pw.println();
                    }
                    pw.print("  ");
                    pw.println(header);
                    needSep = true;
                }
                pw.print("    UID ");
                UserHandle.formatUid(pw, uidRec.uid);
                pw.print(": ");
                pw.println(uidRec);
            }
        }
        return printed;
    }

    /* JADX WARNING: Missing block: B:176:0x066f, code:
            if (r46.equals(r40.mOrigDebugApp) != false) goto L_0x0671;
     */
    /* JADX WARNING: Missing block: B:207:0x07f3, code:
            if (r46.equals(r40.mTrackAllocationApp) != false) goto L_0x07f5;
     */
    /* JADX WARNING: Missing block: B:217:0x0830, code:
            if (r46.equals(r40.mProfileApp) != false) goto L_0x0832;
     */
    /* JADX WARNING: Missing block: B:225:0x08eb, code:
            if (r46.equals(r40.mNativeDebuggingApp) != false) goto L_0x08ed;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void dumpProcessesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        ProcessRecord r;
        boolean printed;
        int i;
        boolean needSep = false;
        boolean printedAnything = false;
        int numPers = 0;
        pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
        if (dumpAll) {
            int NP = this.mProcessNames.getMap().size();
            for (int ip = 0; ip < NP; ip++) {
                SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                int NA = procs.size();
                for (int ia = 0; ia < NA; ia++) {
                    r = (ProcessRecord) procs.valueAt(ia);
                    if (dumpPackage == null || r.pkgList.containsKey(dumpPackage)) {
                        if (!needSep) {
                            pw.println("  All known processes:");
                            needSep = true;
                            printedAnything = true;
                        }
                        pw.print(r.persistent ? "  *PERS*" : "  *APP*");
                        pw.print(" UID ");
                        pw.print(procs.keyAt(ia));
                        pw.print(" ");
                        pw.println(r);
                        r.dump(pw, "    ");
                        if (r.persistent) {
                            numPers++;
                        }
                    }
                }
            }
        }
        if (this.mIsolatedProcesses.size() > 0) {
            printed = false;
            for (i = 0; i < this.mIsolatedProcesses.size(); i++) {
                r = (ProcessRecord) this.mIsolatedProcesses.valueAt(i);
                if (dumpPackage == null || r.pkgList.containsKey(dumpPackage)) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        pw.println("  Isolated process list (sorted by uid):");
                        printedAnything = true;
                        printed = true;
                        needSep = true;
                    }
                    Object[] objArr = new Object[3];
                    objArr[0] = "    ";
                    objArr[1] = Integer.valueOf(i);
                    objArr[2] = r.toString();
                    pw.println(String.format("%sIsolated #%2d: %s", objArr));
                }
            }
        }
        if (this.mActiveUids.size() > 0) {
            if (dumpUids(pw, dumpPackage, this.mActiveUids, "UID states:", needSep)) {
                needSep = true;
                printedAnything = true;
            }
        }
        if (this.mValidateUids.size() > 0) {
            if (dumpUids(pw, dumpPackage, this.mValidateUids, "UID validation:", needSep)) {
                needSep = true;
                printedAnything = true;
            }
        }
        if (this.mLruProcesses.size() > 0) {
            if (needSep) {
                pw.println();
            }
            pw.print("  Process LRU list (sorted by oom_adj, ");
            pw.print(this.mLruProcesses.size());
            pw.print(" total, non-act at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessActivityStart);
            pw.print(", non-svc at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessServiceStart);
            pw.println("):");
            dumpProcessOomList(pw, this, this.mLruProcesses, "    ", "Proc", "PERS", false, dumpPackage);
            needSep = true;
            printedAnything = true;
        }
        if (dumpAll || dumpPackage != null) {
            synchronized (this.mPidsSelfLocked) {
                printed = false;
                for (i = 0; i < this.mPidsSelfLocked.size(); i++) {
                    r = (ProcessRecord) this.mPidsSelfLocked.valueAt(i);
                    if (dumpPackage == null || r.pkgList.containsKey(dumpPackage)) {
                        if (!printed) {
                            if (needSep) {
                                pw.println();
                            }
                            needSep = true;
                            pw.println("  PID mappings:");
                            printed = true;
                            printedAnything = true;
                        }
                        pw.print("    PID #");
                        pw.print(this.mPidsSelfLocked.keyAt(i));
                        pw.print(": ");
                        pw.println(this.mPidsSelfLocked.valueAt(i));
                    }
                }
            }
        }
        if (this.mForegroundProcesses.size() > 0) {
            synchronized (this.mPidsSelfLocked) {
                printed = false;
                for (i = 0; i < this.mForegroundProcesses.size(); i++) {
                    r = (ProcessRecord) this.mPidsSelfLocked.get(((ForegroundToken) this.mForegroundProcesses.valueAt(i)).pid);
                    if (dumpPackage == null || (r != null && r.pkgList.containsKey(dumpPackage))) {
                        if (!printed) {
                            if (needSep) {
                                pw.println();
                            }
                            needSep = true;
                            pw.println("  Foreground Processes:");
                            printed = true;
                            printedAnything = true;
                        }
                        pw.print("    PID #");
                        pw.print(this.mForegroundProcesses.keyAt(i));
                        pw.print(": ");
                        pw.println(this.mForegroundProcesses.valueAt(i));
                    }
                }
            }
        }
        if (this.mPersistentStartingProcesses.size() > 0) {
            if (needSep) {
                pw.println();
            }
            needSep = true;
            printedAnything = true;
            pw.println("  Persisent processes that are starting:");
            dumpProcessList(pw, this, this.mPersistentStartingProcesses, "    ", "Starting Norm", "Restarting PERS", dumpPackage);
        }
        if (this.mRemovedProcesses.size() > 0) {
            if (needSep) {
                pw.println();
            }
            needSep = true;
            printedAnything = true;
            pw.println("  Processes that are being removed:");
            dumpProcessList(pw, this, this.mRemovedProcesses, "    ", "Removed Norm", "Removed PERS", dumpPackage);
        }
        if (this.mProcessesOnHold.size() > 0) {
            if (needSep) {
                pw.println();
            }
            needSep = true;
            printedAnything = true;
            pw.println("  Processes that are on old until the system is ready:");
            dumpProcessList(pw, this, this.mProcessesOnHold, "    ", "OnHold Norm", "OnHold PERS", dumpPackage);
        }
        needSep = this.mAppErrors.dumpLocked(fd, pw, dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, dumpPackage), dumpPackage);
        if (needSep) {
            printedAnything = true;
        }
        if (dumpPackage == null) {
            pw.println();
            needSep = false;
            this.mUserController.dump(pw, dumpAll);
        }
        if (this.mHomeProcess != null && (dumpPackage == null || this.mHomeProcess.pkgList.containsKey(dumpPackage))) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mHomeProcess: " + this.mHomeProcess);
        }
        if (this.mPreviousProcess != null && (dumpPackage == null || this.mPreviousProcess.pkgList.containsKey(dumpPackage))) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mPreviousProcess: " + this.mPreviousProcess);
        }
        if (dumpAll) {
            StringBuilder stringBuilder = new StringBuilder(128);
            stringBuilder.append("  mPreviousProcessVisibleTime: ");
            TimeUtils.formatDuration(this.mPreviousProcessVisibleTime, stringBuilder);
            pw.println(stringBuilder);
        }
        if (this.mHeavyWeightProcess != null && (dumpPackage == null || this.mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mHeavyWeightProcess: " + this.mHeavyWeightProcess);
        }
        if (SystemProperties.get("ro.mtk_gmo_ram_optimize").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON) && this.mWallpaperProcess != null) {
            pw.println("  mWallpaperProcess: " + this.mWallpaperProcess + " fg: " + this.mIsWallpaperFg);
        }
        if (dumpPackage == null) {
            pw.println("  mConfiguration: " + this.mConfiguration);
        }
        if (dumpAll) {
            pw.println("  mConfigWillChange: " + getFocusedStack().mConfigWillChange);
            if (this.mCompatModePackages.getPackages().size() > 0) {
                printed = false;
                for (Entry<String, Integer> entry : this.mCompatModePackages.getPackages().entrySet()) {
                    String pkg = (String) entry.getKey();
                    int mode = ((Integer) entry.getValue()).intValue();
                    if (dumpPackage == null || dumpPackage.equals(pkg)) {
                        if (!printed) {
                            pw.println("  mScreenCompatPackages:");
                            printed = true;
                        }
                        pw.print("    ");
                        pw.print(pkg);
                        pw.print(": ");
                        pw.print(mode);
                        pw.println();
                    }
                }
            }
        }
        if (dumpPackage == null) {
            pw.println("  mWakefulness=" + PowerManagerInternal.wakefulnessToString(this.mWakefulness));
            pw.println("  mSleepTokens=" + this.mSleepTokens);
            pw.println("  mSleeping=" + this.mSleeping + " mLockScreenShown=" + lockScreenShownToString());
            pw.println("  mShuttingDown=" + this.mShuttingDown + " mTestPssMode=" + this.mTestPssMode);
            if (this.mRunningVoice != null) {
                pw.println("  mRunningVoice=" + this.mRunningVoice);
                pw.println("  mVoiceWakeLock" + this.mVoiceWakeLock);
            }
        }
        if (this.mDebugApp != null || this.mOrigDebugApp != null || this.mDebugTransient || this.mOrigWaitForDebugger) {
            if (dumpPackage != null) {
                if (!dumpPackage.equals(this.mDebugApp)) {
                }
            }
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mDebugApp=" + this.mDebugApp + "/orig=" + this.mOrigDebugApp + " mDebugTransient=" + this.mDebugTransient + " mOrigWaitForDebugger=" + this.mOrigWaitForDebugger);
        }
        if (this.mCurAppTimeTracker != null) {
            this.mCurAppTimeTracker.dumpWithHeader(pw, "  ", true);
        }
        if (this.mMemWatchProcesses.getMap().size() > 0) {
            pw.println("  Mem watch processes:");
            ArrayMap<String, SparseArray<Pair<Long, String>>> procs2 = this.mMemWatchProcesses.getMap();
            for (i = 0; i < procs2.size(); i++) {
                String proc = (String) procs2.keyAt(i);
                SparseArray<Pair<Long, String>> uids = (SparseArray) procs2.valueAt(i);
                for (int j = 0; j < uids.size(); j++) {
                    if (needSep) {
                        pw.println();
                        needSep = false;
                    }
                    StringBuilder sb = new StringBuilder();
                    sb.append("    ").append(proc).append('/');
                    UserHandle.formatUid(sb, uids.keyAt(j));
                    Pair<Long, String> val = (Pair) uids.valueAt(j);
                    sb.append(": ");
                    DebugUtils.sizeValueToString(((Long) val.first).longValue(), sb);
                    if (val.second != null) {
                        sb.append(", report to ").append((String) val.second);
                    }
                    pw.println(sb.toString());
                }
            }
            pw.print("  mMemWatchDumpProcName=");
            pw.println(this.mMemWatchDumpProcName);
            pw.print("  mMemWatchDumpFile=");
            pw.println(this.mMemWatchDumpFile);
            pw.print("  mMemWatchDumpPid=");
            pw.print(this.mMemWatchDumpPid);
            pw.print(" mMemWatchDumpUid=");
            pw.println(this.mMemWatchDumpUid);
        }
        if (this.mTrackAllocationApp != null) {
            if (dumpPackage != null) {
            }
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mTrackAllocationApp=" + this.mTrackAllocationApp);
        }
        if (!(this.mProfileApp == null && this.mProfileProc == null && this.mProfileFile == null && this.mProfileFd == null)) {
            if (dumpPackage != null) {
            }
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mProfileApp=" + this.mProfileApp + " mProfileProc=" + this.mProfileProc);
            pw.println("  mProfileFile=" + this.mProfileFile + " mProfileFd=" + this.mProfileFd);
            pw.println("  mSamplingInterval=" + this.mSamplingInterval + " mAutoStopProfiler=" + this.mAutoStopProfiler);
            pw.println("  mProfileType=" + this.mProfileType);
        }
        if (this.mNativeDebuggingApp != null) {
            if (dumpPackage != null) {
            }
            if (needSep) {
                pw.println();
            }
            pw.println("  mNativeDebuggingApp=" + this.mNativeDebuggingApp);
        }
        if (dumpPackage == null) {
            if (this.mAlwaysFinishActivities || this.mLenientBackgroundCheck) {
                pw.println("  mAlwaysFinishActivities=" + this.mAlwaysFinishActivities + " mLenientBackgroundCheck=" + this.mLenientBackgroundCheck);
            }
            if (this.mController != null) {
                pw.println("  mController=" + this.mController + " mControllerIsAMonkey=" + this.mControllerIsAMonkey);
            }
            if (dumpAll) {
                pw.println("  Total persistent processes: " + numPers);
                pw.println("  mProcessesReady=" + this.mProcessesReady + " mSystemReady=" + this.mSystemReady + " mBooted=" + this.mBooted + " mFactoryTest=" + this.mFactoryTest);
                pw.println("  mBooting=" + this.mBooting + " mCallFinishBooting=" + this.mCallFinishBooting + " mBootAnimationComplete=" + this.mBootAnimationComplete);
                pw.print("  mLastPowerCheckRealtime=");
                TimeUtils.formatDuration(this.mLastPowerCheckRealtime, pw);
                pw.println(IElsaManager.EMPTY_PACKAGE);
                pw.print("  mLastPowerCheckUptime=");
                TimeUtils.formatDuration(this.mLastPowerCheckUptime, pw);
                pw.println(IElsaManager.EMPTY_PACKAGE);
                pw.println("  mGoingToSleep=" + this.mStackSupervisor.mGoingToSleep);
                pw.println("  mLaunchingActivity=" + this.mStackSupervisor.mLaunchingActivity);
                pw.println("  mAdjSeq=" + this.mAdjSeq + " mLruSeq=" + this.mLruSeq);
                pw.println("  mNumNonCachedProcs=" + this.mNumNonCachedProcs + " (" + this.mLruProcesses.size() + " total)" + " mNumCachedHiddenProcs=" + this.mNumCachedHiddenProcs + " mNumServiceProcs=" + this.mNumServiceProcs + " mNewNumServiceProcs=" + this.mNewNumServiceProcs);
                pw.println("  mAllowLowerMemLevel=" + this.mAllowLowerMemLevel + " mLastMemoryLevel=" + this.mLastMemoryLevel + " mLastNumProcesses=" + this.mLastNumProcesses);
                long now = SystemClock.uptimeMillis();
                pw.print("  mLastIdleTime=");
                TimeUtils.formatDuration(now, this.mLastIdleTime, pw);
                pw.print(" mLowRamSinceLastIdle=");
                TimeUtils.formatDuration(getLowRamTimeSinceIdle(now), pw);
                pw.println();
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    boolean dumpProcessesToGc(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean needSep, boolean dumpAll, String dumpPackage) {
        if (this.mProcessesToGc.size() > 0) {
            boolean printed = false;
            long now = SystemClock.uptimeMillis();
            for (int i = 0; i < this.mProcessesToGc.size(); i++) {
                ProcessRecord proc = (ProcessRecord) this.mProcessesToGc.get(i);
                if (dumpPackage == null || dumpPackage.equals(proc.info.packageName)) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Processes that are waiting to GC:");
                        printed = true;
                    }
                    pw.print("    Process ");
                    pw.println(proc);
                    pw.print("      lowMem=");
                    pw.print(proc.reportLowMemory);
                    pw.print(", last gced=");
                    pw.print(now - proc.lastRequestedGc);
                    pw.print(" ms ago, last lowMem=");
                    pw.print(now - proc.lastLowMemory);
                    pw.println(" ms ago");
                }
            }
        }
        return needSep;
    }

    void printOomLevel(PrintWriter pw, String name, int adj) {
        pw.print("    ");
        if (adj >= 0) {
            pw.print(' ');
            if (adj < 10) {
                pw.print(' ');
            }
        } else if (adj > -10) {
            pw.print(' ');
        }
        pw.print(adj);
        pw.print(": ");
        pw.print(name);
        pw.print(" (");
        pw.print(stringifySize(this.mProcessList.getMemLevel(adj), 1024));
        pw.println(")");
    }

    boolean dumpOomLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll) {
        boolean needSep = false;
        if (this.mLruProcesses.size() > 0) {
            if (null != null) {
                pw.println();
            }
            pw.println("  OOM levels:");
            printOomLevel(pw, "SYSTEM_ADJ", -900);
            printOomLevel(pw, "PERSISTENT_PROC_ADJ", -800);
            printOomLevel(pw, "PERSISTENT_SERVICE_ADJ", -700);
            printOomLevel(pw, "FOREGROUND_APP_ADJ", 0);
            printOomLevel(pw, "VISIBLE_APP_ADJ", 100);
            printOomLevel(pw, "PERCEPTIBLE_APP_ADJ", 200);
            printOomLevel(pw, "BACKUP_APP_ADJ", 300);
            printOomLevel(pw, "HEAVY_WEIGHT_APP_ADJ", 400);
            printOomLevel(pw, "SERVICE_ADJ", 500);
            printOomLevel(pw, "HOME_APP_ADJ", 600);
            printOomLevel(pw, "PREVIOUS_APP_ADJ", START_OPPO_SITE_MSG);
            printOomLevel(pw, "SERVICE_B_ADJ", 800);
            printOomLevel(pw, "CACHED_APP_MIN_ADJ", 900);
            printOomLevel(pw, "CACHED_APP_MAX_ADJ", 906);
            if (true) {
                pw.println();
            }
            pw.print("  Process OOM control (");
            pw.print(this.mLruProcesses.size());
            pw.print(" total, non-act at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessActivityStart);
            pw.print(", non-svc at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessServiceStart);
            pw.println("):");
            dumpProcessOomList(pw, this, this.mLruProcesses, "    ", "Proc", "PERS", true, null);
            needSep = true;
        }
        dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, null);
        pw.println();
        pw.println("  mHomeProcess: " + this.mHomeProcess);
        pw.println("  mPreviousProcess: " + this.mPreviousProcess);
        if (this.mHeavyWeightProcess != null) {
            pw.println("  mHeavyWeightProcess: " + this.mHeavyWeightProcess);
        }
        if (SystemProperties.get("ro.mtk_gmo_ram_optimize").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON) && this.mWallpaperProcess != null) {
            pw.println("  mWallpaperProcess: " + this.mWallpaperProcess + " fg: " + this.mIsWallpaperFg);
        }
        return true;
    }

    protected boolean dumpProvider(FileDescriptor fd, PrintWriter pw, String name, String[] args, int opti, boolean dumpAll) {
        return this.mProviderMap.dumpProvider(fd, pw, name, args, opti, dumpAll);
    }

    protected boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name, String[] args, int opti, boolean dumpAll) {
        ArrayList<ActivityRecord> activities;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                activities = this.mStackSupervisor.getDumpActivitiesLocked(name);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (activities.size() <= 0) {
            return false;
        }
        String[] newArgs = new String[(args.length - opti)];
        System.arraycopy(args, opti, newArgs, 0, args.length - opti);
        TaskRecord lastTask = null;
        boolean needSep = false;
        for (int i = activities.size() - 1; i >= 0; i--) {
            ActivityRecord r = (ActivityRecord) activities.get(i);
            if (needSep) {
                pw.println();
            }
            needSep = true;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (lastTask != r.task) {
                        lastTask = r.task;
                        pw.print("TASK ");
                        pw.print(lastTask.affinity);
                        pw.print(" id=");
                        pw.println(lastTask.taskId);
                        if (dumpAll) {
                            lastTask.dump(pw, "  ");
                        }
                    }
                } catch (Throwable th2) {
                    resetPriorityAfterLockedSection();
                    throw th2;
                }
            }
            resetPriorityAfterLockedSection();
            dumpActivity("  ", fd, pw, (ActivityRecord) activities.get(i), newArgs, dumpAll);
        }
        return true;
    }

    private void dumpActivity(String prefix, FileDescriptor fd, PrintWriter pw, ActivityRecord r, String[] args, boolean dumpAll) {
        String innerPrefix = prefix + "  ";
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                pw.print(prefix);
                pw.print("ACTIVITY ");
                pw.print(r.shortComponentName);
                pw.print(" ");
                pw.print(Integer.toHexString(System.identityHashCode(r)));
                pw.print(" pid=");
                if (r.app != null) {
                    pw.println(r.app.pid);
                } else {
                    pw.println("(not running)");
                }
                if (dumpAll) {
                    r.dump(pw, innerPrefix);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (r.app != null && r.app.thread != null) {
            pw.flush();
            TransferPipe tp;
            try {
                tp = new TransferPipe();
                r.app.thread.dumpActivity(tp.getWriteFd().getFileDescriptor(), r.appToken, innerPrefix, args);
                tp.go(fd);
                tp.kill();
            } catch (IOException e) {
                pw.println(innerPrefix + "Failure while dumping the activity: " + e);
            } catch (RemoteException e2) {
                pw.println(innerPrefix + "Got a RemoteException while dumping the activity");
            } catch (Throwable th) {
                tp.kill();
            }
        }
    }

    void dumpBroadcastsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean needSep = false;
        boolean onlyHistory = false;
        int printedAnything = false;
        if ("history".equals(dumpPackage)) {
            if (opti < args.length && "-s".equals(args[opti])) {
                dumpAll = false;
            }
            onlyHistory = true;
            dumpPackage = null;
        }
        pw.println("ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts)");
        if (!onlyHistory && dumpAll) {
            if (this.mRegisteredReceivers.size() > 0) {
                boolean printed = false;
                for (ReceiverList r : this.mRegisteredReceivers.values()) {
                    if (dumpPackage != null) {
                        if (r.app != null) {
                            if (!dumpPackage.equals(r.app.info.packageName)) {
                            }
                        }
                    }
                    if (!printed) {
                        pw.println("  Registered Receivers:");
                        needSep = true;
                        printed = true;
                        boolean printedAnything2 = true;
                    }
                    pw.print("  * ");
                    pw.println(r);
                    r.dump(pw, "    ");
                }
            }
            if (this.mReceiverResolver.dump(pw, needSep ? "\n  Receiver Resolver Table:" : "  Receiver Resolver Table:", "    ", dumpPackage, false, false)) {
                needSep = true;
                printedAnything = true;
            }
        }
        BroadcastQueue[] broadcastQueueArr = this.mBroadcastQueues;
        int i = 0;
        int length = broadcastQueueArr.length;
        while (true) {
            int i2 = i;
            if (i2 >= length) {
                break;
            }
            needSep = broadcastQueueArr[i2].dumpLocked(fd, pw, args, opti, dumpAll, dumpPackage, needSep);
            printedAnything |= needSep;
            i = i2 + 1;
        }
        needSep = true;
        if (!(onlyHistory || this.mStickyBroadcasts == null || dumpPackage != null)) {
            for (int user = 0; user < this.mStickyBroadcasts.size(); user++) {
                if (needSep) {
                    pw.println();
                }
                needSep = true;
                printedAnything = 1;
                pw.print("  Sticky broadcasts for user ");
                pw.print(this.mStickyBroadcasts.keyAt(user));
                pw.println(":");
                StringBuilder sb = new StringBuilder(128);
                for (Entry<String, ArrayList<Intent>> ent : ((ArrayMap) this.mStickyBroadcasts.valueAt(user)).entrySet()) {
                    pw.print("  * Sticky action ");
                    pw.print((String) ent.getKey());
                    if (dumpAll) {
                        pw.println(":");
                        ArrayList<Intent> intents = (ArrayList) ent.getValue();
                        int N = intents.size();
                        for (int i3 = 0; i3 < N; i3++) {
                            sb.setLength(0);
                            sb.append("    Intent: ");
                            ((Intent) intents.get(i3)).toShortString(sb, false, true, false, false);
                            pw.println(sb.toString());
                            Bundle bundle = ((Intent) intents.get(i3)).getExtras();
                            if (bundle != null) {
                                pw.print("      ");
                                pw.println(bundle.toString());
                            }
                        }
                    } else {
                        pw.println(IElsaManager.EMPTY_PACKAGE);
                    }
                }
            }
        }
        if (!onlyHistory && dumpAll) {
            pw.println();
            for (BroadcastQueue queue : this.mBroadcastQueues) {
                pw.println("  mBroadcastsScheduled [" + queue.mQueueName + "]=" + queue.mBroadcastsScheduled);
            }
            pw.println("  mHandler:");
            this.mHandler.dump(new PrintWriterPrinter(pw), "    ");
            printedAnything = 1;
        }
        if (printedAnything == 0) {
            pw.println("  (nothing)");
        }
    }

    void dumpBroadcastStatsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        if (this.mCurBroadcastStats != null) {
            pw.println("ACTIVITY MANAGER BROADCAST STATS STATE (dumpsys activity broadcast-stats)");
            long now = SystemClock.elapsedRealtime();
            if (this.mLastBroadcastStats != null) {
                pw.print("  Last stats (from ");
                TimeUtils.formatDuration(this.mLastBroadcastStats.mStartRealtime, now, pw);
                pw.print(" to ");
                TimeUtils.formatDuration(this.mLastBroadcastStats.mEndRealtime, now, pw);
                pw.print(", ");
                TimeUtils.formatDuration(this.mLastBroadcastStats.mEndUptime - this.mLastBroadcastStats.mStartUptime, pw);
                pw.println(" uptime):");
                if (!this.mLastBroadcastStats.dumpStats(pw, "    ", dumpPackage)) {
                    pw.println("    (nothing)");
                }
                pw.println();
            }
            pw.print("  Current stats (from ");
            TimeUtils.formatDuration(this.mCurBroadcastStats.mStartRealtime, now, pw);
            pw.print(" to now, ");
            TimeUtils.formatDuration(SystemClock.uptimeMillis() - this.mCurBroadcastStats.mStartUptime, pw);
            pw.println(" uptime):");
            if (!this.mCurBroadcastStats.dumpStats(pw, "    ", dumpPackage)) {
                pw.println("    (nothing)");
            }
        }
    }

    void dumpBroadcastStatsCheckinLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean fullCheckin, String dumpPackage) {
        if (this.mCurBroadcastStats != null) {
            if (this.mLastBroadcastStats != null) {
                this.mLastBroadcastStats.dumpCheckinStats(pw, dumpPackage);
                if (fullCheckin) {
                    this.mLastBroadcastStats = null;
                    return;
                }
            }
            this.mCurBroadcastStats.dumpCheckinStats(pw, dumpPackage);
            if (fullCheckin) {
                this.mCurBroadcastStats = null;
            }
        }
    }

    void dumpProvidersLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        new ItemMatcher().build(args, opti);
        pw.println("ACTIVITY MANAGER CONTENT PROVIDERS (dumpsys activity providers)");
        boolean needSep = this.mProviderMap.dumpProvidersLocked(pw, dumpAll, dumpPackage);
        boolean z = needSep;
        if (this.mLaunchingProviders.size() > 0) {
            boolean printed = false;
            for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
                ContentProviderRecord r = (ContentProviderRecord) this.mLaunchingProviders.get(i);
                if (dumpPackage == null || dumpPackage.equals(r.name.getPackageName())) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Launching content providers:");
                        printed = true;
                        z = true;
                    }
                    pw.print("  Launching #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(r);
                }
            }
        }
        if (!z) {
            pw.println("  (nothing)");
        }
    }

    void dumpPermissionsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean needSep = false;
        boolean printedAnything = false;
        pw.println("ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)");
        if (this.mGrantedUriPermissions.size() > 0) {
            boolean printed = false;
            int dumpUid = -2;
            if (dumpPackage != null) {
                try {
                    dumpUid = this.mContext.getPackageManager().getPackageUidAsUser(dumpPackage, DumpState.DUMP_PREFERRED_XML, 0);
                } catch (NameNotFoundException e) {
                    dumpUid = -1;
                }
            }
            for (int i = 0; i < this.mGrantedUriPermissions.size(); i++) {
                int uid = this.mGrantedUriPermissions.keyAt(i);
                if (dumpUid < -1 || UserHandle.getAppId(uid) == dumpUid) {
                    ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.valueAt(i);
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Granted Uri Permissions:");
                        printed = true;
                        printedAnything = true;
                    }
                    pw.print("  * UID ");
                    pw.print(uid);
                    pw.println(" holds:");
                    for (UriPermission perm : perms.values()) {
                        pw.print("    ");
                        pw.println(perm);
                        if (dumpAll) {
                            perm.dump(pw, "      ");
                        }
                    }
                }
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpPendingIntentsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean printed = false;
        pw.println("ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents)");
        if (this.mIntentSenderRecords.size() > 0) {
            for (WeakReference<PendingIntentRecord> ref : this.mIntentSenderRecords.values()) {
                PendingIntentRecord rec = ref != null ? (PendingIntentRecord) ref.get() : null;
                if (dumpPackage == null || (rec != null && dumpPackage.equals(rec.key.packageName))) {
                    printed = true;
                    if (rec != null) {
                        pw.print("  * ");
                        pw.println(rec);
                        if (dumpAll) {
                            rec.dump(pw, "    ");
                        }
                    } else {
                        pw.print("  * ");
                        pw.println(ref);
                    }
                }
            }
        }
        if (!printed) {
            pw.println("  (nothing)");
        }
    }

    private static final int dumpProcessList(PrintWriter pw, ActivityManagerService service, List list, String prefix, String normalLabel, String persistentLabel, String dumpPackage) {
        int numPers = 0;
        for (int i = list.size() - 1; i >= 0; i--) {
            ProcessRecord r = (ProcessRecord) list.get(i);
            if (dumpPackage == null || dumpPackage.equals(r.info.packageName)) {
                Object obj;
                String str = "%s%s #%2d: %s";
                Object[] objArr = new Object[4];
                objArr[0] = prefix;
                if (r.persistent) {
                    obj = persistentLabel;
                } else {
                    String obj2 = normalLabel;
                }
                objArr[1] = obj2;
                objArr[2] = Integer.valueOf(i);
                objArr[3] = r.toString();
                pw.println(String.format(str, objArr));
                if (r.persistent) {
                    numPers++;
                }
            }
        }
        return numPers;
    }

    private static final boolean dumpProcessOomList(PrintWriter pw, ActivityManagerService service, List<ProcessRecord> origList, String prefix, String normalLabel, String persistentLabel, boolean inclDetails, String dumpPackage) {
        int i;
        ProcessRecord r;
        ArrayList<Pair<ProcessRecord, Integer>> list = new ArrayList(origList.size());
        for (i = 0; i < origList.size(); i++) {
            r = (ProcessRecord) origList.get(i);
            if (dumpPackage == null || r.pkgList.containsKey(dumpPackage)) {
                list.add(new Pair((ProcessRecord) origList.get(i), Integer.valueOf(i)));
            }
        }
        if (list.size() <= 0) {
            return false;
        }
        Collections.sort(list, new Comparator<Pair<ProcessRecord, Integer>>() {
            public int compare(Pair<ProcessRecord, Integer> object1, Pair<ProcessRecord, Integer> object2) {
                int i = -1;
                if (((ProcessRecord) object1.first).setAdj != ((ProcessRecord) object2.first).setAdj) {
                    return ((ProcessRecord) object1.first).setAdj > ((ProcessRecord) object2.first).setAdj ? -1 : 1;
                } else if (((ProcessRecord) object1.first).setProcState != ((ProcessRecord) object2.first).setProcState) {
                    if (((ProcessRecord) object1.first).setProcState <= ((ProcessRecord) object2.first).setProcState) {
                        i = 1;
                    }
                    return i;
                } else if (((Integer) object1.second).intValue() == ((Integer) object2.second).intValue()) {
                    return 0;
                } else {
                    if (((Integer) object1.second).intValue() <= ((Integer) object2.second).intValue()) {
                        i = 1;
                    }
                    return i;
                }
            }
        });
        long curRealtime = SystemClock.elapsedRealtime();
        long realtimeSince = curRealtime - service.mLastPowerCheckRealtime;
        long uptimeSince = SystemClock.uptimeMillis() - service.mLastPowerCheckUptime;
        for (i = list.size() - 1; i >= 0; i--) {
            char schedGroup;
            char foreground;
            String str;
            r = (ProcessRecord) ((Pair) list.get(i)).first;
            String oomAdj = ProcessList.makeOomAdjString(r.setAdj);
            switch (r.setSchedGroup) {
                case 0:
                    schedGroup = 'B';
                    break;
                case 1:
                    schedGroup = 'F';
                    break;
                case 2:
                    schedGroup = 'T';
                    break;
                default:
                    schedGroup = '?';
                    break;
            }
            if (r.foregroundActivities) {
                foreground = 'A';
            } else if (r.foregroundServices) {
                foreground = 'S';
            } else {
                foreground = ' ';
            }
            String procState = ProcessList.makeProcStateString(r.curProcState);
            pw.print(prefix);
            if (r.persistent) {
                str = persistentLabel;
            } else {
                str = normalLabel;
            }
            pw.print(str);
            pw.print(" #");
            int num = (origList.size() - 1) - ((Integer) ((Pair) list.get(i)).second).intValue();
            if (num < 10) {
                pw.print(' ');
            }
            pw.print(num);
            pw.print(": ");
            pw.print(oomAdj);
            pw.print(' ');
            pw.print(schedGroup);
            pw.print('/');
            pw.print(foreground);
            pw.print('/');
            pw.print(procState);
            pw.print(" trm:");
            if (r.trimMemoryLevel < 10) {
                pw.print(' ');
            }
            pw.print(r.trimMemoryLevel);
            pw.print(' ');
            pw.print(r.toShortString());
            pw.print(" (");
            pw.print(r.adjType);
            pw.println(')');
            if (!(r.adjSource == null && r.adjTarget == null)) {
                pw.print(prefix);
                pw.print("    ");
                if (r.adjTarget instanceof ComponentName) {
                    pw.print(((ComponentName) r.adjTarget).flattenToShortString());
                } else if (r.adjTarget != null) {
                    pw.print(r.adjTarget.toString());
                } else {
                    pw.print("{null}");
                }
                pw.print("<=");
                if (r.adjSource instanceof ProcessRecord) {
                    pw.print("Proc{");
                    pw.print(((ProcessRecord) r.adjSource).toShortString());
                    pw.println("}");
                } else if (r.adjSource != null) {
                    pw.println(r.adjSource.toString());
                } else {
                    pw.println("{null}");
                }
            }
            if (inclDetails) {
                pw.print(prefix);
                pw.print("    ");
                pw.print("oom: max=");
                pw.print(r.maxAdj);
                pw.print(" curRaw=");
                pw.print(r.curRawAdj);
                pw.print(" setRaw=");
                pw.print(r.setRawAdj);
                pw.print(" cur=");
                pw.print(r.curAdj);
                pw.print(" set=");
                pw.println(r.setAdj);
                pw.print(prefix);
                pw.print("    ");
                pw.print("state: cur=");
                pw.print(ProcessList.makeProcStateString(r.curProcState));
                pw.print(" set=");
                pw.print(ProcessList.makeProcStateString(r.setProcState));
                pw.print(" lastPss=");
                DebugUtils.printSizeValue(pw, r.lastPss * 1024);
                pw.print(" lastSwapPss=");
                DebugUtils.printSizeValue(pw, r.lastSwapPss * 1024);
                pw.print(" lastCachedPss=");
                DebugUtils.printSizeValue(pw, r.lastCachedPss * 1024);
                pw.println();
                pw.print(prefix);
                pw.print("    ");
                pw.print("cached=");
                pw.print(r.cached);
                pw.print(" empty=");
                pw.print(r.empty);
                pw.print(" hasAboveClient=");
                pw.println(r.hasAboveClient);
                if (r.setProcState < 10) {
                    continue;
                } else {
                    long timeUsed;
                    if (r.lastWakeTime != 0) {
                        long wtime;
                        BatteryStatsImpl stats = service.mBatteryStatsService.getActiveStatistics();
                        synchronized (stats) {
                            wtime = stats.getProcessWakeTime(r.info.uid, r.pid, curRealtime);
                        }
                        timeUsed = wtime - r.lastWakeTime;
                        pw.print(prefix);
                        pw.print("    ");
                        pw.print("keep awake over ");
                        TimeUtils.formatDuration(realtimeSince, pw);
                        pw.print(" used ");
                        TimeUtils.formatDuration(timeUsed, pw);
                        pw.print(" (");
                        pw.print((100 * timeUsed) / realtimeSince);
                        pw.println("%)");
                    }
                    if (r.lastCpuTime != 0) {
                        timeUsed = r.curCpuTime - r.lastCpuTime;
                        pw.print(prefix);
                        pw.print("    ");
                        pw.print("run cpu over ");
                        TimeUtils.formatDuration(uptimeSince, pw);
                        pw.print(" used ");
                        TimeUtils.formatDuration(timeUsed, pw);
                        pw.print(" (");
                        pw.print((100 * timeUsed) / uptimeSince);
                        pw.println("%)");
                    }
                }
            }
        }
        return true;
    }

    /* JADX WARNING: Missing block: B:39:0x0078, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:40:0x007b, code:
            return r4;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    ArrayList<ProcessRecord> collectProcesses(PrintWriter pw, int start, boolean allPkgs, String[] args) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs;
                if (args == null || args.length <= start || args[start].charAt(0) == '-') {
                    procs = new ArrayList(this.mLruProcesses);
                } else {
                    procs = new ArrayList();
                    int pid = -1;
                    try {
                        pid = Integer.parseInt(args[start]);
                    } catch (NumberFormatException e) {
                    }
                    for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord proc = (ProcessRecord) this.mLruProcesses.get(i);
                        if (proc.pid == pid) {
                            procs.add(proc);
                        } else if (allPkgs && proc.pkgList != null && proc.pkgList.containsKey(args[start])) {
                            procs.add(proc);
                        } else if (proc.processName.equals(args[start])) {
                            procs.add(proc);
                        }
                    }
                    if (procs.size() <= 0) {
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    final void dumpGraphicsHardwareUsage(FileDescriptor fd, PrintWriter pw, String[] args) {
        ArrayList<ProcessRecord> procs = collectProcesses(pw, 0, false, args);
        if (procs == null) {
            pw.println("No process found for: " + args[0]);
            return;
        }
        long uptime = SystemClock.uptimeMillis();
        long realtime = SystemClock.elapsedRealtime();
        pw.println("Applications Graphics Acceleration Info:");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
        for (int i = procs.size() - 1; i >= 0; i--) {
            ProcessRecord r = (ProcessRecord) procs.get(i);
            if (r.thread != null) {
                pw.println("\n** Graphics info for pid " + r.pid + " [" + r.processName + "] **");
                pw.flush();
                TransferPipe tp;
                try {
                    tp = new TransferPipe();
                    r.thread.dumpGfxInfo(tp.getWriteFd().getFileDescriptor(), args);
                    tp.go(fd);
                    tp.kill();
                } catch (IOException e) {
                    pw.println("Failure while dumping the app: " + r);
                    pw.flush();
                } catch (RemoteException e2) {
                    pw.println("Got a RemoteException while dumping the app " + r);
                    pw.flush();
                } catch (Throwable th) {
                    tp.kill();
                }
            }
        }
    }

    final void dumpDbInfo(FileDescriptor fd, PrintWriter pw, String[] args) {
        ArrayList<ProcessRecord> procs = collectProcesses(pw, 0, false, args);
        if (procs == null) {
            pw.println("No process found for: " + args[0]);
            return;
        }
        pw.println("Applications Database Info:");
        for (int i = procs.size() - 1; i >= 0; i--) {
            ProcessRecord r = (ProcessRecord) procs.get(i);
            if (r.thread != null) {
                pw.println("\n** Database info for pid " + r.pid + " [" + r.processName + "] **");
                pw.flush();
                TransferPipe tp;
                try {
                    tp = new TransferPipe();
                    r.thread.dumpDbInfo(tp.getWriteFd().getFileDescriptor(), args);
                    tp.go(fd);
                    tp.kill();
                } catch (IOException e) {
                    pw.println("Failure while dumping the app: " + r);
                    pw.flush();
                } catch (RemoteException e2) {
                    pw.println("Got a RemoteException while dumping the app " + r);
                    pw.flush();
                } catch (Throwable th) {
                    tp.kill();
                }
            }
        }
    }

    static final void dumpMemItems(PrintWriter pw, String prefix, String tag, ArrayList<MemItem> items, boolean sort, boolean isCompact, boolean dumpSwapPss) {
        if (sort && !isCompact) {
            Collections.sort(items, new Comparator<MemItem>() {
                public int compare(MemItem lhs, MemItem rhs) {
                    if (lhs.pss < rhs.pss) {
                        return 1;
                    }
                    if (lhs.pss > rhs.pss) {
                        return -1;
                    }
                    return 0;
                }
            });
        }
        for (int i = 0; i < items.size(); i++) {
            MemItem mi = (MemItem) items.get(i);
            Object[] objArr;
            if (isCompact) {
                if (mi.isProc) {
                    pw.print("proc,");
                    pw.print(tag);
                    pw.print(",");
                    pw.print(mi.shortLabel);
                    pw.print(",");
                    pw.print(mi.id);
                    pw.print(",");
                    pw.print(mi.pss);
                    pw.print(",");
                    pw.print(dumpSwapPss ? Long.valueOf(mi.swapPss) : "N/A");
                    pw.println(mi.hasActivities ? ",a" : ",e");
                } else {
                    pw.print(tag);
                    pw.print(",");
                    pw.print(mi.shortLabel);
                    pw.print(",");
                    pw.print(mi.pss);
                    pw.print(",");
                    pw.println(dumpSwapPss ? Long.valueOf(mi.swapPss) : "N/A");
                }
            } else if (dumpSwapPss) {
                objArr = new Object[4];
                objArr[0] = prefix;
                objArr[1] = stringifyKBSize(mi.pss);
                objArr[2] = mi.label;
                objArr[3] = stringifyKBSize(mi.swapPss);
                pw.printf("%s%s: %-60s (%s in swap)\n", objArr);
            } else {
                objArr = new Object[3];
                objArr[0] = prefix;
                objArr[1] = stringifyKBSize(mi.pss);
                objArr[2] = mi.label;
                pw.printf("%s%s: %s\n", objArr);
            }
            if (mi.subitems != null) {
                dumpMemItems(pw, prefix + "    ", mi.shortLabel, mi.subitems, true, isCompact, dumpSwapPss);
            }
        }
    }

    static final void appendMemBucket(StringBuilder out, long memKB, String label, boolean stackLike) {
        int start = label.lastIndexOf(46);
        if (start >= 0) {
            start++;
        } else {
            start = 0;
        }
        int end = label.length();
        for (int i = 0; i < DUMP_MEM_BUCKETS.length; i++) {
            if (DUMP_MEM_BUCKETS[i] >= memKB) {
                out.append(DUMP_MEM_BUCKETS[i] / 1024);
                out.append(stackLike ? "MB." : "MB ");
                out.append(label, start, end);
                return;
            }
        }
        out.append(memKB / 1024);
        out.append(stackLike ? "MB." : "MB ");
        out.append(label, start, end);
    }

    private final void dumpApplicationMemoryUsageHeader(PrintWriter pw, long uptime, long realtime, boolean isCheckinRequest, boolean isCompact) {
        if (isCompact) {
            pw.print("version,");
            pw.println(1);
        }
        if (isCheckinRequest || isCompact) {
            pw.print("time,");
            pw.print(uptime);
            pw.print(",");
            pw.println(realtime);
            return;
        }
        pw.println("Applications Memory Usage (in Kilobytes):");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
    }

    private final long[] getKsmInfo() {
        long[] longOut = new long[4];
        int[] SINGLE_LONG_FORMAT = new int[1];
        SINGLE_LONG_FORMAT[0] = 8224;
        long[] longTmp = new long[1];
        Process.readProcFile("/sys/kernel/mm/ksm/pages_shared", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[0] = (longTmp[0] * 4096) / 1024;
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_sharing", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[1] = (longTmp[0] * 4096) / 1024;
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_unshared", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[2] = (longTmp[0] * 4096) / 1024;
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_volatile", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[3] = (longTmp[0] * 4096) / 1024;
        return longOut;
    }

    private static String stringifySize(long size, int order) {
        Locale locale = Locale.US;
        Object[] objArr;
        switch (order) {
            case 1:
                objArr = new Object[1];
                objArr[0] = Long.valueOf(size);
                return String.format(locale, "%,13d", objArr);
            case 1024:
                objArr = new Object[1];
                objArr[0] = Long.valueOf(size / 1024);
                return String.format(locale, "%,9dK", objArr);
            case DumpState.DUMP_DEXOPT /*1048576*/:
                objArr = new Object[1];
                objArr[0] = Long.valueOf((size / 1024) / 1024);
                return String.format(locale, "%,5dM", objArr);
            case 1073741824:
                objArr = new Object[1];
                objArr[0] = Long.valueOf(((size / 1024) / 1024) / 1024);
                return String.format(locale, "%,1dG", objArr);
            default:
                throw new IllegalArgumentException("Invalid size order");
        }
    }

    private static String stringifyKBSize(long size) {
        return stringifySize(1024 * size, 1024);
    }

    /* JADX WARNING: Missing block: B:228:0x070c, code:
            r84 = new java.util.ArrayList();
            r84.add(new com.android.server.am.ActivityManagerService.MemItem("Native", "Native", r114, r116, -1));
            r39 = new com.android.server.am.ActivityManagerService.MemItem("Dalvik", "Dalvik", r86, r90, -2);
     */
    /* JADX WARNING: Missing block: B:229:0x073d, code:
            if (r85.length <= 0) goto L_0x076e;
     */
    /* JADX WARNING: Missing block: B:230:0x073f, code:
            r39.subitems = new java.util.ArrayList();
            r48 = 0;
     */
    /* JADX WARNING: Missing block: B:232:0x074f, code:
            if (r48 >= r85.length) goto L_0x076e;
     */
    /* JADX WARNING: Missing block: B:233:0x0751, code:
            r42 = android.os.Debug.MemoryInfo.getOtherLabel(r48 + 17);
            r39.subitems.add(new com.android.server.am.ActivityManagerService.MemItem(r42, r42, r85[r48], r88[r48], r48));
            r48 = r48 + 1;
     */
    /* JADX WARNING: Missing block: B:234:0x076e, code:
            r84.add(r39);
            r84.add(new com.android.server.am.ActivityManagerService.MemItem("Unknown", "Unknown", r52, r54, -3));
            r48 = 0;
     */
    /* JADX WARNING: Missing block: B:236:0x078f, code:
            if (r48 >= 17) goto L_0x07ac;
     */
    /* JADX WARNING: Missing block: B:237:0x0791, code:
            r58 = android.os.Debug.MemoryInfo.getOtherLabel(r48);
            r84.add(new com.android.server.am.ActivityManagerService.MemItem(r58, r58, r111[r48], r112[r48], r48));
            r48 = r48 + 1;
     */
    /* JADX WARNING: Missing block: B:238:0x07ac, code:
            r120 = new java.util.ArrayList();
            r48 = 0;
     */
    /* JADX WARNING: Missing block: B:240:0x07b8, code:
            if (r48 >= r123.length) goto L_0x07ec;
     */
    /* JADX WARNING: Missing block: B:242:0x07c0, code:
            if (r123[r48] == 0) goto L_0x07e4;
     */
    /* JADX WARNING: Missing block: B:243:0x07c2, code:
            if (r13 == false) goto L_0x07e7;
     */
    /* JADX WARNING: Missing block: B:244:0x07c4, code:
            r58 = DUMP_MEM_OOM_COMPACT_LABEL[r48];
     */
    /* JADX WARNING: Missing block: B:245:0x07c8, code:
            r57 = new com.android.server.am.ActivityManagerService.MemItem(r58, r58, r123[r48], r124[r48], DUMP_MEM_OOM_ADJ[r48]);
            r57.subitems = r122[r48];
            r120.add(r57);
     */
    /* JADX WARNING: Missing block: B:246:0x07e4, code:
            r48 = r48 + 1;
     */
    /* JADX WARNING: Missing block: B:247:0x07e7, code:
            r58 = DUMP_MEM_OOM_LABEL[r48];
     */
    /* JADX WARNING: Missing block: B:248:0x07ec, code:
            if (r65 == false) goto L_0x0be6;
     */
    /* JADX WARNING: Missing block: B:249:0x07ee, code:
            if (r98 == false) goto L_0x0be6;
     */
    /* JADX WARNING: Missing block: B:251:0x07f4, code:
            if (r138 == 0) goto L_0x0be6;
     */
    /* JADX WARNING: Missing block: B:252:0x07f6, code:
            r65 = true;
     */
    /* JADX WARNING: Missing block: B:253:0x07f8, code:
            if (r147 != false) goto L_0x07fc;
     */
    /* JADX WARNING: Missing block: B:254:0x07fa, code:
            if (r121 == false) goto L_0x0bea;
     */
    /* JADX WARNING: Missing block: B:255:0x07fc, code:
            if (r13 != false) goto L_0x0806;
     */
    /* JADX WARNING: Missing block: B:256:0x07fe, code:
            r144.println("Total PSS by OOM adjustment:");
     */
    /* JADX WARNING: Missing block: B:257:0x0806, code:
            dumpMemItems(r144, "  ", "oom", r120, false, r13, r65);
     */
    /* JADX WARNING: Missing block: B:258:0x0817, code:
            if (r147 != false) goto L_0x081b;
     */
    /* JADX WARNING: Missing block: B:259:0x0819, code:
            if (r121 == false) goto L_0x0c0d;
     */
    /* JADX WARNING: Missing block: B:260:0x081b, code:
            if (r13 != false) goto L_0x0820;
     */
    /* JADX WARNING: Missing block: B:261:0x081d, code:
            r144.println();
     */
    /* JADX WARNING: Missing block: B:262:0x0820, code:
            r105 = new com.android.internal.util.MemInfoReader();
            r105.readMemInfo();
            r105.readExtraMemInfo();
     */
    /* JADX WARNING: Missing block: B:263:0x082f, code:
            if (r76 <= 0) goto L_0x0871;
     */
    /* JADX WARNING: Missing block: B:264:0x0831, code:
            monitor-enter(r142);
     */
    /* JADX WARNING: Missing block: B:266:?, code:
            boostPriorityForLockedSection();
            r78 = r105.getCachedSizeKb();
            r96 = r105.getFreeSizeKb();
            r140 = r105.getZramTotalSizeKb();
            r102 = r105.getKernelUsedSizeKb();
            com.android.server.am.EventLogTags.writeAmMeminfo(r78 * 1024, r96 * 1024, r140 * 1024, r102 * 1024, r76 * 1024);
            r142.mProcessStats.addSysMemUsageLocked(r78, r96, r140, r102, r76);
     */
    /* JADX WARNING: Missing block: B:299:0x0be6, code:
            r65 = false;
     */
    /* JADX WARNING: Missing block: B:300:0x0bea, code:
            if (r13 != false) goto L_0x07fc;
     */
    /* JADX WARNING: Missing block: B:301:0x0bec, code:
            r144.println();
            r144.println("Total PSS by process:");
            dumpMemItems(r144, "  ", "proc", r128, true, r13, r65);
            r144.println();
     */
    /* JADX WARNING: Missing block: B:302:0x0c0d, code:
            if (r148 == null) goto L_0x0c2f;
     */
    /* JADX WARNING: Missing block: B:303:0x0c0f, code:
            r59 = r148;
     */
    /* JADX WARNING: Missing block: B:304:0x0c11, code:
            if (r13 != false) goto L_0x0c1e;
     */
    /* JADX WARNING: Missing block: B:305:0x0c13, code:
            r59.println();
            r59.println("Total PSS by category:");
     */
    /* JADX WARNING: Missing block: B:306:0x0c1e, code:
            dumpMemItems(r59, "  ", "cat", r84, true, r13, r65);
     */
    /* JADX WARNING: Missing block: B:307:0x0c2f, code:
            r59 = r144;
     */
    /* JADX WARNING: Missing block: B:309:0x0c34, code:
            resetPriorityAfterLockedSection();
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void dumpApplicationMemoryUsage(FileDescriptor fd, PrintWriter pw, String prefix, String[] args, boolean brief, PrintWriter categoryPw) {
        int i;
        MemoryInfo mi;
        int pid;
        Object innerArgs;
        ArrayList<MemItem> procMems;
        SparseArray<MemItem> procMemsMap;
        long nativePss;
        long nativeSwapPss;
        long dalvikPss;
        long dalvikSwapPss;
        long[] dalvikSubitemPss;
        long[] dalvikSubitemSwapPss;
        long otherPss;
        long otherSwapPss;
        long[] miscPss;
        long[] miscSwapPss;
        long[] oomPss;
        long[] oomSwapPss;
        ArrayList<MemItem>[] oomProcs;
        long totalPss;
        long totalSwapPss;
        long cachedPss;
        long cachedSwapPss;
        boolean hasSwapPss;
        ProcessRecord r;
        IApplicationThread iApplicationThread;
        int oomAdj;
        boolean hasActivities;
        MemoryInfo mi2;
        long myTotalPss;
        long myTotalSwapPss;
        int j;
        long mem;
        Throwable th;
        boolean dumpDetails = false;
        boolean dumpFullDetails = false;
        boolean dumpDalvik = false;
        boolean dumpSummaryOnly = false;
        boolean dumpUnreachable = false;
        boolean oomOnly = false;
        boolean isCompact = false;
        boolean localOnly = false;
        boolean packages = false;
        boolean isCheckinRequest = false;
        boolean dumpSwapPss = false;
        int opti = 0;
        while (opti < args.length) {
            String opt = args[opti];
            if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
                break;
            }
            opti++;
            if ("-a".equals(opt)) {
                dumpDetails = true;
                dumpFullDetails = true;
                dumpDalvik = true;
                dumpSwapPss = true;
            } else if ("-d".equals(opt)) {
                dumpDalvik = true;
            } else if ("-c".equals(opt)) {
                isCompact = true;
            } else if ("-s".equals(opt)) {
                dumpDetails = true;
                dumpSummaryOnly = true;
            } else if ("-S".equals(opt)) {
                dumpSwapPss = true;
            } else if ("--unreachable".equals(opt)) {
                dumpUnreachable = true;
            } else if ("--oom".equals(opt)) {
                oomOnly = true;
            } else if ("--local".equals(opt)) {
                localOnly = true;
            } else if ("--package".equals(opt)) {
                packages = true;
            } else if ("--checkin".equals(opt)) {
                isCheckinRequest = true;
            } else if ("-h".equals(opt)) {
                pw.println("meminfo dump options: [-a] [-d] [-c] [-s] [--oom] [process]");
                pw.println("  -a: include all available information for each process.");
                pw.println("  -d: include dalvik details.");
                pw.println("  -c: dump in a compact machine-parseable representation.");
                pw.println("  -s: dump only summary of application memory usage.");
                pw.println("  -S: dump also SwapPss.");
                pw.println("  --oom: only show processes organized by oom adj.");
                pw.println("  --local: only collect details locally, don't call process.");
                pw.println("  --package: interpret process arg as package, dumping all");
                pw.println("             processes that have loaded that package.");
                pw.println("  --checkin: dump data for a checkin");
                pw.println("If [process] is specified it can be the name or ");
                pw.println("pid of a specific process to dump.");
                return;
            } else {
                pw.println("Unknown argument: " + opt + "; use -h for help");
            }
        }
        long uptime = SystemClock.uptimeMillis();
        long realtime = SystemClock.elapsedRealtime();
        long[] tmpLong = new long[1];
        ArrayList<ProcessRecord> procs = collectProcesses(pw, opti, packages, args);
        int N;
        Stats st;
        if (procs == null) {
            if (!(args == null || args.length <= opti || args[opti].charAt(0) == '-')) {
                ArrayList<Stats> nativeProcs = new ArrayList();
                updateCpuStatsNow();
                int findPid = -1;
                try {
                    findPid = Integer.parseInt(args[opti]);
                } catch (NumberFormatException e) {
                }
                synchronized (this.mProcessCpuTracker) {
                    N = this.mProcessCpuTracker.countStats();
                    for (i = 0; i < N; i++) {
                        st = this.mProcessCpuTracker.getStats(i);
                        if (st.pid == findPid || (st.baseName != null && st.baseName.equals(args[opti]))) {
                            nativeProcs.add(st);
                        }
                    }
                }
                if (nativeProcs.size() > 0) {
                    dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
                    mi = null;
                    for (i = nativeProcs.size() - 1; i >= 0; i--) {
                        Stats r2 = (Stats) nativeProcs.get(i);
                        pid = r2.pid;
                        if (!isCheckinRequest && dumpDetails) {
                            pw.println("\n** MEMINFO in pid " + pid + " [" + r2.baseName + "] **");
                        }
                        if (mi == null) {
                            mi = new MemoryInfo();
                        }
                        if (dumpDetails || !(brief || oomOnly)) {
                            Debug.getMemoryInfo(pid, mi);
                        } else {
                            mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                            mi.dalvikPrivateDirty = (int) tmpLong[0];
                        }
                        ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, r2.baseName, 0, 0, 0, 0, 0, 0);
                        if (isCheckinRequest) {
                            pw.println();
                        }
                    }
                    return;
                }
            }
            pw.println("No process found for: " + args[opti]);
            return;
        }
        if (!(brief || oomOnly || (procs.size() != 1 && !isCheckinRequest && !packages))) {
            dumpDetails = true;
        }
        dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
        innerArgs = new String[(args.length - opti)];
        System.arraycopy(args, opti, innerArgs, 0, args.length - opti);
        procMems = new ArrayList();
        procMemsMap = new SparseArray();
        nativePss = 0;
        nativeSwapPss = 0;
        dalvikPss = 0;
        dalvikSwapPss = 0;
        if (dumpDalvik) {
            dalvikSubitemPss = new long[8];
        } else {
            dalvikSubitemPss = EmptyArray.LONG;
        }
        if (dumpDalvik) {
            dalvikSubitemSwapPss = new long[8];
        } else {
            dalvikSubitemSwapPss = EmptyArray.LONG;
        }
        otherPss = 0;
        otherSwapPss = 0;
        miscPss = new long[17];
        miscSwapPss = new long[17];
        oomPss = new long[DUMP_MEM_OOM_LABEL.length];
        oomSwapPss = new long[DUMP_MEM_OOM_LABEL.length];
        oomProcs = new ArrayList[DUMP_MEM_OOM_LABEL.length];
        totalPss = 0;
        totalSwapPss = 0;
        cachedPss = 0;
        cachedSwapPss = 0;
        hasSwapPss = false;
        mi = null;
        i = procs.size() - 1;
        while (i >= 0) {
            r = (ProcessRecord) procs.get(i);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    iApplicationThread = r.thread;
                    pid = r.pid;
                    oomAdj = r.getSetAdjWithServices();
                    hasActivities = r.activities.size() > 0;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        long nativeProcTotalPss = 0;
        if (!(isCheckinRequest || procs.size() <= 1 || packages)) {
            updateCpuStatsNow();
            mi = null;
            synchronized (this.mProcessCpuTracker) {
                try {
                    N = this.mProcessCpuTracker.countStats();
                    i = 0;
                    while (true) {
                        mi2 = mi;
                        if (i >= N) {
                            break;
                        }
                        try {
                            st = this.mProcessCpuTracker.getStats(i);
                            if (st.vsize > 0) {
                                if (procMemsMap.indexOfKey(st.pid) < 0) {
                                    if (mi2 == null) {
                                        mi = new MemoryInfo();
                                    } else {
                                        mi = mi2;
                                    }
                                    if (brief || oomOnly) {
                                        mi.nativePss = (int) Debug.getPss(st.pid, tmpLong, null);
                                        mi.nativePrivateDirty = (int) tmpLong[0];
                                    } else {
                                        Debug.getMemoryInfo(st.pid, mi);
                                    }
                                    myTotalPss = (long) mi.getTotalPss();
                                    myTotalSwapPss = (long) mi.getTotalSwappedOutPss();
                                    totalPss += myTotalPss;
                                    nativeProcTotalPss += myTotalPss;
                                    MemItem memItem = new MemItem(st.name + " (pid " + st.pid + ")", st.name, myTotalPss, (long) mi.getSummaryTotalSwapPss(), st.pid, false);
                                    procMems.add(memItem);
                                    nativePss += (long) mi.nativePss;
                                    nativeSwapPss += (long) mi.nativeSwappedOutPss;
                                    dalvikPss += (long) mi.dalvikPss;
                                    dalvikSwapPss += (long) mi.dalvikSwappedOutPss;
                                    for (j = 0; j < dalvikSubitemPss.length; j++) {
                                        dalvikSubitemPss[j] = dalvikSubitemPss[j] + ((long) mi.getOtherPss(j + 17));
                                        dalvikSubitemSwapPss[j] = dalvikSubitemSwapPss[j] + ((long) mi.getOtherSwappedOutPss(j + 17));
                                    }
                                    otherPss += (long) mi.otherPss;
                                    otherSwapPss += (long) mi.otherSwappedOutPss;
                                    for (j = 0; j < 17; j++) {
                                        mem = (long) mi.getOtherPss(j);
                                        miscPss[j] = miscPss[j] + mem;
                                        otherPss -= mem;
                                        mem = (long) mi.getOtherSwappedOutPss(j);
                                        miscSwapPss[j] = miscSwapPss[j] + mem;
                                        otherSwapPss -= mem;
                                    }
                                    oomPss[0] = oomPss[0] + myTotalPss;
                                    oomSwapPss[0] = oomSwapPss[0] + myTotalSwapPss;
                                    if (oomProcs[0] == null) {
                                        oomProcs[0] = new ArrayList();
                                    }
                                    oomProcs[0].add(memItem);
                                    i++;
                                }
                            }
                            mi = mi2;
                            i++;
                        } catch (Throwable th2) {
                            th = th2;
                            mi = mi2;
                            throw th;
                        }
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        }
        return;
        if (!brief) {
            if (isCompact) {
                pw.print("ram,");
                pw.print(memInfo.getTotalSizeKb());
                pw.print(",");
                pw.print((memInfo.getCachedSizeKb() + cachedPss) + memInfo.getFreeSizeKb());
                pw.print(",");
                pw.println(totalPss - cachedPss);
            } else {
                pw.print("Total RAM: ");
                pw.print(stringifyKBSize(memInfo.getTotalSizeKb()));
                pw.print(" (status ");
                switch (this.mLastMemoryLevel) {
                    case 0:
                        pw.println("normal)");
                        break;
                    case 1:
                        pw.println("moderate)");
                        break;
                    case 2:
                        pw.println("low)");
                        break;
                    case 3:
                        pw.println("critical)");
                        break;
                    default:
                        pw.print(this.mLastMemoryLevel);
                        pw.println(")");
                        break;
                }
                pw.print(" Free RAM: ");
                pw.print(stringifyKBSize((((memInfo.getCachedSizeKb() + cachedPss) + (memInfo.getRawInfo()[13] * 4)) + (memInfo.getRawInfo()[14] * 4)) + memInfo.getFreeSizeKb()));
                pw.print(" (");
                pw.print(stringifyKBSize(cachedPss));
                pw.print(" cached pss + ");
                pw.print(stringifyKBSize(memInfo.getCachedSizeKb()));
                pw.print(" cached kernel + ");
                pw.print(stringifyKBSize(memInfo.getFreeSizeKb()));
                pw.print(" free + ");
                pw.print(stringifyKBSize(memInfo.getRawInfo()[13] * 4));
                pw.print(" ion cached + ");
                pw.print(stringifyKBSize(memInfo.getRawInfo()[14] * 4));
                pw.println(" gpu cached)");
            }
        }
        long lostRAM = (((((((((memInfo.getTotalSizeKb() - (totalPss - totalSwapPss)) - memInfo.getFreeSizeKb()) - memInfo.getCachedSizeKb()) - (memInfo.getRawInfo()[13] * 4)) - (memInfo.getRawInfo()[14] * 4)) - memInfo.getRawInfo()[16]) - memInfo.getRawInfo()[15]) - memInfo.getRawInfo()[17]) - memInfo.getKernelUsedSizeKb()) - memInfo.getZramTotalSizeKb();
        if (isCompact) {
            pw.print("lostram,");
            pw.println(lostRAM);
        } else {
            pw.print(" Used RAM: ");
            pw.print(stringifyKBSize(((((totalPss - cachedPss) + memInfo.getRawInfo()[16]) + memInfo.getRawInfo()[15]) + memInfo.getRawInfo()[17]) + memInfo.getKernelUsedSizeKb()));
            pw.print(" (");
            pw.print(stringifyKBSize(totalPss - cachedPss));
            pw.print(" used pss + ");
            pw.print(stringifyKBSize(memInfo.getKernelUsedSizeKb()));
            pw.print(" kernel + ");
            pw.print(stringifyKBSize(memInfo.getRawInfo()[16]));
            pw.print(" trace buffer + ");
            pw.print(stringifyKBSize(memInfo.getRawInfo()[15]));
            pw.print(" ion disp + ");
            pw.print(stringifyKBSize(memInfo.getRawInfo()[17]));
            pw.print(" cma usage)\n");
            if (SystemProperties.getBoolean("persist.version.confidential", false)) {
                pw.print("UFree RAM: ");
                pw.println(stringifySize(Process.getFreeMemory(), 1024));
            }
            pw.print(" Lost RAM: ");
            pw.println(stringifyKBSize(lostRAM));
        }
        if (brief) {
            mi = mi2;
        } else {
            if (memInfo.getZramTotalSizeKb() != 0) {
                if (isCompact) {
                    pw.print("zram,");
                    pw.print(memInfo.getZramTotalSizeKb());
                    pw.print(",");
                    pw.print(memInfo.getSwapTotalSizeKb());
                    pw.print(",");
                    pw.println(memInfo.getSwapFreeSizeKb());
                } else {
                    pw.print("     ZRAM: ");
                    pw.print(stringifyKBSize(memInfo.getZramTotalSizeKb()));
                    pw.print(" physical used for ");
                    pw.print(stringifyKBSize(memInfo.getSwapTotalSizeKb() - memInfo.getSwapFreeSizeKb()));
                    pw.print(" in swap (");
                    pw.print(stringifyKBSize(memInfo.getSwapTotalSizeKb()));
                    pw.println(" total swap)");
                }
            }
            long[] ksm = getKsmInfo();
            if (isCompact) {
                pw.print("ksm,");
                pw.print(ksm[1]);
                pw.print(",");
                pw.print(ksm[0]);
                pw.print(",");
                pw.print(ksm[2]);
                pw.print(",");
                pw.println(ksm[3]);
                pw.print("tuning,");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(',');
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print(',');
                pw.print(this.mProcessList.getMemLevel(906) / 1024);
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(",low-ram");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(",high-end-gfx");
                }
                pw.println();
                mi = mi2;
            } else {
                if (!(ksm[1] == 0 && ksm[0] == 0 && ksm[2] == 0 && ksm[3] == 0)) {
                    pw.print("      KSM: ");
                    pw.print(stringifyKBSize(ksm[1]));
                    pw.print(" saved from shared ");
                    pw.print(stringifyKBSize(ksm[0]));
                    pw.print("           ");
                    pw.print(stringifyKBSize(ksm[2]));
                    pw.print(" unshared; ");
                    pw.print(stringifyKBSize(ksm[3]));
                    pw.println(" volatile");
                }
                pw.print("   Tuning: ");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(" (large ");
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print("), oom ");
                pw.print(stringifySize(this.mProcessList.getMemLevel(906), 1024));
                pw.print(", restore limit ");
                pw.print(stringifyKBSize(this.mProcessList.getCachedRestoreThresholdKb()));
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(" (low-ram)");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(" (high-end-gfx)");
                }
                pw.println();
                mi = mi2;
            }
        }
        return;
        if (iApplicationThread != null) {
            if (!isCheckinRequest && dumpDetails) {
                pw.println("\n** MEMINFO in pid " + pid + " [" + r.processName + "] **");
            }
            if (mi == null) {
                mi = new MemoryInfo();
            }
            if (dumpDetails || !(brief || oomOnly)) {
                Debug.getMemoryInfo(pid, mi);
                hasSwapPss = mi.hasSwappedOutPss;
            } else {
                mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                mi.dalvikPrivateDirty = (int) tmpLong[0];
            }
            if (dumpDetails) {
                if (localOnly) {
                    iApplicationThread = r.processName;
                    ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, iApplicationThread, 0, 0, 0, 0, 0, 0);
                    if (isCheckinRequest) {
                        pw.println();
                    }
                } else {
                    try {
                        pw.flush();
                        OppoProcessManagerHelper.resumeProcessForSystemCall(r);
                        iApplicationThread.dumpMemInfo(fd, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, dumpUnreachable, innerArgs);
                    } catch (RemoteException e2) {
                        if (!isCheckinRequest) {
                            pw.println("Got RemoteException!");
                            pw.flush();
                        }
                    }
                }
            }
            myTotalPss = (long) mi.getTotalPss();
            long myTotalUss = (long) mi.getTotalUss();
            myTotalSwapPss = (long) mi.getTotalSwappedOutPss();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (r.thread != null && oomAdj == r.getSetAdjWithServices()) {
                        r.baseProcessTracker.addPss(myTotalPss, myTotalUss, true, r.pkgList);
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        i--;
        if (!(isCheckinRequest || mi == null)) {
            totalPss += myTotalPss;
            totalSwapPss += myTotalSwapPss;
            MemItem pssItem = new MemItem(r.processName + " (pid " + pid + (hasActivities ? " / activities)" : ")"), r.processName, myTotalPss, myTotalSwapPss, pid, hasActivities);
            procMems.add(pssItem);
            procMemsMap.put(pid, pssItem);
            nativePss += (long) mi.nativePss;
            nativeSwapPss += (long) mi.nativeSwappedOutPss;
            dalvikPss += (long) mi.dalvikPss;
            dalvikSwapPss += (long) mi.dalvikSwappedOutPss;
            for (j = 0; j < dalvikSubitemPss.length; j++) {
                dalvikSubitemPss[j] = dalvikSubitemPss[j] + ((long) mi.getOtherPss(j + 17));
                dalvikSubitemSwapPss[j] = dalvikSubitemSwapPss[j] + ((long) mi.getOtherSwappedOutPss(j + 17));
            }
            otherPss += (long) mi.otherPss;
            otherSwapPss += (long) mi.otherSwappedOutPss;
            for (j = 0; j < 17; j++) {
                mem = (long) mi.getOtherPss(j);
                miscPss[j] = miscPss[j] + mem;
                otherPss -= mem;
                mem = (long) mi.getOtherSwappedOutPss(j);
                miscSwapPss[j] = miscSwapPss[j] + mem;
                otherSwapPss -= mem;
            }
            if (oomAdj >= 900) {
                cachedPss += myTotalPss;
                cachedSwapPss += myTotalSwapPss;
            }
            int oomIndex = 0;
            while (oomIndex < oomPss.length) {
                if (oomIndex == oomPss.length - 1 || (oomAdj >= DUMP_MEM_OOM_ADJ[oomIndex] && oomAdj < DUMP_MEM_OOM_ADJ[oomIndex + 1])) {
                    oomPss[oomIndex] = oomPss[oomIndex] + myTotalPss;
                    oomSwapPss[oomIndex] = oomSwapPss[oomIndex] + myTotalSwapPss;
                    if (oomProcs[oomIndex] == null) {
                        oomProcs[oomIndex] = new ArrayList();
                    }
                    oomProcs[oomIndex].add(pssItem);
                } else {
                    oomIndex++;
                }
            }
        }
        i--;
    }

    private void appendBasicMemEntry(StringBuilder sb, int oomAdj, int procState, long pss, long memtrack, String name) {
        sb.append("  ");
        sb.append(ProcessList.makeOomAdjString(oomAdj));
        sb.append(' ');
        sb.append(ProcessList.makeProcStateString(procState));
        sb.append(' ');
        ProcessList.appendRamKb(sb, pss);
        sb.append(": ");
        sb.append(name);
        if (memtrack > 0) {
            sb.append(" (");
            sb.append(stringifyKBSize(memtrack));
            sb.append(" memtrack)");
        }
    }

    private void appendMemInfo(StringBuilder sb, ProcessMemInfo mi) {
        appendBasicMemEntry(sb, mi.oomAdj, mi.procState, mi.pss, mi.memtrack, mi.name);
        sb.append(" (pid ");
        sb.append(mi.pid);
        sb.append(") ");
        sb.append(mi.adjType);
        sb.append(10);
        if (mi.adjReason != null) {
            sb.append("                      ");
            sb.append(mi.adjReason);
            sb.append(10);
        }
    }

    /* JADX WARNING: Missing block: B:58:0x01cd, code:
            if (((com.android.server.am.ProcessMemInfo) r59.get(r36 + 1)).oomAdj != r41) goto L_0x01cf;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void reportMemUsage(ArrayList<ProcessMemInfo> memInfos) {
        int i;
        ProcessMemInfo mi;
        List<Stats> stats;
        SparseArray<ProcessMemInfo> sparseArray = new SparseArray(memInfos.size());
        int N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            sparseArray.put(mi.pid, mi);
        }
        updateCpuStatsNow();
        long[] memtrackTmp = new long[1];
        synchronized (this.mProcessCpuTracker) {
            stats = this.mProcessCpuTracker.getStats(new -void_reportMemUsage_java_util_ArrayList_memInfos_LambdaImpl0());
        }
        int statsCount = stats.size();
        for (i = 0; i < statsCount; i++) {
            Stats st = (Stats) stats.get(i);
            long pss = Debug.getPss(st.pid, null, memtrackTmp);
            if (pss > 0) {
                if (sparseArray.indexOfKey(st.pid) < 0) {
                    mi = new ProcessMemInfo(st.name, st.pid, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, "native", null);
                    mi.pss = pss;
                    mi.memtrack = memtrackTmp[0];
                    memInfos.add(mi);
                }
            }
        }
        long totalPss = 0;
        long totalMemtrack = 0;
        N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.pss == 0) {
                mi.pss = Debug.getPss(mi.pid, null, memtrackTmp);
                mi.memtrack = memtrackTmp[0];
            }
            totalPss += mi.pss;
            totalMemtrack += mi.memtrack;
        }
        Collections.sort(memInfos, new Comparator<ProcessMemInfo>() {
            public int compare(ProcessMemInfo lhs, ProcessMemInfo rhs) {
                int i = 1;
                int i2 = -1;
                if (lhs.oomAdj != rhs.oomAdj) {
                    if (lhs.oomAdj >= rhs.oomAdj) {
                        i2 = 1;
                    }
                    return i2;
                } else if (lhs.pss == rhs.pss) {
                    return 0;
                } else {
                    if (lhs.pss >= rhs.pss) {
                        i = -1;
                    }
                    return i;
                }
            }
        });
        StringBuilder stringBuilder = new StringBuilder(128);
        stringBuilder = new StringBuilder(128);
        stringBuilder.append("Low on memory -- ");
        appendMemBucket(stringBuilder, totalPss, "total", false);
        appendMemBucket(stringBuilder, totalPss, "total", true);
        stringBuilder = new StringBuilder(1024);
        StringBuilder shortNativeBuilder = new StringBuilder(1024);
        stringBuilder = new StringBuilder(1024);
        boolean firstLine = true;
        int lastOomAdj = Integer.MIN_VALUE;
        long extraNativeRam = 0;
        long extraNativeMemtrack = 0;
        long cachedPss = 0;
        i = 0;
        N = memInfos.size();
        while (i < N) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.oomAdj >= 900) {
                cachedPss += mi.pss;
            }
            if (mi.oomAdj != JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE && (mi.oomAdj < 500 || mi.oomAdj == 600 || mi.oomAdj == START_OPPO_SITE_MSG)) {
                if (lastOomAdj != mi.oomAdj) {
                    lastOomAdj = mi.oomAdj;
                    if (mi.oomAdj <= 0) {
                        stringBuilder.append(" / ");
                    }
                    if (mi.oomAdj >= 0) {
                        if (firstLine) {
                            stringBuilder.append(":");
                            firstLine = false;
                        }
                        stringBuilder.append("\n\t at ");
                    } else {
                        stringBuilder.append("$");
                    }
                } else {
                    stringBuilder.append(" ");
                    stringBuilder.append("$");
                }
                if (mi.oomAdj <= 0) {
                    appendMemBucket(stringBuilder, mi.pss, mi.name, false);
                }
                appendMemBucket(stringBuilder, mi.pss, mi.name, true);
                if (mi.oomAdj >= 0) {
                    if (i + 1 < N) {
                    }
                    stringBuilder.append("(");
                    for (int k = 0; k < DUMP_MEM_OOM_ADJ.length; k++) {
                        if (DUMP_MEM_OOM_ADJ[k] == mi.oomAdj) {
                            stringBuilder.append(DUMP_MEM_OOM_LABEL[k]);
                            stringBuilder.append(":");
                            stringBuilder.append(DUMP_MEM_OOM_ADJ[k]);
                        }
                    }
                    stringBuilder.append(")");
                }
            }
            appendMemInfo(stringBuilder, mi);
            if (mi.oomAdj != JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE) {
                if (extraNativeRam > 0) {
                    appendBasicMemEntry(shortNativeBuilder, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, extraNativeRam, extraNativeMemtrack, "(Other native)");
                    shortNativeBuilder.append(10);
                    extraNativeRam = 0;
                }
                appendMemInfo(stringBuilder, mi);
            } else if (mi.pss >= 512) {
                appendMemInfo(shortNativeBuilder, mi);
            } else {
                extraNativeRam += mi.pss;
                extraNativeMemtrack += mi.memtrack;
            }
            i++;
        }
        stringBuilder.append("           ");
        ProcessList.appendRamKb(stringBuilder, totalPss);
        stringBuilder.append(": TOTAL");
        if (totalMemtrack > 0) {
            stringBuilder.append(" (");
            stringBuilder.append(stringifyKBSize(totalMemtrack));
            stringBuilder.append(" memtrack)");
        }
        stringBuilder.append("\n");
        MemInfoReader memInfo = new MemInfoReader();
        memInfo.readMemInfo();
        long[] infos = memInfo.getRawInfo();
        stringBuilder = new StringBuilder(1024);
        Debug.getMemInfo(infos);
        stringBuilder.append("  MemInfo: ");
        stringBuilder.append(stringifyKBSize(infos[5])).append(" slab, ");
        stringBuilder.append(stringifyKBSize(infos[4])).append(" shmem, ");
        stringBuilder.append(stringifyKBSize(infos[10])).append(" vm alloc, ");
        stringBuilder.append(stringifyKBSize(infos[11])).append(" page tables ");
        stringBuilder.append(stringifyKBSize(infos[12])).append(" kernel stack\n");
        stringBuilder.append("           ");
        stringBuilder.append(stringifyKBSize(infos[2])).append(" buffers, ");
        stringBuilder.append(stringifyKBSize(infos[3])).append(" cached, ");
        stringBuilder.append(stringifyKBSize(infos[9])).append(" mapped, ");
        stringBuilder.append(stringifyKBSize(infos[1])).append(" free\n");
        if (infos[8] != 0) {
            stringBuilder.append("  ZRAM: ");
            stringBuilder.append(stringifyKBSize(infos[8]));
            stringBuilder.append(" RAM, ");
            stringBuilder.append(stringifyKBSize(infos[6]));
            stringBuilder.append(" swap total, ");
            stringBuilder.append(stringifyKBSize(infos[7]));
            stringBuilder.append(" swap free\n");
        }
        long[] ksm = getKsmInfo();
        if (!(ksm[1] == 0 && ksm[0] == 0 && ksm[2] == 0 && ksm[3] == 0)) {
            stringBuilder.append("  KSM: ");
            stringBuilder.append(stringifyKBSize(ksm[1]));
            stringBuilder.append(" saved from shared ");
            stringBuilder.append(stringifyKBSize(ksm[0]));
            stringBuilder.append("\n       ");
            stringBuilder.append(stringifyKBSize(ksm[2]));
            stringBuilder.append(" unshared; ");
            stringBuilder.append(stringifyKBSize(ksm[3]));
            stringBuilder.append(" volatile\n");
        }
        stringBuilder.append("  Free RAM: ");
        stringBuilder.append(stringifyKBSize((memInfo.getCachedSizeKb() + cachedPss) + memInfo.getFreeSizeKb()));
        stringBuilder.append("\n");
        stringBuilder.append("  Used RAM: ");
        stringBuilder.append(stringifyKBSize((totalPss - cachedPss) + memInfo.getKernelUsedSizeKb()));
        stringBuilder.append("\n");
        stringBuilder.append("  Lost RAM: ");
        stringBuilder.append(stringifyKBSize(((((memInfo.getTotalSizeKb() - totalPss) - memInfo.getFreeSizeKb()) - memInfo.getCachedSizeKb()) - memInfo.getKernelUsedSizeKb()) - memInfo.getZramTotalSizeKb()));
        stringBuilder.append("\n");
        Slog.i(TAG, "Low on memory:");
        Slog.i(TAG, shortNativeBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        stringBuilder = new StringBuilder(1024);
        stringBuilder.append("Low on memory:");
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        Writer catSw = new StringWriter();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                PrintWriter fastPrintWriter = new FastPrintWriter(catSw, false, 256);
                String[] emptyArgs = new String[0];
                fastPrintWriter.println();
                dumpProcessesLocked(null, fastPrintWriter, emptyArgs, 0, false, null);
                fastPrintWriter.println();
                this.mServices.newServiceDumperLocked(null, fastPrintWriter, emptyArgs, 0, false, null).dumpLocked();
                fastPrintWriter.println();
                dumpActivitiesLocked(null, fastPrintWriter, emptyArgs, 0, false, false, null);
                fastPrintWriter.flush();
                stringBuilder.append(catSw.toString());
                addErrorToDropBox("lowmem", null, "system_server", null, null, stringBuilder.toString(), stringBuilder.toString(), null, null);
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        long now = SystemClock.uptimeMillis();
                        if (this.mLastMemUsageReportTime < now) {
                            this.mLastMemUsageReportTime = now;
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* renamed from: -com_android_server_am_ActivityManagerService_lambda$2 */
    static /* synthetic */ boolean m3-com_android_server_am_ActivityManagerService_lambda$2(Stats st) {
        return st.vsize > 0;
    }

    private static boolean scanArgs(String[] args, String value) {
        if (args != null) {
            for (String arg : args) {
                if (value.equals(arg)) {
                    return true;
                }
            }
        }
        return false;
    }

    @OppoHook(level = OppoHookType.CHANGE_ACCESS, note = "ZhiYong.Lin@Plf.Framework, [-private]modify for BPM", property = OppoRomType.ROM)
    final boolean removeDyingProviderLocked(ProcessRecord proc, ContentProviderRecord cpr, boolean always) {
        boolean inLaunching = this.mLaunchingProviders.contains(cpr);
        if (!inLaunching || always) {
            synchronized (cpr) {
                cpr.launchingApp = null;
                cpr.notifyAll();
            }
            this.mProviderMap.removeProviderByClass(cpr.name, UserHandle.getUserId(cpr.uid));
            String[] names = cpr.info.authority.split(";");
            for (String removeProviderByName : names) {
                this.mProviderMap.removeProviderByName(removeProviderByName, UserHandle.getUserId(cpr.uid));
            }
        }
        for (int i = cpr.connections.size() - 1; i >= 0; i--) {
            ContentProviderConnection conn = (ContentProviderConnection) cpr.connections.get(i);
            if (!conn.waiting || !inLaunching || always) {
                ProcessRecord capp = conn.client;
                conn.dead = true;
                if (conn.stableCount > 0) {
                    if (!(capp.persistent || capp.thread == null || capp.pid == 0 || capp.pid == MY_PID)) {
                        capp.kill("depends on provider " + cpr.name.flattenToShortString() + " in dying proc " + (proc != null ? proc.processName : "??") + " (adj " + (proc != null ? Integer.valueOf(proc.setAdj) : "??") + ")", true);
                    }
                } else if (!(capp.thread == null || conn.provider.provider == null)) {
                    try {
                        capp.thread.unstableProviderDied(conn.provider.provider.asBinder());
                    } catch (RemoteException e) {
                    }
                    cpr.connections.remove(i);
                    if (conn.client.conProviders.remove(conn)) {
                        stopAssociationLocked(capp.uid, capp.processName, cpr.uid, cpr.name);
                    }
                }
            }
        }
        if (inLaunching && always) {
            this.mLaunchingProviders.remove(cpr);
        }
        return inLaunching;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    private final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) {
        int i;
        Slog.d(TAG, "cleanUpApplicationRecord -- " + app.pid);
        if (index >= 0) {
            removeLruProcessLocked(app);
            ProcessList.remove(app.pid);
        }
        this.mProcessesToGc.remove(app);
        this.mPendingPssProcesses.remove(app);
        try {
            if (!(app.crashDialog == null || app.forceCrashReport)) {
                app.crashDialog.dismiss();
                app.crashDialog = null;
            }
            if (app.anrDialog != null) {
                app.anrDialog.dismiss();
                app.anrDialog = null;
            }
            if (app.waitDialog != null) {
                app.waitDialog.dismiss();
                app.waitDialog = null;
            }
        } catch (NullPointerException e) {
            Slog.w(TAG, "cleanUpApplicationRecordLocked catch NullPointerException", e);
        }
        app.crashing = false;
        app.notResponding = false;
        app.resetPackageList(this.mProcessStats);
        app.unlinkDeathRecipient();
        app.makeInactive(this.mProcessStats);
        app.waitingToKill = null;
        app.forcingToForeground = null;
        updateProcessForegroundLocked(app, false, false);
        app.foregroundActivities = false;
        app.hasShownUi = false;
        app.treatLikeActivity = false;
        app.hasAboveClient = false;
        app.hasClientActivities = false;
        boolean isAllowedRestart = OppoProcessManagerHelper.checkProcessCanRestart(app);
        if (!isAllowedRestart) {
            allowRestart = isAllowedRestart;
        }
        this.mServices.killServicesLocked(app, allowRestart);
        boolean restart = false;
        if (isAllowedRestart) {
            for (i = app.pubProviders.size() - 1; i >= 0; i--) {
                ContentProviderRecord cpr = (ContentProviderRecord) app.pubProviders.valueAt(i);
                boolean always = app.bad || !allowRestart;
                if ((removeDyingProviderLocked(app, cpr, always) || always) && cpr.hasConnectionOrHandle()) {
                    restart = true;
                }
                cpr.provider = null;
                cpr.proc = null;
            }
            app.pubProviders.clear();
            if (cleanupAppInLaunchingProvidersLocked(app, false)) {
                restart = true;
            }
        } else {
            OppoProcessManagerHelper.checkAppInLaunchingProviders(app);
        }
        if (!app.conProviders.isEmpty()) {
            for (i = app.conProviders.size() - 1; i >= 0; i--) {
                ContentProviderConnection conn = (ContentProviderConnection) app.conProviders.get(i);
                conn.provider.connections.remove(conn);
                stopAssociationLocked(app.uid, app.processName, conn.provider.uid, conn.provider.name);
            }
            app.conProviders.clear();
        }
        skipCurrentReceiverLocked(app);
        for (i = app.receivers.size() - 1; i >= 0; i--) {
            removeReceiverLocked((ReceiverList) app.receivers.valueAt(i));
        }
        app.receivers.clear();
        if (this.mBackupTarget != null && app.pid == this.mBackupTarget.app.pid) {
            if (ActivityManagerDebugConfig.DEBUG_BACKUP || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                Slog.d(TAG_CLEANUP, "App " + this.mBackupTarget.appInfo + " died during backup");
            }
            try {
                IBackupManager.Stub.asInterface(ServiceManager.getService("backup")).agentDisconnected(app.info.packageName);
            } catch (RemoteException e2) {
            }
        }
        for (i = this.mPendingProcessChanges.size() - 1; i >= 0; i--) {
            ProcessChangeItem item = (ProcessChangeItem) this.mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                this.mPendingProcessChanges.remove(i);
                this.mAvailProcessChanges.add(item);
            }
        }
        this.mUiHandler.obtainMessage(32, app.pid, app.info.uid, null).sendToTarget();
        OppoProcessManagerHelper.handleAppDied(app);
        if (restarting) {
            return false;
        }
        int countForSameProcessName = 0;
        if (!app.persistent || app.isolated) {
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                Slog.v(TAG_CLEANUP, "Removing non-persistent process during cleanup: " + app);
            }
            if (!replacingPid) {
                int cleanProcPid = app.pid;
                if (cleanProcPid == 0) {
                    int NP = this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                        int NA = procs.size();
                        for (int ia = 0; ia < NA; ia++) {
                            ProcessRecord checkProc = (ProcessRecord) procs.valueAt(ia);
                            if (checkProc.uid == app.uid && checkProc.pid != cleanProcPid && checkProc.processName.equals(app.processName)) {
                                Slog.w(TAG, "cleanUpApplicationRecordLocked detect same process:" + checkProc);
                                countForSameProcessName++;
                                break;
                            }
                        }
                        if (countForSameProcessName == 1) {
                            break;
                        }
                    }
                }
                if (countForSameProcessName == 0) {
                    removeProcessNameLocked(app.processName, app.uid);
                } else {
                    Slog.w(TAG, "cleanUpApplicationRecordLocked detect same process name proc, num:" + countForSameProcessName + ", proc:" + app);
                }
            }
            if (this.mHeavyWeightProcess == app) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                this.mHeavyWeightProcess = null;
            }
        } else if (!app.removed) {
            if (this.mPersistentStartingProcesses.indexOf(app) < 0) {
                this.mPersistentStartingProcesses.add(app);
                restart = true;
            } else {
                if (isImportantPersistProc(app.processName)) {
                    Slog.i(TAG, "cleanUpApplicationRecordLocked, proc:" + app.processName + " with pid:" + app.pid + ", need to restart!");
                    restart = true;
                }
            }
        }
        if ((ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) && this.mProcessesOnHold.contains(app)) {
            Slog.v(TAG_CLEANUP, "Clean-up removing on hold: " + app);
        }
        this.mProcessesOnHold.remove(app);
        if (app == this.mHomeProcess) {
            this.mHomeProcess = null;
        }
        if (app == this.mPreviousProcess) {
            this.mPreviousProcess = null;
        }
        if (restart && OppoAbnormalAppManager.getInstance().isPackageRestricted(app.info.packageName)) {
            restart = false;
        }
        if (countForSameProcessName > 0 && restart) {
            restart = false;
            Slog.w(TAG, "cleanUpApplicationRecordLocked detect same process name proc, don't restart " + app);
        }
        if (!restart || app.isolated) {
            if (app.pid > 0 && app.pid != MY_PID) {
                synchronized (this.mPidsSelfLocked) {
                    this.mPidsSelfLocked.remove(app.pid);
                    this.mHandler.removeMessages(20, app);
                }
                this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
                if (app.isolated) {
                    this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
                }
                app.setPid(0);
            }
            return false;
        }
        if (index < 0) {
            ProcessList.remove(app.pid);
        }
        addProcessNameLocked(app);
        startProcessLocked(app, "restart", app.processName);
        return true;
    }

    boolean checkAppInLaunchingProvidersLocked(ProcessRecord app) {
        for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
            if (((ContentProviderRecord) this.mLaunchingProviders.get(i)).launchingApp == app) {
                return true;
            }
        }
        return false;
    }

    boolean cleanupAppInLaunchingProvidersLocked(ProcessRecord app, boolean alwaysBad) {
        boolean restart = false;
        for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = (ContentProviderRecord) this.mLaunchingProviders.get(i);
            if (cpr.launchingApp == app) {
                if (alwaysBad || app.bad || !cpr.hasConnectionOrHandle()) {
                    removeDyingProviderLocked(app, cpr, true);
                } else {
                    restart = true;
                }
            }
        }
        return restart;
    }

    public List<RunningServiceInfo> getServices(int maxNum, int flags) {
        List<RunningServiceInfo> runningServiceInfoLocked;
        enforceNotIsolatedCaller("getServices");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                runningServiceInfoLocked = this.mServices.getRunningServiceInfoLocked(maxNum, flags);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return runningServiceInfoLocked;
    }

    public PendingIntent getRunningServiceControlPanel(ComponentName name) {
        PendingIntent runningServiceControlPanelLocked;
        enforceNotIsolatedCaller("getRunningServiceControlPanel");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                runningServiceControlPanelLocked = this.mServices.getRunningServiceControlPanelLocked(name);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return runningServiceControlPanelLocked;
    }

    public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException {
        enforceNotIsolatedCaller("startService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        } else if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        } else {
            ComponentName res;
            if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
                Slog.v(TAG_SERVICE, "startService: " + service + " type=" + resolvedType);
            }
            if (userId == 999) {
                String pName = null;
                if (!(service == null || service.getComponent() == null)) {
                    pName = service.getComponent().getPackageName();
                }
                if (!(pName == null || OppoMultiLauncherUtil.getInstance().isMultiApp(pName) || OppoMultiAppManagerUtil.getInstance().isGms(pName))) {
                    userId = this.mUserController.getCurrentUserIdLocked();
                }
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    int callingPid = Binder.getCallingPid();
                    int callingUid = Binder.getCallingUid();
                    long origId = Binder.clearCallingIdentity();
                    res = this.mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, callingPackage, userId);
                    Binder.restoreCallingIdentity(origId);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return res;
        }
    }

    ComponentName startServiceInPackage(int uid, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException {
        ComponentName res;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
                    Slog.v(TAG_SERVICE, "startServiceInPackage: " + service + " type=" + resolvedType);
                }
                long origId = Binder.clearCallingIdentity();
                res = this.mServices.startServiceLocked(null, service, resolvedType, -1, uid, callingPackage, userId);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return res;
    }

    public int stopService(IApplicationThread caller, Intent service, String resolvedType, int userId) {
        enforceNotIsolatedCaller("stopService");
        if (service == null || !service.hasFileDescriptors()) {
            int stopServiceLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    stopServiceLocked = this.mServices.stopServiceLocked(caller, service, resolvedType, userId);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return stopServiceLocked;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public IBinder peekService(Intent service, String resolvedType, String callingPackage) {
        enforceNotIsolatedCaller("peekService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        } else if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        } else {
            IBinder peekServiceLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    peekServiceLocked = this.mServices.peekServiceLocked(service, resolvedType, callingPackage);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return peekServiceLocked;
        }
    }

    public boolean stopServiceToken(ComponentName className, IBinder token, int startId) {
        boolean stopServiceTokenLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                stopServiceTokenLocked = this.mServices.stopServiceTokenLocked(className, token, startId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return stopServiceTokenLocked;
    }

    public void setServiceForeground(ComponentName className, IBinder token, int id, Notification notification, int flags) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mServices.setServiceForegroundLocked(className, token, id, notification, flags);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, boolean requireFull, String name, String callerPackage) {
        return this.mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll, requireFull ? 2 : 0, name, callerPackage);
    }

    boolean isSingleton(String componentProcessName, ApplicationInfo aInfo, String className, int flags) {
        boolean result = false;
        if (UserHandle.getAppId(aInfo.uid) >= 10000) {
            if ((flags & 1073741824) != 0) {
                if (ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS", aInfo.uid) != 0) {
                    String msg = "Permission Denial: Component " + new ComponentName(aInfo.packageName, className).flattenToShortString() + " requests FLAG_SINGLE_USER, but app does not hold " + "android.permission.INTERACT_ACROSS_USERS";
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                result = true;
            }
        } else if ("system".equals(componentProcessName)) {
            result = true;
        } else if ((flags & 1073741824) != 0) {
            result = !UserHandle.isSameApp(aInfo.uid, 1001) ? (aInfo.flags & 8) != 0 : true;
        }
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "isSingleton(" + componentProcessName + ", " + aInfo + ", " + className + ", 0x" + Integer.toHexString(flags) + ") = " + result);
        }
        return result;
    }

    boolean isValidSingletonCall(int callingUid, int componentUid) {
        int componentAppId = UserHandle.getAppId(componentUid);
        if (UserHandle.isSameApp(callingUid, componentUid) || componentAppId == 1000 || componentAppId == 1001 || ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", componentUid) == 0) {
            return true;
        }
        return false;
    }

    public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException {
        enforceNotIsolatedCaller("bindService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        } else if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        } else {
            int bindServiceLocked;
            if (userId == 999) {
                String pName = null;
                if (!(service == null || service.getPackage() == null)) {
                    pName = service.getPackage();
                }
                if (!(pName != null || service == null || service.getComponent() == null)) {
                    pName = service.getComponent().getPackageName();
                }
                if (!(pName == null || OppoMultiLauncherUtil.getInstance().isMultiApp(pName) || OppoMultiAppManagerUtil.getInstance().isGms(pName))) {
                    userId = this.mUserController.getCurrentUserIdLocked();
                }
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    bindServiceLocked = this.mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return bindServiceLocked;
        }
    }

    public boolean unbindService(IServiceConnection connection) {
        boolean unbindServiceLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                unbindServiceLocked = this.mServices.unbindServiceLocked(connection);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return unbindServiceLocked;
    }

    public void publishService(IBinder token, Intent intent, IBinder service) {
        if (intent == null || !intent.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (token instanceof ServiceRecord) {
                        this.mServices.publishServiceLocked((ServiceRecord) token, intent, service);
                    } else {
                        throw new IllegalArgumentException("Invalid service token");
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public void unbindFinished(IBinder token, Intent intent, boolean doRebind) {
        if (intent == null || !intent.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    this.mServices.unbindFinishedLocked((ServiceRecord) token, intent, doRebind);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public void serviceDoneExecuting(IBinder token, int type, int startId, int res) {
        if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
            Slog.d(TAG, "SVC-Executing service done: " + token + ", type=" + type + ", startId=" + startId + ", res=" + res);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (token instanceof ServiceRecord) {
                    this.mServices.serviceDoneExecutingLocked((ServiceRecord) token, type, startId, res);
                } else {
                    Slog.e(TAG, "serviceDoneExecuting: Invalid service token=" + token);
                    throw new IllegalArgumentException("Invalid service token");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean bindBackupAgent(String packageName, int backupMode, int userId) {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG, "bindBackupAgent: app=" + packageName + " mode=" + backupMode);
        }
        enforceCallingPermission("android.permission.CONFIRM_FULL_BACKUP", "bindBackupAgent");
        ApplicationInfo app = null;
        try {
            app = AppGlobals.getPackageManager().getApplicationInfo(packageName, 0, userId);
        } catch (RemoteException e) {
        }
        if (app == null) {
            Slog.w(TAG, "Unable to bind backup agent for " + packageName);
            return false;
        }
        synchronized (this) {
            try {
                Serv ss;
                ComponentName hostingName;
                boostPriorityForLockedSection();
                BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    ss = stats.getServiceStatsLocked(app.uid, app.packageName, app.name);
                }
                try {
                    AppGlobals.getPackageManager().setPackageStoppedState(app.packageName, false, UserHandle.getUserId(app.uid));
                } catch (RemoteException e2) {
                } catch (IllegalArgumentException e3) {
                    Slog.w(TAG, "Failed trying to unstop package " + app.packageName + ": " + e3);
                }
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                    PackageStoppedStatusChanged eventData = PackageStoppedStatusChanged.createInstance();
                    Object[] objArr = new Object[3];
                    objArr[0] = app.packageName;
                    objArr[1] = Integer.valueOf(0);
                    objArr[2] = "bindBackupAgent";
                    eventData.set(objArr);
                    this.mAMEventHook.hook(Event.AM_PackageStoppedStatusChanged, eventData);
                }
                BackupRecord backupRecord = new BackupRecord(ss, app, backupMode);
                if (backupMode == 0) {
                    hostingName = new ComponentName(app.packageName, app.backupAgentName);
                } else {
                    hostingName = new ComponentName("android", "FullBackupAgent");
                }
                ProcessRecord proc = startProcessLocked(app.processName, app, false, 0, "backup", hostingName, false, false, false);
                if (proc == null) {
                    Slog.e(TAG, "Unable to start backup agent process " + backupRecord);
                } else {
                    if (UserHandle.isApp(app.uid) && backupMode == 1) {
                        proc.inFullBackup = true;
                    }
                    backupRecord.app = proc;
                    this.mBackupTarget = backupRecord;
                    this.mBackupAppName = app.packageName;
                    updateOomAdjLocked(proc);
                    if (proc.thread != null) {
                        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                            Slog.v(TAG_BACKUP, "Agent proc already running: " + proc);
                        }
                        try {
                            proc.thread.scheduleCreateBackupAgent(app, compatibilityInfoForPackageLocked(app), backupMode);
                        } catch (RemoteException e4) {
                        }
                    } else if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                        Slog.v(TAG_BACKUP, "Agent proc not running, waiting for attach");
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return true;
        return false;
    }

    public void clearPendingBackup() {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG_BACKUP, "clearPendingBackup");
        }
        enforceCallingPermission("android.permission.BACKUP", "clearPendingBackup");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mBackupTarget = null;
                this.mBackupAppName = null;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: Missing block: B:11:0x005a, code:
            resetPriorityAfterLockedSection();
            r4 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Missing block: B:13:?, code:
            android.app.backup.IBackupManager.Stub.asInterface(android.os.ServiceManager.getService("backup")).agentConnected(r9, r10);
     */
    /* JADX WARNING: Missing block: B:14:0x0072, code:
            return;
     */
    /* JADX WARNING: Missing block: B:17:0x0079, code:
            r2 = move-exception;
     */
    /* JADX WARNING: Missing block: B:19:?, code:
            android.util.Slog.w(TAG, "Exception trying to deliver BackupAgent binding: ");
            r2.printStackTrace();
     */
    /* JADX WARNING: Missing block: B:22:0x008f, code:
            android.os.Binder.restoreCallingIdentity(r4);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void backupAgentCreated(String agentPackageName, IBinder agent) {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG_BACKUP, "backupAgentCreated: " + agentPackageName + " = " + agent);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!agentPackageName.equals(this.mBackupAppName)) {
                    Slog.e(TAG, "Backup agent created for " + agentPackageName + " but not requested!");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void unbindBackupAgent(ApplicationInfo appInfo) {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG_BACKUP, "unbindBackupAgent: " + appInfo);
        }
        if (appInfo == null) {
            Slog.w(TAG, "unbind backup agent for null app");
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                try {
                    if (this.mBackupAppName == null) {
                        Slog.w(TAG, "Unbinding backup agent with no active backup");
                        this.mBackupTarget = null;
                        this.mBackupAppName = null;
                    } else if (this.mBackupAppName.equals(appInfo.packageName)) {
                        ProcessRecord proc = this.mBackupTarget.app;
                        updateOomAdjLocked(proc);
                        if (proc.thread != null) {
                            proc.thread.scheduleDestroyBackupAgent(appInfo, compatibilityInfoForPackageLocked(appInfo));
                        }
                        this.mBackupTarget = null;
                        this.mBackupAppName = null;
                        resetPriorityAfterLockedSection();
                    } else {
                        Slog.e(TAG, "Unbind of " + appInfo + " but is not the current backup target");
                        this.mBackupTarget = null;
                        this.mBackupAppName = null;
                        resetPriorityAfterLockedSection();
                    }
                } catch (Exception e) {
                    Slog.e(TAG, "Exception when unbinding backup agent:");
                    e.printStackTrace();
                } catch (Throwable th) {
                    this.mBackupTarget = null;
                    this.mBackupAppName = null;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    boolean isPendingBroadcastProcessLocked(int pid) {
        if (this.mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid) || this.mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid)) {
            return true;
        }
        return OppoBroadcastManager.getInstance(this).isPendingBroadcastProcessLocked(pid);
    }

    void skipPendingBroadcastLocked(int pid) {
        Slog.w(TAG, "Unattached app died before broadcast acknowledged, skipping");
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.skipPendingBroadcastLocked(pid);
        }
    }

    boolean sendPendingBroadcastsLocked(ProcessRecord app) {
        boolean didSomething = false;
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            didSomething |= queue.sendPendingBroadcastsLocked(app);
        }
        return didSomething;
    }

    /* JADX WARNING: Missing block: B:45:0x0137, code:
            resetPriorityAfterLockedSection();
            r30 = null;
     */
    /* JADX WARNING: Missing block: B:46:0x013c, code:
            if (r41 == null) goto L_0x0178;
     */
    /* JADX WARNING: Missing block: B:47:0x013e, code:
            r37 = r44.mContext.getContentResolver();
            r33 = 0;
            r27 = r41.size();
     */
    /* JADX WARNING: Missing block: B:49:0x0150, code:
            if (r33 >= r27) goto L_0x0178;
     */
    /* JADX WARNING: Missing block: B:50:0x0152, code:
            r9 = (android.content.Intent) r41.get(r33);
     */
    /* JADX WARNING: Missing block: B:51:0x0167, code:
            if (r48.match(r37, r9, true, TAG) < 0) goto L_0x0175;
     */
    /* JADX WARNING: Missing block: B:52:0x0169, code:
            if (r30 != null) goto L_0x0170;
     */
    /* JADX WARNING: Missing block: B:53:0x016b, code:
            r30 = new java.util.ArrayList();
     */
    /* JADX WARNING: Missing block: B:54:0x0170, code:
            r30.add(r9);
     */
    /* JADX WARNING: Missing block: B:55:0x0175, code:
            r33 = r33 + 1;
     */
    /* JADX WARNING: Missing block: B:56:0x0178, code:
            if (r30 == null) goto L_0x01b2;
     */
    /* JADX WARNING: Missing block: B:57:0x017a, code:
            r39 = (android.content.Intent) r30.get(0);
     */
    /* JADX WARNING: Missing block: B:59:0x0185, code:
            if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_BROADCAST == false) goto L_0x01af;
     */
    /* JADX WARNING: Missing block: B:60:0x0187, code:
            android.util.Slog.v(TAG_BROADCAST, "Register receiver " + r48 + ": " + r39);
     */
    /* JADX WARNING: Missing block: B:61:0x01af, code:
            if (r47 != null) goto L_0x01b5;
     */
    /* JADX WARNING: Missing block: B:62:0x01b1, code:
            return r39;
     */
    /* JADX WARNING: Missing block: B:63:0x01b2, code:
            r39 = null;
     */
    /* JADX WARNING: Missing block: B:64:0x01b5, code:
            monitor-enter(r44);
     */
    /* JADX WARNING: Missing block: B:66:?, code:
            boostPriorityForLockedSection();
     */
    /* JADX WARNING: Missing block: B:67:0x01b9, code:
            if (r31 == null) goto L_0x01d5;
     */
    /* JADX WARNING: Missing block: B:69:0x01bf, code:
            if (r31.thread == null) goto L_0x01cf;
     */
    /* JADX WARNING: Missing block: B:71:0x01cd, code:
            if (r31.thread.asBinder() == r45.asBinder()) goto L_0x01d5;
     */
    /* JADX WARNING: Missing block: B:73:0x01d0, code:
            monitor-exit(r44);
     */
    /* JADX WARNING: Missing block: B:76:?, code:
            r5 = (com.android.server.am.ReceiverList) r44.mRegisteredReceivers.get(r47.asBinder());
     */
    /* JADX WARNING: Missing block: B:77:0x01e3, code:
            if (r5 != null) goto L_0x029a;
     */
    /* JADX WARNING: Missing block: B:78:0x01e5, code:
            r5 = new com.android.server.am.ReceiverList(r44, r31, r3, r4, r50, r47);
     */
    /* JADX WARNING: Missing block: B:79:0x01f6, code:
            if (r5.app == null) goto L_0x0281;
     */
    /* JADX WARNING: Missing block: B:80:0x01f8, code:
            r5.app.receivers.add(r5);
     */
    /* JADX WARNING: Missing block: B:81:0x01ff, code:
            r44.mRegisteredReceivers.put(r47.asBinder(), r5);
     */
    /* JADX WARNING: Missing block: B:82:0x020a, code:
            r6 = new com.android.server.am.BroadcastFilter(r48, r5, r46, r49, r4, r50);
            r5.add(r6);
     */
    /* JADX WARNING: Missing block: B:83:0x0220, code:
            if (r6.debugCheck() != false) goto L_0x022a;
     */
    /* JADX WARNING: Missing block: B:84:0x0222, code:
            android.util.Slog.w(TAG, "==> For Dynamic broadcast");
     */
    /* JADX WARNING: Missing block: B:85:0x022a, code:
            r44.mReceiverResolver.addFilter(r6);
     */
    /* JADX WARNING: Missing block: B:86:0x0231, code:
            if (r30 == null) goto L_0x031f;
     */
    /* JADX WARNING: Missing block: B:87:0x0233, code:
            r18 = new java.util.ArrayList();
            r18.add(r6);
            r40 = r30.size();
            r33 = 0;
     */
    /* JADX WARNING: Missing block: B:89:0x0247, code:
            if (r33 >= r40) goto L_0x031f;
     */
    /* JADX WARNING: Missing block: B:90:0x0249, code:
            r9 = (android.content.Intent) r30.get(r33);
            r8 = broadcastQueueForIntent(r9);
            r8.enqueueParallelBroadcastLocked(new com.android.server.am.BroadcastRecord(r8, r9, null, null, -1, -1, null, null, -1, null, r18, null, 0, null, null, false, true, true, -1));
            r8.scheduleBroadcastsLocked();
     */
    /* JADX WARNING: Missing block: B:91:0x027e, code:
            r33 = r33 + 1;
     */
    /* JADX WARNING: Missing block: B:93:?, code:
            r47.asBinder().linkToDeath(r5, 0);
     */
    /* JADX WARNING: Missing block: B:96:?, code:
            r5.linkedToDeath = true;
     */
    /* JADX WARNING: Missing block: B:98:0x0290, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:100:0x0296, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:101:0x0299, code:
            return r39;
     */
    /* JADX WARNING: Missing block: B:104:0x029c, code:
            if (r5.uid == r4) goto L_0x02c5;
     */
    /* JADX WARNING: Missing block: B:106:0x02c4, code:
            throw new java.lang.IllegalArgumentException("Receiver requested to register for uid " + r4 + " was previously registered for uid " + r5.uid);
     */
    /* JADX WARNING: Missing block: B:108:0x02c7, code:
            if (r5.pid == r3) goto L_0x02f0;
     */
    /* JADX WARNING: Missing block: B:110:0x02ef, code:
            throw new java.lang.IllegalArgumentException("Receiver requested to register for pid " + r3 + " was previously registered for pid " + r5.pid);
     */
    /* JADX WARNING: Missing block: B:112:0x02f4, code:
            if (r5.userId == r50) goto L_0x020a;
     */
    /* JADX WARNING: Missing block: B:114:0x031e, code:
            throw new java.lang.IllegalArgumentException("Receiver requested to register for user " + r50 + " was previously registered for user " + r5.userId);
     */
    /* JADX WARNING: Missing block: B:115:0x031f, code:
            monitor-exit(r44);
     */
    /* JADX WARNING: Missing block: B:116:0x0320, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:117:0x0323, code:
            return r39;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {
        Throwable th;
        enforceNotIsolatedCaller("registerReceiver");
        ArrayList<Intent> stickyIntents = null;
        ProcessRecord callerApp = null;
        synchronized (this) {
            try {
                int callingUid;
                int callingPid;
                boostPriorityForLockedSection();
                if (caller != null) {
                    callerApp = getRecordForAppLocked(caller);
                    if (callerApp == null) {
                        throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when registering receiver " + receiver);
                    } else if (callerApp.info.uid == 1000 || callerApp.pkgList.containsKey(callerPackage) || "android".equals(callerPackage)) {
                        callingUid = callerApp.info.uid;
                        callingPid = callerApp.pid;
                    } else {
                        throw new SecurityException("Given caller package " + callerPackage + " is not running in process " + callerApp);
                    }
                }
                callerPackage = null;
                callingUid = Binder.getCallingUid();
                callingPid = Binder.getCallingPid();
                userId = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, true, 2, "registerReceiver", callerPackage);
                Iterator<String> actions = filter.actionsIterator();
                if (actions == null) {
                    ArrayList<String> arrayList = new ArrayList(1);
                    arrayList.add(null);
                    actions = arrayList.iterator();
                }
                int[] userIds = new int[2];
                userIds[0] = -1;
                userIds[1] = UserHandle.getUserId(callingUid);
                while (actions.hasNext()) {
                    String action = (String) actions.next();
                    int i = 0;
                    int length = userIds.length;
                    ArrayList<Intent> stickyIntents2 = stickyIntents;
                    while (i < length) {
                        try {
                            ArrayMap<String, ArrayList<Intent>> stickies = (ArrayMap) this.mStickyBroadcasts.get(userIds[i]);
                            if (stickies != null) {
                                ArrayList<Intent> intents = (ArrayList) stickies.get(action);
                                if (intents != null) {
                                    if (stickyIntents2 == null) {
                                        stickyIntents = new ArrayList();
                                    } else {
                                        stickyIntents = stickyIntents2;
                                    }
                                    stickyIntents.addAll(intents);
                                    i++;
                                    stickyIntents2 = stickyIntents;
                                }
                            }
                            stickyIntents = stickyIntents2;
                            i++;
                            stickyIntents2 = stickyIntents;
                        } catch (Throwable th2) {
                            th = th2;
                            stickyIntents = stickyIntents2;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                    stickyIntents = stickyIntents2;
                }
            } catch (Throwable th3) {
                th = th3;
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        return null;
    }

    public void unregisterReceiver(IIntentReceiver receiver) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v(TAG_BROADCAST, "Unregister receiver: " + receiver);
        }
        long origId = Binder.clearCallingIdentity();
        boolean doTrim = false;
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ReceiverList rl = (ReceiverList) this.mRegisteredReceivers.get(receiver.asBinder());
                if (rl != null) {
                    BroadcastRecord r = rl.curBroadcast;
                    if (r != null && r == r.queue.getMatchingOrderedReceiver(r) && r.queue.finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false)) {
                        doTrim = true;
                        r.queue.processNextBroadcast(false);
                    }
                    if (rl.app != null) {
                        rl.app.receivers.remove(rl);
                    }
                    removeReceiverLocked(rl);
                    if (rl.linkedToDeath) {
                        rl.linkedToDeath = false;
                        rl.receiver.asBinder().unlinkToDeath(rl, 0);
                    }
                }
            }
            resetPriorityAfterLockedSection();
            if (doTrim) {
                trimApplications();
                Binder.restoreCallingIdentity(origId);
                return;
            }
            Binder.restoreCallingIdentity(origId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    void removeReceiverLocked(ReceiverList rl) {
        this.mRegisteredReceivers.remove(rl.receiver.asBinder());
        for (int i = rl.size() - 1; i >= 0; i--) {
            this.mReceiverResolver.removeFilter((BroadcastFilter) rl.get(i));
        }
    }

    private final void sendPackageBroadcastLocked(int cmd, String[] packages, int userId) {
        if (cmd != 0 || userId != OppoMultiAppManager.USER_ID) {
            for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                ProcessRecord r = (ProcessRecord) this.mLruProcesses.get(i);
                if (r.thread != null && (userId == -1 || r.userId == userId)) {
                    try {
                        r.thread.dispatchPackageBroadcast(cmd, packages);
                    } catch (RemoteException e) {
                    }
                }
            }
        }
    }

    private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType, int callingUid, int[] users, String callerPackage) {
        int i;
        int[] newUsers;
        int n;
        List<ResolveInfo> list = null;
        int callingUserId = UserHandle.getUserId(callingUid);
        int len = users.length;
        boolean hasMultiUser = false;
        boolean hasOwnerUser = false;
        for (i = 0; i < len; i++) {
            if (users[i] == 0) {
                hasOwnerUser = true;
            } else if (users[i] == 999) {
                hasMultiUser = true;
            }
        }
        if (hasMultiUser && !hasOwnerUser) {
            newUsers = new int[(len + 1)];
            for (n = 0; n < len; n++) {
                newUsers[n] = users[n];
            }
            newUsers[len] = 0;
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                Slog.d(TAG, "collectReceiverComponents: add user 0!");
            }
            users = newUsers;
        }
        if (!(hasMultiUser || !hasOwnerUser || OppoMultiLauncherUtil.getInstance().isMultiApp(callerPackage))) {
            newUsers = new int[(len + 1)];
            for (n = 0; n < len; n++) {
                newUsers[n] = users[n];
            }
            newUsers[len] = OppoMultiAppManager.USER_ID;
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                Slog.d(TAG, "collectReceiverComponents: add user 999!");
            }
            users = newUsers;
        }
        HashSet<ComponentName> singleUserReceivers = null;
        boolean scannedFirstReceivers = false;
        for (int user : users) {
            if (callingUserId == 0 && user == 999 && OppoMultiLauncherUtil.getInstance().isMultiApp(callerPackage)) {
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Slog.d(TAG, "multi app: collectReceiverComponents: continue user 999! callerPackage = " + callerPackage);
                }
            } else if (callingUid != PENDING_ASSIST_EXTRAS_LONG_TIMEOUT || !this.mUserController.hasUserRestriction("no_debugging_features", user) || isPermittedShellBroadcast(intent)) {
                ResolveInfo ri;
                List<ResolveInfo> newReceivers = AppGlobals.getPackageManager().queryIntentReceivers(intent, resolvedType, 268436480, user).getList();
                if (!(user == 0 || newReceivers == null)) {
                    i = 0;
                    while (i < newReceivers.size()) {
                        ri = (ResolveInfo) newReceivers.get(i);
                        if ((ri.activityInfo.flags & 536870912) != 0) {
                            newReceivers.remove(i);
                            i--;
                        } else if (callingUserId == 0 && user == 999 && !OppoMultiLauncherUtil.getInstance().isMultiApp(ri.activityInfo.packageName)) {
                            newReceivers.remove(i);
                            i--;
                        }
                        i++;
                    }
                }
                if (user == 0 && newReceivers != null) {
                    i = 0;
                    while (i < newReceivers.size()) {
                        ri = (ResolveInfo) newReceivers.get(i);
                        if (callingUserId == 999 && OppoMultiLauncherUtil.getInstance().isMultiApp(ri.activityInfo.packageName)) {
                            newReceivers.remove(i);
                            i--;
                        }
                        i++;
                    }
                }
                if (newReceivers != null && newReceivers.size() == 0) {
                    newReceivers = null;
                }
                if (list == null) {
                    list = newReceivers;
                } else if (newReceivers != null) {
                    HashSet<ComponentName> singleUserReceivers2;
                    ComponentName cn;
                    if (!scannedFirstReceivers) {
                        scannedFirstReceivers = true;
                        i = 0;
                        while (true) {
                            try {
                                singleUserReceivers2 = singleUserReceivers;
                                if (i >= list.size()) {
                                    singleUserReceivers = singleUserReceivers2;
                                    break;
                                }
                                ri = (ResolveInfo) list.get(i);
                                if ((ri.activityInfo.flags & 1073741824) != 0) {
                                    cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                                    if (singleUserReceivers2 == null) {
                                        singleUserReceivers = new HashSet();
                                    } else {
                                        singleUserReceivers = singleUserReceivers2;
                                    }
                                    singleUserReceivers.add(cn);
                                } else {
                                    singleUserReceivers = singleUserReceivers2;
                                }
                                i++;
                            } catch (RemoteException e) {
                                singleUserReceivers = singleUserReceivers2;
                            }
                        }
                    }
                    i = 0;
                    while (true) {
                        singleUserReceivers2 = singleUserReceivers;
                        if (i >= newReceivers.size()) {
                            singleUserReceivers = singleUserReceivers2;
                            break;
                        }
                        ri = (ResolveInfo) newReceivers.get(i);
                        if ((ri.activityInfo.flags & 1073741824) != 0) {
                            cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                            if (singleUserReceivers2 == null) {
                                singleUserReceivers = new HashSet();
                            } else {
                                singleUserReceivers = singleUserReceivers2;
                            }
                            try {
                                if (!singleUserReceivers.contains(cn)) {
                                    singleUserReceivers.add(cn);
                                    list.add(ri);
                                }
                            } catch (RemoteException e2) {
                            }
                        } else {
                            list.add(ri);
                            singleUserReceivers = singleUserReceivers2;
                        }
                        i++;
                    }
                }
                if (CtaUtils.isCtaSupported()) {
                    ReceiverController.getInstance(this.mContext).filterReceiver(intent, list, user);
                }
            }
        }
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST && list != null) {
            for (i = 0; i < list.size(); i++) {
                Slog.d(TAG, "multi app: collectReceiverComponents: i = " + i + "  ResolveInfo = " + ((ResolveInfo) list.get(i)) + "  intent = " + intent + "  callingUid = " + callingUid);
            }
        }
        return list;
    }

    private boolean isPermittedShellBroadcast(Intent intent) {
        return INTENT_REMOTE_BUGREPORT_FINISHED.equals(intent.getAction());
    }

    private void checkBroadcastFromSystem(Intent intent, ProcessRecord callerApp, String callerPackage, int callingUid, boolean isProtectedBroadcast, List receivers) {
        String action = intent.getAction();
        if (!isProtectedBroadcast && !"android.intent.action.CLOSE_SYSTEM_DIALOGS".equals(action) && !"android.intent.action.DISMISS_KEYBOARD_SHORTCUTS".equals(action) && !"android.intent.action.MEDIA_BUTTON".equals(action) && !"android.intent.action.MEDIA_SCANNER_SCAN_FILE".equals(action) && !"android.intent.action.SHOW_KEYBOARD_SHORTCUTS".equals(action) && !"android.intent.action.MASTER_CLEAR".equals(action) && !"android.appwidget.action.APPWIDGET_CONFIGURE".equals(action) && !"android.appwidget.action.APPWIDGET_UPDATE".equals(action) && !"android.location.HIGH_POWER_REQUEST_CHANGE".equals(action) && !"com.android.omadm.service.CONFIGURATION_UPDATE".equals(action) && !"android.text.style.SUGGESTION_PICKED".equals(action)) {
            if (!(receivers == null || receivers.size() <= 0 || (intent.getPackage() == null && intent.getComponent() == null))) {
                boolean allProtected = true;
                for (int i = receivers.size() - 1; i >= 0; i--) {
                    ResolveInfo target = receivers.get(i);
                    if (target instanceof ResolveInfo) {
                        ResolveInfo ri = target;
                        if (ri.activityInfo.exported && ri.activityInfo.permission == null) {
                            allProtected = false;
                            break;
                        }
                    } else if (((BroadcastFilter) target).requiredPermission == null) {
                        allProtected = false;
                        break;
                    }
                }
                if (allProtected) {
                    return;
                }
            }
            if (callerApp != null) {
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Log.w(TAG, "Sending non-protected broadcast " + action + " from system " + callerApp.toShortString() + " pkg " + callerPackage);
                }
            } else if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                Log.w(TAG, "Sending non-protected broadcast " + action + " from system uid " + UserHandle.formatUid(callingUid) + " pkg " + callerPackage);
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:322:0x0a96  */
    /* JADX WARNING: Missing block: B:28:0x0132, code:
            if (r63.equals("com.android.launcher.action.UNINSTALL_SHORTCUT") != false) goto L_0x0134;
     */
    /* JADX WARNING: Missing block: B:176:0x066a, code:
            if (r62.equals("android.hardware.action.NEW_VIDEO") != false) goto L_0x061d;
     */
    /* JADX WARNING: Missing block: B:260:0x0887, code:
            if (r62.equals("android.intent.action.PACKAGES_UNSUSPENDED") != false) goto L_0x0848;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
        Intent intent2 = new Intent(intent);
        intent2.addFlags(16);
        OppoAppStartupManager.getInstance().handleBroadcastIncludeForceStop(intent2, callerApp);
        if (!this.mProcessesReady && (intent2.getFlags() & 33554432) == 0) {
            intent2.addFlags(1073741824);
        }
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent2 + " ordered=" + ordered + " userid=" + userId + " callerApp=" + callerApp);
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT) {
                Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent2 + " ordered=" + ordered + " userid=" + userId + " resultTo " + resultTo);
            }
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                Slog.v(TAG, "broadcastIntentLocked callingPid: " + callingPid + " callingUid=" + callingUid);
            }
        }
        if (!(resultTo == null || ordered)) {
            Slog.w(TAG, "Broadcast " + intent2 + " not ordered but result callback requested!");
        }
        userId = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, true, 0, OppoProcessManager.RESUME_REASON_BROADCAST_STR, callerPackage);
        String actions = intent2.getAction();
        Intent intent3 = null;
        if (actions != null && OppoMultiLauncherUtil.getInstance().isMultiApp(UserHandle.getUserId(callingUid), callerPackage)) {
            if (!actions.equals("com.android.launcher.action.INSTALL_SHORTCUT")) {
            }
            Slog.d(TAG, "multi app: broadcastIntentLocked: multi app is creating shortCut. ");
            userId = this.mUserController.getCurrentUserIdLocked();
            if (intent2.getExtras() != null) {
                intent3 = (Intent) intent2.getParcelableExtra("android.intent.extra.shortcut.INTENT");
            }
            if (intent3 != null) {
                intent3.addCategory("com.multiple.launcher");
            }
        }
        if (userId == -1 || this.mUserController.isUserRunningLocked(userId, 0) || ((callingUid == 1000 && (intent2.getFlags() & 33554432) != 0) || "android.intent.action.ACTION_SHUTDOWN".equals(intent2.getAction()))) {
            String msg;
            BroadcastOptions broadcastOptions = null;
            if (bOptions != null) {
                BroadcastOptions broadcastOptions2 = new BroadcastOptions(bOptions);
                if (broadcastOptions2.getTemporaryAppWhitelistDuration() > 0) {
                    if (checkComponentPermission("android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST", Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != 0) {
                        msg = "Permission Denial: " + intent2.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + "android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST";
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                }
            }
            String action = intent2.getAction();
            try {
                boolean isCallerSystem;
                Uri data;
                BroadcastQueue queue;
                int i;
                String pkgName;
                int[] users;
                List receivers;
                List receivers2;
                boolean isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);
                switch (UserHandle.getAppId(callingUid)) {
                    case 0:
                    case 1000:
                    case 1001:
                    case 1002:
                    case 1027:
                        isCallerSystem = true;
                        break;
                    default:
                        if (callerApp == null) {
                            isCallerSystem = false;
                            break;
                        }
                        isCallerSystem = callerApp.persistent;
                        break;
                }
                if (!isCallerSystem) {
                    if (isProtectedBroadcast) {
                        msg = "Permission Denial: not allowed to send broadcast " + action + " from pid=" + callingPid + ", uid=" + callingUid;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    } else if ("android.appwidget.action.APPWIDGET_CONFIGURE".equals(action) || "android.appwidget.action.APPWIDGET_UPDATE".equals(action)) {
                        if (callerPackage == null) {
                            msg = "Permission Denial: not allowed to send broadcast " + action + " from unknown caller.";
                            Slog.w(TAG, msg);
                            throw new SecurityException(msg);
                        } else if (intent2.getComponent() == null) {
                            intent2.setPackage(callerPackage);
                        } else if (!intent2.getComponent().getPackageName().equals(callerPackage)) {
                            msg = "Permission Denial: not allowed to send broadcast " + action + " to " + intent2.getComponent().getPackageName() + " from " + callerPackage;
                            Slog.w(TAG, msg);
                            throw new SecurityException(msg);
                        }
                    }
                }
                if (action != null) {
                    String ssp;
                    String[] strArr;
                    if (!action.equals("android.intent.action.UID_REMOVED")) {
                        if (!action.equals("android.intent.action.PACKAGE_REMOVED")) {
                            if (!action.equals("android.intent.action.PACKAGE_CHANGED")) {
                                if (!action.equals("android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE")) {
                                    if (!action.equals("android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE")) {
                                        if (!action.equals("oppo.intent.action.MULTI_APP_PACKAGE_REMOVED")) {
                                            if (!action.equals("android.intent.action.PACKAGES_SUSPENDED")) {
                                                if (!action.equals("android.intent.action.PACKAGES_UNSUSPENDED")) {
                                                    if (action.equals("android.intent.action.PACKAGE_REPLACED")) {
                                                        data = intent2.getData();
                                                        if (data != null) {
                                                            ssp = data.getSchemeSpecificPart();
                                                            if (ssp != null) {
                                                                ApplicationInfo aInfo = getPackageManagerInternalLocked().getApplicationInfo(ssp, userId);
                                                                if (aInfo == null) {
                                                                    Slog.w(TAG, "Dropping ACTION_PACKAGE_REPLACED for non-existent pkg: ssp=" + ssp + " data=" + data);
                                                                    return 0;
                                                                }
                                                                this.mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
                                                                strArr = new String[1];
                                                                strArr[0] = ssp;
                                                                sendPackageBroadcastLocked(3, strArr, userId);
                                                            }
                                                        }
                                                    } else {
                                                        if (action.equals("android.intent.action.PACKAGE_ADDED")) {
                                                            data = intent2.getData();
                                                            if (data != null) {
                                                                ssp = data.getSchemeSpecificPart();
                                                                if (ssp != null) {
                                                                    this.mCompatModePackages.handlePackageAddedLocked(ssp, intent2.getBooleanExtra("android.intent.extra.REPLACING", false));
                                                                    try {
                                                                        ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
                                                                        this.mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0);
                                                                    } catch (RemoteException e) {
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            if (action.equals("android.intent.action.PACKAGE_DATA_CLEARED")) {
                                                                data = intent2.getData();
                                                                if (data != null) {
                                                                    ssp = data.getSchemeSpecificPart();
                                                                    if (ssp != null) {
                                                                        if (this.mUnsupportedDisplaySizeDialog != null && ssp.equals(this.mUnsupportedDisplaySizeDialog.getPackageName())) {
                                                                            this.mUnsupportedDisplaySizeDialog.dismiss();
                                                                            this.mUnsupportedDisplaySizeDialog = null;
                                                                        }
                                                                        this.mCompatModePackages.handlePackageDataClearedLocked(ssp);
                                                                    }
                                                                }
                                                            } else {
                                                                if (action.equals("android.intent.action.TIMEZONE_CHANGED")) {
                                                                    this.mHandler.sendEmptyMessage(13);
                                                                } else {
                                                                    if (action.equals("android.intent.action.TIME_SET")) {
                                                                        int is24Hour;
                                                                        if (intent2.getBooleanExtra("android.intent.extra.TIME_PREF_24_HOUR_FORMAT", false)) {
                                                                            is24Hour = 1;
                                                                        } else {
                                                                            is24Hour = 0;
                                                                        }
                                                                        this.mHandler.sendMessage(this.mHandler.obtainMessage(41, is24Hour, 0));
                                                                        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
                                                                        synchronized (stats) {
                                                                            stats.noteCurrentTimeChangedLocked();
                                                                        }
                                                                    } else {
                                                                        if (action.equals("android.intent.action.CLEAR_DNS_CACHE")) {
                                                                            this.mHandler.sendEmptyMessage(28);
                                                                        } else {
                                                                            if (action.equals("android.intent.action.PROXY_CHANGE")) {
                                                                                this.mHandler.sendMessage(this.mHandler.obtainMessage(29, (ProxyInfo) intent2.getParcelableExtra("android.intent.extra.PROXY_INFO")));
                                                                            } else {
                                                                                if (!action.equals("android.hardware.action.NEW_PICTURE")) {
                                                                                }
                                                                                Slog.w(TAG, action + " no longer allowed; dropping from " + UserHandle.formatUid(callingUid));
                                                                                if (resultTo != null) {
                                                                                    queue = broadcastQueueForIntent(intent2);
                                                                                    try {
                                                                                        queue.performReceiveLocked(callerApp, resultTo, intent2, 0, null, null, false, false, userId);
                                                                                    } catch (Throwable e2) {
                                                                                        Slog.w(TAG, "Failure [" + queue.mQueueName + "] sending broadcast result of " + intent2, e2);
                                                                                    }
                                                                                }
                                                                                return 0;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (checkComponentPermission("android.permission.BROADCAST_PACKAGE_REMOVED", callingPid, callingUid, -1, true) != 0) {
                        msg = "Permission Denial: " + intent2.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + "android.permission.BROADCAST_PACKAGE_REMOVED";
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                    if (action.equals("android.intent.action.UID_REMOVED")) {
                        Bundle intentExtras = intent2.getExtras();
                        int uid = intentExtras != null ? intentExtras.getInt("android.intent.extra.UID") : -1;
                        if (uid >= 0) {
                            this.mBatteryStatsService.removeUid(uid);
                            this.mAppOpsService.uidRemoved(uid);
                        }
                    } else {
                        if (action.equals("android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE")) {
                            String[] list = intent2.getStringArrayExtra("android.intent.extra.changed_package_list");
                            if (list != null && list.length > 0) {
                                for (String ssp2 : list) {
                                    forceStopPackageLocked(ssp2, -1, false, true, true, false, false, userId, "storage unmount");
                                }
                                this.mRecentTasks.cleanupLocked(-1);
                                sendPackageBroadcastLocked(1, list, userId);
                            }
                        } else {
                            if (action.equals("android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE")) {
                                this.mRecentTasks.cleanupLocked(-1);
                            } else {
                                boolean removed;
                                boolean fullUninstall;
                                boolean killProcess;
                                if (!action.equals("android.intent.action.PACKAGE_REMOVED")) {
                                    if (!action.equals("android.intent.action.PACKAGE_CHANGED")) {
                                        if (action.equals("oppo.intent.action.MULTI_APP_PACKAGE_REMOVED")) {
                                            if (DEBUG_COLOROS_AMS) {
                                                Slog.d(TAG, "multi app: AMS dealing with multi app removed.");
                                            }
                                            Uri uriData = intent2.getData();
                                            if (uriData != null) {
                                                pkgName = uriData.getSchemeSpecificPart();
                                                if (pkgName != null) {
                                                    removed = "oppo.intent.action.MULTI_APP_PACKAGE_REMOVED".equals(action);
                                                    if (removed) {
                                                        fullUninstall = !intent2.getBooleanExtra("android.intent.extra.REPLACING", false);
                                                    } else {
                                                        fullUninstall = false;
                                                    }
                                                    killProcess = !intent2.getBooleanExtra("android.intent.extra.DONT_KILL_APP", false);
                                                    if (killProcess) {
                                                        forceStopPackageLocked(pkgName, UserHandle.getAppId(intent2.getIntExtra("android.intent.extra.UID", -1)), false, true, true, false, fullUninstall, OppoMultiAppManager.USER_ID, removed ? "pkg removed" : "pkg changed");
                                                    }
                                                    if (!removed) {
                                                        cleanupDisabledPackageComponentsLocked(pkgName, OppoMultiAppManager.USER_ID, killProcess, intent2.getStringArrayExtra("android.intent.extra.changed_component_name_list"));
                                                    } else if (fullUninstall) {
                                                        removeUriPermissionsForPackageLocked(pkgName, OppoMultiAppManager.USER_ID, true);
                                                        removeTasksByPackageNameLocked(pkgName, OppoMultiAppManager.USER_ID);
                                                    }
                                                }
                                            }
                                        } else {
                                            if (!action.equals("android.intent.action.PACKAGES_SUSPENDED")) {
                                            }
                                            boolean suspended = "android.intent.action.PACKAGES_SUSPENDED".equals(intent2.getAction());
                                            String[] packageNames = intent2.getStringArrayExtra("android.intent.extra.changed_package_list");
                                            int userHandle = intent2.getIntExtra("android.intent.extra.user_handle", -10000);
                                            synchronized (this) {
                                                try {
                                                    boostPriorityForLockedSection();
                                                    this.mRecentTasks.onPackagesSuspendedChanged(packageNames, suspended, userHandle);
                                                } finally {
                                                    resetPriorityAfterLockedSection();
                                                }
                                            }
                                        }
                                    }
                                }
                                data = intent2.getData();
                                if (data != null) {
                                    ssp2 = data.getSchemeSpecificPart();
                                    if (ssp2 != null) {
                                        removed = "android.intent.action.PACKAGE_REMOVED".equals(action);
                                        boolean replacing = intent2.getBooleanExtra("android.intent.extra.REPLACING", false);
                                        killProcess = !intent2.getBooleanExtra("android.intent.extra.DONT_KILL_APP", false);
                                        fullUninstall = removed && !replacing;
                                        if (removed) {
                                            int cmd;
                                            if (killProcess) {
                                                forceStopPackageLocked(ssp2, UserHandle.getAppId(intent2.getIntExtra("android.intent.extra.UID", -1)), false, true, true, false, fullUninstall, userId, removed ? "pkg removed" : "pkg changed");
                                            }
                                            if (killProcess) {
                                                cmd = 0;
                                            } else {
                                                cmd = 2;
                                            }
                                            strArr = new String[1];
                                            strArr[0] = ssp2;
                                            sendPackageBroadcastLocked(cmd, strArr, userId);
                                            if (fullUninstall) {
                                                this.mAppOpsService.packageRemoved(intent2.getIntExtra("android.intent.extra.UID", -1), ssp2);
                                                removeUriPermissionsForPackageLocked(ssp2, userId, true);
                                                removeTasksByPackageNameLocked(ssp2, userId);
                                                if (this.mUnsupportedDisplaySizeDialog != null && ssp2.equals(this.mUnsupportedDisplaySizeDialog.getPackageName())) {
                                                    this.mUnsupportedDisplaySizeDialog.dismiss();
                                                    this.mUnsupportedDisplaySizeDialog = null;
                                                }
                                                this.mCompatModePackages.handlePackageUninstalledLocked(ssp2);
                                                this.mBatteryStatsService.notePackageUninstalled(ssp2);
                                            }
                                        } else {
                                            if (killProcess) {
                                                killPackageProcessesLocked(ssp2, UserHandle.getAppId(intent2.getIntExtra("android.intent.extra.UID", -1)), userId, -10000, false, true, true, false, "change " + ssp2);
                                            }
                                            cleanupDisabledPackageComponentsLocked(ssp2, userId, killProcess, intent2.getStringArrayExtra("android.intent.extra.changed_component_name_list"));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (sticky) {
                    if (checkPermission("android.permission.BROADCAST_STICKY", callingPid, callingUid) != 0) {
                        msg = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid=" + callingUid + " requires " + "android.permission.BROADCAST_STICKY";
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    } else if (requiredPermissions != null && requiredPermissions.length > 0) {
                        Slog.w(TAG, "Can't broadcast sticky intent " + intent2 + " and enforce permissions " + Arrays.toString(requiredPermissions));
                        return -1;
                    } else if (intent2.getComponent() != null) {
                        throw new SecurityException("Sticky broadcasts can't target a specific component");
                    } else {
                        ArrayMap<String, ArrayList<Intent>> stickies;
                        ArrayList<Intent> list2;
                        if (userId != -1) {
                            stickies = (ArrayMap) this.mStickyBroadcasts.get(-1);
                            if (stickies != null) {
                                list2 = (ArrayList) stickies.get(intent2.getAction());
                                if (list2 != null) {
                                    int N = list2.size();
                                    for (i = 0; i < N; i++) {
                                        if (intent2.filterEquals((Intent) list2.get(i))) {
                                            throw new IllegalArgumentException("Sticky broadcast " + intent2 + " for user " + userId + " conflicts with existing global broadcast");
                                        }
                                    }
                                }
                            }
                        }
                        stickies = (ArrayMap) this.mStickyBroadcasts.get(userId);
                        if (stickies == null) {
                            stickies = new ArrayMap();
                            this.mStickyBroadcasts.put(userId, stickies);
                        }
                        list2 = (ArrayList) stickies.get(intent2.getAction());
                        if (list2 == null) {
                            list2 = new ArrayList();
                            stickies.put(intent2.getAction(), list2);
                        }
                        int stickiesCount = list2.size();
                        i = 0;
                        while (i < stickiesCount) {
                            if (intent2.filterEquals((Intent) list2.get(i))) {
                                list2.set(i, new Intent(intent2));
                                if (i >= stickiesCount) {
                                    list2.add(new Intent(intent2));
                                }
                            } else {
                                i++;
                            }
                        }
                        if (i >= stickiesCount) {
                        }
                    }
                }
                if (userId == -1) {
                    users = this.mUserController.getStartedUserArrayLocked();
                } else {
                    users = new int[1];
                    users[0] = userId;
                }
                List registeredReceivers = null;
                if ((intent2.getFlags() & 1073741824) == 0) {
                    receivers = collectReceiverComponents(intent2, resolvedType, callingUid, users, callerPackage);
                } else {
                    receivers = null;
                }
                if (intent2.getComponent() == null) {
                    if (userId == -1 && callingUid == PENDING_ASSIST_EXTRAS_LONG_TIMEOUT) {
                        for (i = 0; i < users.length; i++) {
                            if (!this.mUserController.hasUserRestriction("no_debugging_features", users[i])) {
                                List<BroadcastFilter> registeredReceiversForUser = this.mReceiverResolver.queryIntent(intent2, resolvedType, false, users[i]);
                                if (registeredReceivers == null) {
                                    List<BroadcastFilter> registeredReceivers2 = registeredReceiversForUser;
                                } else if (registeredReceiversForUser != null) {
                                    registeredReceivers.addAll(registeredReceiversForUser);
                                }
                            }
                        }
                    } else {
                        registeredReceivers = this.mReceiverResolver.queryIntent(intent2, resolvedType, false, userId);
                    }
                }
                BeforeSendBroadcast eventData = BeforeSendBroadcast.createInstance();
                List<String> filterStaticList = new ArrayList();
                List<String> filterDynamicList = new ArrayList();
                Object[] objArr = new Object[3];
                objArr[0] = intent2;
                objArr[1] = filterStaticList;
                objArr[2] = filterDynamicList;
                eventData.set(objArr);
                AMEventHookResult eventResult = this.mAMEventHook.hook(Event.AM_BeforeSendBroadcast, eventData);
                if (AMEventHookResult.hasAction(eventResult, AMEventHookAction.AM_FilterRegisteredReceiver)) {
                    filterRegisteredReceivers(registeredReceivers, filterDynamicList);
                }
                if (AMEventHookResult.hasAction(eventResult, AMEventHookAction.AM_FilterStaticReceiver)) {
                    filterStaticReceivers(receivers, filterStaticList);
                }
                boolean replacePending = (intent2.getFlags() & 536870912) != 0;
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Slog.v(TAG_BROADCAST, "Enqueing broadcast: " + intent2.getAction() + " replacePending=" + replacePending);
                }
                int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
                if (!ordered && NR > 0) {
                    if (isCallerSystem) {
                        checkBroadcastFromSystem(intent2, callerApp, callerPackage, callingUid, isProtectedBroadcast, registeredReceivers);
                    }
                    if (callingUid >= 10000) {
                        queue = OppoBroadcastManager.getInstance(this).broadcastQueueForIntent(intent2);
                    } else {
                        queue = broadcastQueueForIntent(intent2);
                    }
                    BroadcastRecord r = new BroadcastRecord(queue, intent2, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, broadcastOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
                    if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                        Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r);
                    }
                    r.enqueueTime = SystemClock.uptimeMillis();
                    if (!(replacePending ? queue.replaceParallelBroadcastLocked(r) : false)) {
                        queue.enqueueParallelBroadcastLocked(r);
                        queue.scheduleBroadcastsLocked();
                    }
                    registeredReceivers = null;
                    NR = 0;
                }
                int ir = 0;
                if (receivers != null) {
                    int NT;
                    int it;
                    String[] skipPackages = null;
                    if ("android.intent.action.PACKAGE_ADDED".equals(intent2.getAction()) || "android.intent.action.PACKAGE_RESTARTED".equals(intent2.getAction()) || "android.intent.action.PACKAGE_DATA_CLEARED".equals(intent2.getAction())) {
                        data = intent2.getData();
                        if (data != null) {
                            pkgName = data.getSchemeSpecificPart();
                            if (pkgName != null) {
                                skipPackages = new String[1];
                                skipPackages[0] = pkgName;
                            }
                        }
                    } else if ("android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE".equals(intent2.getAction())) {
                        skipPackages = intent2.getStringArrayExtra("android.intent.extra.changed_package_list");
                    }
                    if (skipPackages != null && skipPackages.length > 0) {
                        for (String skipPackage : skipPackages) {
                            if (skipPackage != null) {
                                NT = receivers.size();
                                it = 0;
                                while (it < NT) {
                                    if (((ResolveInfo) receivers.get(it)).activityInfo.packageName.equals(skipPackage)) {
                                        receivers.remove(it);
                                        it--;
                                        NT--;
                                    }
                                    it++;
                                }
                            }
                        }
                    }
                    NT = receivers != null ? receivers.size() : 0;
                    it = 0;
                    ResolveInfo curt = null;
                    BroadcastFilter curr = null;
                    while (it < NT && ir < NR) {
                        if (curt == null) {
                            curt = (ResolveInfo) receivers.get(it);
                        }
                        if (curr == null) {
                            curr = (BroadcastFilter) registeredReceivers.get(ir);
                        }
                        if (curr.getPriority() >= curt.priority) {
                            receivers.add(it, curr);
                            ir++;
                            curr = null;
                            it++;
                            NT++;
                        } else {
                            it++;
                            curt = null;
                        }
                    }
                    receivers2 = receivers;
                } else {
                    receivers2 = receivers;
                }
                while (ir < NR) {
                    if (receivers2 == null) {
                        receivers2 = new ArrayList();
                    }
                    receivers2.add(registeredReceivers.get(ir));
                    ir++;
                }
                if (isCallerSystem) {
                    checkBroadcastFromSystem(intent2, callerApp, callerPackage, callingUid, isProtectedBroadcast, receivers2);
                }
                if ((receivers2 != null && receivers2.size() > 0) || resultTo != null) {
                    if (callingUid >= 10000) {
                        queue = OppoBroadcastManager.getInstance(this).broadcastQueueForIntent(intent2);
                    } else {
                        queue = broadcastQueueForIntent(intent2);
                    }
                    BroadcastRecord broadcastRecord = new BroadcastRecord(queue, intent2, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, broadcastOptions, OppoBroadcastManager.getInstance(this).adjustReceiverList(receivers2, intent2), resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
                    boolean showLog = false;
                    if (queue.mOrderedBroadcasts != null && queue.mOrderedBroadcasts.size() > 100) {
                        showLog = true;
                    }
                    if (ActivityManagerDebugConfig.DEBUG_BROADCAST || showLog) {
                        Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + broadcastRecord + ": prev had " + queue.mOrderedBroadcasts.size());
                    }
                    if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                        Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + broadcastRecord.intent.getAction());
                    }
                    broadcastRecord.enqueueTime = SystemClock.uptimeMillis();
                    if (!(replacePending ? queue.replaceOrderedBroadcastLocked(broadcastRecord) : false)) {
                        queue.enqueueOrderedBroadcastLocked(broadcastRecord);
                        queue.scheduleBroadcastsLocked();
                    }
                } else if (intent2.getComponent() == null && intent2.getPackage() == null && (intent2.getFlags() & 1073741824) == 0) {
                    addBroadcastStatLocked(intent2.getAction(), callerPackage, 0, 0, 0);
                }
                return 0;
            } catch (Throwable e22) {
                Slog.w(TAG, "Remote exception", e22);
                return 0;
            }
        }
        Slog.w(TAG, "Skipping broadcast of " + intent2 + ": user " + userId + " is stopped");
        return -2;
    }

    final void addBroadcastStatLocked(String action, String srcPackage, int receiveCount, int skipCount, long dispatchTime) {
        long now = SystemClock.elapsedRealtime();
        if (this.mCurBroadcastStats == null || this.mCurBroadcastStats.mStartRealtime + 86400000 < now) {
            this.mLastBroadcastStats = this.mCurBroadcastStats;
            if (this.mLastBroadcastStats != null) {
                this.mLastBroadcastStats.mEndRealtime = SystemClock.elapsedRealtime();
                this.mLastBroadcastStats.mEndUptime = SystemClock.uptimeMillis();
            }
            this.mCurBroadcastStats = new BroadcastStats();
        }
        this.mCurBroadcastStats.addBroadcast(action, srcPackage, receiveCount, skipCount, dispatchTime);
    }

    final Intent verifyBroadcastLocked(Intent intent) {
        if (intent == null || !intent.hasFileDescriptors()) {
            int flags = intent.getFlags();
            if (!this.mProcessesReady && (67108864 & flags) == 0 && (flags & 1073741824) == 0) {
                Slog.wtf(TAG, "Attempt to launch receivers of broadcast intent " + intent + " before boot completion");
                Intent intent2 = new Intent(intent);
                intent2.addFlags(1073741824);
                intent = intent2;
            }
            if ((33554432 & flags) == 0) {
                return intent;
            }
            throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
        int res;
        enforceNotIsolatedCaller("broadcastIntent");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                intent = verifyBroadcastLocked(intent);
                ProcessRecord callerApp = getRecordForAppLocked(caller);
                int callingPid = Binder.getCallingPid();
                int callingUid = Binder.getCallingUid();
                long origId = Binder.clearCallingIdentity();
                res = 0;
                String suppressAction = "allowed";
                String callerAppPackageName = null;
                if (!(callerApp == null || callerApp.info == null)) {
                    callerAppPackageName = callerApp.info.packageName;
                }
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                    ReadyToStartComponent eventData = ReadyToStartComponent.createInstance();
                    Object[] objArr = new Object[10];
                    objArr[0] = callerAppPackageName;
                    objArr[1] = Integer.valueOf(callingUid);
                    objArr[2] = null;
                    objArr[3] = null;
                    objArr[4] = null;
                    objArr[5] = null;
                    objArr[6] = null;
                    objArr[7] = null;
                    objArr[8] = OppoProcessManager.RESUME_REASON_BROADCAST_STR;
                    objArr[9] = suppressAction;
                    eventData.set(objArr);
                    this.mAMEventHook.hook(Event.AM_ReadyToStartComponent, eventData);
                    suppressAction = eventData.getString(Index.suppressAction);
                    if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                        Slog.i(TAG, "[process suppression] broadcastIntent: suppressAction = " + suppressAction);
                    }
                }
                if (suppressAction != null) {
                    if (suppressAction.equals("skipped")) {
                        res = 0;
                        Binder.restoreCallingIdentity(origId);
                    }
                }
                res = broadcastIntentLocked(callerApp, callerAppPackageName, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, userId);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return res;
    }

    int broadcastIntentInPackage(String packageName, int uid, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String requiredPermission, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
        int res;
        synchronized (this) {
            try {
                String[] requiredPermissions;
                boostPriorityForLockedSection();
                intent = verifyBroadcastLocked(intent);
                long origId = Binder.clearCallingIdentity();
                if (requiredPermission == null) {
                    requiredPermissions = null;
                } else {
                    requiredPermissions = new String[1];
                    requiredPermissions[0] = requiredPermission;
                }
                res = 0;
                String suppressAction = "allowed";
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("persist.runningbooster.support")) || LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("ro.mtk_aws_support"))) {
                    ReadyToStartComponent eventData = ReadyToStartComponent.createInstance();
                    Object[] objArr = new Object[10];
                    objArr[0] = packageName;
                    objArr[1] = Integer.valueOf(uid);
                    objArr[2] = null;
                    objArr[3] = null;
                    objArr[4] = null;
                    objArr[5] = null;
                    objArr[6] = null;
                    objArr[7] = null;
                    objArr[8] = "broadcast_p";
                    objArr[9] = suppressAction;
                    eventData.set(objArr);
                    this.mAMEventHook.hook(Event.AM_ReadyToStartComponent, eventData);
                    suppressAction = eventData.getString(Index.suppressAction);
                    if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_ALL) {
                        Slog.i(TAG, "[process suppression] broadcastIntentInPackage: suppressAction = " + suppressAction);
                    }
                }
                if (suppressAction != null) {
                    if (suppressAction.equals("skipped")) {
                        Slog.d(TAG, "[process suppression] broadcastIntentInPackage : skip sending broadcast by pendingintent");
                        Binder.restoreCallingIdentity(origId);
                    }
                }
                Slog.d(TAG, "[process suppression] broadcastIntentInPackage : allow sending broadcast by pendingintent");
                res = broadcastIntentLocked(null, packageName, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, -1, bOptions, serialized, sticky, -1, uid, userId);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return res;
    }

    public final void unbroadcastIntent(IApplicationThread caller, Intent intent, int userId) {
        if (intent == null || !intent.hasFileDescriptors()) {
            userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 0, "removeStickyBroadcast", null);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (checkCallingPermission("android.permission.BROADCAST_STICKY") != 0) {
                        String msg = "Permission Denial: unbroadcastIntent() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.BROADCAST_STICKY";
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                    ArrayMap<String, ArrayList<Intent>> stickies = (ArrayMap) this.mStickyBroadcasts.get(userId);
                    if (stickies != null) {
                        ArrayList<Intent> list = (ArrayList) stickies.get(intent.getAction());
                        if (list != null) {
                            int N = list.size();
                            for (int i = 0; i < N; i++) {
                                if (intent.filterEquals((Intent) list.get(i))) {
                                    list.remove(i);
                                    break;
                                }
                            }
                            if (list.size() <= 0) {
                                stickies.remove(intent.getAction());
                            }
                        }
                        if (stickies.size() <= 0) {
                            this.mStickyBroadcasts.remove(userId);
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    void backgroundServicesFinishedLocked(int userId) {
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.backgroundServicesFinishedLocked(userId);
        }
    }

    public void finishReceiver(IBinder who, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort, int flags) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v(TAG_BROADCAST, "BDC-Finish receiver: " + who);
        }
        if (resultExtras == null || !resultExtras.hasFileDescriptors()) {
            long origId = Binder.clearCallingIdentity();
            boolean doNext = false;
            try {
                BroadcastRecord r;
                synchronized (this) {
                    boostPriorityForLockedSection();
                    BroadcastQueue queue = (DumpState.DUMP_COMPILER_STATS & flags) != 0 ? OppoBroadcastManager.getInstance(this).GetQueueFromFlag(flags) : (268435456 & flags) != 0 ? this.mFgBroadcastQueue : this.mBgBroadcastQueue;
                    r = queue.getMatchingOrderedReceiver(who);
                    if (r != null) {
                        if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                            Slog.d(TAG_BROADCAST, r + ", spend: " + (SystemClock.uptimeMillis() - r.receiverTime) + (r.receiver != null ? ", " + r.receiver : IElsaManager.EMPTY_PACKAGE) + (r.curFilter != null ? ", " + r.curFilter : IElsaManager.EMPTY_PACKAGE) + (r.curReceiver != null ? ", " + r.curReceiver : IElsaManager.EMPTY_PACKAGE));
                        }
                        doNext = r.queue.finishReceiverLocked(r, resultCode, resultData, resultExtras, resultAbort, true);
                    }
                }
                resetPriorityAfterLockedSection();
                if (doNext) {
                    r.queue.processNextBroadcast(false);
                }
                trimApplications();
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(origId);
            }
        } else {
            throw new IllegalArgumentException("File descriptors passed in Bundle");
        }
    }

    public void finishNotOrderReceiver(IBinder who, int hasCode, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v(TAG, "Finish not order hasCode: " + hasCode);
        }
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ReceiverRecord mReceiverRecord = broadcastRecordForNotOrderReceiverLocked(who, hasCode);
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Slog.v(TAG, "mReceiverRecord: " + mReceiverRecord);
                }
                if (mReceiverRecord != null) {
                    mReceiverRecord.cancelBroadcastTimeoutLocked();
                }
            }
            resetPriorityAfterLockedSection();
            this.mFinishBroadcastCount++;
            if (this.mFinishBroadcastCount == 5) {
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Slog.v(TAG, "trimApplications() ");
                }
                trimApplications();
                this.mFinishBroadcastCount = 0;
            }
            Binder.restoreCallingIdentity(origId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean startInstrumentation(ComponentName className, String profileFile, int flags, Bundle arguments, IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection, int userId, String abiOverride) {
        enforceNotIsolatedCaller("startInstrumentation");
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startInstrumentation", null);
        if (arguments == null || !arguments.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    InstrumentationInfo instrumentationInfo = null;
                    ApplicationInfo ai = null;
                    try {
                        instrumentationInfo = this.mContext.getPackageManager().getInstrumentationInfo(className, 1024);
                        ai = AppGlobals.getPackageManager().getApplicationInfo(instrumentationInfo.targetPackage, 1024, userId);
                    } catch (NameNotFoundException e) {
                    } catch (RemoteException e2) {
                    }
                    if (instrumentationInfo == null) {
                        reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation info for: " + className);
                    } else if (ai == null) {
                        reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation target package: " + instrumentationInfo.targetPackage);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else if (ai.hasCode()) {
                        int match = this.mContext.getPackageManager().checkSignatures(instrumentationInfo.targetPackage, instrumentationInfo.packageName);
                        if (match >= 0 || match == -1) {
                            long origId = Binder.clearCallingIdentity();
                            forceStopPackageLocked(instrumentationInfo.targetPackage, -1, true, false, true, true, false, userId, "start instr");
                            ProcessRecord app = addAppLocked(ai, false, abiOverride);
                            app.instrumentationClass = className;
                            app.instrumentationInfo = ai;
                            app.instrumentationProfileFile = profileFile;
                            app.instrumentationArguments = arguments;
                            app.instrumentationWatcher = watcher;
                            app.instrumentationUiAutomationConnection = uiAutomationConnection;
                            app.instrumentationResultClass = className;
                            Binder.restoreCallingIdentity(origId);
                            resetPriorityAfterLockedSection();
                            return true;
                        }
                        String msg = "Permission Denial: starting instrumentation " + className + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingPid() + " not allowed because package " + instrumentationInfo.packageName + " does not have a signature matching the target " + instrumentationInfo.targetPackage;
                        reportStartInstrumentationFailureLocked(watcher, className, msg);
                        throw new SecurityException(msg);
                    } else {
                        reportStartInstrumentationFailureLocked(watcher, className, "Instrumentation target has no code: " + instrumentationInfo.targetPackage);
                        resetPriorityAfterLockedSection();
                        return false;
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } else {
            throw new IllegalArgumentException("File descriptors passed in Bundle");
        }
        return false;
    }

    private void reportStartInstrumentationFailureLocked(IInstrumentationWatcher watcher, ComponentName cn, String report) {
        Slog.w(TAG, report);
        if (watcher != null) {
            Bundle results = new Bundle();
            results.putString(DecryptTool.UNLOCK_TYPE_ID, "ActivityManagerService");
            results.putString("Error", report);
            this.mInstrumentationReporter.reportStatus(watcher, cn, -1, results);
        }
    }

    void finishInstrumentationLocked(ProcessRecord app, int resultCode, Bundle results) {
        if (app.instrumentationWatcher != null) {
            this.mInstrumentationReporter.reportFinished(app.instrumentationWatcher, app.instrumentationClass, resultCode, results);
        }
        if (app.instrumentationUiAutomationConnection != null) {
            this.mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG, app.instrumentationUiAutomationConnection).sendToTarget();
        }
        app.instrumentationWatcher = null;
        app.instrumentationUiAutomationConnection = null;
        app.instrumentationClass = null;
        app.instrumentationInfo = null;
        app.instrumentationProfileFile = null;
        app.instrumentationArguments = null;
        forceStopPackageLocked(app.info.packageName, -1, false, false, true, true, false, app.userId, "finished inst");
    }

    public void finishInstrumentation(IApplicationThread target, int resultCode, Bundle results) {
        int userId = UserHandle.getCallingUserId();
        if (results == null || !results.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord app = getRecordForAppLocked(target);
                    if (app == null) {
                        Slog.w(TAG, "finishInstrumentation: no app for " + target);
                    } else {
                        long origId = Binder.clearCallingIdentity();
                        finishInstrumentationLocked(app, resultCode, results);
                        Binder.restoreCallingIdentity(origId);
                        resetPriorityAfterLockedSection();
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } else {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
    }

    public ConfigurationInfo getDeviceConfigurationInfo() {
        ConfigurationInfo config = new ConfigurationInfo();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                config.reqTouchScreen = this.mConfiguration.touchscreen;
                config.reqKeyboardType = this.mConfiguration.keyboard;
                config.reqNavigation = this.mConfiguration.navigation;
                if (this.mConfiguration.navigation == 2 || this.mConfiguration.navigation == 3) {
                    config.reqInputFeatures |= 2;
                }
                if (!(this.mConfiguration.keyboard == 0 || this.mConfiguration.keyboard == 1)) {
                    config.reqInputFeatures |= 1;
                }
                config.reqGlEsVersion = this.GL_ES_VERSION;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return config;
    }

    ActivityStack getFocusedStack() {
        return this.mStackSupervisor.getFocusedStack();
    }

    public int getFocusedStackId() throws RemoteException {
        ActivityStack focusedStack = getFocusedStack();
        if (focusedStack != null) {
            return focusedStack.getStackId();
        }
        return -1;
    }

    public Configuration getConfiguration() {
        Configuration ci;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ci = new Configuration(this.mConfiguration);
                ci.userSetLocale = false;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return ci;
    }

    public void suppressResizeConfigChanges(boolean suppress) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "suppressResizeConfigChanges()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mSuppressResizeConfigChanges = suppress;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void moveTasksToFullscreenStack(int fromStackId, boolean onTop) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTasksToFullscreenStack()");
        if (fromStackId == 0) {
            throw new IllegalArgumentException("You can't move tasks from the home stack.");
        }
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                this.mStackSupervisor.moveTasksToFullscreenStackLocked(fromStackId, onTop);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void updatePersistentConfiguration(Configuration values) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updateConfiguration()");
        enforceWriteSettingsPermission("updateConfiguration()");
        if (values == null) {
            throw new NullPointerException("Configuration must not be null");
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                updatePersistentConfigurationLocked(values, userId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void updatePersistentConfigurationLocked(Configuration values, int userId) {
        long origId = Binder.clearCallingIdentity();
        try {
            updateConfigurationLocked(values, null, false, true, userId, false);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    private void updateFontScaleIfNeeded(int userId) {
        float scaleFactor = System.getFloatForUser(this.mContext.getContentResolver(), "font_scale", 1.0f, userId);
        if (this.mConfiguration.fontScale != scaleFactor) {
            Configuration configuration = this.mWindowManager.computeNewConfiguration();
            configuration.fontScale = scaleFactor;
            synchronized (this) {
                long origId;
                try {
                    boostPriorityForLockedSection();
                    origId = Binder.clearCallingIdentity();
                    updateConfigurationLocked(configuration, null, false, false, userId, false);
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
        }
    }

    private void enforceWriteSettingsPermission(String func) {
        int uid = Binder.getCallingUid();
        if (uid != 0 && !Settings.checkAndNoteWriteSettingsOperation(this.mContext, uid, Settings.getPackageNameForUid(this.mContext, uid), false)) {
            String msg = "Permission Denial: " + func + " from pid=" + Binder.getCallingPid() + ", uid=" + uid + " requires " + "android.permission.WRITE_SETTINGS";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
    }

    public void updateConfiguration(Configuration values) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updateConfiguration()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (values == null && this.mWindowManager != null) {
                    values = this.mWindowManager.computeNewConfiguration();
                }
                if (this.mWindowManager != null) {
                    this.mProcessList.applyDisplaySize(this.mWindowManager);
                }
                long origId = Binder.clearCallingIdentity();
                if (values != null) {
                    System.clearConfiguration(values);
                }
                updateConfigurationLocked(values, null, false);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void updateUserConfigurationLocked() {
        Configuration configuration = new Configuration(this.mConfiguration);
        System.adjustConfigurationForUser(this.mContext.getContentResolver(), configuration, this.mUserController.getCurrentUserIdLocked(), System.canWrite(this.mContext));
        updateConfigurationLocked(configuration, null, false);
    }

    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale) {
        return updateConfigurationLocked(values, starting, initLocale, false);
    }

    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean deferResume) {
        return updateConfigurationLocked(values, starting, initLocale, false, -10000, deferResume);
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "YaoJun.Luo@Plf.SDK : Modify for rom theme", property = OppoRomType.ROM)
    private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean persistent, int userId, boolean deferResume) {
        int changes = 0;
        if (!(this.mConfiguration == null || values == null)) {
            Locale beforeLocale = this.mConfiguration.getLocales() == null ? null : this.mConfiguration.getLocales().get(0);
            Locale newLocale = values.getLocales() == null ? null : values.getLocales().get(0);
            if (!(beforeLocale == null || newLocale == null)) {
                String sbeforeLocale = beforeLocale.toLanguageTag();
                String snewLocale = newLocale.toLanguageTag();
                if (!(sbeforeLocale == null || snewLocale == null)) {
                    if (sbeforeLocale.equals(snewLocale)) {
                    }
                }
            }
        }
        if (this.mWindowManager != null) {
            this.mWindowManager.deferSurfaceLayout();
        }
        if (values != null) {
            Configuration configuration = new Configuration(this.mConfiguration);
            changes = configuration.updateFrom(values);
            if (changes != 0) {
                if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                    Slog.i(TAG_CONFIGURATION, "Updating configuration to: " + values);
                }
                EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes);
                if (!(initLocale || values.getLocales().isEmpty() || !values.userSetLocale)) {
                    LocaleList locales = values.getLocales();
                    int bestLocaleIndex = 0;
                    if (locales.size() > 1) {
                        if (this.mSupportedSystemLocales == null) {
                            this.mSupportedSystemLocales = Resources.getSystem().getAssets().getLocales();
                        }
                        bestLocaleIndex = Math.max(0, locales.getFirstMatchIndex(this.mSupportedSystemLocales));
                    }
                    SystemProperties.set("persist.sys.locale", locales.get(bestLocaleIndex).toLanguageTag());
                    LocaleList.setDefault(locales, bestLocaleIndex);
                    this.mHandler.sendMessage(this.mHandler.obtainMessage(47, locales.get(bestLocaleIndex)));
                }
                this.mConfigurationSeq++;
                if (this.mConfigurationSeq <= 0) {
                    this.mConfigurationSeq = 1;
                }
                configuration.seq = this.mConfigurationSeq;
                this.mConfiguration = configuration;
                Slog.i(TAG, "Config changes=" + Integer.toHexString(changes) + " " + configuration);
                this.mUsageStatsService.reportConfigurationChange(configuration, this.mUserController.getCurrentUserIdLocked());
                configuration = new Configuration(this.mConfiguration);
                this.mShowDialogs = shouldShowDialogs(configuration, this.mInVrMode);
                AttributeCache ac = AttributeCache.instance();
                if (ac != null) {
                    ac.updateConfiguration(configuration);
                }
                this.mSystemThread.applyConfigurationToResources(configuration);
                if (persistent && System.hasInterestingConfigurationChanges(changes)) {
                    Message msg = this.mHandler.obtainMessage(4);
                    msg.obj = new Configuration(configuration);
                    msg.arg1 = userId;
                    this.mHandler.sendMessage(msg);
                }
                if ((changes & 4096) != 0) {
                    this.mUiHandler.sendEmptyMessage(70);
                    killAllBackgroundProcessesExcept(24, 4);
                }
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                    try {
                        if (app.thread != null) {
                            if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                                Slog.v(TAG_CONFIGURATION, "Sending to proc " + app.processName + " new config " + this.mConfiguration);
                            }
                            app.thread.scheduleConfigurationChanged(configuration);
                        }
                    } catch (Exception e) {
                    }
                }
                Intent intent = new Intent("android.intent.action.CONFIGURATION_CHANGED");
                intent.addFlags(1879048192);
                broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, -1);
                if ((changes & 4) != 0) {
                    intent = new Intent("android.intent.action.LOCALE_CHANGED");
                    intent.addFlags(268435456);
                    if (initLocale || !this.mProcessesReady) {
                        intent.addFlags(1073741824);
                    }
                    broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, -1);
                }
                if ((134217728 & changes) != 0) {
                    Log.e(TAG, "skin is changed, send broadcast to app!!");
                    SystemProperties.set("persist.sys.themeflag", Long.toString(configuration.mOppoExtraConfiguration.mThemeChangedFlags));
                    broadcastIntentLocked(null, null, new Intent("android.intent.action.SKIN_CHANGED"), null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, 0);
                }
                OppoThemeHelper.handleExtraConfigurationChanges(changes, configuration, this.mContext, this.mHandler);
            }
            if (this.mWindowManager != null) {
                int[] resizedStacks = this.mWindowManager.setNewConfiguration(this.mConfiguration);
                if (resizedStacks != null) {
                    for (int stackId : resizedStacks) {
                        this.mStackSupervisor.resizeStackLocked(stackId, this.mWindowManager.getBoundsForNewConfiguration(stackId), null, null, false, false, deferResume);
                    }
                }
            }
        }
        boolean kept = true;
        ActivityStack mainStack = this.mStackSupervisor.getFocusedStack();
        if (mainStack != null) {
            if (changes != 0 && starting == null) {
                starting = mainStack.topRunningActivityLocked();
            }
            if (starting != null) {
                kept = mainStack.ensureActivityConfigurationLocked(starting, changes, false);
                this.mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes, false);
            }
        }
        if (this.mWindowManager != null) {
            this.mWindowManager.continueSurfaceLayout();
        }
        return kept;
    }

    private static final boolean shouldShowDialogs(Configuration config, boolean inVrMode) {
        boolean inputMethodExists = (config.keyboard == 1 && config.touchscreen == 1) ? config.navigation != 1 : true;
        int modeType = config.uiMode & 15;
        boolean uiModeSupportsDialogs = modeType != 3 ? (modeType == 6 && "user".equals(Build.TYPE)) ? false : true : false;
        if (inputMethodExists && uiModeSupportsDialogs && !inVrMode) {
            return true;
        }
        return false;
    }

    public boolean shouldUpRecreateTask(IBinder token, String destAffinity) {
        boolean shouldUpRecreateTaskLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord srec = ActivityRecord.forTokenLocked(token);
                if (srec != null) {
                    shouldUpRecreateTaskLocked = srec.task.stack.shouldUpRecreateTaskLocked(srec, destAffinity);
                } else {
                    resetPriorityAfterLockedSection();
                    return false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return shouldUpRecreateTaskLocked;
    }

    public boolean navigateUpTo(IBinder token, Intent destIntent, int resultCode, Intent resultData) {
        boolean navigateUpToLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r != null) {
                    navigateUpToLocked = r.task.stack.navigateUpToLocked(r, destIntent, resultCode, resultData);
                } else {
                    resetPriorityAfterLockedSection();
                    return false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return navigateUpToLocked;
    }

    public int getLaunchedFromUid(IBinder activityToken) {
        ActivityRecord srec;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                srec = ActivityRecord.forTokenLocked(activityToken);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (srec == null) {
            return -1;
        }
        return srec.launchedFromUid;
    }

    public String getLaunchedFromPackage(IBinder activityToken) {
        ActivityRecord srec;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                srec = ActivityRecord.forTokenLocked(activityToken);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (srec == null) {
            return null;
        }
        return srec.launchedFromPackage;
    }

    /* JADX WARNING: Missing block: B:15:0x0023, code:
            r2 = null;
     */
    /* JADX WARNING: Missing block: B:16:0x0026, code:
            if (r10.foreCurReceiver == null) goto L_0x0032;
     */
    /* JADX WARNING: Missing block: B:17:0x0028, code:
            r2 = r10.foreCurReceiver;
     */
    /* JADX WARNING: Missing block: B:18:0x002a, code:
            if (r2 == null) goto L_0x0047;
     */
    /* JADX WARNING: Missing block: B:20:0x002e, code:
            return r2.queue;
     */
    /* JADX WARNING: Missing block: B:25:0x0034, code:
            if (r10.backCurReceiver == null) goto L_0x0039;
     */
    /* JADX WARNING: Missing block: B:26:0x0036, code:
            r2 = r10.backCurReceiver;
     */
    /* JADX WARNING: Missing block: B:28:0x003b, code:
            if (r10.oppoforeCurReceiver == null) goto L_0x0040;
     */
    /* JADX WARNING: Missing block: B:29:0x003d, code:
            r2 = r10.oppoforeCurReceiver;
     */
    /* JADX WARNING: Missing block: B:31:0x0042, code:
            if (r10.oppobackCurReceiver == null) goto L_0x002a;
     */
    /* JADX WARNING: Missing block: B:32:0x0044, code:
            r2 = r10.oppobackCurReceiver;
     */
    /* JADX WARNING: Missing block: B:33:0x0047, code:
            monitor-enter(r9);
     */
    /* JADX WARNING: Missing block: B:35:?, code:
            boostPriorityForLockedSection();
            r5 = r9.mBroadcastQueues;
            r4 = 0;
            r6 = r5.length;
     */
    /* JADX WARNING: Missing block: B:36:0x004f, code:
            if (r4 >= r6) goto L_0x0063;
     */
    /* JADX WARNING: Missing block: B:37:0x0051, code:
            r1 = r5[r4];
            r2 = r1.mPendingBroadcast;
     */
    /* JADX WARNING: Missing block: B:38:0x0055, code:
            if (r2 == null) goto L_0x0060;
     */
    /* JADX WARNING: Missing block: B:40:0x0059, code:
            if (r2.curApp != r10) goto L_0x0060;
     */
    /* JADX WARNING: Missing block: B:41:0x005b, code:
            monitor-exit(r9);
     */
    /* JADX WARNING: Missing block: B:43:0x0060, code:
            r4 = r4 + 1;
     */
    /* JADX WARNING: Missing block: B:44:0x0063, code:
            monitor-exit(r9);
     */
    /* JADX WARNING: Missing block: B:45:0x0064, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:46:0x0067, code:
            return null;
     */
    /* JADX WARNING: Missing block: B:48:0x006a, code:
            resetPriorityAfterLockedSection();
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private BroadcastQueue isReceivingBroadcast(ProcessRecord app) {
        synchronized (app.receiverRecords) {
            int i = 0;
            while (i < app.receiverRecords.size()) {
                ReceiverRecord receiverRecord = (ReceiverRecord) app.receiverRecords.get(i);
                if (receiverRecord == null || receiverRecord.mQueue == null) {
                    i++;
                } else {
                    BroadcastQueue broadcastQueue = receiverRecord.mQueue;
                    return broadcastQueue;
                }
            }
        }
        return queue;
    }

    Association startAssociationLocked(int sourceUid, String sourceProcess, int sourceState, int targetUid, ComponentName targetComponent, String targetProcess) {
        if (!this.mTrackingAssociations) {
            return null;
        }
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = (ArrayMap) this.mAssociations.get(targetUid);
        if (components == null) {
            components = new ArrayMap();
            this.mAssociations.put(targetUid, components);
        }
        SparseArray<ArrayMap<String, Association>> sourceUids = (SparseArray) components.get(targetComponent);
        if (sourceUids == null) {
            sourceUids = new SparseArray();
            components.put(targetComponent, sourceUids);
        }
        ArrayMap<String, Association> sourceProcesses = (ArrayMap) sourceUids.get(sourceUid);
        if (sourceProcesses == null) {
            sourceProcesses = new ArrayMap();
            sourceUids.put(sourceUid, sourceProcesses);
        }
        Association ass = (Association) sourceProcesses.get(sourceProcess);
        if (ass == null) {
            ass = new Association(sourceUid, sourceProcess, targetUid, targetComponent, targetProcess);
            sourceProcesses.put(sourceProcess, ass);
        }
        ass.mCount++;
        ass.mNesting++;
        if (ass.mNesting == 1) {
            long uptimeMillis = SystemClock.uptimeMillis();
            ass.mLastStateUptime = uptimeMillis;
            ass.mStartTime = uptimeMillis;
            ass.mLastState = sourceState;
        }
        return ass;
    }

    void stopAssociationLocked(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent) {
        if (this.mTrackingAssociations) {
            ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = (ArrayMap) this.mAssociations.get(targetUid);
            if (components != null) {
                SparseArray<ArrayMap<String, Association>> sourceUids = (SparseArray) components.get(targetComponent);
                if (sourceUids != null) {
                    ArrayMap<String, Association> sourceProcesses = (ArrayMap) sourceUids.get(sourceUid);
                    if (sourceProcesses != null) {
                        Association ass = (Association) sourceProcesses.get(sourceProcess);
                        if (ass != null && ass.mNesting > 0) {
                            ass.mNesting--;
                            if (ass.mNesting == 0) {
                                long uptime = SystemClock.uptimeMillis();
                                ass.mTime += uptime - ass.mStartTime;
                                long[] jArr = ass.mStateTimes;
                                int i = ass.mLastState + 1;
                                jArr[i] = jArr[i] + (uptime - ass.mLastStateUptime);
                                ass.mLastState = 18;
                            }
                        }
                    }
                }
            }
        }
    }

    private void noteUidProcessState(int uid, int state) {
        this.mBatteryStatsService.noteUidProcessState(uid, state);
        if (this.mTrackingAssociations) {
            int N1 = this.mAssociations.size();
            for (int i1 = 0; i1 < N1; i1++) {
                ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents = (ArrayMap) this.mAssociations.valueAt(i1);
                int N2 = targetComponents.size();
                for (int i2 = 0; i2 < N2; i2++) {
                    ArrayMap<String, Association> sourceProcesses = (ArrayMap) ((SparseArray) targetComponents.valueAt(i2)).get(uid);
                    if (sourceProcesses != null) {
                        int N4 = sourceProcesses.size();
                        for (int i4 = 0; i4 < N4; i4++) {
                            Association ass = (Association) sourceProcesses.valueAt(i4);
                            if (ass.mNesting >= 1) {
                                long uptime = SystemClock.uptimeMillis();
                                long[] jArr = ass.mStateTimes;
                                int i = ass.mLastState + 1;
                                jArr[i] = jArr[i] + (uptime - ass.mLastStateUptime);
                                ass.mLastState = state;
                                ass.mLastStateUptime = uptime;
                            }
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:61:0x01bf  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
        if (this.mAdjSeq == app.adjSeq) {
            return app.curRawAdj;
        }
        if (app.thread == null) {
            app.adjSeq = this.mAdjSeq;
            app.curSchedGroup = 0;
            app.curProcState = 16;
            app.curRawAdj = 906;
            app.curAdj = 906;
            return 906;
        }
        app.adjTypeCode = 0;
        app.adjSource = null;
        app.adjTarget = null;
        app.empty = false;
        app.cached = false;
        int activitiesSize = app.activities.size();
        int j;
        if (app.maxAdj <= 0) {
            app.adjType = "fixed";
            app.adjSeq = this.mAdjSeq;
            app.curRawAdj = app.maxAdj;
            app.foregroundActivities = false;
            app.curSchedGroup = 1;
            app.curProcState = 0;
            app.systemNoUi = true;
            if (app == TOP_APP) {
                app.systemNoUi = false;
                app.curSchedGroup = 2;
                app.adjType = "pers-top-activity";
            } else if (app.hasTopUi) {
                app.systemNoUi = false;
                app.curSchedGroup = 2;
                app.adjType = "pers-top-ui";
            } else if (activitiesSize > 0) {
                for (j = 0; j < activitiesSize; j++) {
                    if (((ActivityRecord) app.activities.get(j)).visible) {
                        app.systemNoUi = false;
                    }
                }
            }
            if (!app.systemNoUi) {
                app.curProcState = 1;
            }
            int i = app.maxAdj;
            app.curAdj = i;
            return i;
        }
        int adj;
        int schedGroup;
        int procState;
        int i2;
        ProcessRecord client;
        int clientAdj;
        int clientProcState;
        app.systemNoUi = false;
        int PROCESS_STATE_CUR_TOP = this.mTopProcessState;
        boolean foregroundActivities = false;
        if (app == TOP_APP) {
            adj = 0;
            schedGroup = 2;
            app.adjType = "top-activity";
            foregroundActivities = true;
            procState = PROCESS_STATE_CUR_TOP;
        } else if (app.instrumentationClass != null) {
            adj = 0;
            schedGroup = 1;
            app.adjType = "instrumentation";
            procState = 4;
        } else {
            BroadcastQueue queue = isReceivingBroadcast(app);
            if (queue != null) {
                adj = 0;
                schedGroup = (queue == this.mFgBroadcastQueue || queue == OppoBroadcastManager.getInstance(this).mOppoFgBroadcastQueue) ? 1 : 0;
                app.adjType = OppoProcessManager.RESUME_REASON_BROADCAST_STR;
                procState = 11;
            } else if (app.executingServices.size() > 0) {
                adj = 0;
                schedGroup = app.execServicesFg ? 1 : 0;
                app.adjType = "exec-service";
                procState = 10;
            } else {
                schedGroup = 0;
                adj = cachedAdj;
                procState = 16;
                app.cached = true;
                app.empty = true;
                app.adjType = "cch-empty";
            }
        }
        if (!foregroundActivities && activitiesSize > 0) {
            int minLayer = 99;
            j = 0;
            while (j < activitiesSize) {
                ActivityRecord r = (ActivityRecord) app.activities.get(j);
                if (r.app != app) {
                    Log.e(TAG, "Found activity " + r + " in proc activity list using " + r.app + " instead of expected " + app);
                    if (r.app == null || r.app.uid == app.uid) {
                        r.app = app;
                    } else {
                        j++;
                    }
                }
                if (r.visible) {
                    if (adj > 100) {
                        adj = 100;
                        app.adjType = "visible";
                    }
                    if (procState > PROCESS_STATE_CUR_TOP) {
                        procState = PROCESS_STATE_CUR_TOP;
                    }
                    schedGroup = 1;
                    app.cached = false;
                    app.empty = false;
                    foregroundActivities = true;
                    if (r.task != null) {
                        int layer = r.task.mLayerRank;
                        if (layer >= 0 && 99 > layer) {
                            minLayer = layer;
                        }
                    }
                    if (adj == 100) {
                        adj += minLayer;
                    }
                } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
                    if (adj > 200) {
                        adj = 200;
                        app.adjType = "pausing";
                    }
                    if (procState > PROCESS_STATE_CUR_TOP) {
                        procState = PROCESS_STATE_CUR_TOP;
                    }
                    schedGroup = 1;
                    app.cached = false;
                    app.empty = false;
                    foregroundActivities = true;
                    j++;
                } else {
                    if (r.state == ActivityState.STOPPING) {
                        if (adj > 200) {
                            adj = 200;
                            app.adjType = "stopping";
                        }
                        if (!r.finishing && procState > 13) {
                            procState = 13;
                        }
                        app.cached = false;
                        app.empty = false;
                        foregroundActivities = true;
                    } else if (procState > 14) {
                        procState = 14;
                        app.adjType = "cch-act";
                    }
                    j++;
                }
            }
            if (adj == 100) {
            }
        }
        if (adj > 200 || procState > 4) {
            if (app.foregroundServices) {
                adj = 200;
                procState = 4;
                app.cached = false;
                app.adjType = "fg-service";
                schedGroup = 1;
            } else if (app.forcingToForeground != null) {
                adj = 200;
                procState = 6;
                app.cached = false;
                app.adjType = "force-fg";
                app.adjSource = app.forcingToForeground;
                schedGroup = 1;
            }
        }
        if (app == this.mHeavyWeightProcess) {
            if (adj > 400) {
                adj = 400;
                schedGroup = 0;
                app.cached = false;
                app.adjType = "heavy";
            }
            if (procState > 9) {
                procState = 9;
            }
        }
        if (app == this.mHomeProcess) {
            if (adj > 600) {
                adj = 600;
                schedGroup = 0;
                app.cached = false;
                app.adjType = "home";
            }
            if (procState > 12) {
                procState = 12;
            }
        }
        if (app == this.mPreviousProcess && app.activities.size() > 0) {
            if (adj > START_OPPO_SITE_MSG) {
                adj = START_OPPO_SITE_MSG;
                schedGroup = 0;
                app.cached = false;
                app.adjType = "previous";
            }
            if (procState > 13) {
                procState = 13;
            }
        }
        app.adjSeq = this.mAdjSeq;
        app.curRawAdj = adj;
        app.hasStartedServices = false;
        if (this.mBackupTarget != null && app == this.mBackupTarget.app) {
            if (adj > 300) {
                if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                    Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
                }
                adj = 300;
                if (procState > 7) {
                    procState = 7;
                }
                app.adjType = "backup";
                app.cached = false;
            }
            if (procState > 8) {
                procState = 8;
            }
        }
        boolean mayBeTop = false;
        for (int is = app.services.size() - 1; is >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); is--) {
            ServiceRecord s = (ServiceRecord) app.services.valueAt(is);
            if (s.startRequested) {
                app.hasStartedServices = true;
                if (procState > 10) {
                    procState = 10;
                }
                if (!app.hasShownUi || app == this.mHomeProcess) {
                    if (now < s.lastActivity + 1800000 && adj > 500) {
                        adj = 500;
                        app.adjType = "started-services";
                        app.cached = false;
                    }
                    if (adj > 500) {
                        app.adjType = "cch-started-services";
                    }
                } else if (adj > 500) {
                    app.adjType = "cch-started-ui-services";
                }
            }
            for (int conni = s.connections.size() - 1; conni >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); conni--) {
                ArrayList<ConnectionRecord> clist = (ArrayList) s.connections.valueAt(conni);
                for (i2 = 0; i2 < clist.size() && (adj > 0 || schedGroup == 0 || procState > 2); i2++) {
                    ConnectionRecord cr = (ConnectionRecord) clist.get(i2);
                    if (cr.binding.client != app) {
                        if ((cr.flags & 32) == 0) {
                            client = cr.binding.client;
                            clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                            clientProcState = client.curProcState;
                            if (clientProcState >= 14) {
                                clientProcState = 16;
                            }
                            String adjType = null;
                            if ((cr.flags & 16) != 0) {
                                if (app.hasShownUi && app != this.mHomeProcess) {
                                    if (adj > clientAdj) {
                                        adjType = "cch-bound-ui-services";
                                    }
                                    app.cached = false;
                                    clientAdj = adj;
                                    clientProcState = procState;
                                } else if (now >= s.lastActivity + 1800000) {
                                    if (adj > clientAdj) {
                                        adjType = "cch-bound-services";
                                    }
                                    clientAdj = adj;
                                }
                            }
                            if (adj > clientAdj) {
                                if (!app.hasShownUi || app == this.mHomeProcess || clientAdj <= 200) {
                                    if ((cr.flags & 72) != 0) {
                                        adj = clientAdj >= -700 ? clientAdj : -700;
                                    } else if ((cr.flags & 1073741824) != 0 && clientAdj < 200 && adj > 200) {
                                        adj = 200;
                                    } else if (clientAdj >= 200) {
                                        adj = clientAdj;
                                    } else if (adj > 100) {
                                        adj = Math.max(clientAdj, 100);
                                    }
                                    if (!client.cached) {
                                        app.cached = false;
                                    }
                                    adjType = OppoProcessManager.RESUME_REASON_SERVICE_STR;
                                } else {
                                    adjType = "cch-bound-ui-services";
                                }
                            }
                            if ((cr.flags & 4) == 0) {
                                if (client.curSchedGroup > schedGroup) {
                                    if ((cr.flags & 64) != 0) {
                                        schedGroup = client.curSchedGroup;
                                    } else {
                                        schedGroup = 1;
                                    }
                                }
                                if (clientProcState <= 2) {
                                    if (clientProcState == 2) {
                                        mayBeTop = true;
                                        clientProcState = 16;
                                    } else if ((cr.flags & 67108864) != 0) {
                                        clientProcState = 3;
                                    } else if (this.mWakefulness != 1 || (cr.flags & 33554432) == 0) {
                                        clientProcState = 6;
                                    } else {
                                        clientProcState = 3;
                                    }
                                }
                            } else if (clientProcState < 7) {
                                clientProcState = 7;
                            }
                            if (procState > clientProcState) {
                                procState = clientProcState;
                            }
                            if (procState < 7 && (cr.flags & 536870912) != 0) {
                                app.pendingUiClean = true;
                            }
                            if (adjType != null) {
                                app.adjType = adjType;
                                app.adjTypeCode = 2;
                                app.adjSource = cr.binding.client;
                                app.adjSourceProcState = clientProcState;
                                app.adjTarget = s.name;
                            }
                        }
                        if ((cr.flags & 134217728) != 0) {
                            app.treatLikeActivity = true;
                        }
                        ActivityRecord a = cr.activity;
                        if ((cr.flags & 128) != 0 && a != null && adj > 0 && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
                            adj = 0;
                            if ((cr.flags & 4) == 0) {
                                if ((cr.flags & 64) != 0) {
                                    schedGroup = 3;
                                } else {
                                    schedGroup = 1;
                                }
                            }
                            app.cached = false;
                            app.adjType = OppoProcessManager.RESUME_REASON_SERVICE_STR;
                            app.adjTypeCode = 2;
                            app.adjSource = a;
                            app.adjSourceProcState = procState;
                            app.adjTarget = s.name;
                        }
                    }
                }
            }
        }
        for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); provi--) {
            ContentProviderRecord cpr = (ContentProviderRecord) app.pubProviders.valueAt(provi);
            for (i2 = cpr.connections.size() - 1; i2 >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); i2--) {
                client = ((ContentProviderConnection) cpr.connections.get(i2)).client;
                if (client != app) {
                    clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    clientProcState = client.curProcState;
                    if (clientProcState >= 14) {
                        clientProcState = 16;
                    }
                    if (adj > clientAdj) {
                        if (!app.hasShownUi || app == this.mHomeProcess || clientAdj <= 200) {
                            adj = clientAdj > 0 ? clientAdj : 0;
                            app.adjType = OppoProcessManager.RESUME_REASON_PROVIDER_STR;
                        } else {
                            app.adjType = "cch-ui-provider";
                        }
                        app.cached &= client.cached;
                        app.adjTypeCode = 1;
                        app.adjSource = client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = cpr.name;
                    }
                    if (clientProcState <= 2) {
                        if (clientProcState == 2) {
                            mayBeTop = true;
                            clientProcState = 16;
                        } else {
                            clientProcState = 3;
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                    }
                    if (client.curSchedGroup > schedGroup) {
                        schedGroup = 1;
                    }
                }
            }
            if (cpr.hasExternalProcessHandles()) {
                if (adj > 0) {
                    adj = 0;
                    schedGroup = 1;
                    app.cached = false;
                    app.adjType = OppoProcessManager.RESUME_REASON_PROVIDER_STR;
                    app.adjTarget = cpr.name;
                }
                if (procState > 6) {
                    procState = 6;
                }
            }
        }
        if (app.lastProviderTime > 0 && app.lastProviderTime + APP_DEXOPT_TIMEOUT > now) {
            if (adj > START_OPPO_SITE_MSG) {
                adj = START_OPPO_SITE_MSG;
                schedGroup = 0;
                app.cached = false;
                app.adjType = OppoProcessManager.RESUME_REASON_PROVIDER_STR;
            }
            if (procState > 13) {
                procState = 13;
            }
        }
        if (mayBeTop && procState > 2) {
            switch (procState) {
                case 6:
                case 7:
                case 10:
                    procState = 3;
                    break;
                default:
                    procState = 2;
                    break;
            }
        }
        if (procState >= 16) {
            if (app.hasClientActivities) {
                procState = 15;
                app.adjType = "cch-client-act";
            } else if (app.treatLikeActivity) {
                procState = 14;
                app.adjType = "cch-as-act";
            }
        }
        if (adj == 500) {
            if (doingAll) {
                app.serviceb = this.mNewNumAServiceProcs > this.mNumServiceProcs / 3;
                this.mNewNumServiceProcs++;
                if (app.serviceb) {
                    app.serviceHighRam = false;
                } else if (this.mLastMemoryLevel <= 0 || app.lastPss < this.mProcessList.getCachedRestoreThresholdKb()) {
                    this.mNewNumAServiceProcs++;
                } else {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                }
            }
            if (app.serviceb) {
                adj = 800;
            }
        }
        if (SystemProperties.get("ro.mtk_gmo_ram_optimize").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON) && app == this.mWallpaperProcess && adj == 100 && !this.mIsWallpaperFg) {
            adj = 600;
        }
        adj = getCustomizedAdj(app.processName, adj);
        if (app.info.uid == 1000 && app.processName != null) {
            if (isAgingTestTool(app.processName)) {
                adj = 0;
            }
        }
        if (!(app == TOP_APP || app.processName == null)) {
            if (isOppoImportantApp(app.processName) && !ActivityManager.isOppoLowRamDeviceStatic() && adj > START_OPPO_SITE_MSG) {
                adj = START_OPPO_SITE_MSG;
                app.adjType = "previous";
                schedGroup = 0;
                app.cached = false;
            }
        }
        app.curRawAdj = adj;
        if (adj > app.maxAdj) {
            adj = app.maxAdj;
            if (app.maxAdj <= 200) {
                schedGroup = 1;
            }
        }
        app.curAdj = app.modifyRawOomAdj(adj);
        app.curSchedGroup = schedGroup;
        app.curProcState = procState;
        app.foregroundActivities = foregroundActivities;
        return app.curRawAdj;
    }

    private boolean isAgingTestTool(String processName) {
        return !processName.contains("com.oppo.qetest") ? processName.contains("com.oppo.qemonitor") : true;
    }

    private boolean isOppoImportantApp(String processName) {
        if (processName.equals(TENCENT_NAME)) {
            return true;
        }
        return false;
    }

    void recordPssSampleLocked(ProcessRecord proc, int procState, long pss, long uss, long swapPss, long now) {
        EventLogTags.writeAmPss(proc.pid, proc.uid, proc.processName, 1024 * pss, 1024 * uss, 1024 * swapPss);
        proc.lastPssTime = now;
        try {
            proc.baseProcessTracker.addPss(pss, uss, true, proc.pkgList);
        } catch (Exception e) {
            Slog.d(TAG_PSS, "PSS of " + proc.toShortString() + ": " + pss + " lastPss=" + proc.lastPss + " state=" + ProcessList.makeProcStateString(procState));
            Slog.d(TAG_PSS, "addPss exception " + e);
        }
        if (ActivityManagerDebugConfig.DEBUG_PSS) {
            Slog.d(TAG_PSS, "PSS of " + proc.toShortString() + ": " + pss + " lastPss=" + proc.lastPss + " state=" + ProcessList.makeProcStateString(procState));
        }
        if (proc.initialIdlePss == 0) {
            proc.initialIdlePss = pss;
        }
        proc.lastPss = pss;
        proc.lastSwapPss = swapPss;
        if (procState >= 12) {
            proc.lastCachedPss = pss;
            proc.lastCachedSwapPss = swapPss;
        }
        if (SystemProperties.get("ro.mtk_aws_support").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON) && AWSManager.getInstance() != null) {
            AWSManager.getInstance().storeRecord(convertStoreRecord(proc, pss + swapPss));
        }
        SparseArray<Pair<Long, String>> watchUids = (SparseArray) this.mMemWatchProcesses.getMap().get(proc.processName);
        Long l = null;
        if (watchUids != null) {
            Pair<Long, String> val = (Pair) watchUids.get(proc.uid);
            if (val == null) {
                val = (Pair) watchUids.get(0);
            }
            if (val != null) {
                l = val.first;
            }
        }
        if (l != null && 1024 * pss >= l.longValue() && proc.thread != null && this.mMemWatchDumpProcName == null) {
            boolean isDebuggable = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
            if (!(isDebuggable || (proc.info.flags & 2) == 0)) {
                isDebuggable = true;
            }
            if (isDebuggable) {
                Slog.w(TAG, "Process " + proc + " exceeded pss limit " + l + "; reporting");
                ProcessRecord myProc = proc;
                final File heapdumpFile = DumpHeapProvider.getJavaFile();
                this.mMemWatchDumpProcName = proc.processName;
                this.mMemWatchDumpFile = heapdumpFile.toString();
                this.mMemWatchDumpPid = proc.pid;
                this.mMemWatchDumpUid = proc.uid;
                final ProcessRecord processRecord = proc;
                BackgroundThread.getHandler().post(new Runnable() {
                    public void run() {
                        ActivityManagerService.this.revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, 3, UserHandle.myUserId());
                        ParcelFileDescriptor fd = null;
                        try {
                            heapdumpFile.delete();
                            fd = ParcelFileDescriptor.open(heapdumpFile, 771751936);
                            IApplicationThread thread = processRecord.thread;
                            if (thread != null) {
                                try {
                                    if (ActivityManagerDebugConfig.DEBUG_PSS) {
                                        Slog.d(ActivityManagerService.TAG_PSS, "Requesting dump heap from " + processRecord + " to " + heapdumpFile);
                                    }
                                    thread.dumpHeap(true, heapdumpFile.toString(), fd);
                                } catch (RemoteException e) {
                                }
                            }
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e2) {
                                }
                            }
                        } catch (FileNotFoundException e3) {
                            e3.printStackTrace();
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e4) {
                                }
                            }
                        } catch (Throwable th) {
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e5) {
                                }
                            }
                        }
                    }
                });
                return;
            }
            Slog.w(TAG, "Process " + proc + " exceeded pss limit " + l + ", but debugging not enabled");
        }
    }

    void requestPssLocked(ProcessRecord proc, int procState) {
        if (!this.mPendingPssProcesses.contains(proc)) {
            if (this.mPendingPssProcesses.size() == 0) {
                this.mBgHandler.sendEmptyMessage(1);
            }
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d(TAG_PSS, "Requesting PSS of: " + proc);
            }
            proc.pssProcState = procState;
            this.mPendingPssProcesses.add(proc);
        }
    }

    void requestPssAllProcsLocked(long now, boolean always, boolean memLowered) {
        if (!always) {
            if (now < this.mLastFullPssTime + ((long) (memLowered ? FULL_PSS_LOWERED_INTERVAL : 600000))) {
                return;
            }
        }
        if (ActivityManagerDebugConfig.DEBUG_PSS) {
            Slog.d(TAG_PSS, "Requesting PSS of all procs!  memLowered=" + memLowered);
        }
        this.mLastFullPssTime = now;
        this.mFullPssPending = true;
        this.mPendingPssProcesses.ensureCapacity(this.mLruProcesses.size());
        this.mPendingPssProcesses.clear();
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (!(app.thread == null || app.curProcState == -1 || (!memLowered && now <= app.lastStateTime + LocationFudger.FASTEST_INTERVAL_MS))) {
                app.pssProcState = app.setProcState;
                app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, this.mTestPssMode, isSleepingLocked(), now);
                this.mPendingPssProcesses.add(app);
            }
        }
        this.mBgHandler.sendEmptyMessage(1);
    }

    public void setTestPssMode(boolean enabled) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mTestPssMode = enabled;
                if (enabled) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, true);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void performAppGcLocked(ProcessRecord app) {
        try {
            app.lastRequestedGc = SystemClock.uptimeMillis();
            if (app.thread == null) {
                return;
            }
            if (app.reportLowMemory) {
                app.reportLowMemory = false;
                app.thread.scheduleLowMemory();
                return;
            }
            app.thread.processInBackground();
        } catch (Exception e) {
        }
    }

    private final boolean canGcNowLocked() {
        boolean processingBroadcasts = false;
        for (BroadcastQueue q : this.mBroadcastQueues) {
            if (q.mParallelBroadcasts.size() != 0 || q.mOrderedBroadcasts.size() != 0) {
                processingBroadcasts = true;
            }
        }
        if (processingBroadcasts) {
            return false;
        }
        return !isSleepingLocked() ? this.mStackSupervisor.allResumedActivitiesIdle() : true;
    }

    final void performAppGcsLocked() {
        if (this.mProcessesToGc.size() > 0 && canGcNowLocked()) {
            while (this.mProcessesToGc.size() > 0) {
                ProcessRecord proc = (ProcessRecord) this.mProcessesToGc.remove(0);
                if (proc.curRawAdj <= 200) {
                    if (proc.reportLowMemory) {
                    }
                }
                if (proc.lastRequestedGc + 60000 <= SystemClock.uptimeMillis()) {
                    performAppGcLocked(proc);
                    scheduleAppGcsLocked();
                    return;
                }
                addProcessToGcListLocked(proc);
                scheduleAppGcsLocked();
            }
            scheduleAppGcsLocked();
        }
    }

    final void performAppGcsIfAppropriateLocked() {
        if (canGcNowLocked()) {
            performAppGcsLocked();
        } else {
            scheduleAppGcsLocked();
        }
    }

    final void scheduleAppGcsLocked() {
        this.mHandler.removeMessages(5);
        if (this.mProcessesToGc.size() > 0) {
            ProcessRecord proc = (ProcessRecord) this.mProcessesToGc.get(0);
            Message msg = this.mHandler.obtainMessage(5);
            long when = proc.lastRequestedGc + 60000;
            long now = SystemClock.uptimeMillis();
            if (when < now + 5000) {
                when = now + 5000;
            }
            this.mHandler.sendMessageAtTime(msg, when);
        }
    }

    final void addProcessToGcListLocked(ProcessRecord proc) {
        boolean added = false;
        for (int i = this.mProcessesToGc.size() - 1; i >= 0; i--) {
            if (((ProcessRecord) this.mProcessesToGc.get(i)).lastRequestedGc < proc.lastRequestedGc) {
                added = true;
                this.mProcessesToGc.add(i + 1, proc);
                break;
            }
        }
        if (!added) {
            this.mProcessesToGc.add(0, proc);
        }
    }

    final void scheduleAppGcLocked(ProcessRecord app) {
        if (app.lastRequestedGc + 60000 <= SystemClock.uptimeMillis() && !this.mProcessesToGc.contains(app)) {
            addProcessToGcListLocked(app);
            scheduleAppGcsLocked();
        }
    }

    final void checkExcessivePowerUsageLocked(boolean doKills) {
        updateCpuStatsNow();
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        boolean doWakeKills = doKills;
        boolean doCpuKills = doKills;
        if (this.mLastPowerCheckRealtime == 0) {
            doWakeKills = false;
        }
        if (this.mLastPowerCheckUptime == 0) {
            doCpuKills = false;
        }
        if (stats.isScreenOn()) {
            doWakeKills = false;
        }
        long curRealtime = SystemClock.elapsedRealtime();
        long realtimeSince = curRealtime - this.mLastPowerCheckRealtime;
        long curUptime = SystemClock.uptimeMillis();
        long uptimeSince = curUptime - this.mLastPowerCheckUptime;
        this.mLastPowerCheckRealtime = curRealtime;
        this.mLastPowerCheckUptime = curUptime;
        if (realtimeSince < ((long) WAKE_LOCK_MIN_CHECK_DURATION)) {
            doWakeKills = false;
        }
        if (uptimeSince < ((long) CPU_MIN_CHECK_DURATION)) {
            doCpuKills = false;
        }
        int i = this.mLruProcesses.size();
        while (i > 0) {
            i--;
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (app.setProcState >= 12) {
                long wtime;
                synchronized (stats) {
                    wtime = stats.getProcessWakeTime(app.info.uid, app.pid, curRealtime);
                }
                long wtimeUsed = wtime - app.lastWakeTime;
                long cputimeUsed = app.curCpuTime - app.lastCpuTime;
                if (ActivityManagerDebugConfig.DEBUG_POWER) {
                    StringBuilder stringBuilder = new StringBuilder(128);
                    stringBuilder.append("Wake for ");
                    app.toShortString(stringBuilder);
                    stringBuilder.append(": over ");
                    TimeUtils.formatDuration(realtimeSince, stringBuilder);
                    stringBuilder.append(" used ");
                    TimeUtils.formatDuration(wtimeUsed, stringBuilder);
                    stringBuilder.append(" (");
                    stringBuilder.append((100 * wtimeUsed) / realtimeSince);
                    stringBuilder.append("%)");
                    Slog.i(TAG_POWER, stringBuilder.toString());
                    stringBuilder.setLength(0);
                    stringBuilder.append("CPU for ");
                    app.toShortString(stringBuilder);
                    stringBuilder.append(": over ");
                    TimeUtils.formatDuration(uptimeSince, stringBuilder);
                    stringBuilder.append(" used ");
                    TimeUtils.formatDuration(cputimeUsed, stringBuilder);
                    stringBuilder.append(" (");
                    stringBuilder.append((100 * cputimeUsed) / uptimeSince);
                    stringBuilder.append("%)");
                    Slog.i(TAG_POWER, stringBuilder.toString());
                }
                if (doWakeKills && realtimeSince > 0 && (100 * wtimeUsed) / realtimeSince >= 50) {
                    synchronized (stats) {
                        stats.reportExcessiveWakeLocked(app.info.uid, app.processName, realtimeSince, wtimeUsed);
                    }
                    app.kill("excessive wake held " + wtimeUsed + " during " + realtimeSince, true);
                    if (app.baseProcessTracker != null) {
                        app.baseProcessTracker.reportExcessiveWake(app.pkgList);
                    }
                } else if (!doCpuKills || uptimeSince <= 0 || (100 * cputimeUsed) / uptimeSince < 25) {
                    app.lastWakeTime = wtime;
                    app.lastCpuTime = app.curCpuTime;
                } else {
                    synchronized (stats) {
                        stats.reportExcessiveCpuLocked(app.info.uid, app.processName, uptimeSince, cputimeUsed);
                    }
                    app.kill("excessive cpu " + cputimeUsed + " during " + uptimeSince, true);
                    if (app.baseProcessTracker != null) {
                        app.baseProcessTracker.reportExcessiveCpu(app.pkgList);
                    }
                }
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:79:0x0323  */
    /* JADX WARNING: Removed duplicated region for block: B:93:0x03b8  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
        boolean success = true;
        if (app.curRawAdj != app.setRawAdj) {
            app.setRawAdj = app.curRawAdj;
        }
        int changes = 0;
        boolean isAdjUnChanged = true;
        if (app.curAdj != app.setAdj) {
            ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj);
            OppoProcessManagerHelper.updateProcessState(app);
            isAdjUnChanged = false;
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.v(TAG_OOM_ADJ, "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType);
            }
            app.setAdj = app.curAdj;
            app.verifiedAdj = -10000;
        }
        if (app.setSchedGroup != app.curSchedGroup) {
            if (isAdjUnChanged && app.adjType != null && "top-activity".equals(app.adjType)) {
                OppoProcessManagerHelper.updateProcessState(app);
                Slog.v("OppoProcessManager", app.pid + " " + app.processName + " curadj " + app.curAdj + ": " + app.adjType + ": setAdj = " + app.setAdj);
            }
            int oldSchedGroup = app.setSchedGroup;
            app.setSchedGroup = app.curSchedGroup;
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.v(TAG_OOM_ADJ, "Setting sched group of " + app.processName + " to " + app.curSchedGroup);
            }
            if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == 0) {
                app.kill(app.waitingToKill, true);
                success = false;
            } else {
                int processGroup;
                switch (app.curSchedGroup) {
                    case 0:
                        processGroup = 0;
                        break;
                    case 2:
                    case 3:
                        processGroup = 5;
                        break;
                    default:
                        processGroup = -1;
                        break;
                }
                long oldId = Binder.clearCallingIdentity();
                Process.setProcessGroup(app.pid, processGroup);
                if (app.curSchedGroup == 2) {
                    if (oldSchedGroup != 2) {
                        if (this.mInVrMode && app.vrThreadTid != 0) {
                            try {
                                Process.setThreadScheduler(app.vrThreadTid, 1073741825, 1);
                            } catch (IllegalArgumentException e) {
                            }
                        }
                        try {
                            if (this.mUseFifoUiScheduling) {
                                app.savedPriority = Process.getThreadPriority(app.pid);
                                try {
                                    Process.setThreadScheduler(app.pid, 1073741825, 1);
                                } catch (IllegalArgumentException e2) {
                                }
                                if (app.renderThreadTid != 0) {
                                    try {
                                        Process.setThreadScheduler(app.renderThreadTid, 1073741825, 1);
                                    } catch (IllegalArgumentException e3) {
                                    }
                                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                        Slog.d("UI_FIFO", "Set RenderThread (TID " + app.renderThreadTid + ") to FIFO");
                                    }
                                } else if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Not setting RenderThread TID");
                                }
                            } else {
                                Process.setThreadPriority(app.pid, -10);
                                if (app.renderThreadTid != 0) {
                                    try {
                                        Process.setThreadPriority(app.renderThreadTid, -10);
                                    } catch (IllegalArgumentException e4) {
                                    }
                                }
                            }
                        } catch (Exception e5) {
                            Slog.w(TAG, "Failed setting process group of " + app.pid + " to " + app.curSchedGroup);
                            e5.printStackTrace();
                            Binder.restoreCallingIdentity(oldId);
                        } catch (Throwable th) {
                            Binder.restoreCallingIdentity(oldId);
                            throw th;
                        }
                    }
                } else if (oldSchedGroup == 2) {
                    if (app.curSchedGroup != 2) {
                        if (app.vrThreadTid != 0) {
                            Process.setThreadScheduler(app.vrThreadTid, 0, 0);
                        }
                        if (this.mUseFifoUiScheduling) {
                            Process.setThreadScheduler(app.pid, 0, 0);
                            Process.setThreadPriority(app.pid, app.savedPriority);
                            if (app.renderThreadTid != 0) {
                                Process.setThreadScheduler(app.renderThreadTid, 0, 0);
                                Process.setThreadPriority(app.renderThreadTid, -4);
                            }
                        } else {
                            Process.setThreadPriority(app.pid, 0);
                            if (app.renderThreadTid != 0) {
                                Process.setThreadPriority(app.renderThreadTid, 0);
                            }
                        }
                    }
                }
                Binder.restoreCallingIdentity(oldId);
            }
        }
        if (app.repForegroundActivities != app.foregroundActivities) {
            app.repForegroundActivities = app.foregroundActivities;
            changes = 1;
        }
        if (app.repProcState != app.curProcState) {
            app.repProcState = app.curProcState;
            changes |= 2;
            if (app.thread != null) {
                try {
                    app.thread.setProcessState(app.repProcState);
                } catch (RemoteException e6) {
                }
            }
        }
        if (app.setProcState == -1 || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
            app.lastStateTime = now;
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, this.mTestPssMode, isSleepingLocked(), now);
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
            }
        } else if (now > app.nextPssTime || (now > app.lastPssTime + 1800000 && now > app.lastStateTime + ProcessList.minTimeFromStateChange(this.mTestPssMode))) {
            requestPssLocked(app, app.setProcState);
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false, this.mTestPssMode, isSleepingLocked(), now);
        }
        if (app.setProcState != app.curProcState) {
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.v(TAG_OOM_ADJ, "Proc state change of " + app.processName + " to " + app.curProcState);
            }
            boolean setImportant = app.setProcState < 10;
            boolean curImportant = app.curProcState < 10;
            if (setImportant && !curImportant) {
                BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    try {
                        app.lastWakeTime = stats.getProcessWakeTime(app.info.uid, app.pid, nowElapsed);
                    } catch (Throwable th2) {
                        throw th2;
                    }
                }
                app.lastCpuTime = app.curCpuTime;
            }
            maybeUpdateUsageStatsLocked(app, nowElapsed);
            app.setProcState = app.curProcState;
            if (app.setProcState >= 12) {
                app.notCachedSinceIdle = false;
            }
            if (doingAll) {
                app.procStateChanged = true;
            } else {
                setProcessTrackerStateLocked(app, this.mProcessStats.getMemFactorLocked(), now);
            }
        } else if (app.reportedInteraction && nowElapsed - app.interactionEventTime > 86400000) {
            maybeUpdateUsageStatsLocked(app, nowElapsed);
        }
        if (changes != 0) {
            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
            }
            int i = this.mPendingProcessChanges.size() - 1;
            ProcessChangeItem item = null;
            while (i >= 0) {
                item = (ProcessChangeItem) this.mPendingProcessChanges.get(i);
                if (item.pid == app.pid) {
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                    }
                    if (i < 0) {
                        int NA = this.mAvailProcessChanges.size();
                        if (NA > 0) {
                            item = (ProcessChangeItem) this.mAvailProcessChanges.remove(NA - 1);
                            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
                            }
                        } else {
                            item = new ProcessChangeItem();
                            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
                            }
                        }
                        item.changes = 0;
                        item.pid = app.pid;
                        item.uid = app.info.uid;
                        if (this.mPendingProcessChanges.size() == 0) {
                            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                            }
                            this.mUiHandler.obtainMessage(31).sendToTarget();
                        }
                        this.mPendingProcessChanges.add(item);
                    }
                    item.changes |= changes;
                    item.processState = app.repProcState;
                    item.foregroundActivities = app.repForegroundActivities;
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " procState=" + item.processState + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
                    }
                } else {
                    i--;
                }
            }
            if (i < 0) {
            }
            item.changes |= changes;
            item.processState = app.repProcState;
            item.foregroundActivities = app.repForegroundActivities;
            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
            }
        }
        return success;
    }

    private final void enqueueUidChangeLocked(UidRecord uidRec, int uid, int change) {
        ChangeItem pendingChange;
        if (uidRec == null || uidRec.pendingChange == null) {
            if (this.mPendingUidChanges.size() == 0) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "*** Enqueueing dispatch uid changed!");
                }
                this.mUiHandler.obtainMessage(54).sendToTarget();
            }
            int NA = this.mAvailUidChanges.size();
            if (NA > 0) {
                pendingChange = (ChangeItem) this.mAvailUidChanges.remove(NA - 1);
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "Retrieving available item: " + pendingChange);
                }
            } else {
                pendingChange = new ChangeItem();
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "Allocating new item: " + pendingChange);
                }
            }
            if (uidRec != null) {
                uidRec.pendingChange = pendingChange;
                if (change == 1 && !uidRec.idle) {
                    change = 2;
                }
            } else if (uid < 0) {
                throw new IllegalArgumentException("No UidRecord or uid");
            }
            pendingChange.uidRecord = uidRec;
            if (uidRec != null) {
                uid = uidRec.uid;
            }
            pendingChange.uid = uid;
            this.mPendingUidChanges.add(pendingChange);
        } else {
            pendingChange = uidRec.pendingChange;
            if (change == 1 && pendingChange.change == 3) {
                change = 2;
            }
        }
        pendingChange.change = change;
        pendingChange.processState = uidRec != null ? uidRec.setProcState : -1;
    }

    private void maybeUpdateProviderUsageStatsLocked(ProcessRecord app, String providerPkgName, String authority) {
        if (app != null && app.curProcState <= 6) {
            UserState userState = this.mUserController.getStartedUserStateLocked(app.userId);
            if (userState != null) {
                long now = SystemClock.elapsedRealtime();
                Long lastReported = (Long) userState.mProviderLastReportedFg.get(authority);
                if (lastReported == null || lastReported.longValue() < now - 60000) {
                    if (this.mSystemReady) {
                        this.mUsageStatsService.reportContentProviderUsage(authority, providerPkgName, app.userId);
                    }
                    userState.mProviderLastReportedFg.put(authority, Long.valueOf(now));
                }
            }
        }
    }

    private void maybeUpdateUsageStatsLocked(ProcessRecord app, long nowElapsed) {
        if (ActivityManagerDebugConfig.DEBUG_USAGE_STATS) {
            Slog.d(TAG, "Checking proc [" + Arrays.toString(app.getPackageList()) + "] state changes: old = " + app.setProcState + ", new = " + app.curProcState);
        }
        if (this.mUsageStatsService != null) {
            boolean isInteraction;
            if (app.curProcState <= 3) {
                isInteraction = true;
                app.fgInteractionTime = 0;
            } else if (app.curProcState > 5) {
                isInteraction = app.forcingToForeground == null ? app.curProcState <= 6 : false;
                app.fgInteractionTime = 0;
            } else if (app.fgInteractionTime == 0) {
                app.fgInteractionTime = nowElapsed;
                isInteraction = false;
            } else {
                isInteraction = nowElapsed > app.fgInteractionTime + 1800000;
            }
            if (isInteraction && (!app.reportedInteraction || nowElapsed - app.interactionEventTime > 86400000)) {
                app.interactionEventTime = nowElapsed;
                String[] packages = app.getPackageList();
                if (packages != null) {
                    for (String reportEvent : packages) {
                        this.mUsageStatsService.reportEvent(reportEvent, app.userId, 6);
                    }
                }
            }
            app.reportedInteraction = isInteraction;
            if (!isInteraction) {
                app.interactionEventTime = 0;
            }
        }
    }

    private final void setProcessTrackerStateLocked(ProcessRecord proc, int memFactor, long now) {
        if (proc.thread != null && proc.baseProcessTracker != null) {
            try {
                proc.baseProcessTracker.setState(proc.repProcState, memFactor, now, proc.pkgList);
            } catch (Exception e) {
                Slog.d(TAG, "repProcState " + proc.repProcState + " memFactor " + memFactor + " pkgList " + proc.pkgList);
                Slog.d(TAG, "setState Exception " + e);
            }
        }
    }

    private final boolean updateOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
        if (app.thread == null) {
            return false;
        }
        computeOomAdjLocked(app, cachedAdj, TOP_APP, doingAll, now);
        return applyOomAdjLocked(app, doingAll, now, SystemClock.elapsedRealtime());
    }

    final void updateProcessForegroundLocked(ProcessRecord proc, boolean isForeground, boolean oomAdj) {
        if (isForeground != proc.foregroundServices) {
            proc.foregroundServices = isForeground;
            ArrayList<ProcessRecord> curProcs = (ArrayList) this.mForegroundPackages.get(proc.info.packageName, proc.info.uid);
            if (isForeground) {
                if (curProcs == null) {
                    curProcs = new ArrayList();
                    this.mForegroundPackages.put(proc.info.packageName, proc.info.uid, curProcs);
                }
                if (!curProcs.contains(proc)) {
                    curProcs.add(proc);
                    this.mBatteryStatsService.noteEvent(32770, proc.info.packageName, proc.info.uid);
                }
            } else if (curProcs != null && curProcs.remove(proc)) {
                this.mBatteryStatsService.noteEvent(16386, proc.info.packageName, proc.info.uid);
                if (curProcs.size() <= 0) {
                    this.mForegroundPackages.remove(proc.info.packageName, proc.info.uid);
                }
            }
            if (oomAdj) {
                updateOomAdjLocked();
            }
        }
    }

    private final ActivityRecord resumedAppLocked() {
        String pkg;
        int uid;
        ActivityRecord act = this.mStackSupervisor.resumedAppLocked();
        if (act != null) {
            pkg = act.packageName;
            uid = act.info.applicationInfo.uid;
        } else {
            pkg = null;
            uid = -1;
        }
        if (uid != this.mCurResumedUid || (pkg != this.mCurResumedPackage && (pkg == null || !pkg.equals(this.mCurResumedPackage)))) {
            if (this.mCurResumedPackage != null) {
                this.mBatteryStatsService.noteEvent(16387, this.mCurResumedPackage, this.mCurResumedUid);
            }
            this.mCurResumedPackage = pkg;
            this.mCurResumedUid = uid;
            if (this.mCurResumedPackage != null) {
                this.mBatteryStatsService.noteEvent(32771, this.mCurResumedPackage, this.mCurResumedUid);
            }
        }
        return act;
    }

    final ActivityRecord resumedAppLockedForBroadcast() {
        return this.mStackSupervisor.resumedAppLocked();
    }

    final boolean updateOomAdjLocked(ProcessRecord app) {
        ActivityRecord TOP_ACT = resumedAppLocked();
        ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;
        boolean wasCached = app.cached;
        this.mAdjSeq++;
        boolean success = updateOomAdjLocked(app, app.curRawAdj >= 900 ? app.curRawAdj : 1001, TOP_APP, false, SystemClock.uptimeMillis());
        if (wasCached != app.cached || app.curRawAdj == 1001) {
            updateOomAdjLocked();
        }
        return success;
    }

    private boolean isQeTestTool(String processName) {
        return !"com.oppo.qetest".equals(processName) ? "com.oppo.qemonitor".equals(processName) : true;
    }

    /* JADX WARNING: Removed duplicated region for block: B:93:0x0249  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void updateOomAdjLocked() {
        int i;
        int cachedProcessLimit;
        ProcessRecord app;
        UidRecord uidRec;
        int memFactor;
        ActivityRecord TOP_ACT = resumedAppLocked();
        ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;
        long now = SystemClock.uptimeMillis();
        long nowElapsed = SystemClock.elapsedRealtime();
        long oldTime = now - 1800000;
        int N = this.mLruProcesses.size();
        for (i = this.mActiveUids.size() - 1; i >= 0; i--) {
            ((UidRecord) this.mActiveUids.valueAt(i)).reset();
        }
        this.mStackSupervisor.rankTaskLayersIfNeeded();
        this.mAdjSeq++;
        this.mNewNumServiceProcs = 0;
        this.mNewNumAServiceProcs = 0;
        int emptyProcessLimit;
        if (this.mProcessLimit <= 0) {
            cachedProcessLimit = 0;
            emptyProcessLimit = 0;
        } else if (this.mProcessLimit == 1) {
            emptyProcessLimit = 1;
            cachedProcessLimit = 0;
        } else {
            emptyProcessLimit = ProcessList.computeEmptyProcessLimit(this.mProcessLimit);
            cachedProcessLimit = this.mProcessLimit - emptyProcessLimit;
        }
        int numEmptyProcs = (N - this.mNumNonCachedProcs) - this.mNumCachedHiddenProcs;
        if (numEmptyProcs > cachedProcessLimit) {
            numEmptyProcs = cachedProcessLimit;
        }
        int emptyFactor = numEmptyProcs / 3;
        if (emptyFactor < 1) {
            emptyFactor = 1;
        }
        int cachedFactor = (this.mNumCachedHiddenProcs > 0 ? this.mNumCachedHiddenProcs : 1) / 3;
        if (cachedFactor < 1) {
            cachedFactor = 1;
        }
        int stepCached = 0;
        int stepEmpty = 0;
        int numCached = 0;
        int numEmpty = 0;
        int numTrimming = 0;
        this.mNumNonCachedProcs = 0;
        this.mNumCachedHiddenProcs = 0;
        int curCachedAdj = 900;
        int nextCachedAdj = 901;
        int curEmptyAdj = 900;
        int nextEmptyAdj = 902;
        for (i = N - 1; i >= 0; i--) {
            app = (ProcessRecord) this.mLruProcesses.get(i);
            if (!(app.killedByAm || app.thread == null)) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, 1001, TOP_APP, true, now);
                if (app.curAdj >= 1001) {
                    switch (app.curProcState) {
                        case 14:
                        case 15:
                            app.curRawAdj = curCachedAdj;
                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);
                            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                            }
                            if (curCachedAdj != nextCachedAdj) {
                                stepCached++;
                                if (stepCached >= cachedFactor) {
                                    stepCached = 0;
                                    curCachedAdj = nextCachedAdj;
                                    nextCachedAdj += 2;
                                    if (nextCachedAdj > 906) {
                                        nextCachedAdj = 906;
                                        break;
                                    }
                                }
                            }
                            break;
                        default:
                            app.curRawAdj = curEmptyAdj;
                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                            }
                            if (curEmptyAdj != nextEmptyAdj) {
                                stepEmpty++;
                                if (stepEmpty >= emptyFactor) {
                                    stepEmpty = 0;
                                    curEmptyAdj = nextEmptyAdj;
                                    nextEmptyAdj += 2;
                                    if (nextEmptyAdj > 906) {
                                        nextEmptyAdj = 906;
                                        break;
                                    }
                                }
                            }
                            break;
                    }
                }
                applyOomAdjLocked(app, true, now, nowElapsed);
                switch (app.curProcState) {
                    case 14:
                    case 15:
                        if (!isQeTestTool(app.processName)) {
                            this.mNumCachedHiddenProcs++;
                            numCached++;
                            if (numCached > cachedProcessLimit) {
                                app.kill("cached #" + numCached, true);
                                break;
                            }
                        }
                        break;
                    case 16:
                        boolean ignoreProces;
                        boolean isAcoreProcess = "android.process.acore".equals(app.processName);
                        boolean isAlarmProcess = "com.coloros.alarmclock".equals(app.processName);
                        boolean isContactsProcess = "android.process.contacts".equals(app.processName);
                        boolean isNewsimProcess = "com.coloros.newsimdetect".equals(app.processName);
                        boolean isYellowPage = "com.coloros.lives".equals(app.processName);
                        boolean isTeleRelative;
                        if ("com.redteamobile.roaming".equals(app.processName) || "com.android.vendors.bridge.softsim".equals(app.processName)) {
                            isTeleRelative = true;
                        } else {
                            isTeleRelative = "com.redteamobile.virtual.softsim".equals(app.processName);
                        }
                        boolean isSelfProtectProcess = false;
                        if (!(app.info == null || app.info.packageName == null)) {
                            isSelfProtectProcess = OppoListManager.getInstance().getStageProtectList().contains(app.info.packageName);
                        }
                        if (!(isAcoreProcess || isAlarmProcess || isContactsProcess || isNewsimProcess || isYellowPage)) {
                            if (!(isQeTestTool(app.processName) || isTeleRelative)) {
                                ignoreProces = isSelfProtectProcess;
                                if (!ignoreProces) {
                                    if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
                                        app.kill("empty for " + (((1800000 + oldTime) - app.lastActivityTime) / 1000) + "s", true);
                                        break;
                                    }
                                    numEmpty++;
                                    boolean isMmsProcess = "com.android.mms".equals(app.processName);
                                    boolean isCalendarProcess = "com.android.providers.calendar".equals(app.processName);
                                    boolean isLineProcess = "jp.naver.line.android".equals(app.processName);
                                    if (!(isMmsProcess || isCalendarProcess || numEmpty <= emptyProcessLimit)) {
                                        if (isLineProcess && getSystemRuntime() < ColorOSDeviceIdleHelper.ALARM_WINDOW_LENGTH) {
                                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                                Slog.d(TAG, app.processName + " kill(empty #) skipped before system start 3mins");
                                                break;
                                            }
                                        }
                                        app.kill("empty #" + numEmpty, true);
                                        break;
                                    }
                                }
                            }
                        }
                        ignoreProces = true;
                        if (ignoreProces) {
                        }
                        break;
                    default:
                        this.mNumNonCachedProcs++;
                        break;
                }
                if (!app.isolated || app.services.size() > 0) {
                    uidRec = app.uidRecord;
                    if (uidRec != null && uidRec.curProcState > app.curProcState) {
                        uidRec.curProcState = app.curProcState;
                    }
                } else {
                    app.kill("isolated not needed", true);
                }
                if (app.curProcState >= 12 && !app.killedByAm) {
                    numTrimming++;
                }
            }
        }
        if (SystemProperties.get("ro.mtk_gmo_ram_optimize").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON)) {
            int numTotalCached = 0;
            for (i = N - 1; i >= 0; i--) {
                if (((ProcessRecord) this.mLruProcesses.get(i)).curAdj >= 900) {
                    numTotalCached++;
                }
            }
            if (numTotalCached <= 3 && this.mLruProcesses.size() < this.mLastNumProcesses && this.mAllowLowerMemLevel) {
                MemInfoReader memInfo = new MemInfoReader();
                memInfo.readMemInfo();
                long[] memInfos = memInfo.getRawInfo();
                if (memInfos[3] <= this.mProcessList.getMemLevel(900) / 1024) {
                    int expiredApp = 0;
                    int expiredService = 0;
                    long lastActivity = 0;
                    boolean lastActivityFound = false;
                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                        Slog.d(TAG, "Memory Critical! Cached Size = " + memInfos[3] + " <= minfree [adj=9] = " + this.mProcessList.getMemLevel(900));
                    }
                    for (i = N - 1; i >= 0; i--) {
                        app = (ProcessRecord) this.mLruProcesses.get(i);
                        if (app.serviceb) {
                            if (!isSystemOrProtectedPackageName(app.processName)) {
                                for (int is = app.services.size() - 1; is >= 0; is--) {
                                    ServiceRecord s = (ServiceRecord) app.services.valueAt(is);
                                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                        Slog.d(TAG, "Try to find expiredApp(" + i + ")=" + this.mLruProcesses.get(i) + ",expiredService(" + is + ")=" + ((ProcessRecord) this.mLruProcesses.get(i)).services.valueAt(is) + ",lastActivity=" + ((((double) (now - s.lastActivity)) / 1000.0d) / 60.0d) + " minute(s) ago. App lastPss size = " + ((ProcessRecord) this.mLruProcesses.get(i)).lastPss);
                                    }
                                    if (now - s.lastActivity < 1800000 && now - s.lastActivity > lastActivity) {
                                        expiredApp = i;
                                        expiredService = is;
                                        lastActivity = now - s.lastActivity;
                                        lastActivityFound = true;
                                    }
                                }
                            }
                        }
                    }
                    if (lastActivityFound) {
                        Slog.d(TAG, "Set the expiredService! app = " + this.mLruProcesses.get(expiredApp) + ",service = " + ((ProcessRecord) this.mLruProcesses.get(expiredApp)).services.valueAt(expiredService) + ",lastActivity=" + ((((double) lastActivity) / 1000.0d) / 60.0d) + " minute(s) ago.");
                        ((ServiceRecord) ((ProcessRecord) this.mLruProcesses.get(expiredApp)).services.valueAt(expiredService)).lastActivity = now - 1800000;
                    }
                }
            }
        }
        this.mNumServiceProcs = this.mNewNumServiceProcs;
        int numCachedAndEmpty = numCached + numEmpty;
        if (numCached > ProcessList.TRIM_CACHED_APPS || numEmpty > ProcessList.TRIM_EMPTY_APPS) {
            memFactor = 0;
        } else if (numCachedAndEmpty <= 3) {
            memFactor = 3;
        } else if (numCachedAndEmpty <= 5) {
            memFactor = 2;
        } else {
            memFactor = 1;
        }
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG_OOM_ADJ, "oom: memFactor=" + memFactor + " last=" + this.mLastMemoryLevel + " allowLow=" + this.mAllowLowerMemLevel + " numProcs=" + this.mLruProcesses.size() + " last=" + this.mLastNumProcesses);
        }
        if (memFactor > this.mLastMemoryLevel && (!this.mAllowLowerMemLevel || this.mLruProcesses.size() >= this.mLastNumProcesses)) {
            memFactor = this.mLastMemoryLevel;
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.d(TAG_OOM_ADJ, "Keeping last mem factor!");
            }
        }
        if (memFactor != this.mLastMemoryLevel) {
            EventLogTags.writeAmMemFactor(memFactor, this.mLastMemoryLevel);
        }
        this.mLastMemoryLevel = memFactor;
        this.mLastNumProcesses = this.mLruProcesses.size();
        boolean allChanged = this.mProcessStats.setMemFactorLocked(memFactor, !isSleepingLocked(), now);
        int trackerMemFactor = this.mProcessStats.getMemFactorLocked();
        if (memFactor != 0) {
            int fgTrimLevel;
            if (this.mLowRamStartTime == 0) {
                this.mLowRamStartTime = now;
            }
            int step = 0;
            switch (memFactor) {
                case 2:
                    fgTrimLevel = 10;
                    break;
                case 3:
                    fgTrimLevel = 15;
                    break;
                default:
                    fgTrimLevel = 5;
                    break;
            }
            int factor = numTrimming / 3;
            int minFactor = 2;
            if (this.mHomeProcess != null) {
                minFactor = 3;
            }
            if (this.mPreviousProcess != null) {
                minFactor++;
            }
            if (factor < minFactor) {
                factor = minFactor;
            }
            int curLevel = 80;
            for (i = N - 1; i >= 0; i--) {
                app = (ProcessRecord) this.mLruProcesses.get(i);
                if (allChanged || app.procStateChanged) {
                    setProcessTrackerStateLocked(app, trackerMemFactor, now);
                    app.procStateChanged = false;
                }
                if (app.curProcState >= 12 && !app.killedByAm) {
                    if (app.trimMemoryLevel < curLevel && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of " + app.processName + " to " + curLevel);
                            }
                            app.thread.scheduleTrimMemory(curLevel);
                        } catch (RemoteException e) {
                        }
                    }
                    app.trimMemoryLevel = curLevel;
                    step++;
                    if (step >= factor) {
                        step = 0;
                        switch (curLevel) {
                            case 60:
                                curLevel = 40;
                                break;
                            case 80:
                                curLevel = 60;
                                break;
                            default:
                                break;
                        }
                    }
                } else if (app.curProcState == 9) {
                    if (app.trimMemoryLevel < 40 && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of heavy-weight " + app.processName + " to " + 40);
                            }
                            app.thread.scheduleTrimMemory(40);
                        } catch (RemoteException e2) {
                        }
                    }
                    app.trimMemoryLevel = 40;
                } else {
                    if ((app.curProcState >= 7 || app.systemNoUi) && app.pendingUiClean) {
                        if (app.trimMemoryLevel < 20 && app.thread != null) {
                            try {
                                if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                    Slog.v(TAG_OOM_ADJ, "Trimming memory of bg-ui " + app.processName + " to " + 20);
                                }
                                app.thread.scheduleTrimMemory(20);
                            } catch (RemoteException e3) {
                            }
                        }
                        app.pendingUiClean = false;
                    }
                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of fg " + app.processName + " to " + fgTrimLevel);
                            }
                            app.thread.scheduleTrimMemory(fgTrimLevel);
                        } catch (RemoteException e4) {
                        }
                    }
                    app.trimMemoryLevel = fgTrimLevel;
                }
            }
        } else {
            if (this.mLowRamStartTime != 0) {
                this.mLowRamTimeSinceLastIdle += now - this.mLowRamStartTime;
                this.mLowRamStartTime = 0;
            }
            for (i = N - 1; i >= 0; i--) {
                app = (ProcessRecord) this.mLruProcesses.get(i);
                if (allChanged || app.procStateChanged) {
                    setProcessTrackerStateLocked(app, trackerMemFactor, now);
                    app.procStateChanged = false;
                }
                if ((app.curProcState >= 7 || app.systemNoUi) && app.pendingUiClean) {
                    if (app.trimMemoryLevel < 20 && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of ui hidden " + app.processName + " to " + 20);
                            }
                            app.thread.scheduleTrimMemory(20);
                        } catch (RemoteException e5) {
                        }
                    }
                    app.pendingUiClean = false;
                }
                app.trimMemoryLevel = 0;
            }
        }
        if (this.mAlwaysFinishActivities) {
            this.mStackSupervisor.scheduleDestroyAllActivities(null, "always-finish");
        }
        if (allChanged) {
            requestPssAllProcsLocked(now, false, this.mProcessStats.isMemFactorLowered());
        }
        for (i = this.mActiveUids.size() - 1; i >= 0; i--) {
            uidRec = (UidRecord) this.mActiveUids.valueAt(i);
            int uidChange = 0;
            if (uidRec.setProcState != uidRec.curProcState) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "Changes in " + uidRec + ": proc state from " + uidRec.setProcState + " to " + uidRec.curProcState);
                }
                if (!ActivityManager.isProcStateBackground(uidRec.curProcState)) {
                    if (uidRec.idle) {
                        uidChange = 4;
                        uidRec.idle = false;
                    }
                    uidRec.lastBackgroundTime = 0;
                } else if (!ActivityManager.isProcStateBackground(uidRec.setProcState)) {
                    uidRec.lastBackgroundTime = nowElapsed;
                    if (!this.mHandler.hasMessages(60)) {
                        this.mHandler.sendEmptyMessageDelayed(60, 60000);
                    }
                }
                uidRec.setProcState = uidRec.curProcState;
                enqueueUidChangeLocked(uidRec, -1, uidChange);
                noteUidProcessState(uidRec.uid, uidRec.curProcState);
            }
        }
        if (this.mProcessStats.shouldWriteNowLocked(now)) {
            this.mHandler.post(new Runnable() {
                public void run() {
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mProcessStats.writeStateAsyncLocked();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                }
            });
        }
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG_OOM_ADJ, "Did OOM ADJ in " + (SystemClock.uptimeMillis() - now) + "ms");
        }
    }

    final void idleUids() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long nowElapsed = SystemClock.elapsedRealtime();
                long maxBgTime = nowElapsed - 60000;
                long nextTime = 0;
                for (int i = this.mActiveUids.size() - 1; i >= 0; i--) {
                    UidRecord uidRec = (UidRecord) this.mActiveUids.valueAt(i);
                    long bgTime = uidRec.lastBackgroundTime;
                    if (bgTime > 0 && !uidRec.idle) {
                        if (bgTime <= maxBgTime) {
                            uidRec.idle = true;
                            doStopUidLocked(uidRec.uid, uidRec);
                        } else if (nextTime == 0 || nextTime > bgTime) {
                            nextTime = bgTime;
                        }
                    }
                }
                if (nextTime > 0) {
                    this.mHandler.removeMessages(60);
                    this.mHandler.sendEmptyMessageDelayed(60, (60000 + nextTime) - nowElapsed);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void runInBackgroundDisabled(int uid) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
                if (uidRec == null) {
                    doStopUidLocked(uid, null);
                } else if (uidRec.idle) {
                    doStopUidLocked(uidRec.uid, uidRec);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void doStopUidLocked(int uid, UidRecord uidRec) {
        this.mServices.stopInBackgroundLocked(uid);
        enqueueUidChangeLocked(uidRec, uid, 3);
    }

    private long getSystemRuntime() {
        long currentSystemTime = System.currentTimeMillis();
        long fisrtBootTime = Long.parseLong(SystemProperties.get("ro.runtime.firstboot", "0"));
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG, "currentSystemTime = " + currentSystemTime + "; fisrtBootTime = " + fisrtBootTime);
        }
        return currentSystemTime - fisrtBootTime;
    }

    final void trimApplications() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mRemovedProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = (ProcessRecord) this.mRemovedProcesses.get(i);
                    int size = app.receiverRecords.size();
                    if (DEBUG_COLOROS_AMS) {
                        Slog.i(TAG, "trimApplications : size = " + size + " ,app = " + app + " " + Debug.getCallers(4));
                    }
                    if (app.foreCurReceiver != null) {
                        app.curReceiver = app.foreCurReceiver;
                    } else if (app.backCurReceiver != null) {
                        app.curReceiver = app.backCurReceiver;
                    } else if (app.oppoforeCurReceiver != null) {
                        app.curReceiver = app.oppoforeCurReceiver;
                    } else if (app.oppobackCurReceiver != null) {
                        app.curReceiver = app.oppobackCurReceiver;
                    } else {
                        app.curReceiver = null;
                    }
                    if (DEBUG_COLOROS_AMS) {
                        Slog.i(TAG, "app.foreCurReceiver = " + app.foreCurReceiver + " ,app.backCurReceiver = " + app.backCurReceiver);
                    }
                    if (app.activities.size() == 0 && app.curReceiver == null && size == 0 && app.services.size() == 0) {
                        Object asBinder;
                        String str = TAG;
                        StringBuilder append = new StringBuilder().append("Exiting empty application process ").append(app.toShortString()).append(" (");
                        if (app.thread != null) {
                            asBinder = app.thread.asBinder();
                        } else {
                            asBinder = null;
                        }
                        Slog.i(str, append.append(asBinder).append(")\n").toString());
                        if (app.pid <= 0 || app.pid == MY_PID) {
                            try {
                                app.thread.scheduleExit();
                            } catch (Exception e) {
                            }
                        } else {
                            app.kill("empty", false);
                        }
                        cleanUpApplicationRecordLocked(app, false, true, -1, false);
                        this.mRemovedProcesses.remove(i);
                        if (app.persistent) {
                            addAppLocked(app.info, false, null);
                        }
                    }
                }
                updateOomAdjLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void signalPersistentProcesses(int sig) throws RemoteException {
        if (sig != 10) {
            throw new SecurityException("Only SIGNAL_USR1 is allowed");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SIGNAL_PERSISTENT_PROCESSES") != 0) {
                    throw new SecurityException("Requires permission android.permission.SIGNAL_PERSISTENT_PROCESSES");
                }
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord r = (ProcessRecord) this.mLruProcesses.get(i);
                    if (r.thread != null && r.persistent) {
                        Process.sendSignal(r.pid, sig);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void stopProfilerLocked(ProcessRecord proc, int profileType) {
        if (proc == null || proc == this.mProfileProc) {
            proc = this.mProfileProc;
            profileType = this.mProfileType;
            clearProfilerLocked();
        }
        if (proc != null) {
            try {
                proc.thread.profilerControl(false, null, profileType);
            } catch (RemoteException e) {
                throw new IllegalStateException("Process disappeared");
            }
        }
    }

    private void clearProfilerLocked() {
        if (this.mProfileFd != null) {
            try {
                this.mProfileFd.close();
            } catch (IOException e) {
            }
        }
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mProfileFile = null;
        this.mProfileType = 0;
        this.mAutoStopProfiler = false;
        this.mSamplingInterval = 0;
    }

    /* JADX WARNING: Missing block: B:27:0x0039, code:
            if (r11.profileFd == null) goto L_0x003b;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean profileControl(String process, int userId, boolean start, ProfilerInfo profilerInfo, int profileType) throws RemoteException {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                }
                if (start) {
                    if (profilerInfo != null) {
                    }
                    throw new IllegalArgumentException("null profile info or fd");
                }
                ProcessRecord proc = null;
                if (process != null) {
                    proc = findProcessLocked(process, userId, "profileControl");
                }
                if (start && (proc == null || proc.thread == null)) {
                    throw new IllegalArgumentException("Unknown process: " + process);
                }
                if (start) {
                    ParcelFileDescriptor fd;
                    stopProfilerLocked(null, 0);
                    setProfileApp(proc.info, proc.processName, profilerInfo);
                    this.mProfileProc = proc;
                    this.mProfileType = profileType;
                    try {
                        fd = profilerInfo.profileFd.dup();
                    } catch (IOException e) {
                        fd = null;
                    }
                    profilerInfo.profileFd = fd;
                    proc.thread.profilerControl(start, profilerInfo, profileType);
                    this.mProfileFd = null;
                } else {
                    stopProfilerLocked(proc, profileType);
                    if (!(profilerInfo == null || profilerInfo.profileFd == null)) {
                        try {
                            profilerInfo.profileFd.close();
                        } catch (IOException e2) {
                        }
                    }
                }
            }
            resetPriorityAfterLockedSection();
            if (!(profilerInfo == null || profilerInfo.profileFd == null)) {
                try {
                    profilerInfo.profileFd.close();
                } catch (IOException e3) {
                }
            }
            return true;
        } catch (RemoteException e4) {
            try {
                throw new IllegalStateException("Process disappeared");
            } catch (Throwable th) {
                if (!(profilerInfo == null || profilerInfo.profileFd == null)) {
                    try {
                        profilerInfo.profileFd.close();
                    } catch (IOException e5) {
                    }
                }
            }
        } catch (Throwable th2) {
            resetPriorityAfterLockedSection();
        }
    }

    private ProcessRecord findProcessLocked(String process, int userId, String callName) {
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 2, callName, null);
        ProcessRecord proc = null;
        try {
            int pid = Integer.parseInt(process);
            synchronized (this.mPidsSelfLocked) {
                proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            }
        } catch (NumberFormatException e) {
        }
        if (proc != null) {
            return proc;
        }
        SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().get(process);
        if (procs == null || procs.size() <= 0) {
            return proc;
        }
        proc = (ProcessRecord) procs.valueAt(0);
        if (userId == -1 || proc.userId == userId) {
            return proc;
        }
        for (int i = 1; i < procs.size(); i++) {
            ProcessRecord thisProc = (ProcessRecord) procs.valueAt(i);
            if (thisProc.userId == userId) {
                return thisProc;
            }
        }
        return proc;
    }

    public boolean dumpHeap(String process, int userId, boolean managed, String path, ParcelFileDescriptor fd) throws RemoteException {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                } else if (fd == null) {
                    throw new IllegalArgumentException("null fd");
                } else {
                    ProcessRecord proc = findProcessLocked(process, userId, "dumpHeap");
                    if (proc == null || proc.thread == null) {
                        throw new IllegalArgumentException("Unknown process: " + process);
                    } else if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (proc.info.flags & 2) != 0) {
                        proc.thread.dumpHeap(managed, path, fd);
                        fd = null;
                    } else {
                        throw new SecurityException("Process not debuggable: " + proc);
                    }
                }
            }
            resetPriorityAfterLockedSection();
            return true;
        } catch (RemoteException e) {
            try {
                throw new IllegalStateException("Process disappeared");
            } catch (Throwable th) {
                if (fd != null) {
                    try {
                        fd.close();
                    } catch (IOException e2) {
                    }
                }
            }
        } catch (Throwable th2) {
            resetPriorityAfterLockedSection();
        }
    }

    public void setDumpHeapDebugLimit(String processName, int uid, long maxMemSize, String reportPackage) {
        if (processName != null) {
            enforceCallingPermission("android.permission.SET_DEBUG_APP", "setDumpHeapDebugLimit()");
        } else {
            synchronized (this.mPidsSelfLocked) {
                ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
                if (proc == null) {
                    throw new SecurityException("No process found for calling pid " + Binder.getCallingPid());
                } else if (Build.IS_DEBUGGABLE || (proc.info.flags & 2) != 0) {
                    processName = proc.processName;
                    uid = proc.uid;
                    if (reportPackage == null || proc.pkgList.containsKey(reportPackage)) {
                    } else {
                        throw new SecurityException("Package " + reportPackage + " is not running in " + proc);
                    }
                } else {
                    throw new SecurityException("Not running a debuggable build");
                }
            }
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (maxMemSize > 0) {
                    this.mMemWatchProcesses.put(processName, uid, new Pair(Long.valueOf(maxMemSize), reportPackage));
                } else if (uid != 0) {
                    this.mMemWatchProcesses.remove(processName, uid);
                } else {
                    this.mMemWatchProcesses.getMap().remove(processName);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void dumpHeapFinished(String path) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (Binder.getCallingPid() != this.mMemWatchDumpPid) {
                    Slog.w(TAG, "dumpHeapFinished: Calling pid " + Binder.getCallingPid() + " does not match last pid " + this.mMemWatchDumpPid);
                } else if (this.mMemWatchDumpFile == null || !this.mMemWatchDumpFile.equals(path)) {
                    Slog.w(TAG, "dumpHeapFinished: Calling path " + path + " does not match last path " + this.mMemWatchDumpFile);
                    resetPriorityAfterLockedSection();
                } else {
                    if (ActivityManagerDebugConfig.DEBUG_PSS) {
                        Slog.d(TAG_PSS, "Dump heap finished for " + path);
                    }
                    this.mHandler.sendEmptyMessage(51);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void monitor() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void onCoreSettingsChange(Bundle settings) {
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord processRecord = (ProcessRecord) this.mLruProcesses.get(i);
            try {
                if (processRecord.thread != null) {
                    processRecord.thread.setCoreSettings(settings);
                }
            } catch (RemoteException e) {
            }
        }
    }

    public boolean startUserInBackground(int userId) {
        return this.mUserController.startUser(userId, false);
    }

    public boolean unlockUser(int userId, byte[] token, byte[] secret, IProgressListener listener) {
        return this.mUserController.unlockUser(userId, token, secret, listener);
    }

    public boolean switchUser(int targetUserId) {
        enforceShellRestriction("no_debugging_features", targetUserId);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UserInfo currentUserInfo = this.mUserController.getUserInfo(this.mUserController.getCurrentUserIdLocked());
                UserInfo targetUserInfo = this.mUserController.getUserInfo(targetUserId);
                if (targetUserInfo == null) {
                    Slog.w(TAG, "No user info for user #" + targetUserId);
                } else if (!targetUserInfo.isDemo() && UserManager.isDeviceInDemoMode(this.mContext)) {
                    Slog.w(TAG, "Cannot switch to non-demo user #" + targetUserId + " when device is in demo mode");
                    resetPriorityAfterLockedSection();
                    return false;
                } else if (!targetUserInfo.supportsSwitchTo()) {
                    Slog.w(TAG, "Cannot switch to User #" + targetUserId + ": not supported");
                    resetPriorityAfterLockedSection();
                    return false;
                } else if (targetUserInfo.isManagedProfile()) {
                    Slog.w(TAG, "Cannot switch to User #" + targetUserId + ": not a full user");
                    resetPriorityAfterLockedSection();
                    return false;
                } else {
                    this.mUserController.setTargetUserIdLocked(targetUserId);
                    resetPriorityAfterLockedSection();
                    Pair<UserInfo, UserInfo> userNames = new Pair(currentUserInfo, targetUserInfo);
                    this.mUiHandler.removeMessages(46);
                    this.mUiHandler.sendMessage(this.mUiHandler.obtainMessage(46, userNames));
                    return true;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    void scheduleStartProfilesLocked() {
        if (!this.mHandler.hasMessages(40)) {
            this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(40), 1000);
        }
    }

    public int stopUser(int userId, boolean force, IStopUserCallback callback) {
        return this.mUserController.stopUser(userId, force, callback);
    }

    public UserInfo getCurrentUser() {
        return this.mUserController.getCurrentUser();
    }

    public boolean isUserRunning(int userId, int flags) {
        if (this.mUserController.isSameProfileGroup(userId, UserHandle.getCallingUserId()) || checkCallingPermission("android.permission.INTERACT_ACROSS_USERS") == 0) {
            boolean isUserRunningLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    isUserRunningLocked = this.mUserController.isUserRunningLocked(userId, flags);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return isUserRunningLocked;
        }
        String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.INTERACT_ACROSS_USERS";
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }

    public int[] getRunningUserIds() {
        if (checkCallingPermission("android.permission.INTERACT_ACROSS_USERS") != 0) {
            String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.INTERACT_ACROSS_USERS";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        int[] startedUserArrayLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                startedUserArrayLocked = this.mUserController.getStartedUserArrayLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return startedUserArrayLocked;
    }

    public void registerUserSwitchObserver(IUserSwitchObserver observer, String name) {
        this.mUserController.registerUserSwitchObserver(observer, name);
    }

    public void unregisterUserSwitchObserver(IUserSwitchObserver observer) {
        this.mUserController.unregisterUserSwitchObserver(observer);
    }

    ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {
        if (info == null) {
            return null;
        }
        ApplicationInfo newInfo = new ApplicationInfo(info);
        newInfo.initForUser(userId);
        return newInfo;
    }

    public boolean isUserStopped(int userId) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                z = this.mUserController.getStartedUserStateLocked(userId) == null;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    ActivityInfo getActivityInfoForUser(ActivityInfo aInfo, int userId) {
        if (aInfo == null || (userId < 1 && aInfo.applicationInfo.uid < 100000)) {
            return aInfo;
        }
        ActivityInfo info = new ActivityInfo(aInfo);
        info.applicationInfo = getAppInfoForUser(info.applicationInfo, userId);
        return info;
    }

    private boolean processSanityChecksLocked(ProcessRecord process) {
        if (process == null || process.thread == null) {
            return false;
        }
        if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (process.info.flags & 2) != 0) {
            return true;
        }
        return false;
    }

    public boolean startBinderTracking() throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mBinderTransactionTrackingEnabled = true;
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                }
                for (int i = 0; i < this.mLruProcesses.size(); i++) {
                    ProcessRecord process = (ProcessRecord) this.mLruProcesses.get(i);
                    if (processSanityChecksLocked(process)) {
                        process.thread.startBinderTracking();
                    }
                }
            } catch (RemoteException e) {
                Log.v(TAG, "Process disappared");
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return true;
    }

    public boolean stopBinderTrackingAndDump(ParcelFileDescriptor fd) throws RemoteException {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mBinderTransactionTrackingEnabled = false;
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                } else if (fd == null) {
                    throw new IllegalArgumentException("null fd");
                } else {
                    PrintWriter pw = new FastPrintWriter(new FileOutputStream(fd.getFileDescriptor()));
                    pw.println("Binder transaction traces for all processes.\n");
                    for (ProcessRecord process : this.mLruProcesses) {
                        if (processSanityChecksLocked(process)) {
                            pw.println("Traces for process: " + process.processName);
                            pw.flush();
                            TransferPipe tp;
                            try {
                                tp = new TransferPipe();
                                process.thread.stopBinderTrackingAndDump(tp.getWriteFd().getFileDescriptor());
                                tp.go(fd.getFileDescriptor());
                                tp.kill();
                            } catch (IOException e) {
                                pw.println("Failure while dumping IPC traces from " + process + ".  Exception: " + e);
                                pw.flush();
                            } catch (RemoteException e2) {
                                pw.println("Got a RemoteException while dumping IPC traces from " + process + ".  Exception: " + e2);
                                pw.flush();
                            } catch (Throwable th) {
                                tp.kill();
                            }
                        }
                    }
                    fd = null;
                }
            }
            resetPriorityAfterLockedSection();
            return true;
        } catch (Throwable th2) {
            if (fd != null) {
                try {
                    fd.close();
                } catch (IOException e3) {
                }
            }
        }
    }

    private void collectErrorInfo(String dropboxTag, String eventType, ProcessRecord process, String processName, ActivityRecord activity, String subject, CrashInfo crashInfo) {
        try {
            if (dropboxTag.contains("app_crash") || dropboxTag.contains("app_anr")) {
                Intent errorIntent = new Intent("android.intent.action.OPPO_APP_ERROR_REPORT");
                errorIntent.setFlags(67108864);
                errorIntent.putExtra("eventType", eventType);
                errorIntent.putExtra("processName", this.mErrorPkgName);
                errorIntent.putExtra("fileId", this.mErrorTime);
                if (process != null) {
                    errorIntent.putExtra("foreground", process.isInterestingToUserLocked());
                }
                if (activity != null) {
                    errorIntent.putExtra("activity", activity.shortComponentName);
                }
                if ("anr".equals(eventType)) {
                    errorIntent.putExtra("message", subject);
                }
                if ("crash".equals(eventType) && crashInfo != null) {
                    errorIntent.putExtra("className", crashInfo.exceptionClassName);
                    errorIntent.putExtra("message", crashInfo.exceptionMessage);
                    errorIntent.putExtra("stackTrace", crashInfo.stackTrace);
                }
                this.mContext.sendBroadcast(errorIntent);
            }
        } catch (Exception e) {
            Log.e(TAG, "fail to collect app error info, " + e);
        }
    }

    private void appendCpuInfo(StringBuilder sb, String eventType) {
        try {
            if ("crash".equals(eventType)) {
                long anrTime = SystemClock.uptimeMillis();
                updateCpuStatsNow();
                synchronized (this.mProcessCpuTracker) {
                    String cpuInfo = this.mProcessCpuTracker.printCurrentState(anrTime);
                    if (cpuInfo != null && cpuInfo.length() > PENDING_ASSIST_EXTRAS_LONG_TIMEOUT) {
                        cpuInfo = cpuInfo.substring(0, PENDING_ASSIST_EXTRAS_LONG_TIMEOUT);
                    }
                    sb.append("\n").append(cpuInfo).append("\n");
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "fail to add cpu info, " + e);
        }
    }

    @OppoHook(level = OppoHookType.NEW_METHOD, note = "ZhiYong.Lin@Plf.Framework, add for permission intercept", property = OppoRomType.ROM)
    public void permissionInterceptPolicyReady() {
    }

    /* JADX WARNING: Missing block: B:23:0x003d, code:
            resetPriorityAfterLockedSection();
     */
    /* JADX WARNING: Missing block: B:24:0x0041, code:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean adjustSplitScreen(int action, int from) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (from != 2 || this.mFocusedActivity == null || !this.splitBack.contains(this.mFocusedActivity.packageName)) {
                    if (from == 1) {
                        if (!(this.mFocusedActivity == null || this.splitBack.contains(this.mFocusedActivity.packageName))) {
                            resetPriorityAfterLockedSection();
                            return false;
                        }
                    }
                    ActivityStack stack = this.mStackSupervisor.getFocusedStack();
                    if (!(stack == null || stack.mFullscreen)) {
                        TaskRecord task = null;
                        if (stack.mResumedActivity != null) {
                            task = stack.mResumedActivity.task;
                        }
                        boolean change = false;
                        if (this.mSplitActivity != null) {
                            change = this.mSplitActivity != this.mFocusedActivity;
                        }
                        this.mSplitActivity = null;
                        int numTasks = stack.getTaskHistory().size();
                        if (task != null) {
                            int size = task.mActivities.size();
                            if (size <= 1 || this.mFocusedActivity == null || this.mFocusedActivity.frontOfTask) {
                                if ((!task.isHomeTask() ? task.isOverHomeStack() : false) || numTasks <= 1 || size <= 1) {
                                    if (this.mWindowManager.getDockedStackSide() == -1) {
                                        resetPriorityAfterLockedSection();
                                        return false;
                                    } else if (action != 1) {
                                        resetPriorityAfterLockedSection();
                                        return true;
                                    } else {
                                        this.mSplitActivity = null;
                                        if (this.mWindowManager.getInputShow()) {
                                            InputMethodManagerInternal inputMethodManagerInternal = (InputMethodManagerInternal) LocalServices.getService(InputMethodManagerInternal.class);
                                            if (inputMethodManagerInternal != null) {
                                                inputMethodManagerInternal.hideCurrentInputMethod();
                                            }
                                            resetPriorityAfterLockedSection();
                                            return true;
                                        }
                                        if (change) {
                                            if (this.mFocusedActivity.frontOfTask) {
                                                if (DEBUG_COLOROS_AMS) {
                                                    Slog.v(TAG, "adjustSplitScreen change=" + change);
                                                }
                                                resetPriorityAfterLockedSection();
                                                return true;
                                            }
                                        }
                                        if (stack.mStackId == 3) {
                                            this.mWindowManager.getPolicy().exitSplitScreen(1);
                                        } else {
                                            this.mWindowManager.getPolicy().exitSplitScreen(0);
                                        }
                                        if (DEBUG_COLOROS_AMS) {
                                            Slog.v(TAG, "adjustSplitScreen mFocusedActivity=" + this.mFocusedActivity);
                                        }
                                        resetPriorityAfterLockedSection();
                                        return true;
                                    }
                                }
                            }
                            if (from == 3) {
                                if (!task.isHomeTask() && task.isOverHomeStack()) {
                                    if (stack.mStackId == 3) {
                                        this.mWindowManager.getPolicy().exitSplitScreen(1);
                                    } else {
                                        this.mWindowManager.getPolicy().exitSplitScreen(0);
                                    }
                                    if (DEBUG_COLOROS_AMS) {
                                        Slog.v(TAG, "adjustSplitScreen from=" + this.mFocusedActivity);
                                    }
                                    resetPriorityAfterLockedSection();
                                    return true;
                                }
                            }
                            this.mSplitActivity = this.mFocusedActivity;
                            resetPriorityAfterLockedSection();
                            return false;
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    public ComponentName getDockTopAppName() {
        return this.mStackSupervisor.getDockTopAppName();
    }

    public boolean addDisallowedRunningApp(List<String> appPkgNamesList) {
        if (!this.mContext.getPackageManager().hasSystemFeature(FEATURE_DISALLOW_APP_RUN_STR) || appPkgNamesList == null || appPkgNamesList.size() <= 0) {
            return false;
        }
        boolean result;
        synchronized (this.mDisallowedRuningAppListLock) {
            int size = appPkgNamesList.size();
            for (int index = 0; index < size; index++) {
                final String pkgName = (String) appPkgNamesList.get(index);
                if (!(pkgName == null || pkgName.length() <= 0 || this.mDisallowedRuningAppList.contains(pkgName))) {
                    this.mDisallowedRuningAppList.add(pkgName);
                    new Thread(new Runnable() {
                        public void run() {
                            ActivityManagerService.this.forceStopPackage(pkgName, UserHandle.myUserId());
                        }
                    }).start();
                }
            }
            result = saveDisallowAppListFile(this.mDisallowedRuningAppList);
        }
        return result;
    }

    public boolean removeDisallowedRunningApp(List<String> appPkgNamesList) {
        if (!this.mContext.getPackageManager().hasSystemFeature(FEATURE_DISALLOW_APP_RUN_STR) || appPkgNamesList == null || appPkgNamesList.size() <= 0) {
            return false;
        }
        synchronized (this.mDisallowedRuningAppListLock) {
            int size = appPkgNamesList.size();
            for (int index = 0; index < size; index++) {
                String pkgName = (String) appPkgNamesList.get(index);
                if (pkgName != null && pkgName.length() > 0 && this.mDisallowedRuningAppList.contains(pkgName)) {
                    this.mDisallowedRuningAppList.remove(pkgName);
                    saveDisallowAppListFile(this.mDisallowedRuningAppList);
                }
            }
        }
        return true;
    }

    public List<String> getDisallowedRunningApp() {
        return new ArrayList(this.mDisallowedRuningAppList);
    }

    public List<String> getDisallowedRunningList() {
        return this.mDisallowedRuningAppList;
    }

    public boolean isInDisallowedRunningAppList(String pkgName) {
        if (pkgName == null || pkgName.length() <= 0) {
            return false;
        }
        return this.mDisallowedRuningAppList.contains(pkgName);
    }

    public void showDisallowedRunningAppDialog() {
        Message msg = Message.obtain();
        msg.what = SHOW_NOT_ALLOW_DIALOG_MSG;
        this.mUiHandler.sendMessage(msg);
    }

    private boolean saveDisallowAppListFile(List<String> packages) {
        try {
            BufferedOutputStream str = new BufferedOutputStream(new FileOutputStream(this.mNotAllowAppFilename));
            XmlSerializer serializer = new FastXmlSerializer();
            String strUtf8 = "utf-8";
            String strPackages = "packages";
            String strName = "name";
            String strPackage = "package";
            serializer.setOutput(str, "utf-8");
            serializer.startDocument(null, Boolean.valueOf(true));
            serializer.startTag(null, "packages");
            int size = packages.size();
            for (int index = 0; index < size; index++) {
                String pkgName = (String) packages.get(index);
                serializer.startTag(null, "package");
                serializer.attribute(null, "name", pkgName);
                serializer.endTag(null, "package");
            }
            serializer.endTag(null, "packages");
            serializer.endDocument();
            str.flush();
            str.close();
            return true;
        } catch (IOException e) {
            Slog.w(TAG, "Unable to write not allow running package, current changes will be lost at reboot", e);
            return false;
        } catch (Exception e2) {
            Slog.w(TAG, "Unable to write not allow running package, current changes will be lost at reboot", e2);
            return false;
        }
    }

    private boolean readDisallowAppListFile() {
        try {
            if (!this.mNotAllowAppFilename.exists()) {
                return false;
            }
            FileInputStream str = new FileInputStream(this.mNotAllowAppFilename);
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(str, null);
            String strPackage = "package";
            String strName = "name";
            int type;
            do {
                type = parser.next();
                if (type == 2) {
                    if ("package".equals(parser.getName())) {
                        String name = parser.getAttributeValue(null, "name");
                        if (!(name == null || this.mDisallowedRuningAppList.contains(name))) {
                            this.mDisallowedRuningAppList.add(name);
                            continue;
                        }
                    } else {
                        continue;
                    }
                }
            } while (type != 1);
            return true;
        } catch (IOException e) {
            Slog.w(TAG, "Error reading not allow running package", e);
            return false;
        } catch (Exception e2) {
            Slog.w(TAG, "Error reading not allow running package", e2);
            return false;
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:63:0x0104 A:{SYNTHETIC, Splitter: B:63:0x0104} */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:55:0x00ec A:{SYNTHETIC, Splitter: B:55:0x00ec} */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:47:0x00d4 A:{SYNTHETIC, Splitter: B:47:0x00d4} */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:39:0x00bc A:{SYNTHETIC, Splitter: B:39:0x00bc} */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:31:0x00a4 A:{SYNTHETIC, Splitter: B:31:0x00a4} */
    /* JADX WARNING: Removed duplicated region for block: B:24:0x008f A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:74:0x0119  */
    /* JADX WARNING: Removed duplicated region for block: B:69:0x0110 A:{SYNTHETIC, Splitter: B:69:0x0110} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private List<String> loadCustomizeWhiteList(String path) {
        IOException e;
        NullPointerException e2;
        NumberFormatException e3;
        XmlPullParserException e4;
        IndexOutOfBoundsException e5;
        Throwable th;
        ArrayList<String> emptyList = new ArrayList();
        File file = new File(path);
        if (file.exists()) {
            ArrayList<String> ret = new ArrayList();
            FileInputStream listFileInputStream = null;
            boolean success = false;
            try {
                FileInputStream listFileInputStream2 = new FileInputStream(file);
                try {
                    XmlPullParser parser = Xml.newPullParser();
                    parser.setInput(listFileInputStream2, null);
                    String strTagP = OppoCrashClearManager.CRASH_CLEAR_NAME;
                    String strTagAtt = "att";
                    int type;
                    do {
                        type = parser.next();
                        if (type == 2) {
                            if (OppoCrashClearManager.CRASH_CLEAR_NAME.equals(parser.getName())) {
                                String value = parser.getAttributeValue(null, "att");
                                if (value != null) {
                                    ret.add(value);
                                }
                            }
                        }
                    } while (type != 1);
                    success = true;
                    if (listFileInputStream2 != null) {
                        try {
                            listFileInputStream2.close();
                        } catch (IOException e6) {
                            e6.printStackTrace();
                        }
                    }
                    listFileInputStream = listFileInputStream2;
                } catch (NullPointerException e7) {
                    e2 = e7;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e2);
                    if (listFileInputStream != null) {
                    }
                    if (success) {
                    }
                } catch (NumberFormatException e8) {
                    e3 = e8;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e3);
                    if (listFileInputStream != null) {
                    }
                    if (success) {
                    }
                } catch (XmlPullParserException e9) {
                    e4 = e9;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e4);
                    if (listFileInputStream != null) {
                    }
                    if (success) {
                    }
                } catch (IOException e10) {
                    e6 = e10;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e6);
                    if (listFileInputStream != null) {
                    }
                    if (success) {
                    }
                } catch (IndexOutOfBoundsException e11) {
                    e5 = e11;
                    listFileInputStream = listFileInputStream2;
                    try {
                        Slog.w(TAG, "failed parsing ", e5);
                        if (listFileInputStream != null) {
                        }
                        if (success) {
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        if (listFileInputStream != null) {
                            try {
                                listFileInputStream.close();
                            } catch (IOException e62) {
                                e62.printStackTrace();
                            }
                        }
                        throw th;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    listFileInputStream = listFileInputStream2;
                    if (listFileInputStream != null) {
                    }
                    throw th;
                }
            } catch (NullPointerException e12) {
                e2 = e12;
                Slog.w(TAG, "failed parsing ", e2);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e622) {
                        e622.printStackTrace();
                    }
                }
                if (success) {
                }
            } catch (NumberFormatException e13) {
                e3 = e13;
                Slog.w(TAG, "failed parsing ", e3);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e6222) {
                        e6222.printStackTrace();
                    }
                }
                if (success) {
                }
            } catch (XmlPullParserException e14) {
                e4 = e14;
                Slog.w(TAG, "failed parsing ", e4);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e62222) {
                        e62222.printStackTrace();
                    }
                }
                if (success) {
                }
            } catch (IOException e15) {
                e62222 = e15;
                Slog.w(TAG, "failed parsing ", e62222);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e622222) {
                        e622222.printStackTrace();
                    }
                }
                if (success) {
                }
            } catch (IndexOutOfBoundsException e16) {
                e5 = e16;
                Slog.w(TAG, "failed parsing ", e5);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e6222222) {
                        e6222222.printStackTrace();
                    }
                }
                if (success) {
                }
            }
            if (success) {
                return ret;
            }
            Slog.w(TAG, path + " file failed parsing!");
            return emptyList;
        }
        Slog.w(TAG, path + " file don't exist!");
        return emptyList;
    }

    private boolean checkWhiteList(String packageName) {
        if (this.mCustomizeList == null || this.mCustomizeList.size() <= 0 || packageName == null) {
            return false;
        }
        try {
            for (String pkg : this.mCustomizeList) {
                if (pkg.equalsIgnoreCase(packageName)) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            Slog.w(TAG, "check white list has exception! ", e);
            return false;
        }
    }

    private boolean checkProtectAppList(String packageName) {
        if (!this.mContext.getPackageManager().hasSystemFeature("oppo.customize.function.addprotectapp")) {
            return false;
        }
        List<String> protectApplist = loadCustomizeWhiteList("/data/system/custom_protect_app.xml");
        if (protectApplist == null || protectApplist.isEmpty() || !protectApplist.contains(packageName)) {
            return false;
        }
        return true;
    }

    public void allowToUseSdcard(boolean allow) {
        String propStrExStoreage = "persist.sys.exStorage_support";
        String enableStr = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON;
        if (allow != SystemProperties.get("persist.sys.exStorage_support", LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON).equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON)) {
            SystemProperties.set("persist.sys.exStorage_support", allow ? LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON : "0");
        }
    }

    private boolean isImportantPersistProc(String processName) {
        if (SYSTEMUI_PROC_NAME.equals(processName)) {
            return true;
        }
        return KEYGUARD_PROC_NAME.equals(processName);
    }

    private boolean restartAfterStartTimeout(String processName) {
        if (SYSTEMUI_PROC_NAME.equals(processName)) {
            this.mHandler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        ActivityManagerService.this.startSystemUi(ActivityManagerService.this.mContext);
                    } catch (Exception e) {
                        Slog.e(ActivityManagerService.TAG, "restartAfterStartTimeout startSystemUi failed!", e);
                    }
                }
            }, 2000);
            return true;
        } else if (!KEYGUARD_PROC_NAME.equals(processName)) {
            return false;
        } else {
            this.mHandler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        ActivityManagerService.this.notifyKeyguardStartProcTimeout(ActivityManagerService.this.mContext);
                    } catch (Exception e) {
                        Slog.e(ActivityManagerService.TAG, "restartAfterStartTimeout notifyKeyguardStartProcTimeout failed!", e);
                    }
                }
            }, 2000);
            return true;
        }
    }

    private void startSystemUi(Context context) {
        Intent intent = new Intent();
        intent.setComponent(new ComponentName(SYSTEMUI_PROC_NAME, "com.android.systemui.SystemUIService"));
        Slog.d(TAG, "Starting systemui service: " + intent);
        context.startServiceAsUser(intent, UserHandle.OWNER);
    }

    private void notifyKeyguardStartProcTimeout(Context context) {
        if (this.mSystemReady) {
            Slog.d(TAG, "notifyKeyguardStartProcTimeout: send broadcast android.intent.action.KEYGUARD_TIMEOUT");
            context.sendBroadcast(new Intent(KEYGUARD_STARTPROC_TIMEOUT_ACTION));
            return;
        }
        Slog.d(TAG, "notifyKeyguardStartProcTimeout: system not ready, ignore!");
    }

    public int forceTrimMemory(int level, List<String> protectList) {
        int result = 0;
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (app != null) {
                ApplicationInfo info = app.info;
                if (info != null) {
                    String pkgName = info.packageName;
                    if (protectList != null && protectList.contains(pkgName)) {
                        Slog.d(TAG, "forceTrimMemory skip protect name=" + pkgName);
                    }
                }
                if (app.thread != null) {
                    try {
                        app.thread.scheduleTrimMemory(level);
                    } catch (RemoteException e) {
                        result = -1;
                    }
                }
            }
        }
        Slog.d(TAG, "forceTrimMemory() level = " + level + ", result = " + result);
        return result;
    }

    public boolean isPkgInRecentTasks(String pkg) {
        if (pkg == null || this.mRecentTasks == null) {
            return false;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int recentsCount = this.mRecentTasks.size();
                int i = 0;
                while (i < recentsCount) {
                    TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                    if (tr.getBaseIntent() == null || tr.getBaseIntent().getComponent() == null || tr.getBaseIntent().getComponent().getPackageName() == null || !pkg.equals(tr.getBaseIntent().getComponent().getPackageName())) {
                        i++;
                    }
                }
                resetPriorityAfterLockedSection();
                return false;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return true;
    }

    public ArraySet<Integer> getPidsForPackage(String pkg) {
        ArraySet<Integer> tempSet = new ArraySet();
        if (pkg == null || pkg.isEmpty()) {
            return tempSet;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                    if (!(app == null || app.pkgList == null || !app.pkgList.containsKey(pkg))) {
                        tempSet.add(Integer.valueOf(app.pid));
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return tempSet;
    }

    final int broadcastOppoBootComleteLocked(Intent intent, IIntentReceiver resultTo, int userId) {
        String[] strArr = new String[1];
        strArr[0] = "android.permission.RECEIVE_BOOT_COMPLETED";
        return broadcastIntentLocked(null, null, intent, null, resultTo, 0, null, null, strArr, -1, null, true, false, MY_PID, 1000, userId);
    }

    public void removePermissionNotificationListener(String pkgName, int userId) {
        if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
            Slog.d(TAG, "removePermissionNotificationListener pkgName == " + pkgName);
        }
        if (pkgName != null) {
            String result = IElsaManager.EMPTY_PACKAGE;
            ContentResolver cr = this.mContext.getContentResolver();
            Set<ComponentName> enabledServices = new HashSet();
            String flat = Secure.getString(cr, "enabled_notification_listeners");
            if (flat == null || IElsaManager.EMPTY_PACKAGE.equals(flat)) {
                if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                    Slog.d(TAG, "removePermissionNotificationListener str is empty!");
                }
                return;
            }
            if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                Slog.d(TAG, "removePermissionNotificationListener before == " + flat);
            }
            if (flat.contains(pkgName)) {
                PackageInfo pkgInfo = null;
                try {
                    pkgInfo = this.mContext.getPackageManager().getPackageInfo(pkgName, userId);
                } catch (NameNotFoundException e) {
                    e.printStackTrace();
                }
                if (pkgInfo == null || pkgInfo.applicationInfo == null || (pkgInfo.applicationInfo.flags & 1) == 0) {
                    int i;
                    ComponentName cn;
                    String[] names = flat.split(":");
                    for (String unflattenFromString : names) {
                        cn = ComponentName.unflattenFromString(unflattenFromString);
                        if (cn != null) {
                            enabledServices.add(cn);
                        }
                    }
                    if (enabledServices.size() == 0) {
                        if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                            Slog.d(TAG, "removePermissionNotificationListener size == 0");
                        }
                        return;
                    }
                    StringBuilder sb = new StringBuilder();
                    i = 0;
                    for (ComponentName cn2 : enabledServices) {
                        String cpn = cn2.flattenToString();
                        if (cpn == null || cpn.contains(pkgName)) {
                            if (pkgName != null) {
                                if (!pkgName.contains("coloros")) {
                                }
                            }
                            i++;
                        }
                        if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                            Slog.d(TAG, "removePermissionNotificationListener cpn == " + cpn);
                        }
                        if (i == 0) {
                            sb.append(cpn);
                        } else {
                            sb.append(':');
                            sb.append(cpn);
                        }
                        i++;
                    }
                    result = sb.toString();
                    if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                        Slog.d(TAG, "removePermissionNotificationListener result == " + result);
                    }
                    Secure.putString(cr, "enabled_notification_listeners", result);
                    return;
                }
                if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                    Slog.d(TAG, "removePermissionNotificationListener system app return!");
                }
                return;
            }
            if (ActivityManagerDebugConfig.DEBUG_PERMISSION) {
                Slog.d(TAG, "removePermissionNotificationListener is't contain " + pkgName);
            }
        }
    }

    public void killPackageDependents(String packageName, int userId) {
        enforceCallingPermission("android.permission.KILL_UID", "killPackageDependents()");
        if (packageName == null) {
            throw new NullPointerException("Cannot kill the dependents of a package without its name.");
        }
        long callingId = Binder.clearCallingIdentity();
        IPackageManager pm = AppGlobals.getPackageManager();
        Slog.d(TAG, "killPackageDependents : callingPid = " + Binder.getCallingPid() + ", callingUid = " + Binder.getCallingUid());
        int pkgUid = -1;
        try {
            pkgUid = pm.getPackageUid(packageName, 268435456, userId);
        } catch (RemoteException e) {
        }
        if (userId == -1 || pkgUid != -1) {
            try {
                synchronized (this) {
                    boostPriorityForLockedSection();
                    killPackageProcessesLocked(packageName, UserHandle.getAppId(pkgUid), userId, 0, false, true, true, false, "dep: " + packageName);
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
            }
        } else {
            throw new IllegalArgumentException("Cannot kill dependents of non-existing package " + packageName);
        }
    }

    private void oppoCreateFileInData() {
        this.mHandler.removeCallbacks(this.mCreateDataReserveFile);
        File file = new File(DATA_RESERVE_PATH);
        if (!file.exists()) {
            int dataAviSize = getAvaiDataSize() - 40;
            Slog.d(TAG, "free data size is:" + dataAviSize);
            if (dataAviSize > 64) {
                Slog.d(TAG, "create a reserve file 64M");
                createReserveFile(file, 64);
            } else if (dataAviSize > 64 || dataAviSize <= 16) {
                Slog.e(TAG, "data size is less than 16M");
            } else {
                createReserveFile(file, dataAviSize);
                Slog.d(TAG, "create a reserve file dataFreeSize:" + dataAviSize + " finish!");
            }
        }
    }

    private void createReserveFile(File file, int size) {
        Throwable th;
        FileOutputStream fos = null;
        try {
            FileOutputStream fos2 = new FileOutputStream(file, true);
            try {
                byte[] buf = new byte[1024];
                int large = size * 1024;
                for (long i = 0; i < ((long) large); i++) {
                    fos2.write(buf);
                }
                fos2.flush();
                try {
                    fos2.close();
                } catch (IOException e) {
                    Slog.e(TAG, "fos close fatal error:" + e);
                }
                fos = fos2;
            } catch (IOException e2) {
                fos = fos2;
                try {
                    Slog.e(TAG, "reserve.log create faile!!!");
                    try {
                        fos.close();
                    } catch (IOException e3) {
                        Slog.e(TAG, "fos close fatal error:" + e3);
                    }
                } catch (Throwable th2) {
                    th = th2;
                    try {
                        fos.close();
                    } catch (IOException e32) {
                        Slog.e(TAG, "fos close fatal error:" + e32);
                    }
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                fos = fos2;
                fos.close();
                throw th;
            }
        } catch (IOException e4) {
            Slog.e(TAG, "reserve.log create faile!!!");
            fos.close();
        }
    }

    private int getAvaiDataSize() {
        StatFs sf = new StatFs("/data");
        return (int) ((sf.getBlockSizeLong() * sf.getAvailableBlocksLong()) / 1048576);
    }

    public boolean canBypassWorkChallenge(PendingIntent intent) throws RemoteException {
        boolean z = false;
        int userId = intent.getCreatorUserHandle().getIdentifier();
        if (!this.mUserController.isUserRunningLocked(userId, 2)) {
            return false;
        }
        IIntentSender target = intent.getTarget();
        if (!(target instanceof PendingIntentRecord)) {
            return false;
        }
        PendingIntentRecord record = (PendingIntentRecord) target;
        ResolveInfo rInfo = this.mStackSupervisor.resolveIntent(record.key.requestIntent, record.key.requestResolvedType, userId, DumpState.DUMP_FROZEN);
        if (!(rInfo == null || rInfo.activityInfo == null)) {
            z = true;
        }
        return z;
    }

    public void getRunningProcessPids(ArrayList<Integer> pids) {
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            try {
                pids.add(Integer.valueOf(((ProcessRecord) this.mLruProcesses.get(i)).pid));
            } catch (IndexOutOfBoundsException e) {
                Slog.w(TAG, "Failed to get mLruProcesses element i = " + i);
            }
        }
    }

    protected void configLogTag() {
        String activitylog = SystemProperties.get("persist.sys.activitylog", null);
        if (activitylog != null && !activitylog.equals(IElsaManager.EMPTY_PACKAGE)) {
            if (activitylog.indexOf(" ") + 1 > activitylog.length() || activitylog.indexOf(" ") == -1) {
                SystemProperties.set("persist.sys.activitylog", IElsaManager.EMPTY_PACKAGE);
                return;
            }
            String[] args = new String[2];
            args[0] = activitylog.substring(0, activitylog.indexOf(" "));
            args[1] = activitylog.substring(activitylog.indexOf(" ") + 1, activitylog.length());
            configLogTag(null, args, 0);
        }
    }

    public ComponentName getTopAppName() {
        return this.mStackSupervisor.getTopAppName();
    }

    protected void configLogTag(PrintWriter pw, String[] args, int opti) {
        if (opti + 1 >= args.length) {
            if (pw != null) {
                pw.println("  Invalid argument!");
            }
            SystemProperties.set("persist.sys.activitylog", IElsaManager.EMPTY_PACKAGE);
            return;
        }
        String tag = args[opti];
        boolean on = "on".equals(args[opti + 1]);
        SystemProperties.set("persist.sys.activitylog", args[opti] + " " + args[opti + 1]);
        if (tag.equals("a")) {
            ActivityManagerDebugConfig.DEBUG_ALL = false;
            ActivityManagerDebugConfig.DEBUG_PROCESSES = on;
            ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
            ActivityManagerDebugConfig.DEBUG_MU = on;
            ActivityManagerDebugConfig.DEBUG_SWITCH = on;
            ActivityManagerDebugConfig.DEBUG_TASKS = on;
            ActivityManagerDebugConfig.DEBUG_PAUSE = on;
            ActivityManagerDebugConfig.DEBUG_TRANSITION = on;
            ActivityManagerDebugConfig.DEBUG_CONFIGURATION = on;
            ActivityManagerDebugConfig.DEBUG_STATES = on;
            ActivityManagerDebugConfig.DEBUG_ADD_REMOVE = on;
            ActivityManagerDebugConfig.DEBUG_SAVED_STATE = on;
            ActivityManagerDebugConfig.DEBUG_APP = on;
            ActivityManagerDebugConfig.DEBUG_IDLE = on;
        } else if (tag.equals("da")) {
            ActivityManagerDebugConfig.DEBUG_ALL = false;
            ActivityManagerDebugConfig.DEBUG_OOM_ADJ = on;
            ActivityManagerDebugConfig.DEBUG_VISIBILITY = on;
            ActivityManagerDebugConfig.DEBUG_USER_LEAVING = on;
            ActivityManagerDebugConfig.DEBUG_RESULTS = on;
        } else if (tag.equals("br")) {
            ActivityManagerDebugConfig.DEBUG_ALL = false;
            ActivityManagerDebugConfig.DEBUG_PROCESSES = on;
            ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
            ActivityManagerDebugConfig.DEBUG_MU = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT = on;
        } else if (tag.equals("s")) {
            ActivityManagerDebugConfig.DEBUG_ALL = false;
            ActivityManagerDebugConfig.DEBUG_PROCESSES = on;
            ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
            ActivityManagerDebugConfig.DEBUG_MU = on;
            ActivityManagerDebugConfig.DEBUG_SERVICE = on;
            ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING = on;
        } else if (tag.equals("cp")) {
            ActivityManagerDebugConfig.DEBUG_ALL = false;
            ActivityManagerDebugConfig.DEBUG_PROCESSES = on;
            ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
            ActivityManagerDebugConfig.DEBUG_MU = on;
            ActivityManagerDebugConfig.DEBUG_PROVIDER = on;
        } else if (tag.equals(OppoCrashClearManager.CRASH_CLEAR_NAME)) {
            ActivityManagerDebugConfig.DEBUG_ALL = false;
            ActivityManagerDebugConfig.DEBUG_URI_PERMISSION = on;
        } else if (tag.equals("m")) {
            ActivityManagerDebugConfig.DEBUG_ALL = false;
            ActivityManagerDebugConfig.DEBUG_BACKUP = on;
            ActivityManagerDebugConfig.DEBUG_POWER = on;
            ActivityManagerDebugConfig.DEBUG_POWER_QUICK = on;
        } else if (tag.equals("x")) {
            ActivityManagerDebugConfig.DEBUG_ALL = on;
            ActivityManagerDebugConfig.DEBUG_ALL_ACTIVITIES = on;
            ActivityManagerDebugConfig.DEBUG_ADD_REMOVE = on;
            ActivityManagerDebugConfig.DEBUG_ANR = on;
            ActivityManagerDebugConfig.DEBUG_APP = on;
            ActivityManagerDebugConfig.DEBUG_BACKUP = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
            ActivityManagerDebugConfig.DEBUG_CONFIGURATION = on;
            ActivityManagerDebugConfig.DEBUG_CONTAINERS = on;
            ActivityManagerDebugConfig.DEBUG_FOCUS = on;
            ActivityManagerDebugConfig.DEBUG_IDLE = on;
            ActivityManagerDebugConfig.DEBUG_IMMERSIVE = on;
            ActivityManagerDebugConfig.DEBUG_LOCKSCREEN = on;
            ActivityManagerDebugConfig.DEBUG_LOCKTASK = on;
            ActivityManagerDebugConfig.DEBUG_LRU = on;
            ActivityManagerDebugConfig.DEBUG_MU = on;
            ActivityManagerDebugConfig.DEBUG_OOM_ADJ = on;
            ActivityManagerDebugConfig.DEBUG_PAUSE = on;
            ActivityManagerDebugConfig.DEBUG_POWER = on;
            ActivityManagerDebugConfig.DEBUG_POWER_QUICK = on;
            ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS = on;
            ActivityManagerDebugConfig.DEBUG_PROCESSES = on;
            ActivityManagerDebugConfig.DEBUG_PROVIDER = on;
            ActivityManagerDebugConfig.DEBUG_PSS = on;
            ActivityManagerDebugConfig.DEBUG_RECENTS = on;
            ActivityManagerDebugConfig.DEBUG_RELEASE = on;
            ActivityManagerDebugConfig.DEBUG_RESULTS = on;
            ActivityManagerDebugConfig.DEBUG_SAVED_STATE = on;
            ActivityManagerDebugConfig.DEBUG_SCREENSHOTS = on;
            ActivityManagerDebugConfig.DEBUG_SERVICE = on;
            ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING = on;
            ActivityManagerDebugConfig.DEBUG_STACK = on;
            ActivityManagerDebugConfig.DEBUG_STATES = on;
            ActivityManagerDebugConfig.DEBUG_SWITCH = on;
            ActivityManagerDebugConfig.DEBUG_TASKS = on;
            ActivityManagerDebugConfig.DEBUG_THUMBNAILS = on;
            ActivityManagerDebugConfig.DEBUG_TRANSITION = on;
            ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS = on;
            ActivityManagerDebugConfig.DEBUG_URI_PERMISSION = on;
            ActivityManagerDebugConfig.DEBUG_USER_LEAVING = on;
            ActivityManagerDebugConfig.DEBUG_VISIBILITY = on;
            ActivityManagerDebugConfig.DEBUG_VISIBLE_BEHIND = on;
            ActivityManagerDebugConfig.DEBUG_USAGE_STATS = on;
            ActivityManagerDebugConfig.DEBUG_PERMISSIONS_REVIEW = on;
            ActivityManagerDebugConfig.DEBUG_WHITELISTS = on;
            ActivityManagerDebugConfig.DEBUG_PERMISSION = on;
            ActivityManagerDebugConfig.DEBUG_TASK_RETURNTO = on;
            ActivityManagerDebugConfig.DEBUG_MULTIWINDOW = on;
            AMEventHook.setDebug(on);
            configActivityLogTag(tag, on);
        } else if (tag.equals("lp")) {
            String processName = args[opti + 1];
            Slog.i(TAG, "Enalbe Looper Log: " + processName);
            int i = 0;
            while (i < this.mLruProcesses.size()) {
                ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                if (app == null || app.processName.toLowerCase().indexOf(processName.toLowerCase()) < 0) {
                    i++;
                } else if (app.thread != null) {
                    try {
                        app.thread.enableLooperLog();
                        return;
                    } catch (Exception e) {
                        Slog.e(TAG, "Error happens when enable looper log", e);
                        return;
                    }
                } else {
                    return;
                }
            }
        } else if (tag.equals("anr")) {
            int anrOption = Integer.valueOf(args[opti + 1]).intValue();
            System.putInt(this.mContext.getContentResolver(), "anr_debugging_mechanism", anrOption);
            ANRManager.AnrOption = anrOption;
        } else if (tag.equals("event")) {
            AMEventHook.setEventDetailDebug(on);
        } else {
            if (pw != null) {
                pw.println("  Invalid argument!");
            }
            SystemProperties.set("persist.sys.activitylog", IElsaManager.EMPTY_PACKAGE);
        }
    }

    public AMEventHook getAMEventHook() {
        return this.mAMEventHook;
    }

    private static String getProcessPid(ProcessRecord process) {
        if (process == null) {
            return Integer.toString(MY_PID);
        }
        return Integer.toString(process.pid);
    }

    public void setWallpaperProcess(ComponentName className) {
        if (SystemProperties.get("ro.mtk_gmo_ram_optimize").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON)) {
            final ComponentName cmpName = className.clone();
            this.mHandler.post(new Runnable() {
                public void run() {
                    synchronized (this) {
                        ActivityManagerService.this.mWallpaperClassName = cmpName;
                        ActivityManagerService.this.mIsWallpaperFg = true;
                    }
                }
            });
        }
    }

    public void updateWallpaperState(final boolean isForeground) {
        if (SystemProperties.get("ro.mtk_gmo_ram_optimize").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON)) {
            boolean isFg = isForeground;
            this.mHandler.post(new Runnable() {
                public void run() {
                    synchronized (this) {
                        ActivityManagerService.this.mIsWallpaperFg = isForeground;
                        if (ActivityManagerService.this.mWallpaperProcess != null && ActivityManagerService.this.mIsWallpaperFg) {
                            ActivityManagerService.this.updateOomAdjLocked(ActivityManagerService.this.mWallpaperProcess);
                        }
                    }
                }
            });
        }
    }

    public boolean resumeTopActivityOnSystemReadyFocusedStackLocked() {
        if (this.mSystemReadyFocusedStack != null) {
            return this.mSystemReadyFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        }
        Slog.d(TAG, "SystemReadyFocusedStack not ready");
        return false;
    }

    private void initOnSystemReady() {
        this.mSystemReadyFocusedStack = getFocusedStack();
        mANRManager.registerDumpNBTReceiver();
        int anrStatus = System.getInt(this.mContext.getContentResolver(), "anr_debugging_mechanism_status", 0);
        ANRManager.AnrOption = System.getInt(this.mContext.getContentResolver(), "anr_debugging_mechanism", 0);
        if (!IS_USER_BUILD && anrStatus == 0) {
            System.putInt(this.mContext.getContentResolver(), "anr_debugging_mechanism", 2);
            ANRManager.AnrOption = 2;
            System.putInt(this.mContext.getContentResolver(), "anr_debugging_mechanism_status", 1);
        }
        if (SystemProperties.get("ro.mtk_emulator_support").equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON)) {
            ANRManager.AnrOption = 0;
        }
        this.mCustomizedOomExt = (ICustomizedOomExt) MPlugin.createInstance(ICustomizedOomExt.class.getName(), this.mContext);
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG, "CustomizedOomExt initialized: " + this.mCustomizedOomExt);
        }
    }

    private void filterStaticReceivers(List<ResolveInfo> receivers, List<String> filterList) {
        int size = receivers != null ? receivers.size() : 0;
        int i = 0;
        while (i < size) {
            if (filterList.contains(((ResolveInfo) receivers.get(i)).activityInfo.packageName)) {
                receivers.remove(i);
                size--;
                i--;
            }
            i++;
        }
    }

    private void filterRegisteredReceivers(List<BroadcastFilter> receivers, List<String> filterList) {
        int size = receivers != null ? receivers.size() : 0;
        int i = 0;
        while (i < size) {
            if (filterList.contains(((BroadcastFilter) receivers.get(i)).receiverList.app.processName)) {
                receivers.remove(i);
                size--;
                i--;
            }
            i++;
        }
    }

    public void forceKillPackage(String packageName, int userId, String reason) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: forceKillPackage() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        int callingPid = Binder.getCallingPid();
        userId = this.mUserController.handleIncomingUser(callingPid, Binder.getCallingUid(), userId, true, 2, "forceKillPackage", null);
        long callingId = Binder.clearCallingIdentity();
        try {
            IPackageManager pm = AppGlobals.getPackageManager();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    int[] users;
                    if (userId == -1) {
                        users = this.mUserController.getUsers();
                    } else {
                        users = new int[1];
                        users[0] = userId;
                    }
                    for (int user : users) {
                        int pkgUid = -1;
                        pkgUid = pm.getPackageUid(packageName, 268435456, user);
                        if (pkgUid == -1) {
                            Slog.w(TAG, "Invalid packageName: " + packageName);
                        } else if (this.mUserController.isUserRunningLocked(user, 0)) {
                            forceStopPackageLocked(packageName, pkgUid, reason + " from pid " + callingPid);
                            finishForceStopPackageLocked(packageName, pkgUid);
                        }
                    }
                } catch (RemoteException e) {
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private boolean isSystemOrProtectedPackageName(String name) {
        if (name.matches("com\\.android\\..*")) {
            return true;
        }
        return name.matches("com\\.mediatek\\..*");
    }

    private int getCustomizedAdj(String processName, int adj) {
        if (this.mCustomizedOomExt == null) {
            return adj;
        }
        int customizedAdj = this.mCustomizedOomExt.getCustomizedAdj(processName);
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG, "getCustomizedAdj(" + processName + ") with adj = " + customizedAdj + " cur = " + adj);
        }
        if (customizedAdj == 1001 || adj <= customizedAdj) {
            return adj;
        }
        return customizedAdj;
    }

    public void stickWindow(IBinder token, boolean isSticky) throws RemoteException {
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException("stickWindow: No activity record matching token=" + token);
                }
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack == null || stack.mStackId != 2) {
                    throw new IllegalStateException("stickWindow: You can only stick window from freeform.");
                }
                stickWindow(r.task, isSticky);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    void stickWindow(TaskRecord task, boolean isSticky) {
        Slog.d(TAG_STACK, "stickWindow, task = " + task + ", isSticky = " + isSticky);
        task.mSticky = isSticky;
        this.mWindowManager.stickWindow(task.stack.mStackId, task.taskId, isSticky);
    }

    public boolean isStickyByMtk(IBinder token) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException("isSticky: No activity record matching token=" + token);
                }
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack == null || stack.mStackId != 2) {
                    Slog.e(TAG, "isSticky: You can only stick window from freeform.");
                } else {
                    boolean z = r.task.mSticky;
                    resetPriorityAfterLockedSection();
                    return z;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    public void restoreWindow() throws RemoteException {
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                ActivityRecord r = this.mFocusedActivity;
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "[BMW] restoreWindow: " + r);
                }
                if (r == null) {
                    throw new IllegalArgumentException("[BMW] restoreWindow: mFocusedActivity is null.");
                } else if (!r.task.isResizeable() || r.task.isRecentsTask()) {
                    Slog.e(TAG_STACK, "[BMW] restoreWindow: You can only restore window from resizeable task.");
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                } else {
                    r.forceNewConfig = true;
                    this.mStackSupervisor.moveTaskToStackLocked(r.task.taskId, 2, true, false, "restoreWindow", false);
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public String[] getPackageListFromPid(int pid) {
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000) {
            ProcessRecord pr;
            synchronized (this.mPidsSelfLocked) {
                pr = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            }
            if (pr != null) {
                return pr.getPackageList();
            }
            return null;
        }
        throw new SecurityException("getPackageListFromPid called from non-system process");
    }

    public ArrayMap<Integer, ArrayList<Integer>> getProcessesWithAdj() {
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000) {
            ArrayMap<Integer, ArrayList<Integer>> processMap = new ArrayMap();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = (ProcessRecord) this.mLruProcesses.get(i);
                        int adj = r.setAdj;
                        int pid = r.pid;
                        ArrayList<Integer> indicateList = (ArrayList) processMap.get(Integer.valueOf(adj));
                        if (indicateList == null) {
                            indicateList = new ArrayList();
                            processMap.put(Integer.valueOf(adj), indicateList);
                        }
                        indicateList.add(Integer.valueOf(pid));
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return processMap;
        }
        throw new SecurityException("getProcessesWithAdj called from non-system process");
    }

    public int readyToGetContentProvider(IApplicationThread caller, String name, int userId) {
        String suppressAction = "allowed";
        if (caller == null) {
            return 0;
        }
        ContentProviderRecord cpr = this.mProviderMap.getProviderByName(name, userId);
        ProviderInfo cpi = null;
        String packageName = null;
        if (cpr != null) {
            cpi = cpr.info;
        }
        if (!(cpi == null || cpi.applicationInfo == null)) {
            packageName = cpi.applicationInfo.packageName;
        }
        List<String> callerList = new ArrayList();
        List<Integer> callerUidList = new ArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord callerApp = getRecordForAppLocked(caller);
                if (!(callerApp == null || callerApp.pkgList == null)) {
                    for (int i = 0; i < callerApp.pkgList.size(); i++) {
                        callerList.add((String) callerApp.pkgList.keyAt(i));
                        callerUidList.add(Integer.valueOf(callerApp.userId));
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        ReadyToStartComponent eventData = ReadyToStartComponent.createInstance();
        Object[] objArr = new Object[10];
        objArr[0] = packageName;
        objArr[1] = Integer.valueOf(userId);
        objArr[2] = callerList;
        objArr[3] = callerUidList;
        objArr[4] = null;
        objArr[5] = null;
        objArr[6] = null;
        objArr[7] = null;
        objArr[8] = OppoProcessManager.RESUME_REASON_PROVIDER_STR;
        objArr[9] = suppressAction;
        eventData.set(objArr);
        this.mAMEventHook.hook(Event.AM_ReadyToStartComponent, eventData);
        suppressAction = eventData.getString(Index.suppressAction);
        if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_ALL) {
            Slog.i(TAG, "[process suppression] suppressAction = " + suppressAction);
        }
        if (suppressAction != null && suppressAction.equals("delayed")) {
            return 1;
        }
        if (suppressAction == null || !suppressAction.equals("skipped")) {
            return 0;
        }
        return 2;
    }

    static final IAWSProcessRecord convertProcessRecord(final ProcessRecord pr) {
        if (pr == null) {
            return null;
        }
        return new IAWSProcessRecord() {
            public String getPkgName() {
                return pr.info.packageName;
            }

            public int getPkgVer() {
                return pr.info.versionCode;
            }

            public String getProcName() {
                return pr.processName;
            }

            public int getPid() {
                return pr.pid;
            }

            public int getAdj() {
                return pr.curAdj;
            }

            public int getUid() {
                return pr.uid;
            }

            public int getprocState() {
                return pr.curProcState;
            }

            public ArrayMap<String, ProcessStateHolder> getpkgList() {
                return pr.pkgList;
            }

            public boolean isKilledByAm() {
                return pr.killedByAm;
            }

            public boolean isKilled() {
                return pr.killed;
            }

            public String getWaitingToKill() {
                return pr.waitingToKill;
            }
        };
    }

    final IAWSStoreRecord convertStoreRecord(final ProcessRecord proc, final long extraVal) {
        return new IAWSStoreRecord() {
            public ArrayList<IAWSProcessRecord> getRecords() {
                ArrayList<IAWSProcessRecord> procList = new ArrayList();
                synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                    int size = ActivityManagerService.this.mPidsSelfLocked.size();
                    for (int i = 0; i < size; i++) {
                        procList.add(ActivityManagerService.convertProcessRecord((ProcessRecord) ActivityManagerService.this.mPidsSelfLocked.valueAt(i)));
                    }
                }
                return procList;
            }

            public IAWSProcessRecord getRecord() {
                if (proc != null) {
                    return ActivityManagerService.convertProcessRecord(proc);
                }
                return null;
            }

            /* JADX WARNING: Missing block: B:13:0x0025, code:
            com.android.server.am.ActivityManagerService.resetPriorityAfterLockedSection();
     */
            /* JADX WARNING: Missing block: B:14:0x0028, code:
            return null;
     */
            /* Code decompiled incorrectly, please refer to instructions dump. */
            public String getTopPkgName() {
                String str;
                synchronized (ActivityManagerService.this) {
                    try {
                        ActivityManagerService.boostPriorityForLockedSection();
                        ActivityStack stack = ActivityManagerService.this.mStackSupervisor.getFocusedStack();
                        if (!(stack == null || stack.topTask() == null)) {
                            ActivityRecord top = stack.topActivity();
                            if (top != null) {
                                str = top.packageName;
                            }
                        }
                    } finally {
                        ActivityManagerService.resetPriorityAfterLockedSection();
                    }
                }
                return str;
            }

            public long getExtraVal() {
                return extraVal;
            }
        };
    }

    protected void configActivityLogTag(PrintWriter pw, String[] args, int opti) {
        if (opti + 1 >= args.length) {
            if (pw != null) {
                pw.println("  Invalid argument!");
            }
            SystemProperties.set("persist.sys.actthreadlog", IElsaManager.EMPTY_PACKAGE);
            return;
        }
        String tag = args[opti];
        boolean on = "on".equals(args[opti + 1]);
        if (tag != null) {
            configActivityLogTag(tag, on);
            return;
        }
        if (pw != null) {
            pw.println("  Invalid argument!");
        }
        SystemProperties.set("persist.sys.actthreadlog", IElsaManager.EMPTY_PACKAGE);
    }

    protected void configActivityLogTag(String tag, boolean on) {
        if (tag == null) {
            Slog.d(TAG, "Invalid argument: " + tag + " " + on);
            SystemProperties.set("persist.sys.actthreadlog", IElsaManager.EMPTY_PACKAGE);
            return;
        }
        if (on) {
            SystemProperties.set("persist.sys.actthreadlog", tag + " on");
        } else {
            SystemProperties.set("persist.sys.actthreadlog", tag + " off");
        }
        for (int i = 0; i < this.mLruProcesses.size(); i++) {
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (!(app == null || app.thread == null)) {
                try {
                    app.thread.configActivityLogTag(tag, on);
                } catch (Exception e) {
                    Slog.e(TAG, "Error happens when configActivityLogTag", e);
                }
            }
        }
    }

    private boolean isChooserProcessFromUid(ProcessRecord app, int uid) {
        for (int i = app.activities.size() - 1; i >= 0; i--) {
            ActivityRecord r = (ActivityRecord) app.activities.get(i);
            if (r.launchedFromUid == uid) {
                if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.d(TAG, "isChooserProcessFromUid: r=" + r + " launchedFromUid=" + r.launchedFromUid + " realActivity=" + r.realActivity + " intent=" + r.intent + " stack=" + r.task.stack + " task=" + r.task);
                }
                if (("android.intent.action.CHOOSER".equals(r.intent.getAction()) || r.isResolverActivity()) && r.task.stack != null) {
                    ActivityRecord top = r.task.stack.topRunningActivityLocked();
                    if (top == r) {
                        return true;
                    }
                    if (!IS_USER_BUILD || ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                        Slog.d(TAG, "top=" + top);
                    }
                }
            }
        }
        return false;
    }

    public void setAalMode(int mode) {
        AalUtils.getInstance(true).setAalModeInternal(mode);
    }

    public void setAalEnabled(boolean enabled) {
        AalUtils.getInstance(true).setEnabledInternal(enabled);
    }

    public static String getCurrentUsingFont() {
        String dataFontPath = SystemProperties.get("persist.sys.lovelyfonts.path");
        if (dataFontPath == null || dataFontPath.equals(IElsaManager.EMPTY_PACKAGE)) {
            return null;
        }
        return dataFontPath;
    }

    public SuppressManager getSuppressManager() {
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000) {
            return this.mSuppressManager;
        }
        throw new SecurityException("getSuppressManager called from non-system process");
    }

    protected void dynamicallyConfigLogTag(PrintWriter pw, String[] args, int opti) {
        pw.println("dynamicallyConfigLogTag, opti:" + opti + ", args.length:" + args.length);
        for (int index = 0; index < args.length; index++) {
            pw.println("dynamicallyConfigLogTag, args[" + index + "]:" + args[index]);
        }
        if (args.length != 3) {
            pw.println("********** Invalid argument! Get detail help as bellow: **********");
            logoutTagConfigHelp(pw);
            return;
        }
        String tag = args[1];
        boolean on = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(args[2]);
        pw.println("dynamicallyConfigLogTag, tag:" + tag + ", on:" + on);
        if ("life".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_SWITCH = on;
            ActivityManagerDebugConfig.DEBUG_PAUSE = on;
            ActivityManagerDebugConfig.DEBUG_RESULTS = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
            ActivityManagerDebugConfig.DEBUG_USER_LEAVING = on;
        } else if ("visibility".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_FOCUS = on;
            ActivityManagerDebugConfig.DEBUG_VISIBILITY = on;
            ActivityManagerDebugConfig.DEBUG_VISIBLE_BEHIND = on;
            ActivityManagerDebugConfig.DEBUG_TRANSITION = on;
        } else if ("config".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_CONFIGURATION = on;
        } else if ("task".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_TASKS = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
        } else if (OppoProcessManager.RESUME_REASON_BROADCAST_STR.equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_BROADCAST = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT = on;
        } else if ("oppobroadcast".equals(tag)) {
            OppoBroadcastManager.getInstance(this).handleDynamicLog(on);
        } else if (OppoProcessManager.RESUME_REASON_SERVICE_STR.equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_SERVICE = on;
            ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING = on;
            ActivityManagerDebugConfig.DEBUG_MU = on;
            this.mServices.dynaicallyUpdateLogTag(on);
        } else if (OppoProcessManager.RESUME_REASON_PROVIDER_STR.equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_PROVIDER = on;
            ActivityManagerDebugConfig.DEBUG_URI_PERMISSION = on;
            ActivityManagerDebugConfig.DEBUG_MU = on;
        } else if ("backup".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_BACKUP = on;
        } else if ("stack".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_STACK = on;
            ActivityManagerDebugConfig.DEBUG_ADD_REMOVE = on;
            ActivityManagerDebugConfig.DEBUG_APP = on;
            ActivityManagerDebugConfig.DEBUG_CONTAINERS = on;
            ActivityManagerDebugConfig.DEBUG_IDLE = on;
            ActivityManagerDebugConfig.DEBUG_RELEASE = on;
            ActivityManagerDebugConfig.DEBUG_SAVED_STATE = on;
            ActivityManagerDebugConfig.DEBUG_SCREENSHOTS = on;
            ActivityManagerDebugConfig.DEBUG_STATES = on;
        } else if ("process".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_PROCESSES = on;
            ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS = on;
        } else if ("other".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_POWER = on;
            ActivityManagerDebugConfig.DEBUG_THUMBNAILS = on;
            ActivityManagerDebugConfig.DEBUG_OOM_ADJ = on;
            OppoSplitWindowAppReader.getInstance().handleDynamicLog(on);
            ActivityManagerDebugConfig.DEBUG_PSS = on;
            ActivityManagerDebugConfig.DEBUG_LRU = on;
            ActivityManagerDebugConfig.DEBUG_LOCKSCREEN = on;
            ActivityManagerDebugConfig.DEBUG_RECENTS = on;
            if (on) {
                SystemProperties.set("sys.activity.thread.log", "true");
            } else {
                SystemProperties.set("sys.activity.thread.log", "false");
            }
            for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                if (app.thread != null) {
                    Slog.v(TAG, "app.thread.openActivityLog app " + app + " on " + on);
                    try {
                        app.thread.openActivityLog(on);
                    } catch (RemoteException e) {
                        Slog.w(TAG, "Got a RemoteException while open the activity log ");
                    }
                }
            }
        } else if ("fstrim".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_FSTRIM = on;
        } else if ("permission".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_PERMISSION = on;
        } else if (OppoJunkRecorder.JUNK_RECORD_BASEDIR.equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_JUNK = on;
        } else {
            pw.println("Failed! Invalid argument! Type cmd for help: dumpsys activity log");
        }
    }

    protected void dynamicGetValue(PrintWriter pw, String[] args) {
        if (args.length == 1 || args.length == 2) {
            new DumpObject().dumpValue(pw, this, args.length == 2 ? args[1] : IElsaManager.EMPTY_PACKAGE);
            return;
        }
        pw.println("get_value usage:");
        pw.println("dumpsys activity get_value");
        pw.println("or");
        pw.println("dumpsys activity get_value variable");
    }

    protected void logoutTagConfigHelp(PrintWriter pw) {
        pw.println("********************** Help begin:**********************");
        pw.println("1 Activity life circle:DEBUG_SWITCH | DEBUG_PAUSE DEBUG_RESULTS | DEBUG_CLEANUP | DEBUG_STATES");
        pw.println("cmd: dumpsys activity oppo-log life 0/1");
        pw.println("----------------------------------");
        pw.println("2 App visibility:DEBUG_VISIBILITY | DEBUG_TRANSITION | DEBUG_FOCUS");
        pw.println("cmd: dumpsys activity oppo-log visibility 0/1");
        pw.println("----------------------------------");
        pw.println("3 Config process:DEBUG_CONFIGURATION");
        pw.println("cmd: dumpsys activity oppo-log config 0/1");
        pw.println("----------------------------------");
        pw.println("4 Task manage:DEBUG_TASKS | DEBUG_CLEANUP | DEBUG_ADD_REMOVE | DEBUG_SAVED_STATE");
        pw.println("cmd: dumpsys activity oppo-log task 0/1");
        pw.println("----------------------------------");
        pw.println("5 Broadcast manage:DEBUG_BROADCAST | DEBUG_BROADCAST_BACKGROUND | DEBUG_BROADCAST_LIGHT");
        pw.println("cmd: dumpsys activity oppo-log broadcast 0/1");
        pw.println("----------------------------------");
        pw.println("6 Service manage:DEBUG_SERVICE | DEBUG_SERVICE_EXECUTING | DEBUG_MU | ActiveServices's Log");
        pw.println("cmd: dumpsys activity oppo-log service 0/1");
        pw.println("----------------------------------");
        pw.println("7 Provider manage:DEBUG_PROVIDER | DEBUG_URI_PERMISSION | DEBUG_MU");
        pw.println("cmd: dumpsys activity oppo-log provider 0/1");
        pw.println("----------------------------------");
        pw.println("8 backup manage:DEBUG_BACKUP");
        pw.println("cmd: dumpsys activity oppo-log backup 0/1");
        pw.println("----------------------------------");
        pw.println("9 stack manager log:Ams stack & ActivityStackSupervisor & ActivityStack");
        pw.println("cmd: dumpsys activity oppo-log stack 0/1");
        pw.println("----------------------------------");
        pw.println("10 process manage:DEBUG_PROCESSES | DEBUG_PROCESS_OBSERVERS");
        pw.println("cmd: dumpsys activity oppo-log process 0/1");
        pw.println("----------------------------------");
        pw.println("11 oppoBroadcast manage:DEBUG_JUMP_QUEUE | DEBUG_ADJUST_PB_REC_QUE | DEBUG_ADJUST_OB_REC_QUE | DEBUG_BROADCAST_FIREWALL ");
        pw.println("cmd: dumpsys activity oppo-log oppobroadcast 0/1");
        pw.println("----------------------------------");
        pw.println("12 other not in common use:DEBUG_POWER | DEBUG_THUMBNAILS | DEBUG_OOM_ADJ | DEBUG_LOCKSCREEN | DEBUG_LRU | DEBUG_PSS ");
        pw.println("cmd: dumpsys activity oppo-log other 0/1");
        pw.println("----------------------------------");
        pw.println("13 fstrim:DEBUG_FSTRIM");
        pw.println("cmd: dumpsys activity oppo-log fstrim 0/1");
        pw.println("----------------------------------");
        pw.println("14 fstrim:DEBUG_PERMISSION");
        pw.println("cmd: dumpsys activity oppo-log permission 0/1");
        pw.println("----------------------------------");
        pw.println("15 junk:DEBUG_JUNK");
        pw.println("cmd: dumpsys activity oppo-log junk 0/1");
        pw.println("----------------------------------");
        pw.println("********************** Help end.  **********************");
    }

    protected void dumpDynamicallyLogSwitch(PrintWriter pw, String[] args, int opti) {
        boolean z = false;
        StringBuilder append;
        if (args.length == 1) {
            boolean z2;
            StringBuilder append2 = new StringBuilder().append("  life=");
            if (ActivityManagerDebugConfig.DEBUG_SWITCH && ActivityManagerDebugConfig.DEBUG_PAUSE && ActivityManagerDebugConfig.DEBUG_RESULTS) {
                z2 = ActivityManagerDebugConfig.DEBUG_CLEANUP;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" visibility=");
            if (ActivityManagerDebugConfig.DEBUG_FOCUS && ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
                z2 = ActivityManagerDebugConfig.DEBUG_TRANSITION;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" config=").append(ActivityManagerDebugConfig.DEBUG_CONFIGURATION).append(" task=");
            if (ActivityManagerDebugConfig.DEBUG_TASKS) {
                z2 = ActivityManagerDebugConfig.DEBUG_CLEANUP;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" broadcast=");
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST && ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND) {
                z2 = ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" service=");
            if (ActivityManagerDebugConfig.DEBUG_SERVICE && ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING) {
                z2 = ActivityManagerDebugConfig.DEBUG_MU;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" provider=");
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER && ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                z2 = ActivityManagerDebugConfig.DEBUG_MU;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" backup=").append(ActivityManagerDebugConfig.DEBUG_BACKUP).append(" stack=").append(ActivityManagerDebugConfig.DEBUG_STACK).append(" process=");
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                z2 = ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS;
            } else {
                z2 = false;
            }
            append = append2.append(z2).append(" other=");
            if (ActivityManagerDebugConfig.DEBUG_POWER && ActivityManagerDebugConfig.DEBUG_THUMBNAILS && ActivityManagerDebugConfig.DEBUG_OOM_ADJ && ActivityManagerDebugConfig.DEBUG_PSS && ActivityManagerDebugConfig.DEBUG_LRU) {
                z = ActivityManagerDebugConfig.DEBUG_LOCKSCREEN;
            }
            pw.println(append.append(z).append(" fstrim=").append(ActivityManagerDebugConfig.DEBUG_FSTRIM).toString());
        } else if (args.length == 2) {
            String tag = args[1];
            if ("life".equals(tag)) {
                append = new StringBuilder().append("  life=");
                if (ActivityManagerDebugConfig.DEBUG_SWITCH && ActivityManagerDebugConfig.DEBUG_PAUSE && ActivityManagerDebugConfig.DEBUG_RESULTS) {
                    z = ActivityManagerDebugConfig.DEBUG_CLEANUP;
                }
                pw.println(append.append(z).toString());
            } else if ("visibility".equals(tag)) {
                append = new StringBuilder().append("  visibility=");
                if (ActivityManagerDebugConfig.DEBUG_FOCUS && ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
                    z = ActivityManagerDebugConfig.DEBUG_TRANSITION;
                }
                pw.println(append.append(z).toString());
            } else if ("config".equals(tag)) {
                pw.println("  config=" + ActivityManagerDebugConfig.DEBUG_CONFIGURATION);
            } else if ("task".equals(tag)) {
                append = new StringBuilder().append("  task=");
                if (ActivityManagerDebugConfig.DEBUG_TASKS) {
                    z = ActivityManagerDebugConfig.DEBUG_CLEANUP;
                }
                pw.println(append.append(z).toString());
            } else if (OppoProcessManager.RESUME_REASON_BROADCAST_STR.equals(tag)) {
                append = new StringBuilder().append("  broadcast=");
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST && ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND) {
                    z = ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT;
                }
                pw.println(append.append(z).toString());
            } else if (OppoProcessManager.RESUME_REASON_SERVICE_STR.equals(tag)) {
                append = new StringBuilder().append("  service=");
                if (ActivityManagerDebugConfig.DEBUG_SERVICE && ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING) {
                    z = ActivityManagerDebugConfig.DEBUG_MU;
                }
                pw.println(append.append(z).toString());
            } else if (OppoProcessManager.RESUME_REASON_PROVIDER_STR.equals(tag)) {
                append = new StringBuilder().append("  provider=");
                if (ActivityManagerDebugConfig.DEBUG_PROVIDER && ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                    z = ActivityManagerDebugConfig.DEBUG_MU;
                }
                pw.println(append.append(z).toString());
            } else if ("backup".equals(tag)) {
                pw.println("  backup=" + ActivityManagerDebugConfig.DEBUG_BACKUP);
            } else if ("stack".equals(tag)) {
                pw.println("  stack=" + ActivityManagerDebugConfig.DEBUG_STACK);
            } else if ("process".equals(tag)) {
                pw.println("  process=" + ActivityManagerDebugConfig.DEBUG_PROCESSES);
            } else if ("other".equals(tag)) {
                append = new StringBuilder().append("  other=");
                if (ActivityManagerDebugConfig.DEBUG_POWER && ActivityManagerDebugConfig.DEBUG_THUMBNAILS && ActivityManagerDebugConfig.DEBUG_OOM_ADJ && ActivityManagerDebugConfig.DEBUG_PSS && ActivityManagerDebugConfig.DEBUG_LRU) {
                    z = ActivityManagerDebugConfig.DEBUG_LOCKSCREEN;
                }
                pw.println(append.append(z).toString());
            } else if ("fstrim".equals(tag)) {
                pw.println("  fstrim=" + ActivityManagerDebugConfig.DEBUG_FSTRIM);
            } else {
                pw.println("Failed! Invalid argument!");
            }
        }
    }
}
