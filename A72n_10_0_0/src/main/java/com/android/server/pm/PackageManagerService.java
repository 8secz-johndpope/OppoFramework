package com.android.server.pm;

import android.app.ActivityManager;
import android.app.ActivityManagerInternal;
import android.app.ActivityThread;
import android.app.AppOpsManager;
import android.app.BroadcastOptions;
import android.app.IActivityManager;
import android.app.IApplicationThread;
import android.app.ResourcesManager;
import android.app.admin.IDevicePolicyManager;
import android.app.admin.SecurityLog;
import android.app.backup.IBackupManager;
import android.common.OppoFeatureCache;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.AppsQueryHelper;
import android.content.pm.AuxiliaryResolveInfo;
import android.content.pm.ChangedPackages;
import android.content.pm.ComponentInfo;
import android.content.pm.FeatureInfo;
import android.content.pm.IDexModuleRegisterCallback;
import android.content.pm.IOnPermissionsChangeListener;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageDeleteObserver;
import android.content.pm.IPackageDeleteObserver2;
import android.content.pm.IPackageInstallObserver2;
import android.content.pm.IPackageInstaller;
import android.content.pm.IPackageManager;
import android.content.pm.IPackageManagerNative;
import android.content.pm.IPackageMoveObserver;
import android.content.pm.IPackageStatsObserver;
import android.content.pm.InstantAppInfo;
import android.content.pm.InstantAppRequest;
import android.content.pm.InstrumentationInfo;
import android.content.pm.IntentFilterVerificationInfo;
import android.content.pm.KeySet;
import android.content.pm.ModuleInfo;
import android.content.pm.OppoCutomizeManagerInternal;
import android.content.pm.PackageBackwardCompatibility;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInfoLite;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageList;
import android.content.pm.PackageManager;
import android.content.pm.PackageManagerInternal;
import android.content.pm.PackageParser;
import android.content.pm.PackageStats;
import android.content.pm.PackageUserState;
import android.content.pm.ParceledListSlice;
import android.content.pm.PermissionGroupInfo;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.SELinuxUtil;
import android.content.pm.ServiceInfo;
import android.content.pm.SharedLibraryInfo;
import android.content.pm.Signature;
import android.content.pm.SuspendDialogInfo;
import android.content.pm.UserInfo;
import android.content.pm.VerifierDeviceIdentity;
import android.content.pm.VerifierInfo;
import android.content.pm.VersionedPackage;
import android.content.pm.dex.ArtManager;
import android.content.pm.dex.DexMetadataHelper;
import android.content.pm.dex.IArtManager;
import android.content.rollback.IRollbackManager;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.hardware.display.DisplayManager;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.os.FileUtils;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.OppoManager;
import android.os.OppoUsageManager;
import android.os.Parcel;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.SELinux;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.UserManagerInternal;
import android.os.storage.DiskInfo;
import android.os.storage.IStorageManager;
import android.os.storage.StorageEventListener;
import android.os.storage.StorageManager;
import android.os.storage.StorageManagerInternal;
import android.os.storage.VolumeInfo;
import android.provider.DeviceConfig;
import android.provider.MediaStore;
import android.provider.Settings;
import android.security.KeyStore;
import android.security.SystemKeyStore;
import android.system.ErrnoException;
import android.system.Os;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Base64;
import android.util.ByteStringUtils;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.ExceptionUtils;
import android.util.IntArray;
import android.util.Log;
import android.util.LogPrinter;
import android.util.LongSparseArray;
import android.util.LongSparseLongArray;
import android.util.MathUtils;
import android.util.PackageUtils;
import android.util.Pair;
import android.util.PrintStreamPrinter;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseBooleanArray;
import android.util.SparseIntArray;
import android.util.StatsLog;
import android.util.TimingsTraceLog;
import android.util.Xml;
import android.util.jar.StrictJarFile;
import android.util.proto.ProtoOutputStream;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.IntentForwarderActivity;
import com.android.internal.app.ResolverActivity;
import com.android.internal.content.NativeLibraryHelper;
import com.android.internal.content.PackageHelper;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.os.SomeArgs;
import com.android.internal.telephony.CarrierAppUtils;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.ConcurrentUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.FunctionalUtils;
import com.android.internal.util.IndentingPrintWriter;
import com.android.internal.util.IntPair;
import com.android.internal.util.Preconditions;
import com.android.internal.util.function.TriFunction;
import com.android.server.AttributeCache;
import com.android.server.BatteryService;
import com.android.server.ColorServiceFactory;
import com.android.server.DeviceIdleController;
import com.android.server.EventLogTags;
import com.android.server.LocalServices;
import com.android.server.LockGuard;
import com.android.server.OppoCommonServiceFactory;
import com.android.server.PackageWatchdog;
import com.android.server.PinnerService;
import com.android.server.PswServiceFactory;
import com.android.server.ServiceThread;
import com.android.server.SystemConfig;
import com.android.server.SystemServerInitThreadPool;
import com.android.server.am.IColorAppStartupManager;
import com.android.server.am.IColorCommonListManager;
import com.android.server.am.IColorFastAppManager;
import com.android.server.am.IColorMultiAppManager;
import com.android.server.backup.BackupAgentTimeoutParameters;
import com.android.server.connectivity.networkrecovery.dnsresolve.StringUtils;
import com.android.server.job.controllers.JobStatus;
import com.android.server.net.NetworkPolicyManagerInternal;
import com.android.server.net.watchlist.WatchlistLoggingHandler;
import com.android.server.notification.ZenModeHelper;
import com.android.server.operator.OppoOperatorManagerService;
import com.android.server.oppo.OppoCustomizeNotificationHelper;
import com.android.server.oppo.TemperatureProvider;
import com.android.server.pm.CompilerStats;
import com.android.server.pm.Installer;
import com.android.server.pm.OppoBasePackageManagerService;
import com.android.server.pm.PackageDexOptimizer;
import com.android.server.pm.PackageInstallerService;
import com.android.server.pm.PackageManagerService;
import com.android.server.pm.ParallelPackageParser;
import com.android.server.pm.Settings;
import com.android.server.pm.dex.ArtManagerService;
import com.android.server.pm.dex.DexManager;
import com.android.server.pm.dex.DexoptOptions;
import com.android.server.pm.dex.PackageDexUsage;
import com.android.server.pm.dex.ViewCompiler;
import com.android.server.pm.permission.BasePermission;
import com.android.server.pm.permission.DefaultPermissionGrantPolicy;
import com.android.server.pm.permission.PermissionManagerService;
import com.android.server.pm.permission.PermissionManagerServiceInternal;
import com.android.server.pm.permission.PermissionsState;
import com.android.server.security.VerityUtils;
import com.android.server.slice.SliceClientPermissions;
import com.android.server.storage.DeviceStorageMonitorInternal;
import com.android.server.theia.NoFocusWindow;
import com.android.server.usage.AppStandbyController;
import com.android.server.usage.UnixCalendar;
import com.android.server.usb.descriptors.UsbTerminalTypes;
import com.android.server.utils.PriorityDump;
import com.android.server.wm.ActivityTaskManagerInternal;
import com.android.server.wm.ActivityTaskManagerService;
import com.android.server.wm.IColorIntentInterceptManager;
import com.mediatek.cta.CtaManagerFactory;
import com.mediatek.server.MtkSystemServer;
import com.mediatek.server.MtkSystemServiceFactory;
import com.mediatek.server.pm.PmsExt;
import com.mediatek.server.powerhal.PowerHalManager;
import com.oppo.hypnus.Hypnus;
import com.oppo.nfc.OppoNfcPackageFilter;
import com.oppo.phoenix.Phoenix;
import dalvik.system.CloseGuard;
import dalvik.system.VMRuntime;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.charset.StandardCharsets;
import java.security.DigestException;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
import libcore.io.IoUtils;
import libcore.util.EmptyArray;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class PackageManagerService extends OppoBasePackageManagerService implements PackageSender {
    private static final String ATTR_IS_GRANTED = "g";
    private static final String ATTR_PACKAGE_NAME = "pkg";
    private static final String ATTR_PERMISSION_NAME = "name";
    private static final String ATTR_REVOKE_ON_UPGRADE = "rou";
    private static final String ATTR_USER_FIXED = "fixed";
    private static final String ATTR_USER_SET = "set";
    private static final int BLUETOOTH_UID = 1002;
    private static final long BROADCAST_DELAY = 1000;
    private static final long BROADCAST_DELAY_DURING_STARTUP = 10000;
    static final int CHECK_PENDING_VERIFICATION = 16;
    static final boolean CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE = false;
    public static final String COMPRESSED_EXTENSION = ".gz";
    private static final String CUSTOM_ACTION_BACKUP_APP_DATA_FAILED = "action.backup.app.data.failed";
    private static final String CUSTOM_ACTION_BACKUP_APP_DATA_SUCCESS = "action.backup.app.data.success";
    public static boolean DEBUG_ABI_SELECTION = false;
    public static boolean DEBUG_APP_DATA = false;
    public static boolean DEBUG_BACKUP = false;
    public static boolean DEBUG_BROADCASTS = false;
    public static boolean DEBUG_COMPRESSION = Build.IS_DEBUGGABLE;
    public static boolean DEBUG_DEXOPT = false;
    public static boolean DEBUG_DOMAIN_VERIFICATION = false;
    public static boolean DEBUG_INSTALL = false;
    public static boolean DEBUG_INSTANT = Build.IS_DEBUGGABLE;
    public static boolean DEBUG_INTENT_MATCHING = false;
    public static boolean DEBUG_PACKAGE_INFO = false;
    public static boolean DEBUG_PACKAGE_SCANNING = false;
    public static boolean DEBUG_PERMISSIONS = false;
    static boolean DEBUG_PMS = true;
    public static boolean DEBUG_PREFERRED = false;
    private static boolean DEBUG_PROCESS_SPLIT = SystemProperties.getBoolean("persist.sys.oppo.process.merge.debug", false);
    public static boolean DEBUG_REMOVE = false;
    static final boolean DEBUG_SD_INSTALL = false;
    public static boolean DEBUG_SETTINGS = false;
    public static boolean DEBUG_SHARED_LIBRARIES = false;
    public static boolean DEBUG_UPGRADE = false;
    public static boolean DEBUG_VERIFY = false;
    private static final long DEFAULT_ENABLE_ROLLBACK_TIMEOUT_MILLIS = 10000;
    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 259200000;
    private static final boolean DEFAULT_PACKAGE_PARSER_CACHE_ENABLED = true;
    private static final long DEFAULT_UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD = 7200000;
    private static final int DEFAULT_VERIFICATION_RESPONSE = 1;
    private static final long DEFAULT_VERIFICATION_TIMEOUT = 10000;
    private static final boolean DEFAULT_VERIFY_ENABLE = true;
    static final int DEFERRED_NO_KILL_INSTALL_OBSERVER = 24;
    static final int DEFERRED_NO_KILL_INSTALL_OBSERVER_DELAY_MS = 500;
    static final int DEFERRED_NO_KILL_POST_DELETE = 23;
    static final int DEFERRED_NO_KILL_POST_DELETE_DELAY_MS = 3000;
    private static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final boolean ENABLE_FREE_CACHE_V2 = SystemProperties.getBoolean("fw.free_cache_v2", true);
    static final int ENABLE_ROLLBACK_STATUS = 21;
    static final int ENABLE_ROLLBACK_TIMEOUT = 22;
    static final boolean EXP_VERSION = SystemProperties.get("ro.oppo.version", "CN").equalsIgnoreCase("US");
    private static final boolean HIDE_EPHEMERAL_APIS = false;
    static final int INIT_COPY = 5;
    private static final String[] INSTANT_APP_BROADCAST_PERMISSION = {"android.permission.ACCESS_INSTANT_APPS"};
    static final int INSTANT_APP_RESOLUTION_PHASE_TWO = 20;
    static final int INTENT_FILTER_VERIFIED = 18;
    private static final String KILL_APP_REASON_GIDS_CHANGED = "permission grant or revoke changed gids";
    private static final String KILL_APP_REASON_PERMISSIONS_REVOKED = "permissions revoked";
    private static final int LOG_UID = 1007;
    private static final int NETWORKSTACK_UID = 1073;
    private static final int NFC_UID = 1027;
    private static final String ODM_OVERLAY_DIR = "/odm/overlay";
    private static final String OEM_OVERLAY_DIR = "/oem/overlay";
    private static final String OPPO_CUSTOM_OVERLAY_DIR = ("" + Environment.getOppoCustomDirectory().getAbsolutePath() + "/overlay");
    private static final String OPPO_PRODUCT_OVERLAY_DIR = ("" + Environment.getOppoProductDirectory().getAbsolutePath() + "/overlay");
    private static final String OPPO_VERSION_OVERLAY_DIR = ("" + Environment.getOppoVersionDirectory().getAbsolutePath() + "/overlay");
    private static final String PACKAGE_MIME_TYPE = "application/vnd.android.package-archive";
    private static final String PACKAGE_SCHEME = "package";
    static final int PACKAGE_VERIFIED = 15;
    public static final String PLATFORM_PACKAGE_NAME = "android";
    static final int POST_INSTALL = 9;
    private static final String PRECOMPILE_LAYOUTS = "pm.precompile_layouts";
    private static final String PRODUCT_OVERLAY_DIR = "/product/overlay";
    private static final String PRODUCT_SERVICES_OVERLAY_DIR = "/product_services/overlay";
    private static final String PROPERTY_ENABLE_ROLLBACK_TIMEOUT_MILLIS = "enable_rollback_timeout";
    private static final int RADIO_UID = 1001;
    public static final int REASON_AB_OTA = 4;
    public static final int REASON_AGRESSIVE = 10000;
    public static final int REASON_BACKGROUND_DEXOPT = 3;
    public static final int REASON_BOOT = 1;
    public static final int REASON_CORE_APP = 7;
    public static final int REASON_FIRST_BOOT = 0;
    public static final int REASON_INACTIVE_PACKAGE_DOWNGRADE = 5;
    public static final int REASON_INSTALL = 2;
    public static final int REASON_LAST = 7;
    public static final int REASON_SHARED = 6;
    public static final int REASON_UNKNOWN = -1;
    private static final String SCANSTAGE_PROPERTY = "persist.sys.oppo.scanstage";
    static final int SCAN_AS_CUSTOM = 4194304;
    static final int SCAN_AS_FULL_APP = 32768;
    static final int SCAN_AS_INSTANT_APP = 16384;
    static final int SCAN_AS_ODM = 8388608;
    static final int SCAN_AS_OEM = 524288;
    static final int SCAN_AS_PRIVILEGED = 262144;
    static final int SCAN_AS_PRODUCT = 2097152;
    static final int SCAN_AS_PRODUCT_SERVICES = 4194304;
    static final int SCAN_AS_SYSTEM = 131072;
    static final int SCAN_AS_VENDOR = 1048576;
    static final int SCAN_AS_VIRTUAL_PRELOAD = 65536;
    static final int SCAN_BOOTING = 16;
    static final int SCAN_CHECK_ONLY = 1024;
    static final int SCAN_DONT_KILL_APP = 2048;
    static final int SCAN_FIRST_BOOT_OR_UPGRADE = 8192;
    static final int SCAN_IGNORE_FROZEN = 4096;
    static final int SCAN_INITIAL = 512;
    static final int SCAN_MOVE = 256;
    static final int SCAN_NEW_INSTALL = 4;
    static final int SCAN_NO_DEX = 1;
    static final int SCAN_REQUIRE_KNOWN = 128;
    static final int SCAN_UPDATE_SIGNATURE = 2;
    static final int SCAN_UPDATE_TIME = 8;
    private static final String SD_ENCRYPTION_ALGORITHM = "AES";
    private static final String SD_ENCRYPTION_KEYSTORE_NAME = "AppsOnSD";
    static final int SEND_PENDING_BROADCAST = 1;
    private static final int SE_UID = 1068;
    private static final int SHELL_UID = 2000;
    static final int START_INTENT_FILTER_VERIFICATIONS = 17;
    private static final String STATIC_SHARED_LIB_DELIMITER = "_";
    public static final String STUB_SUFFIX = "-Stub";
    private static final int SYSTEM_RUNTIME_GRANT_MASK = 52;
    static final String TAG = "PackageManager";
    private static final String TAG_ALL_GRANTS = "rt-grants";
    private static final String TAG_DEFAULT_APPS = "da";
    private static final String TAG_GRANT = "grant";
    private static final String TAG_INTENT_FILTER_VERIFICATION = "iv";
    private static final String TAG_PERMISSION = "perm";
    private static final String TAG_PERMISSION_BACKUP = "perm-grant-backup";
    private static final String TAG_PREFERRED_BACKUP = "pa";
    private static final int TYPE_ACTIVITY = 1;
    private static final int TYPE_PROVIDER = 4;
    private static final int TYPE_RECEIVER = 2;
    private static final int TYPE_SERVICE = 3;
    private static final int TYPE_UNKNOWN = 0;
    private static final int USER_RUNTIME_GRANT_MASK = 11;
    private static final String VENDOR_OVERLAY_DIR = "/vendor/overlay";
    static final long WATCHDOG_TIMEOUT = 600000;
    static final int WRITE_PACKAGE_LIST = 19;
    static final int WRITE_PACKAGE_RESTRICTIONS = 14;
    static final int WRITE_SETTINGS = 13;
    static final int WRITE_SETTINGS_DELAY = 10000;
    static final int iMultitaskNum = SystemProperties.getInt("persist.pm.multitask", 6);
    private static final boolean isCustomApiSupported = SystemProperties.getBoolean("persist.sys.custom.enable", false);
    private static CompatibilityHelper mCompatibilityHelper = null;
    private static CommonDcsUploader mDcsUploader = null;
    private static Hypnus mHyp = null;
    static final String mOperator = SystemProperties.get("ro.oppo.operator", "oppo");
    static final String mRegion = SystemProperties.get("persist.sys.oppo.region", "CN");
    private static final File sAppInstallDir = new File(Environment.getDataDirectory(), "app");
    private static final File sAppLib32InstallDir = new File(Environment.getDataDirectory(), "app-lib");
    private static Handler sBgDexoptHandler;
    private static HandlerThread sBgDexoptThread;
    private static final Intent sBrowserIntent = new Intent();
    private static volatile Handler sFirstUseHandler;
    private static Object sFirstUseLock = new Object();
    private static HandlerThread sFirstUseThread;
    private static MtkSystemServer sMtkSystemServerIns = MtkSystemServer.getInstance();
    private static PmsExt sPmsExt = MtkSystemServiceFactory.getInstance().makePmsExt();
    private static final Comparator<ProviderInfo> sProviderInitOrderSorter = $$Lambda$PackageManagerService$gOdSzzOoHvFHJbKlJkAgg4fzOH8.INSTANCE;
    static UserManagerService sUserManager;
    private final String CUSTOMIZE_LIST_PATH = "/system/etc/oppo_customize_whitelist.xml";
    private final String CUSTOMIZE_SYSTEM_APP_BLACKLIST_PATH = "/system/etc/customize_system_app_blacklist.xml";
    private ActivityManagerInternal mActivityManagerInternal;
    private ActivityTaskManagerInternal mActivityTaskManagerInternal;
    ApplicationInfo mAndroidApplication;
    private final ApexManager mApexManager;
    final String mAppPredictionServicePackage;
    final ArtManagerService mArtManagerService;
    @GuardedBy({"mAvailableFeatures"})
    ArrayMap<String, FeatureInfo> mAvailableFeatures;
    private BlackAppInstallHelper mBlackAppInstallHelper = null;
    private File mCacheDir;
    @GuardedBy({"mPackages"})
    final SparseArray<SparseArray<String>> mChangedPackages = new SparseArray<>();
    @GuardedBy({"mPackages"})
    int mChangedPackagesSequenceNumber;
    @GuardedBy({"mPackages"})
    final SparseArray<Map<String, Integer>> mChangedPackagesSequenceNumbers = new SparseArray<>();
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.CheckPermissionDelegate mCheckPermissionDelegate;
    private final CompilerStats mCompilerStats = new CompilerStats();
    private final ComponentResolver mComponentResolver;
    final String mConfiguratorPackage;
    final Context mContext;
    ComponentName mCustomResolverComponentName;
    private List<String> mCustomizeList = new ArrayList();
    private List<String> mCustomizeSystemAppBlacklist = new ArrayList();
    final int mDefParseFlags;
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.DefaultBrowserProvider mDefaultBrowserProvider;
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.DefaultDialerProvider mDefaultDialerProvider;
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.DefaultHomeProvider mDefaultHomeProvider;
    final DefaultPermissionGrantPolicy mDefaultPermissionPolicy;
    @GuardedBy({"mPackages"})
    private final SparseIntArray mDefaultPermissionsGrantedUsers = new SparseIntArray();
    private DeviceIdleController.LocalService mDeviceIdleController;
    private final DexManager mDexManager;
    @GuardedBy({"mPackages"})
    private boolean mDexOptDialogShown;
    private ArraySet<Integer> mDirtyUsers = new ArraySet<>();
    final String mDocumenterPackage;
    private final ArraySet<String> mExistingSystemPackages = new ArraySet<>();
    private final ArrayMap<String, File> mExpectingBetter = new ArrayMap<>();
    PackageManagerInternal.ExternalSourcesPolicy mExternalSourcesPolicy;
    final boolean mFactoryTest;
    boolean mFirstBoot;
    @GuardedBy({"mPackages"})
    final ArraySet<String> mFrozenPackages = new ArraySet<>();
    final PackageHandler mHandler;
    final ServiceThread mHandlerThread;
    volatile boolean mHasSystemUidErrors;
    final String mIncidentReportApproverPackage;
    final Object mInstallLock = new Object();
    @GuardedBy({"mInstallLock"})
    final Installer mInstaller;
    final PackageInstallerService mInstallerService;
    ActivityInfo mInstantAppInstallerActivity;
    final ResolveInfo mInstantAppInstallerInfo = new ResolveInfo();
    private final InstantAppRegistry mInstantAppRegistry;
    final InstantAppResolverConnection mInstantAppResolverConnection;
    final ComponentName mInstantAppResolverSettingsComponent;
    final ArrayMap<ComponentName, PackageParser.Instrumentation> mInstrumentation = new ArrayMap<>();
    final SparseArray<IntentFilterVerificationState> mIntentFilterVerificationStates = new SparseArray<>();
    private int mIntentFilterVerificationToken = 0;
    private final IntentFilterVerifier<PackageParser.ActivityIntentInfo> mIntentFilterVerifier;
    private final ComponentName mIntentFilterVerifierComponent;
    final boolean mIsPreNMR1Upgrade;
    final boolean mIsPreNUpgrade;
    final boolean mIsPreQUpgrade;
    final boolean mIsUpgrade;
    @GuardedBy({"mPackages"})
    final SparseIntArray mIsolatedOwners = new SparseIntArray();
    private List<String> mKeepUninstalledPackages;
    @GuardedBy({"mLoadedVolumes"})
    final ArraySet<String> mLoadedVolumes = new ArraySet<>();
    private boolean mMediaMounted = false;
    final DisplayMetrics mMetrics;
    private final ModuleInfoProvider mModuleInfoProvider;
    private final MoveCallbacks mMoveCallbacks;
    int mNextInstallToken = 1;
    private AtomicInteger mNextMoveId = new AtomicInteger();
    private final Map<String, Pair<PackageInstalledInfo, IPackageInstallObserver2>> mNoKillInstallObservers = Collections.synchronizedMap(new HashMap());
    private final OnPermissionChangeListeners mOnPermissionChangeListeners;
    final boolean mOnlyCore;
    private final PackageDexOptimizer mPackageDexOptimizer;
    @GuardedBy({"mPackages"})
    private final ArraySet<PackageManagerInternal.PackageListObserver> mPackageListObservers = new ArraySet<>();
    final PackageParser.Callback mPackageParserCallback = new PackageParserCallback();
    private final PackageUsage mPackageUsage = new PackageUsage();
    @GuardedBy({"mPackages"})
    final ArrayMap<String, PackageParser.Package> mPackages = new ArrayMap<>();
    final ParallelPackageParserCallback mParallelPackageParserCallback = new ParallelPackageParserCallback();
    final PendingPackageBroadcasts mPendingBroadcasts = new PendingPackageBroadcasts();
    final SparseArray<InstallParams> mPendingEnableRollback = new SparseArray<>();
    private int mPendingEnableRollbackToken = 0;
    final SparseArray<PackageVerificationState> mPendingVerification = new SparseArray<>();
    private int mPendingVerificationToken = 0;
    private PermissionManagerServiceInternal.PermissionCallback mPermissionCallback = new PermissionManagerServiceInternal.PermissionCallback() {
        /* class com.android.server.pm.PackageManagerService.AnonymousClass1 */

        public /* synthetic */ void lambda$onGidsChanged$0$PackageManagerService$1(int appId, int userId) {
            PackageManagerService.this.killUid(appId, userId, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onGidsChanged(int appId, int userId) {
            PackageManagerService.this.mHandler.post(new Runnable(appId, userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$1$7o99DenVu604GN9uaO7x0s_Ispw */
                private final /* synthetic */ int f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void run() {
                    PackageManagerService.AnonymousClass1.this.lambda$onGidsChanged$0$PackageManagerService$1(this.f$1, this.f$2);
                }
            });
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onPermissionGranted(int uid, int userId) {
            PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onInstallPermissionGranted() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onPermissionRevoked(int uid, int userId) {
            PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
            }
            PackageManagerService.this.killUid(UserHandle.getAppId(uid), userId, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onInstallPermissionRevoked() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
            synchronized (PackageManagerService.this.mPackages) {
                for (int userId : updatedUserIds) {
                    PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, sync);
                }
            }
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onInstallPermissionUpdated() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
        public void onPermissionRemoved() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeLPr();
            }
        }
    };
    private final PermissionManagerServiceInternal mPermissionManager;
    PackageParser.Package mPlatformPackage;
    private PowerHalManager mPowerHalManager = MtkSystemServiceFactory.getInstance().makePowerHalManager();
    private Future<?> mPrepareAppDataFuture;
    private final ProcessLoggingHandler mProcessLoggingHandler;
    boolean mPromoteSystemApps;
    @GuardedBy({"mProtectedBroadcasts"})
    final ArraySet<String> mProtectedBroadcasts = new ArraySet<>();
    final ProtectedPackages mProtectedPackages;
    final String mRequiredInstallerPackage;
    final String mRequiredPermissionControllerPackage;
    final String mRequiredUninstallerPackage;
    final String mRequiredVerifierPackage;
    final ActivityInfo mResolveActivity = new ActivityInfo();
    ComponentName mResolveComponentName;
    final ResolveInfo mResolveInfo = new ResolveInfo();
    boolean mResolverReplaced = false;
    private ArrayMap<OriginInfo, String> mRunningInstallerPkgName = new ArrayMap<>();
    final SparseArray<PostInstallData> mRunningInstalls = new SparseArray<>();
    volatile boolean mSafeMode;
    final int mSdkVersion = Build.VERSION.SDK_INT;
    final String[] mSeparateProcesses;
    private long mServiceStartWithDelay;
    final String mServicesSystemSharedLibraryPackageName;
    @GuardedBy({"mPackages"})
    final Settings mSettings;
    final String mSetupWizardPackage;
    final ArrayMap<String, LongSparseArray<SharedLibraryInfo>> mSharedLibraries = new ArrayMap<>();
    final String mSharedSystemSharedLibraryPackageName;
    final ArrayMap<String, LongSparseArray<SharedLibraryInfo>> mStaticLibsByDeclaringPackage = new ArrayMap<>();
    private StorageEventListener mStorageListener = new StorageEventListener() {
        /* class com.android.server.pm.PackageManagerService.AnonymousClass3 */

        public void onVolumeStateChanged(VolumeInfo vol, int oldState, int newState) {
            if (vol.type != 1) {
                return;
            }
            if (vol.state == 2) {
                String volumeUuid = vol.getFsUuid();
                PackageManagerService.sUserManager.reconcileUsers(volumeUuid);
                PackageManagerService.this.reconcileApps(volumeUuid);
                PackageManagerService.this.mInstallerService.onPrivateVolumeMounted(volumeUuid);
                PackageManagerService.this.loadPrivatePackages(vol);
            } else if (vol.state == 5) {
                PackageManagerService.this.unloadPrivatePackages(vol);
            }
        }

        public void onVolumeForgotten(String fsUuid) {
            if (TextUtils.isEmpty(fsUuid)) {
                Slog.e(PackageManagerService.TAG, "Forgetting internal storage is probably a mistake; ignoring");
                return;
            }
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageSetting ps : PackageManagerService.this.mSettings.getVolumePackagesLPr(fsUuid)) {
                    Slog.d(PackageManagerService.TAG, "Destroying " + ps.name + " because volume was forgotten");
                    PackageManagerService.this.deletePackageVersioned(new VersionedPackage(ps.name, -1), new PackageManager.LegacyPackageDeleteObserver((IPackageDeleteObserver) null).getBinder(), 0, 2);
                    AttributeCache.instance().removePackage(ps.name);
                }
                PackageManagerService.this.mSettings.onVolumeForgotten(fsUuid);
                PackageManagerService.this.mSettings.writeLPr();
            }
        }
    };
    private StorageManagerInternal mStorageManagerInternal;
    final String mStorageManagerPackage;
    volatile boolean mSystemReady;
    final String mSystemTextClassifierPackage;
    final ArraySet<String> mTransferedPackages = new ArraySet<>();
    private UserManagerInternal mUserManagerInternal;
    private final SparseBooleanArray mUserNeedsBadging = new SparseBooleanArray();
    private final ViewCompiler mViewCompiler;
    private volatile SparseBooleanArray mWebInstantAppsDisabled = new SparseBooleanArray();
    final String mWellbeingPackage;

    /* access modifiers changed from: private */
    public interface BlobXmlRestorer {
        void apply(XmlPullParser xmlPullParser, int i) throws IOException, XmlPullParserException;
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ComponentType {
    }

    /* access modifiers changed from: private */
    public interface IntentFilterVerifier<T extends IntentFilter> {
        boolean addOneIntentFilterVerification(int i, int i2, int i3, T t, String str);

        void receiveVerificationResponse(int i);

        void startVerifications(int i);
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ScanFlags {
    }

    static /* synthetic */ int access$4008(PackageManagerService x0) {
        int i = x0.mPendingVerificationToken;
        x0.mPendingVerificationToken = i + 1;
        return i;
    }

    static /* synthetic */ int access$4308(PackageManagerService x0) {
        int i = x0.mPendingEnableRollbackToken;
        x0.mPendingEnableRollbackToken = i + 1;
        return i;
    }

    static {
        sBrowserIntent.setAction("android.intent.action.VIEW");
        sBrowserIntent.addCategory("android.intent.category.BROWSABLE");
        sBrowserIntent.setData(Uri.parse("http:"));
        sBrowserIntent.addFlags(512);
    }

    class PackageParserCallback implements PackageParser.Callback {
        PackageParserCallback() {
        }

        public final boolean hasFeature(String feature) {
            return PackageManagerService.this.hasSystemFeature(feature, 0);
        }

        /* access modifiers changed from: package-private */
        public final List<PackageParser.Package> getStaticOverlayPackages(Collection<PackageParser.Package> allPackages, String targetPackageName) {
            if (PackageManagerService.PLATFORM_PACKAGE_NAME.equals(targetPackageName)) {
                return null;
            }
            List<PackageParser.Package> overlayPackages = null;
            for (PackageParser.Package p : allPackages) {
                if (targetPackageName.equals(p.mOverlayTarget) && p.mOverlayIsStatic) {
                    if (overlayPackages == null) {
                        overlayPackages = new ArrayList<>();
                    }
                    overlayPackages.add(p);
                }
            }
            if (overlayPackages != null) {
                overlayPackages.sort(Comparator.comparingInt($$Lambda$PackageManagerService$PackageParserCallback$xinvBJUpQse3J1IBBKjvYTIW8MQ.INSTANCE));
            }
            return overlayPackages;
        }

        /* access modifiers changed from: package-private */
        public final String[] getStaticOverlayPaths(List<PackageParser.Package> overlayPackages, String targetPath) {
            if (overlayPackages == null || overlayPackages.isEmpty()) {
                return null;
            }
            List<String> overlayPathList = null;
            for (PackageParser.Package overlayPackage : overlayPackages) {
                if (targetPath == null) {
                    if (overlayPathList == null) {
                        overlayPathList = new ArrayList<>();
                    }
                    overlayPathList.add(overlayPackage.baseCodePath);
                } else {
                    try {
                        PackageManagerService.this.mInstaller.idmap(targetPath, overlayPackage.baseCodePath, UserHandle.getSharedAppGid(UserHandle.getUserGid(0)));
                        if (overlayPathList == null) {
                            overlayPathList = new ArrayList<>();
                        }
                        overlayPathList.add(overlayPackage.baseCodePath);
                    } catch (Installer.InstallerException e) {
                        Slog.e(PackageManagerService.TAG, "Failed to generate idmap for " + targetPath + " and " + overlayPackage.baseCodePath);
                    }
                }
            }
            if (overlayPathList == null) {
                return null;
            }
            return (String[]) overlayPathList.toArray(new String[0]);
        }

        /* access modifiers changed from: package-private */
        public String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            List<PackageParser.Package> overlayPackages;
            String[] staticOverlayPaths;
            synchronized (PackageManagerService.this.mInstallLock) {
                synchronized (PackageManagerService.this.mPackages) {
                    overlayPackages = getStaticOverlayPackages(PackageManagerService.this.mPackages.values(), targetPackageName);
                }
                staticOverlayPaths = getStaticOverlayPaths(overlayPackages, targetPath);
            }
            return staticOverlayPaths;
        }

        public final String[] getOverlayApks(String targetPackageName) {
            return getStaticOverlayPaths(targetPackageName, (String) null);
        }

        public final String[] getOverlayPaths(String targetPackageName, String targetPath) {
            return getStaticOverlayPaths(targetPackageName, targetPath);
        }
    }

    /* access modifiers changed from: package-private */
    public class ParallelPackageParserCallback extends PackageParserCallback {
        List<PackageParser.Package> mOverlayPackages = null;

        ParallelPackageParserCallback() {
            super();
        }

        /* access modifiers changed from: package-private */
        public void findStaticOverlayPackages() {
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayIsStatic) {
                        if (this.mOverlayPackages == null) {
                            this.mOverlayPackages = new ArrayList();
                        }
                        this.mOverlayPackages.add(p);
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.PackageParserCallback
        public synchronized String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] strArr;
            if (this.mOverlayPackages == null) {
                strArr = null;
            } else {
                strArr = getStaticOverlayPaths(getStaticOverlayPackages(this.mOverlayPackages, targetPackageName), targetPath);
            }
            return strArr;
        }
    }

    /* access modifiers changed from: private */
    public static class IFVerificationParams {
        PackageParser.Package pkg;
        boolean replacing;
        int userId;
        int verifierUid;

        public IFVerificationParams(PackageParser.Package _pkg, boolean _replacing, int _userId, int _verifierUid) {
            this.pkg = _pkg;
            this.replacing = _replacing;
            this.userId = _userId;
            this.verifierUid = _verifierUid;
        }
    }

    private class IntentVerifierProxy implements IntentFilterVerifier<PackageParser.ActivityIntentInfo> {
        private Context mContext;
        private ArrayList<Integer> mCurrentIntentFilterVerifications = new ArrayList<>();
        private ComponentName mIntentFilterVerifierComponent;

        public IntentVerifierProxy(Context context, ComponentName verifierComponent) {
            this.mContext = context;
            this.mIntentFilterVerifierComponent = verifierComponent;
        }

        private String getDefaultScheme() {
            return "https";
        }

        @Override // com.android.server.pm.PackageManagerService.IntentFilterVerifier
        public void startVerifications(int userId) {
            int count = this.mCurrentIntentFilterVerifications.size();
            for (int n = 0; n < count; n++) {
                int verificationId = this.mCurrentIntentFilterVerifications.get(n).intValue();
                IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
                String packageName = ivs.getPackageName();
                ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
                int filterCount = filters.size();
                ArraySet<String> domainsSet = new ArraySet<>();
                for (int m = 0; m < filterCount; m++) {
                    domainsSet.addAll(filters.get(m).getHostsList());
                }
                synchronized (PackageManagerService.this.mPackages) {
                    if (PackageManagerService.this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domainsSet) != null) {
                        PackageManagerService.this.scheduleWriteSettingsLocked();
                    }
                }
                sendVerificationRequest(verificationId, ivs);
            }
            this.mCurrentIntentFilterVerifications.clear();
        }

        private void sendVerificationRequest(int verificationId, IntentFilterVerificationState ivs) {
            Intent verificationIntent = new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION");
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_ID", verificationId);
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_URI_SCHEME", getDefaultScheme());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_HOSTS", ivs.getHostsString());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_PACKAGE_NAME", ivs.getPackageName());
            verificationIntent.setComponent(this.mIntentFilterVerifierComponent);
            verificationIntent.addFlags(268435456);
            long whitelistTimeout = PackageManagerService.this.getVerificationTimeout();
            BroadcastOptions options = BroadcastOptions.makeBasic();
            options.setTemporaryAppWhitelistDuration(whitelistTimeout);
            PackageManagerService.this.getDeviceIdleController().addPowerSaveTempWhitelistApp(Process.myUid(), this.mIntentFilterVerifierComponent.getPackageName(), whitelistTimeout, 0, true, "intent filter verifier");
            this.mContext.sendBroadcastAsUser(verificationIntent, UserHandle.SYSTEM, null, options.toBundle());
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Sending IntentFilter verification broadcast");
            }
        }

        @Override // com.android.server.pm.PackageManagerService.IntentFilterVerifier
        public void receiveVerificationResponse(int verificationId) {
            IntentFilterVerificationInfo ivi;
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            boolean verified = ivs.isVerified();
            ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
            int count = filters.size();
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.i(PackageManagerService.TAG, "Received verification response " + verificationId + " for " + count + " filters, verified=" + verified);
            }
            for (int n = 0; n < count; n++) {
                PackageParser.ActivityIntentInfo filter = filters.get(n);
                filter.setVerified(verified);
                if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                    Slog.d(PackageManagerService.TAG, "IntentFilter " + filter.toString() + " verified with result:" + verified + " and hosts:" + ivs.getHostsString());
                }
            }
            PackageManagerService.this.mIntentFilterVerificationStates.remove(verificationId);
            String packageName = ivs.getPackageName();
            synchronized (PackageManagerService.this.mPackages) {
                ivi = PackageManagerService.this.mSettings.getIntentFilterVerificationLPr(packageName);
            }
            if (ivi == null) {
                Slog.w(PackageManagerService.TAG, "IntentFilterVerificationInfo not found for verificationId:" + verificationId + " packageName:" + packageName);
                return;
            }
            synchronized (PackageManagerService.this.mPackages) {
                if (verified) {
                    ivi.setStatus(2);
                } else {
                    ivi.setStatus(1);
                }
                PackageManagerService.this.scheduleWriteSettingsLocked();
                int userId = ivs.getUserId();
                if (userId != -1) {
                    int userStatus = PackageManagerService.this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                    int updatedStatus = 0;
                    boolean needUpdate = false;
                    if (userStatus == 0) {
                        if (verified) {
                            updatedStatus = 2;
                        }
                        needUpdate = true;
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Applying update; old=" + userStatus + " new=" + updatedStatus);
                        }
                    } else if (userStatus != 1) {
                        if (userStatus == 2) {
                            if (!verified) {
                                if (!SystemConfig.getInstance().getLinkedApps().contains(packageName)) {
                                    needUpdate = true;
                                    if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                        Slog.d(PackageManagerService.TAG, "Formerly validated but now failing; demoting");
                                    }
                                } else if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                    Slog.d(PackageManagerService.TAG, "Updating bundled package " + packageName + " failed autoVerify, but sysconfig supersedes");
                                }
                            }
                        }
                    } else if (verified) {
                        updatedStatus = 2;
                        needUpdate = true;
                    }
                    if (needUpdate) {
                        PackageManagerService.this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, updatedStatus, userId);
                        PackageManagerService.this.scheduleWritePackageRestrictionsLocked(userId);
                    }
                } else {
                    Slog.i(PackageManagerService.TAG, "autoVerify ignored when installing for all users");
                }
            }
        }

        public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, PackageParser.ActivityIntentInfo filter, String packageName) {
            if (!PackageManagerService.hasValidDomains(filter)) {
                return false;
            }
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            if (ivs == null) {
                ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
            }
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Adding verification filter for " + packageName + ": " + filter);
            }
            ivs.addFilter(filter);
            return true;
        }

        private IntentFilterVerificationState createDomainVerificationState(int verifierUid, int userId, int verificationId, String packageName) {
            IntentFilterVerificationState ivs = new IntentFilterVerificationState(verifierUid, userId, packageName);
            ivs.setPendingState();
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIntentFilterVerificationStates.append(verificationId, ivs);
                this.mCurrentIntentFilterVerifications.add(Integer.valueOf(verificationId));
            }
            return ivs;
        }
    }

    /* access modifiers changed from: private */
    public static boolean hasValidDomains(PackageParser.ActivityIntentInfo filter) {
        return filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"));
    }

    /* access modifiers changed from: package-private */
    public static class PendingPackageBroadcasts {
        final SparseArray<ArrayMap<String, ArrayList<String>>> mUidMap = new SparseArray<>(2);

        public ArrayList<String> get(int userId, String packageName) {
            return getOrAllocate(userId).get(packageName);
        }

        public void put(int userId, String packageName, ArrayList<String> components) {
            getOrAllocate(userId).put(packageName, components);
        }

        public void remove(int userId, String packageName) {
            ArrayMap<String, ArrayList<String>> packages = this.mUidMap.get(userId);
            if (packages != null) {
                packages.remove(packageName);
            }
        }

        public void remove(int userId) {
            this.mUidMap.remove(userId);
        }

        public int userIdCount() {
            return this.mUidMap.size();
        }

        public int userIdAt(int n) {
            return this.mUidMap.keyAt(n);
        }

        public ArrayMap<String, ArrayList<String>> packagesForUserId(int userId) {
            return this.mUidMap.get(userId);
        }

        public int size() {
            int num = 0;
            for (int i = 0; i < this.mUidMap.size(); i++) {
                num += this.mUidMap.valueAt(i).size();
            }
            return num;
        }

        public void clear() {
            this.mUidMap.clear();
        }

        private ArrayMap<String, ArrayList<String>> getOrAllocate(int userId) {
            ArrayMap<String, ArrayList<String>> map = this.mUidMap.get(userId);
            if (map != null) {
                return map;
            }
            ArrayMap<String, ArrayList<String>> map2 = new ArrayMap<>();
            this.mUidMap.put(userId, map2);
            return map2;
        }
    }

    /* access modifiers changed from: package-private */
    public static class PostInstallData {
        public final InstallArgs args;
        public final Runnable mPostInstallRunnable;
        public final PackageInstalledInfo res;

        PostInstallData(InstallArgs _a, PackageInstalledInfo _r, Runnable postInstallRunnable) {
            this.args = _a;
            this.res = _r;
            this.mPostInstallRunnable = postInstallRunnable;
        }
    }

    /* access modifiers changed from: package-private */
    public class PackageHandler extends Handler {
        PackageHandler(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            try {
                doHandleMessage(msg);
            } finally {
                Process.setThreadPriority(10);
            }
        }

        /* JADX INFO: Multiple debug info for r0v59 int: [D('verificationId' int), D('params' com.android.server.pm.PackageManagerService$IFVerificationParams)] */
        /* access modifiers changed from: package-private */
        /* JADX WARNING: Code restructure failed: missing block: B:203:0x06ac, code lost:
            r3 = 0;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:204:0x06ad, code lost:
            if (r3 >= r10) goto L_0x06bd;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:205:0x06af, code lost:
            r29.this$0.sendPackageChangedBroadcast(r0[r3], true, r8[r3], r9[r3]);
            r3 = r3 + 1;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:206:0x06bd, code lost:
            android.os.Process.setThreadPriority(10);
         */
        /* JADX WARNING: Code restructure failed: missing block: B:220:?, code lost:
            return;
         */
        public void doHandleMessage(Message msg) {
            int i;
            ArrayList whitelistedRestrictedPermissions;
            int i2 = msg.what;
            int userId = 0;
            if (i2 == 1) {
                Process.setThreadPriority(0);
                synchronized (PackageManagerService.this.mPackages) {
                    int size = PackageManagerService.this.mPendingBroadcasts.size();
                    if (size > 0) {
                        String[] packages = new String[size];
                        ArrayList<String>[] components = new ArrayList[size];
                        int[] uids = new int[size];
                        int i3 = 0;
                        for (int n = 0; n < PackageManagerService.this.mPendingBroadcasts.userIdCount(); n++) {
                            int packageUserId = PackageManagerService.this.mPendingBroadcasts.userIdAt(n);
                            Iterator<Map.Entry<String, ArrayList<String>>> it = PackageManagerService.this.mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                            while (it.hasNext() && i3 < size) {
                                Map.Entry<String, ArrayList<String>> ent = it.next();
                                packages[i3] = ent.getKey();
                                components[i3] = ent.getValue();
                                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(ent.getKey());
                                if (ps != null) {
                                    i = UserHandle.getUid(packageUserId, ps.appId);
                                } else {
                                    i = -1;
                                }
                                uids[i3] = i;
                                i3++;
                            }
                        }
                        PackageManagerService.this.mPendingBroadcasts.clear();
                    }
                }
            } else if (i2 == 5) {
                HandlerParams params = (HandlerParams) msg.obj;
                if (params != null) {
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "init_copy: " + params);
                    }
                    Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params));
                    Trace.traceBegin(262144, "startCopy");
                    params.startCopy();
                    Trace.traceEnd(262144);
                }
            } else if (i2 != 9) {
                switch (i2) {
                    case 13:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(13);
                            removeMessages(14);
                            PackageManagerService.this.mSettings.writeLPr();
                            PackageManagerService.this.mDirtyUsers.clear();
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 14:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(14);
                            Iterator it2 = PackageManagerService.this.mDirtyUsers.iterator();
                            while (it2.hasNext()) {
                                PackageManagerService.this.mSettings.writePackageRestrictionsLPr(((Integer) it2.next()).intValue());
                            }
                            PackageManagerService.this.mDirtyUsers.clear();
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 15:
                        int verificationId = msg.arg1;
                        PackageVerificationState state = PackageManagerService.this.mPendingVerification.get(verificationId);
                        if (state == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid verification token " + verificationId + " received");
                            return;
                        }
                        PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                        state.setVerifierResponse(response.callerUid, response.code);
                        if (state.isVerificationComplete()) {
                            PackageManagerService.this.mPendingVerification.remove(verificationId);
                            InstallParams params2 = state.getInstallParams();
                            InstallArgs args = params2.mArgs;
                            Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                            if (state.isInstallAllowed()) {
                                PackageManagerService.this.broadcastPackageVerified(verificationId, originUri, response.code, args.getUser());
                            } else {
                                params2.setReturnCode(-22);
                                if (params2.getUser() != null) {
                                    userId = params2.getUser().getIdentifier();
                                }
                                OppoFeatureCache.get(IColorAppInstallProgressManager.DEFAULT).sendFailBroInInstallFinishStage(params2.mRet, args.installArgsEx.packageName, params2.installerPackageName, userId);
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId);
                            params2.handleVerificationFinished();
                            return;
                        }
                        return;
                    case 16:
                        int verificationId2 = msg.arg1;
                        PackageVerificationState state2 = PackageManagerService.this.mPendingVerification.get(verificationId2);
                        if (!(state2 == null || state2.timeoutExtended())) {
                            InstallParams params3 = state2.getInstallParams();
                            InstallArgs args2 = params3.mArgs;
                            Uri originUri2 = Uri.fromFile(args2.origin.resolvedFile);
                            Slog.i(PackageManagerService.TAG, "Verification timed out for " + originUri2);
                            PackageManagerService.this.mPendingVerification.remove(verificationId2);
                            UserHandle user = args2.getUser();
                            if (PackageManagerService.this.getDefaultVerificationResponse(user) == 1) {
                                Slog.i(PackageManagerService.TAG, "Continuing with installation of " + originUri2);
                                state2.setVerifierResponse(Binder.getCallingUid(), 2);
                                PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, 1, user);
                            } else {
                                PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, -1, user);
                                params3.setReturnCode(-22);
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId2);
                            params3.handleVerificationFinished();
                            return;
                        }
                        return;
                    case 17:
                        IFVerificationParams params4 = (IFVerificationParams) msg.obj;
                        PackageManagerService.this.verifyIntentFiltersIfNeeded(params4.userId, params4.verifierUid, params4.replacing, params4.pkg);
                        return;
                    case 18:
                        int verificationId3 = msg.arg1;
                        IntentFilterVerificationState state3 = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId3);
                        if (state3 == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid IntentFilter verification token " + verificationId3 + " received");
                            return;
                        }
                        int userId2 = state3.getUserId();
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Processing IntentFilter verification with token:" + verificationId3 + " and userId:" + userId2);
                        }
                        IntentFilterVerificationResponse response2 = (IntentFilterVerificationResponse) msg.obj;
                        state3.setVerifierResponse(response2.callerUid, response2.code);
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " and userId:" + userId2 + " is settings verifier response with response code:" + response2.code);
                        }
                        if (response2.code == -1 && PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Domains failing verification: " + response2.getFailedDomainsString());
                        }
                        if (state3.isVerificationComplete()) {
                            PackageManagerService.this.mIntentFilterVerifier.receiveVerificationResponse(verificationId3);
                            return;
                        } else if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " was not said to be complete");
                            return;
                        } else {
                            return;
                        }
                    case 19:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(19);
                            PackageManagerService.this.mSettings.writePackageListLPr(msg.arg1);
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 20:
                        InstantAppResolver.doInstantAppResolutionPhaseTwo(PackageManagerService.this.mContext, PackageManagerService.this.mInstantAppResolverConnection, (InstantAppRequest) msg.obj, PackageManagerService.this.mInstantAppInstallerActivity, PackageManagerService.this.mHandler);
                        return;
                    case 21:
                        int enableRollbackToken = msg.arg1;
                        int enableRollbackCode = msg.arg2;
                        InstallParams params5 = PackageManagerService.this.mPendingEnableRollback.get(enableRollbackToken);
                        if (params5 == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid rollback enabled token " + enableRollbackToken + " received");
                            return;
                        }
                        PackageManagerService.this.mPendingEnableRollback.remove(enableRollbackToken);
                        if (enableRollbackCode != 1) {
                            Uri originUri3 = Uri.fromFile(params5.mArgs.origin.resolvedFile);
                            Slog.w(PackageManagerService.TAG, "Failed to enable rollback for " + originUri3);
                            Slog.w(PackageManagerService.TAG, "Continuing with installation of " + originUri3);
                        }
                        Trace.asyncTraceEnd(262144, "enable_rollback", enableRollbackToken);
                        params5.handleRollbackEnabled();
                        return;
                    case 22:
                        int enableRollbackToken2 = msg.arg1;
                        InstallParams params6 = PackageManagerService.this.mPendingEnableRollback.get(enableRollbackToken2);
                        if (params6 != null) {
                            Uri originUri4 = Uri.fromFile(params6.mArgs.origin.resolvedFile);
                            Slog.w(PackageManagerService.TAG, "Enable rollback timed out for " + originUri4);
                            PackageManagerService.this.mPendingEnableRollback.remove(enableRollbackToken2);
                            Slog.w(PackageManagerService.TAG, "Continuing with installation of " + originUri4);
                            Trace.asyncTraceEnd(262144, "enable_rollback", enableRollbackToken2);
                            params6.handleRollbackEnabled();
                            Intent rollbackTimeoutIntent = new Intent("android.intent.action.CANCEL_ENABLE_ROLLBACK");
                            rollbackTimeoutIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_TOKEN", enableRollbackToken2);
                            rollbackTimeoutIntent.addFlags(67108864);
                            PackageManagerService.this.mContext.sendBroadcastAsUser(rollbackTimeoutIntent, UserHandle.SYSTEM, "android.permission.PACKAGE_ROLLBACK_AGENT");
                            return;
                        }
                        return;
                    case 23:
                        synchronized (PackageManagerService.this.mInstallLock) {
                            InstallArgs args3 = (InstallArgs) msg.obj;
                            if (args3 != null) {
                                args3.doPostDeleteLI(true);
                            }
                        }
                        return;
                    case 24:
                        String packageName = (String) msg.obj;
                        if (packageName != null) {
                            PackageManagerService.this.notifyInstallObserver(packageName);
                            return;
                        }
                        return;
                    default:
                        PackageManagerService.this.handleOppoMessage(msg, 1);
                        return;
                }
            } else {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Log.v(PackageManagerService.TAG, "Handling post-install for " + msg.arg1);
                }
                PostInstallData data = PackageManagerService.this.mRunningInstalls.get(msg.arg1);
                boolean didRestore = msg.arg2 != 0;
                PackageManagerService.this.mRunningInstalls.delete(msg.arg1);
                if (data != null && data.mPostInstallRunnable != null) {
                    data.mPostInstallRunnable.run();
                } else if (data != null) {
                    InstallArgs args4 = data.args;
                    PackageInstalledInfo parentRes = data.res;
                    boolean grantPermissions = (args4.installFlags & 256) != 0;
                    boolean killApp = (args4.installFlags & 4096) == 0;
                    boolean virtualPreload = (args4.installFlags & 65536) != 0;
                    String[] grantedPermissions = args4.installGrantPermissions;
                    if ((args4.installFlags & DumpState.DUMP_CHANGES) == 0 || parentRes.pkg == null) {
                        whitelistedRestrictedPermissions = args4.whitelistedRestrictedPermissions;
                    } else {
                        whitelistedRestrictedPermissions = parentRes.pkg.requestedPermissions;
                    }
                    PackageManagerService.this.handlePackagePostInstall(parentRes, grantPermissions, killApp, virtualPreload, grantedPermissions, whitelistedRestrictedPermissions, didRestore, args4.installerPackageName, args4.observer);
                    try {
                        if (parentRes.returnCode < 0) {
                            Slog.v(PackageManagerService.TAG, "install fail");
                            StringBuilder log = new StringBuilder(512);
                            log.append(args4.origin == null ? "origin:null\r\n" : "origin:" + args4.origin.file + "\r\n");
                            log.append("apk install fail ");
                            log.append("apk name = ");
                            log.append(parentRes.name);
                            log.append(" returnCode = ");
                            log.append(parentRes.returnCode);
                            log.append(" returnMsg = ");
                            log.append(parentRes.returnMsg);
                            if (parentRes.pkg != null) {
                                log.append(" package = ");
                                log.append(parentRes.pkg.packageName);
                                log.append(" versionCode = ");
                                log.append(parentRes.pkg.mVersionCode);
                                log.append(" versionName = ");
                                log.append(parentRes.pkg.mVersionName);
                            }
                            OppoManager.writeLogToPartition(OppoManager.TYPE_ANDROID_INSTALL_FAILD, log.toString(), "ANDROID", "install_fail", PackageManagerService.this.mContext.getString(201653522));
                            Slog.v(PackageManagerService.TAG, "record end");
                        }
                    } catch (Exception e) {
                        Slog.v(PackageManagerService.TAG, "record install fail event e = " + e.toString());
                    }
                    int childCount = parentRes.addedChildPackages != null ? parentRes.addedChildPackages.size() : 0;
                    if (parentRes.returnCode == 1) {
                        OppoFeatureCache.get(IColorPackageInstallStatisticManager.DEFAULT).sendNonSilentInstallBroadcastExp(args4.installerPackageName, args4.origin, parentRes, childCount, -1);
                    }
                    for (int i4 = 0; i4 < childCount; i4++) {
                        PackageInstalledInfo childRes = parentRes.addedChildPackages.valueAt(i4);
                        PackageManagerService.this.handlePackagePostInstall(childRes, grantPermissions, killApp, virtualPreload, grantedPermissions, whitelistedRestrictedPermissions, false, args4.installerPackageName, args4.observer);
                        if (childRes.returnCode == 1) {
                            OppoFeatureCache.get(IColorPackageInstallStatisticManager.DEFAULT).sendNonSilentInstallBroadcastExp(args4.installerPackageName, args4.origin, childRes, childCount, i4);
                        }
                    }
                    if (args4.traceMethod != null) {
                        Trace.asyncTraceEnd(262144, args4.traceMethod, args4.traceCookie);
                    }
                } else if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "Nothing to do for post-install token " + msg.arg1);
                }
                Trace.asyncTraceEnd(262144, "postInstall", msg.arg1);
            }
        }
    }

    /* JADX INFO: Multiple debug info for r15v6 'installerPackageName'  java.lang.String: [D('isSystem' boolean), D('installerPackageName' java.lang.String)] */
    /* JADX INFO: Multiple debug info for r6v17 int: [D('newUser' int), D('installerPackageName' java.lang.String)] */
    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x043d, code lost:
        r0 = th;
     */
    private void handlePackagePostInstall(final PackageInstalledInfo res, boolean grantPermissions, boolean killApp, boolean virtualPreload, String[] grantedPermissions, List<String> whitelistedRestrictedPermissions, boolean launchedForRestore, String installerPackage, IPackageInstallObserver2 installObserver) {
        boolean update;
        boolean z;
        boolean deferInstallObserver;
        String str;
        int[] updateUserIds;
        final String installerPackageName;
        int[] firstUserIds;
        String packageName;
        int packageExternalStorageType;
        int i;
        int[] iArr;
        PackageSetting ps;
        boolean succeeded = res.returnCode == 1;
        boolean update2 = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
        if (succeeded) {
            if (res.removedInfo != null) {
                res.removedInfo.sendPackageRemovedBroadcasts(killApp);
            }
            if (whitelistedRestrictedPermissions != null && !whitelistedRestrictedPermissions.isEmpty()) {
                this.mPermissionManager.setWhitelistedRestrictedPermissions(res.pkg, res.newUsers, whitelistedRestrictedPermissions, Process.myUid(), 2, this.mPermissionCallback);
            }
            if (grantPermissions) {
                this.mPermissionManager.grantRequestedRuntimePermissions(res.pkg, res.newUsers, grantedPermissions, Binder.getCallingUid(), this.mPermissionCallback);
            }
            if (res.installerPackageName != null) {
                str = res.installerPackageName;
            } else if (res.removedInfo != null) {
                str = res.removedInfo.installerPackageName;
            } else {
                str = null;
            }
            String installerPackageName2 = str;
            grantCtaRuntimePerm(update2, res);
            if (res.pkg.parentPackage != null) {
                this.mPermissionManager.grantRuntimePermissionsGrantedToDisabledPackage(res.pkg, Binder.getCallingUid(), this.mPermissionCallback);
            }
            synchronized (this.mPackages) {
                this.mInstantAppRegistry.onPackageInstalledLPw(res.pkg, res.newUsers);
            }
            String packageName2 = res.pkg.applicationInfo.packageName;
            int[] firstUserIds2 = EMPTY_INT_ARRAY;
            int[] firstInstantUserIds = EMPTY_INT_ARRAY;
            int[] updateUserIds2 = EMPTY_INT_ARRAY;
            int[] instantUserIds = EMPTY_INT_ARRAY;
            boolean allNewUsers = res.origUsers == null || res.origUsers.length == 0;
            PackageSetting ps2 = (PackageSetting) res.pkg.mExtras;
            int[] iArr2 = res.newUsers;
            int length = iArr2.length;
            int[] instantUserIds2 = instantUserIds;
            int[] firstUserIds3 = firstUserIds2;
            int i2 = 0;
            int[] firstInstantUserIds2 = firstInstantUserIds;
            int[] updateUserIds3 = updateUserIds2;
            while (i2 < length) {
                int newUser = iArr2[i2];
                boolean isInstantApp = ps2.getInstantApp(newUser);
                if (!allNewUsers) {
                    boolean isNew = true;
                    ps = ps2;
                    int[] iArr3 = res.origUsers;
                    iArr = iArr2;
                    int length2 = iArr3.length;
                    i = length;
                    int i3 = 0;
                    while (true) {
                        if (i3 >= length2) {
                            break;
                        } else if (iArr3[i3] == newUser) {
                            isNew = false;
                            break;
                        } else {
                            i3++;
                            length2 = length2;
                        }
                    }
                    if (isNew) {
                        if (isInstantApp) {
                            firstInstantUserIds2 = ArrayUtils.appendInt(firstInstantUserIds2, newUser);
                        } else {
                            firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                        }
                    } else if (isInstantApp) {
                        instantUserIds2 = ArrayUtils.appendInt(instantUserIds2, newUser);
                    } else {
                        updateUserIds3 = ArrayUtils.appendInt(updateUserIds3, newUser);
                    }
                } else if (isInstantApp) {
                    firstInstantUserIds2 = ArrayUtils.appendInt(firstInstantUserIds2, newUser);
                    ps = ps2;
                    iArr = iArr2;
                    i = length;
                } else {
                    firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                    ps = ps2;
                    iArr = iArr2;
                    i = length;
                }
                i2++;
                installerPackageName2 = installerPackageName2;
                ps2 = ps;
                iArr2 = iArr;
                length = i;
            }
            if (res.pkg.staticSharedLibName == null) {
                this.mProcessLoggingHandler.invalidateProcessLoggingBaseApkHash(res.pkg.baseCodePath);
                installerPackageName = installerPackageName2;
                updateUserIds = updateUserIds3;
                sendPackageAddedForNewUsers(packageName2, res.pkg.applicationInfo.isSystemApp() || virtualPreload, virtualPreload, UserHandle.getAppId(res.uid), firstUserIds3, firstInstantUserIds2);
                Bundle extras = new Bundle(1);
                extras.putInt("android.intent.extra.UID", res.uid);
                if (update2) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName2, extras, 0, null, null, updateUserIds, instantUserIds2);
                OppoFeatureCache.get(IColorFullmodeManager.DEFAULT).trySetClosedSuperFirewall(res.pkg);
                PowerHalManager powerHalManager = this.mPowerHalManager;
                if (powerHalManager != null) {
                    powerHalManager.setInstallationBoost(false);
                }
                if (installerPackage != null) {
                    OppoFeatureCache.get(IColorPackageInstallStatisticManager.DEFAULT).sendDcsSilentInstallBroadcast(res.pkg.applicationInfo.packageName, extras, installerPackage, 0);
                }
                if (installerPackageName != null) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName2, extras, 0, installerPackageName, null, updateUserIds, instantUserIds2);
                }
                String str2 = this.mRequiredVerifierPackage;
                boolean notifyVerifier = str2 != null && !str2.equals(installerPackageName);
                if (notifyVerifier) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName2, extras, 0, this.mRequiredVerifierPackage, null, updateUserIds, instantUserIds2);
                }
                String str3 = this.mRequiredInstallerPackage;
                if (str3 != null) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName2, extras, DumpState.DUMP_SERVICE_PERMISSIONS, str3, null, firstUserIds3, instantUserIds2);
                }
                if (update2) {
                    update = update2;
                    sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName2, extras, 0, null, null, updateUserIds, instantUserIds2);
                    if (installerPackageName != null) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName2, extras, 0, installerPackageName, null, updateUserIds, instantUserIds2);
                    }
                    if (notifyVerifier) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName2, extras, 0, this.mRequiredVerifierPackage, null, updateUserIds, instantUserIds2);
                    }
                    sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, packageName2, null, updateUserIds, instantUserIds2);
                    firstUserIds = firstUserIds3;
                    packageName = packageName2;
                } else {
                    update = update2;
                    if (!launchedForRestore || isSystemApp(res.pkg)) {
                        firstUserIds = firstUserIds3;
                        packageName = packageName2;
                    } else {
                        if (DEBUG_BACKUP) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Post-restore of ");
                            packageName = packageName2;
                            sb.append(packageName);
                            sb.append(" sending FIRST_LAUNCH in ");
                            sb.append(Arrays.toString(firstUserIds3));
                            Slog.i(TAG, sb.toString());
                        } else {
                            packageName = packageName2;
                        }
                        firstUserIds = firstUserIds3;
                        sendFirstLaunchBroadcast(packageName, installerPackage, firstUserIds, firstInstantUserIds2);
                    }
                }
                if (isExternal(res.pkg)) {
                    if (!update && (packageExternalStorageType = getPackageExternalStorageType(((StorageManager) this.mContext.getSystemService(StorageManager.class)).findVolumeByUuid(res.pkg.applicationInfo.storageUuid.toString()), isExternal(res.pkg))) != 0) {
                        StatsLog.write(181, packageExternalStorageType, res.pkg.packageName);
                    }
                    if (DEBUG_INSTALL) {
                        Slog.i(TAG, "upgrading pkg " + res.pkg + " is external");
                    }
                    int[] uidArray = {res.pkg.applicationInfo.uid};
                    ArrayList<String> pkgList = new ArrayList<>(1);
                    pkgList.add(packageName);
                    sendResourcesChangedBroadcast(true, true, pkgList, uidArray, (IIntentReceiver) null);
                }
            } else {
                updateUserIds = updateUserIds3;
                packageName = packageName2;
                update = update2;
                installerPackageName = installerPackageName2;
                firstUserIds = firstUserIds3;
                if (!ArrayUtils.isEmpty(res.libraryConsumers)) {
                    for (int i4 = 0; i4 < res.libraryConsumers.size(); i4++) {
                        PackageParser.Package pkg = res.libraryConsumers.get(i4);
                        sendPackageChangedBroadcast(pkg.packageName, false, new ArrayList<>(Collections.singletonList(pkg.packageName)), pkg.applicationInfo.uid);
                    }
                }
            }
            if (firstUserIds != null && firstUserIds.length > 0) {
                for (int userId : firstUserIds) {
                    if (packageIsBrowser(packageName, userId)) {
                        synchronized (this.mPackages) {
                            if (this.mSettings.mPackages.get(packageName).getInstallReason(userId) != 2) {
                                setDefaultBrowserAsyncLPw(null, userId);
                            }
                        }
                    }
                    this.mPermissionManager.restoreDelayedRuntimePermissions(packageName, UserHandle.of(userId));
                    updateDefaultHomeNotLocked(userId);
                }
            }
            if (!allNewUsers || update) {
                notifyPackageChanged(packageName, res.uid);
            } else {
                notifyPackageAdded(packageName, res.uid);
            }
            EventLog.writeEvent((int) EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
            InstallArgs args = res.removedInfo != null ? res.removedInfo.args : null;
            if (args == null) {
                VMRuntime.getRuntime().requestConcurrentGC();
            } else if (!killApp) {
                scheduleDeferredNoKillPostDelete(args);
            } else {
                synchronized (this.mInstallLock) {
                    args.doPostDeleteLI(true);
                }
            }
            for (int userId2 : firstUserIds) {
                PackageInfo info = getPackageInfo(packageName, 0, userId2);
                if (info != null) {
                    this.mDexManager.notifyPackageInstalled(info, userId2);
                }
            }
            deferInstallObserver = false;
            OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).setApplicationEnabledSetting(update, updateUserIds, packageName);
            z = true;
            OppoFeatureCache.get(IColorRemovableAppManager.DEFAULT).changePackageInstalledState(null, packageName, true);
            if (update && !isSystemApp(res.pkg)) {
                OppoFeatureCache.get(IColorPkgStartInfoManager.DEFAULT).addPkgToNotLaunchedList(packageName);
            }
            if (!(installerPackageName == null || res.pkg == null)) {
                this.mHandler.post(new Runnable() {
                    /* class com.android.server.pm.PackageManagerService.AnonymousClass2 */

                    public void run() {
                        PackageManagerService packageManagerService = PackageManagerService.this;
                        packageManagerService.uploadInstallAppInfos(packageManagerService.mContext, res.pkg, installerPackageName);
                    }
                });
            }
        } else {
            update = update2;
            z = true;
            deferInstallObserver = false;
        }
        if (succeeded && update && !killApp) {
            deferInstallObserver = z;
        }
        if (deferInstallObserver) {
            scheduleDeferredNoKillInstallObserver(res, installObserver);
            return;
        } else {
            notifyInstallObserver(res, installObserver);
            return;
        }
        while (true) {
        }
    }

    public void notifyPackagesReplacedReceived(String[] packages) {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        for (String packageName : packages) {
            PackageSetting setting = this.mSettings.mPackages.get(packageName);
            if (setting != null && filterAppAccessLPr(setting, callingUid, callingUserId)) {
                notifyInstallObserver(packageName);
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void notifyInstallObserver(String packageName) {
        Pair<PackageInstalledInfo, IPackageInstallObserver2> pair = this.mNoKillInstallObservers.remove(packageName);
        if (pair != null) {
            notifyInstallObserver((PackageInstalledInfo) pair.first, (IPackageInstallObserver2) pair.second);
        }
    }

    private void notifyInstallObserver(PackageInstalledInfo info, IPackageInstallObserver2 installObserver) {
        if (installObserver != null) {
            try {
                installObserver.onPackageInstalled(info.name, info.returnCode, info.returnMsg, extrasForInstallResult(info));
            } catch (RemoteException e) {
                Slog.i(TAG, "Observer no longer exists.");
            }
        }
        OppoFeatureCache.get(IColorPackageInstallInterceptManager.DEFAULT).handleForAdbSessionInstallerObserver(info.name, info.returnCode);
        OppoFeatureCache.get(IColorAppInstallProgressManager.DEFAULT).sendFailBroInInstallFinishStage(info.returnCode, info.name, info.installerPackageName, 0);
    }

    private void scheduleDeferredNoKillPostDelete(InstallArgs args) {
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(23, args), BackupAgentTimeoutParameters.DEFAULT_QUOTA_EXCEEDED_TIMEOUT_MILLIS);
    }

    private void scheduleDeferredNoKillInstallObserver(PackageInstalledInfo info, IPackageInstallObserver2 observer) {
        String packageName = info.pkg.packageName;
        this.mNoKillInstallObservers.put(packageName, Pair.create(info, observer));
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(24, packageName), 500);
    }

    private static int getPackageExternalStorageType(VolumeInfo packageVolume, boolean packageIsExternal) {
        DiskInfo disk;
        if (packageVolume == null || (disk = packageVolume.getDisk()) == null) {
            return 0;
        }
        if (disk.isSd()) {
            return 1;
        }
        if (disk.isUsb()) {
            return 2;
        }
        if (packageIsExternal) {
            return 3;
        }
        return 0;
    }

    /* access modifiers changed from: package-private */
    public Bundle extrasForInstallResult(PackageInstalledInfo res) {
        int i = res.returnCode;
        if (i != -112) {
            boolean z = true;
            if (i != 1) {
                return null;
            }
            Bundle extras = new Bundle();
            if (res.removedInfo == null || res.removedInfo.removedPackage == null) {
                z = false;
            }
            extras.putBoolean("android.intent.extra.REPLACING", z);
            return extras;
        }
        Bundle extras2 = new Bundle();
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PERMISSION", res.origPermission);
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PACKAGE", res.origPackage);
        return extras2;
    }

    public void scheduleWriteSettingsLocked() {
        if (!this.mHandler.hasMessages(13)) {
            this.mHandler.sendEmptyMessageDelayed(13, 10000);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageListLocked(int userId) {
        if (!this.mHandler.hasMessages(19)) {
            Message msg = this.mHandler.obtainMessage(19);
            msg.arg1 = userId;
            this.mHandler.sendMessageDelayed(msg, 10000);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(UserHandle user) {
        scheduleWritePackageRestrictionsLocked(user == null ? -1 : user.getIdentifier());
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(int userId) {
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (sUserManager.exists(nextUserId)) {
                this.mDirtyUsers.add(Integer.valueOf(nextUserId));
                if (!this.mHandler.hasMessages(14)) {
                    this.mHandler.sendEmptyMessageDelayed(14, 10000);
                }
            } else {
                return;
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void immediatelyWritePackageRestrictionsLocked(int userId) {
        if (sUserManager.exists(userId)) {
            this.mDirtyUsers.add(Integer.valueOf(userId));
            if (this.mHandler.hasMessages(14)) {
                this.mHandler.removeMessages(14);
            }
            this.mHandler.sendEmptyMessage(14);
        }
    }

    /* JADX WARN: Type inference failed for: r0v1, types: [com.android.server.pm.PackageManagerService, java.lang.Object, android.os.IBinder] */
    /* JADX WARN: Type inference failed for: r2v1, types: [com.android.server.pm.PackageManagerService$PackageManagerNative, android.os.IBinder] */
    /* JADX WARN: Type inference failed for: r0v2 */
    /* JADX WARN: Type inference failed for: r0v3 */
    /* JADX WARNING: Unknown variable types count: 2 */
    public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        ?? r0;
        PackageManagerServiceCompilerMapping.checkProperties();
        PackageManagerService oppoPms = OppoCommonServiceFactory.getPackageManagerService(context, installer, factoryTest, onlyCore);
        if (oppoPms != null) {
            r0 = oppoPms;
        } else {
            r0 = new PackageManagerService(context, installer, factoryTest, onlyCore);
        }
        r0.enableSystemUserPackages();
        ServiceManager.addService("package", (IBinder) r0);
        Objects.requireNonNull(r0);
        ServiceManager.addService("package_native", (IBinder) new PackageManagerNative());
        return r0;
    }

    private void enableSystemUserPackages() {
        if (UserManager.isSplitSystemUser()) {
            AppsQueryHelper queryHelper = new AppsQueryHelper(this);
            Set<String> enableApps = new ArraySet<>();
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_NON_LAUNCHABLE_APPS | AppsQueryHelper.GET_APPS_WITH_INTERACT_ACROSS_USERS_PERM | AppsQueryHelper.GET_IMES, true, UserHandle.SYSTEM));
            enableApps.addAll(SystemConfig.getInstance().getSystemUserWhitelistedApps());
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_REQUIRED_FOR_SYSTEM_USER, false, UserHandle.SYSTEM));
            enableApps.removeAll(SystemConfig.getInstance().getSystemUserBlacklistedApps());
            Log.i(TAG, "Applications installed for system user: " + enableApps);
            List<String> allAps = queryHelper.queryApps(0, false, UserHandle.SYSTEM);
            int allAppsSize = allAps.size();
            synchronized (this.mPackages) {
                for (int i = 0; i < allAppsSize; i++) {
                    String pName = allAps.get(i);
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(pName);
                    if (pkgSetting != null) {
                        boolean install = enableApps.contains(pName);
                        if (pkgSetting.getInstalled(0) != install) {
                            StringBuilder sb = new StringBuilder();
                            sb.append(install ? "Installing " : "Uninstalling ");
                            sb.append(pName);
                            sb.append(" for system user");
                            Log.i(TAG, sb.toString());
                            pkgSetting.setInstalled(install, 0);
                        }
                    }
                }
                scheduleWritePackageRestrictionsLocked(0);
            }
        }
    }

    private static void getDefaultDisplayMetrics(Context context, DisplayMetrics metrics) {
        ((DisplayManager) context.getSystemService("display")).getDisplay(0).getMetrics(metrics);
    }

    private static void requestCopyPreoptedFiles() {
        if (SystemProperties.getInt("ro.cp_system_other_odex", 0) == 1) {
            SystemProperties.set("sys.cppreopt", "requested");
            long timeStart = SystemClock.uptimeMillis();
            long timeEnd = 100000 + timeStart;
            long timeNow = timeStart;
            while (true) {
                if (SystemProperties.get("sys.cppreopt").equals("finished")) {
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
                timeNow = SystemClock.uptimeMillis();
                if (timeNow > timeEnd) {
                    SystemProperties.set("sys.cppreopt", "timed-out");
                    Slog.wtf(TAG, "cppreopt did not finish!");
                    break;
                }
            }
            Slog.i(TAG, "cppreopts took " + (timeNow - timeStart) + " ms");
        }
    }

    private void addFeature(String name, int version) {
        synchronized (this.mAvailableFeatures) {
            FeatureInfo fi = this.mAvailableFeatures.get(name);
            if (fi == null) {
                FeatureInfo fi2 = new FeatureInfo();
                fi2.name = name;
                fi2.version = version;
                this.mAvailableFeatures.put(name, fi2);
            } else {
                fi.version = Math.max(fi.version, version);
            }
        }
    }

    private boolean is_system_app(String packageName) {
        boolean z;
        boolean isSystem = false;
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                if (!isSystemApp(pkgSetting)) {
                    if (!isUpdatedSystemApp(pkgSetting)) {
                        z = false;
                        isSystem = z;
                    }
                }
                z = true;
                isSystem = z;
            }
        }
        return isSystem;
    }

    /* JADX INFO: Multiple debug info for r45v10 'i'  int: [D('i' int), D('rescanFlags' int)] */
    /* JADX INFO: Multiple debug info for r7v32 'oppoProductAppDir'  java.io.File: [D('oppoProductAppDir' java.io.File), D('oppoPrivilegeProductAppDir' java.io.File)] */
    /* JADX WARNING: Code restructure failed: missing block: B:100:0x057e, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x057f, code lost:
        r70.mIsPreNMR1Upgrade = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x0583, code lost:
        if (r70.mIsUpgrade == false) goto L_0x058d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x0589, code lost:
        if (r6.sdkVersion >= 29) goto L_0x058d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x058b, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x058d, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x058e, code lost:
        r70.mIsPreQUpgrade = r0;
        r10 = r6.sdkVersion;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x0594, code lost:
        if (r70.mPromoteSystemApps == false) goto L_0x05ce;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x0596, code lost:
        r0 = r70.mSettings.mPackages.values().iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x05a6, code lost:
        if (r0.hasNext() == false) goto L_0x05c9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x05a8, code lost:
        r9 = r0.next();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x05b2, code lost:
        if (isSystemApp(r9) == false) goto L_0x05c0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x05b4, code lost:
        r25 = r0;
        r26 = r1;
        r70.mExistingSystemPackages.add(r9.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x05c0, code lost:
        r25 = r0;
        r26 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x05c4, code lost:
        r0 = r25;
        r1 = r26;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x05c9, code lost:
        r26 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x05ce, code lost:
        r26 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x05d0, code lost:
        r25 = android.os.Environment.getPackageCacheDirectory();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x05d8, code lost:
        if (isBootFromOTA() == false) goto L_0x05dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x05da, code lost:
        android.os.FileUtils.deleteContents(r25);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x05dd, code lost:
        r70.mCacheDir = preparePackageParserCache();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x05e7, code lost:
        if (r70.mIsUpgrade != false) goto L_0x05f0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x05eb, code lost:
        if (r70.mFirstBoot == false) goto L_0x05ee;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x05ee, code lost:
        r9 = 528;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:0x05f0, code lost:
        r9 = 528 | 8192;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x05f3, code lost:
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.VENDOR_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | 1048576, 0);
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.PRODUCT_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | 2097152, 0);
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.PRODUCT_SERVICES_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | com.android.server.pm.DumpState.DUMP_CHANGES, 0);
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.OPPO_CUSTOM_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | com.android.server.pm.DumpState.DUMP_CHANGES, 0);
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.OPPO_VERSION_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | 2097152, 0);
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.OPPO_PRODUCT_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | 2097152, 0);
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.ODM_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | 8388608, 0);
        scanDirTracedLI(new java.io.File(com.android.server.pm.PackageManagerService.OEM_OVERLAY_DIR), r70.mDefParseFlags | 16, (r9 | 131072) | 524288, 0);
        com.android.server.pm.PackageManagerService.sPmsExt.scanDirLI(9, r70.mDefParseFlags, r9, 0);
        r70.mParallelPackageParserCallback.findStaticOverlayPackages();
        scanDirTracedLI(r8, r70.mDefParseFlags | 16, ((r9 | 1) | 131072) | 262144, 0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x06dd, code lost:
        if (r70.mPackages.containsKey(com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME) == false) goto L_0x15d1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x06df, code lost:
        com.android.server.pm.PackageManagerService.sPmsExt.scanDirLI(10, r70.mDefParseFlags, r9, 0);
        com.android.server.pm.PackageManagerService.sPmsExt.scanDirLI(11, r70.mDefParseFlags, r9, 0);
        r0 = new java.io.File(android.os.Environment.getRootDirectory(), "priv-app");
        r7 = r9;
        r12 = 1;
        scanDirTracedLI(r0, r70.mDefParseFlags | 16, (r9 | 131072) | 262144, 0);
        com.android.server.pm.PackageManagerService.sPmsExt.scanDirLI(12, r70.mDefParseFlags, r7, 0);
        r0 = new java.io.File(android.os.Environment.getRootDirectory(), "app");
        scanDirTracedLI(r0, r70.mDefParseFlags | 16, r7 | 131072, 0);
        r0 = new java.io.File(android.os.Environment.getVendorDirectory(), "priv-app");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x0753, code lost:
        r11 = r0.getCanonicalFile();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x0756, code lost:
        r11 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x022d, code lost:
        r70.mSettings.checkPackageXml(r70);
        r70.mSettings.addSharedUserLPw("android.uid.system", 1000, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.phone", 1001, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.log", 1007, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.nfc", 1027, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.bluetooth", 1002, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.shell", 2000, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.se", com.android.server.pm.PackageManagerService.SE_UID, 1, 8);
        r70.mSettings.addSharedUserLPw("android.uid.networkstack", com.android.server.pm.PackageManagerService.NETWORKSTACK_UID, 1, 8);
        r12 = android.os.SystemProperties.get("debug.separate_processes");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0282, code lost:
        if (r12 == null) goto L_0x02c3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x0288, code lost:
        if (r12.length() <= 0) goto L_0x02c3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x0290, code lost:
        if ("*".equals(r12) == false) goto L_0x02a0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x0292, code lost:
        r70.mDefParseFlags = 2;
        r70.mSeparateProcesses = null;
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Running with debug.separate_processes: * (ALL)");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x02a0, code lost:
        r70.mDefParseFlags = 0;
        r70.mSeparateProcesses = r12.split(",");
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Running with debug.separate_processes: " + r12);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x02c3, code lost:
        r70.mDefParseFlags = 0;
        r70.mSeparateProcesses = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:26:0x02c9, code lost:
        r70.mPackageDexOptimizer = new com.android.server.pm.PackageDexOptimizer(r72, r70.mInstallLock, r71, "*dexopt*");
        r70.mDexManager = new com.android.server.pm.dex.DexManager(r70.mContext, r70, r70.mPackageDexOptimizer, r72, r70.mInstallLock);
        r70.mArtManagerService = new com.android.server.pm.dex.ArtManagerService(r70.mContext, r70, r72, r70.mInstallLock);
        r70.mMoveCallbacks = new com.android.server.pm.PackageManagerService.MoveCallbacks(com.android.server.FgThread.get().getLooper());
        r70.mViewCompiler = new com.android.server.pm.dex.ViewCompiler(r70.mInstallLock, r70.mInstaller);
        r70.mOnPermissionChangeListeners = new com.android.server.pm.PackageManagerService.OnPermissionChangeListeners(com.android.server.FgThread.get().getLooper());
        getDefaultDisplayMetrics(r71, r70.mMetrics);
        android.os.Trace.traceBegin(262144, "get system config");
        r19 = com.android.server.SystemConfig.getInstance();
        com.android.server.pm.PackageManagerCommonSoft.loadCustomFeatures();
        r70.mAvailableFeatures = r19.getAvailableFeatures();
        android.os.Trace.traceEnd(262144);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:27:0x033f, code lost:
        if (android.os.SystemProperties.getBoolean("persist.sys.oplus.multiapp.support", true) != false) goto L_0x0359;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x0341, code lost:
        r1 = r70.mAvailableFeatures;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0343, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:?, code lost:
        r70.mAvailableFeatures.remove("oppo.multiapp.support");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x034c, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:33:0x034d, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "remove multiapp feature on enterprise device!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x0359, code lost:
        onOppoStart();
        r70.mProtectedPackages = new com.android.server.pm.ProtectedPackages(r70.mContext);
        com.android.server.pm.PackageManagerService.mCompatibilityHelper = new com.android.server.pm.CompatibilityHelper(r71);
        com.android.server.pm.PackageManagerService.mDcsUploader = com.android.server.pm.CommonDcsUploader.getInstance(r71);
        r70.mApexManager = new com.android.server.pm.ApexManager(r71);
        r70.mCustomizeList = loadCustomizeWhiteList("/system/etc/oppo_customize_whitelist.xml");
        r70.mCustomizeSystemAppBlacklist = loadCustomizeWhiteList("/system/etc/customize_system_app_blacklist.xml");
        r70.mHandlerThread = new com.android.server.ServiceThread(com.android.server.pm.PackageManagerService.TAG, 10, true);
        r70.mHandlerThread.start();
        r70.mHandler = new com.android.server.pm.PackageManagerService.PackageHandler(r70, r70.mHandlerThread.getLooper());
        r70.mProcessLoggingHandler = new com.android.server.pm.ProcessLoggingHandler();
        com.android.server.Watchdog.getInstance().addThread(r70.mHandler, 600000);
        r70.mInstantAppRegistry = new com.android.server.pm.InstantAppRegistry(r70);
        r7 = r19.getSharedLibraries();
        r5 = r7.size();
        r0 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x03ca, code lost:
        if (r0 >= r5) goto L_0x03e0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x03cc, code lost:
        addBuiltInSharedLibraryLocked(r7.valueAt(r0).filename, r7.keyAt(r0));
        r0 = r0 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:40:0x03e0, code lost:
        r0 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x03e3, code lost:
        if (r0 >= r5) goto L_0x0412;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x03e5, code lost:
        r1 = r7.keyAt(r0);
        r2 = r7.valueAt(r0);
        r6 = r2.dependencies.length;
        r8 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x03f5, code lost:
        if (r8 >= r6) goto L_0x040d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x03f7, code lost:
        r10 = getSharedLibraryInfoLPr(r2.dependencies[r8], -1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x03ff, code lost:
        if (r10 == null) goto L_0x0408;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x0401, code lost:
        getSharedLibraryInfoLPr(r1, -1).addDependency(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x0408, code lost:
        r8 = r8 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x040d, code lost:
        r0 = r0 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x0412, code lost:
        com.android.server.pm.SELinuxMMAC.readInstallPolicy();
        android.os.Trace.traceBegin(262144, "loadFallbacks");
        android.content.pm.FallbackCategoryProvider.loadFallbacks();
        android.os.Trace.traceEnd(262144);
        android.os.Trace.traceBegin(262144, "read user settings");
        r70.mFirstBoot = !r70.mSettings.readLPw(com.android.server.pm.PackageManagerService.sUserManager.getUsers(false));
        android.os.Trace.traceEnd(262144);
        com.android.server.pm.PackageManagerService.sPmsExt.init(r70, com.android.server.pm.PackageManagerService.sUserManager);
        r0 = r70.mSettings.mPackages.size() - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0452, code lost:
        if (r0 < 0) goto L_0x048e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0454, code lost:
        r6 = r70.mSettings.mPackages.valueAt(r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0462, code lost:
        if (isExternal(r6) != false) goto L_0x0488;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:532:0x15d8, code lost:
        throw new java.lang.IllegalStateException("Failed to load frameworks package; check log for warnings");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:539:0x15de, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0466, code lost:
        if (r6.codePath == null) goto L_0x0470;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x046e, code lost:
        if (r6.codePath.exists() != false) goto L_0x0488;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x0478, code lost:
        if (r70.mSettings.getDisabledSystemPkgLPr(r6.name) == null) goto L_0x0488;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x047a, code lost:
        r70.mSettings.mPackages.removeAt(r0);
        r70.mSettings.enableSystemPackageLPw(r6.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x0488, code lost:
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x0490, code lost:
        if (r70.mOnlyCore != false) goto L_0x0499;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0494, code lost:
        if (r70.mFirstBoot == false) goto L_0x0499;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x0496, code lost:
        requestCopyPreoptedFiles();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x0499, code lost:
        com.android.server.pm.PackageManagerCommonSoft.commonSoftInit(r72, r70);
        com.android.server.pm.OppoPackageManagerHelper.isFirstBoot(isFirstBoot());
        r21 = android.content.res.Resources.getSystem().getString(17039690);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x04b2, code lost:
        if (android.text.TextUtils.isEmpty(r21) != false) goto L_0x04ba;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x04b4, code lost:
        r70.mCustomResolverComponentName = android.content.ComponentName.unflattenFromString(r21);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x04ba, code lost:
        r1 = android.os.SystemClock.uptimeMillis();
        android.util.EventLog.writeEvent((int) com.android.server.EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, r1);
        com.oppo.phoenix.Phoenix.setBootstage("ANDROID_PMS_SCAN_START");
        android.os.SystemProperties.set(com.android.server.pm.PackageManagerService.SCANSTAGE_PROPERTY, com.android.server.oppo.TemperatureProvider.SWITCH_ON);
        com.android.server.pm.PackageManagerService.sMtkSystemServerIns.addBootEvent("Android:PMS_scan_START");
        com.mediatek.cta.CtaManagerFactory.getInstance().makeCtaManager().createCtaPermsController(r70.mContext);
        com.android.server.pm.PackageManagerService.sPmsExt.initBeforeScan();
        r22 = java.lang.System.getenv("BOOTCLASSPATH");
        r23 = java.lang.System.getenv("SYSTEMSERVERCLASSPATH");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x04f6, code lost:
        if (r22 != null) goto L_0x04ff;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x04f8, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "No BOOTCLASSPATH found!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x04ff, code lost:
        if (r23 != null) goto L_0x0508;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0501, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "No SYSTEMSERVERCLASSPATH found!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0508, code lost:
        r8 = new java.io.File(android.os.Environment.getRootDirectory(), "framework");
        r6 = r70.mSettings.getInternalVersion();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x0521, code lost:
        if (android.os.Build.FINGERPRINT.equals(r6.fingerprint) == false) goto L_0x052c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0527, code lost:
        if (isBootFromOTA() == false) goto L_0x052a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x052a, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x052c, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x052d, code lost:
        r70.mIsUpgrade = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x0531, code lost:
        if (r70.mIsUpgrade == false) goto L_0x0554;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x0533, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, "Upgrading from " + r6.fingerprint + " to " + android.os.Build.FINGERPRINT);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x0556, code lost:
        if (r70.mIsUpgrade == false) goto L_0x0560;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x055c, code lost:
        if (r6.sdkVersion > 22) goto L_0x0560;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x055e, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x0560, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x0561, code lost:
        r70.mPromoteSystemApps = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x0565, code lost:
        if (r70.mIsUpgrade == false) goto L_0x056f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x056b, code lost:
        if (r6.sdkVersion >= 24) goto L_0x056f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x056d, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x056f, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x0570, code lost:
        r70.mIsPreNUpgrade = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x0574, code lost:
        if (r70.mIsUpgrade == false) goto L_0x057e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x057a, code lost:
        if (r6.sdkVersion >= 25) goto L_0x057e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x057c, code lost:
        r0 = true;
     */
    /* JADX WARNING: Removed duplicated region for block: B:238:0x0a46  */
    /* JADX WARNING: Removed duplicated region for block: B:272:0x0b56  */
    /* JADX WARNING: Removed duplicated region for block: B:275:0x0b5f  */
    /* JADX WARNING: Removed duplicated region for block: B:278:0x0ba1  */
    /* JADX WARNING: Removed duplicated region for block: B:279:0x0ba4  */
    /* JADX WARNING: Removed duplicated region for block: B:286:0x0bce  */
    /* JADX WARNING: Removed duplicated region for block: B:288:0x0c32  */
    /* JADX WARNING: Removed duplicated region for block: B:310:0x0d1a  */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0d9e  */
    /* JADX WARNING: Removed duplicated region for block: B:333:0x0da9  */
    /* JADX WARNING: Removed duplicated region for block: B:404:0x1146  */
    /* JADX WARNING: Removed duplicated region for block: B:405:0x1149  */
    /* JADX WARNING: Removed duplicated region for block: B:410:0x1170  */
    /* JADX WARNING: Removed duplicated region for block: B:414:0x11f0  */
    /* JADX WARNING: Removed duplicated region for block: B:433:0x1295  */
    /* JADX WARNING: Removed duplicated region for block: B:434:0x1297  */
    /* JADX WARNING: Removed duplicated region for block: B:437:0x129b  */
    /* JADX WARNING: Removed duplicated region for block: B:447:0x12f0 A[LOOP:12: B:445:0x12ea->B:447:0x12f0, LOOP_END] */
    /* JADX WARNING: Removed duplicated region for block: B:450:0x1309  */
    /* JADX WARNING: Removed duplicated region for block: B:451:0x130c  */
    /* JADX WARNING: Removed duplicated region for block: B:454:0x1314  */
    /* JADX WARNING: Removed duplicated region for block: B:468:0x1382  */
    /* JADX WARNING: Removed duplicated region for block: B:478:0x13bc  */
    /* JADX WARNING: Removed duplicated region for block: B:488:0x1419  */
    /* JADX WARNING: Removed duplicated region for block: B:493:0x1453  */
    /* JADX WARNING: Removed duplicated region for block: B:497:0x1480  */
    /* JADX WARNING: Removed duplicated region for block: B:514:0x14e0  */
    /* JADX WARNING: Removed duplicated region for block: B:518:0x1517  */
    /* JADX WARNING: Removed duplicated region for block: B:521:0x1528 A[LOOP:17: B:520:0x1526->B:521:0x1528, LOOP_END] */
    /* JADX WARNING: Removed duplicated region for block: B:524:0x1553  */
    /* JADX WARNING: Removed duplicated region for block: B:527:0x15c5 A[ADDED_TO_REGION] */
    /* JADX WARNING: Removed duplicated region for block: B:605:? A[ADDED_TO_REGION, RETURN, SYNTHETIC] */
    public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        Settings.VersionInfo ver;
        long startTime;
        File privilegedAppDir;
        int scanFlags;
        int i;
        File systemAppDir;
        File privilegedVendorAppDir;
        File vendorAppDir;
        File vendorAppDir2;
        File privilegedOdmAppDir;
        File privilegedOdmAppDir2;
        File privilegedOdmAppDir3;
        File odmAppDir;
        File odmAppDir2;
        File oemAppDir;
        File oemAppDir2;
        File privilegedProductAppDir;
        File privilegedProductAppDir2;
        File vendorAppDir3;
        File productAppDir;
        File productAppDir2;
        File productAppDir3;
        File privilegedProductServicesAppDir;
        File privilegedProductServicesAppDir2;
        File privilegedProductServicesAppDir3;
        File productServicesAppDir;
        File productServicesAppDir2;
        File productServicesAppDir3;
        File privilegedCustomAppDir;
        File privilegedCustomAppDir2;
        File privilegedCustomAppDir3;
        File customAppDir;
        File customAppDir2;
        File customAppDir3;
        File oppoPrivilegeEngineerAppDir;
        File oppoPrivilegeEngineerAppDir2;
        File oppoPrivilegeEngineerAppDir3;
        File oppoEngineerAppDir;
        File oppoEngineerAppDir2;
        File oppoEngineerAppDir3;
        File oppoPrivilegeVersionAppDir;
        File oppoPrivilegeVersionAppDir2;
        File oppoPrivilegeVersionAppDir3;
        File oppoVersionAppDir;
        File oppoVersionAppDir2;
        File oppoVersionAppDir3;
        File oppoPrivilegeProductAppDir;
        File oppoPrivilegeProductAppDir2;
        File oppoPrivilegeProductAppDir3;
        File oppoProductAppDir;
        File oppoProductAppDir2;
        File privilegedOdmAppDir4;
        List<String> stubSystemApps;
        int cachedSystemApps;
        long systemScanTime;
        int systemPackagesCount;
        boolean sdkUpdated;
        int storageFlags;
        int storageFlags2;
        Iterator<PackageParser.Package> it;
        Pair<ComponentName, String> instantAppResolverComponent;
        String str;
        int length;
        int i2;
        boolean isDialerFeatureAvailable;
        int storageFlags3;
        PackageParser.Package pkg;
        int size;
        int i3;
        int i4;
        MultiTaskDealer scandealer;
        int i5;
        int i6;
        int i7;
        int i8;
        int dataPackagesCount;
        int i9;
        File oppoProductAppDir3;
        File oppoPrivilegeProductAppDir4;
        File oppoVersionAppDir4;
        File oppoPrivilegeVersionAppDir4;
        File oppoEngineerAppDir4;
        File oppoPrivilegeEngineerAppDir4;
        File customAppDir4;
        File privilegedCustomAppDir4;
        File productServicesAppDir4;
        File privilegedProductServicesAppDir4;
        File productAppDir4;
        File privilegedProductAppDir3;
        File oemAppDir3;
        File odmAppDir3;
        File productAppDir5;
        File privilegedProductAppDir4;
        int rescanFlags;
        int reparseFlags;
        int i10;
        File productAppDir6;
        File privilegedOdmAppDir5;
        File vendorAppDir4;
        File odmAppDir4;
        int i11;
        int i12;
        List<String> possiblyDeletedUpdatedSystemApps;
        String packageName;
        long systemScanTime2;
        int scanFlags2;
        String msg;
        PackageSetting ps;
        PackageManagerException e;
        LockGuard.installLock(this.mPackages, 3);
        Trace.traceBegin(262144, "create package manager");
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PackageManagerService_Start");
        Phoenix.setBootstage("ANDROID_PMS_INIT_START");
        if (this.mSdkVersion <= 0) {
            Slog.w(TAG, "**** ro.build.version.sdk not set!");
        }
        this.mContext = context;
        this.mFactoryTest = factoryTest;
        this.mOnlyCore = onlyCore;
        this.mMetrics = new DisplayMetrics();
        this.mInstaller = installer;
        this.mColorPmsInner = new ColorPackageManagerServiceInner();
        mColorPmsEx = ColorServiceFactory.getInstance().getFeature(IColorPackageManagerServiceEx.DEFAULT, new Object[]{context, this});
        this.mPswPmsEx = PswServiceFactory.getInstance().getFeature(IPswPackageManagerServiceEx.DEFAULT, new Object[]{context, this});
        registerOppoPackageManagerInternalImpl();
        OppoPackageManagerHelper.parsePackageXml();
        synchronized (this.mInstallLock) {
            try {
                synchronized (this.mPackages) {
                    LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());
                    UserManagerService oppoUms = OppoCommonServiceFactory.getUserManagerService(context, this, new OppoUserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                    if (oppoUms != null) {
                        sUserManager = oppoUms;
                    } else {
                        sUserManager = new UserManagerService(context, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                    }
                    this.mComponentResolver = new ComponentResolver(sUserManager, (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class), this.mPackages);
                    this.mPermissionManager = PermissionManagerService.create(context, this.mPackages);
                    this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                    this.mSettings = new Settings(Environment.getDataDirectory(), this.mPermissionManager.getPermissionSettings(), this.mPackages);
                }
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        try {
            productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        } catch (IOException e2) {
            productServicesAppDir2 = productServicesAppDir;
        }
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        try {
            privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        } catch (IOException e3) {
            privilegedCustomAppDir2 = privilegedCustomAppDir;
        }
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        try {
            customAppDir2 = customAppDir.getCanonicalFile();
        } catch (IOException e4) {
            customAppDir2 = customAppDir;
        }
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        try {
            oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        } catch (IOException e5) {
            oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir;
        }
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        try {
            oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        } catch (IOException e6) {
            oppoEngineerAppDir2 = oppoEngineerAppDir;
        }
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        try {
            oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        } catch (IOException e7) {
            oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir;
        }
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        try {
            oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        } catch (IOException e8) {
            oppoVersionAppDir2 = oppoVersionAppDir;
        }
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        try {
            oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        } catch (IOException e9) {
            oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir;
        }
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        try {
            oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        } catch (IOException e10) {
            oppoProductAppDir2 = oppoProductAppDir;
        }
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps2 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
            for (PackageParser.Package pkg2 : this.mPackages.values()) {
                if (pkg2.isStub) {
                    stubSystemApps.add(pkg2.packageName);
                }
            }
            Iterator<PackageSetting> psit = this.mSettings.mPackages.values().iterator();
            while (psit.hasNext()) {
                PackageSetting ps2 = psit.next();
                if ((ps2.pkgFlags & i) != 0 || sPmsExt.isRemovableSysApp(ps2.name)) {
                    PackageParser.Package scannedPkg = this.mPackages.get(ps2.name);
                    if (scannedPkg == null) {
                        if (!this.mSettings.isDisabledSystemPackageLPr(ps2.name)) {
                            psit.remove();
                            PackageManagerServiceUtils.logCriticalInfo(5, "System package " + ps2.name + " no longer exists; it's data will be wiped");
                        } else {
                            PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(ps2.name);
                            if (disabledPs.codePath == null || !disabledPs.codePath.exists() || disabledPs.pkg == null) {
                                possiblyDeletedUpdatedSystemApps2.add(ps2.name);
                            } else {
                                this.mExpectingBetter.put(disabledPs.name, disabledPs.codePath);
                            }
                        }
                        i = 1;
                    } else if (this.mSettings.isDisabledSystemPackageLPr(ps2.name)) {
                        PackageManagerServiceUtils.logCriticalInfo(5, "Expecting better updated system app for " + ps2.name + "; removing system app.  Last known codePath=" + ps2.codePathString + ", versionCode=" + ps2.versionCode + "; scanned versionCode=" + scannedPkg.getLongVersionCode());
                        removePackageLI(scannedPkg, true);
                        this.mExpectingBetter.put(ps2.name, ps2.codePath);
                        i = 1;
                    } else {
                        i = 1;
                    }
                } else {
                    i = 1;
                }
            }
        }
        if (isFirstBoot()) {
            PackageManagerCommonSoft.copyReserveApk();
        }
        if (isFirstBoot()) {
            PackageManagerCommonSoft.deleteDataFileForDifferentDevice();
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb = new StringBuilder();
        sb.append("Finished scanning system apps. Time: ");
        sb.append(systemScanTime);
        sb.append(" ms, packageCount: ");
        sb.append(systemPackagesCount);
        sb.append(" , timePerPackage: ");
        sb.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb.append(" , cached: ");
        sb.append(cachedSystemApps);
        Slog.i(TAG, sb.toString());
        if (this.mIsUpgrade && systemPackagesCount > 0) {
            MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        }
        if (this.mOnlyCore) {
            OppoFeatureCache.get(IColorOtaDataManager.DEFAULT).setDataPackageNameList(PackageManagerCommonSoft.getDataPackageNameList());
            OppoFeatureCache.get(IColorOtaDataManager.DEFAULT).update();
            OppoFeatureCache.get(IColorRemovableAppManager.DEFAULT).setDataPackageNameList(PackageManagerCommonSoft.getDataPackageNameList());
            OppoFeatureCache.get(IColorRemovableAppManager.DEFAULT).scanPreinstalledApps();
            EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis());
            SystemProperties.set(SCANSTAGE_PROPERTY, NoFocusWindow.HUNG_CONFIG_ENABLE);
            List<String> possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps2;
            scanDirTracedLI(sAppInstallDir, 0, scanFlags | 128, 0);
            i6 = possiblyDeletedUpdatedSystemApps3.size() - 1;
            while (i6 >= 0) {
                String packageName2 = possiblyDeletedUpdatedSystemApps3.get(i6);
                PackageParser.Package pkg3 = this.mPackages.get(packageName2);
                this.mSettings.removeDisabledSystemPackageLPw(packageName2);
                if (pkg3 == null) {
                    msg = "Updated system package " + packageName2 + " no longer exists; removing its data";
                    packageName = packageName2;
                    i12 = i6;
                    possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
                    systemScanTime2 = systemScanTime;
                    scanFlags2 = scanFlags;
                } else {
                    String msg2 = "Updated system package " + packageName2 + " no longer exists; rescanning package on data";
                    removePackageLI(pkg3, true);
                    try {
                        packageName = packageName2;
                        i12 = i6;
                        possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
                        systemScanTime2 = systemScanTime;
                        scanFlags2 = scanFlags;
                        try {
                            scanPackageTracedLI(new File(pkg3.applicationInfo.getCodePath()), 0, scanFlags, 0, (UserHandle) null);
                        } catch (PackageManagerException e11) {
                            e = e11;
                        }
                    } catch (PackageManagerException e12) {
                        e = e12;
                        packageName = packageName2;
                        i12 = i6;
                        possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
                        systemScanTime2 = systemScanTime;
                        scanFlags2 = scanFlags;
                        Slog.e(TAG, "Failed to parse updated, ex-system package: " + e.getMessage());
                        msg = msg2;
                        ps = this.mSettings.mPackages.get(packageName);
                        if (ps != null && this.mPackages.get(packageName) == null) {
                            removePackageDataLIF(ps, null, null, 0, false);
                        }
                        PackageManagerServiceUtils.logCriticalInfo(5, msg);
                        i6 = i12 - 1;
                        scanFlags = scanFlags2;
                        systemScanTime = systemScanTime2;
                        possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps;
                    }
                    msg = msg2;
                }
                ps = this.mSettings.mPackages.get(packageName);
                removePackageDataLIF(ps, null, null, 0, false);
                PackageManagerServiceUtils.logCriticalInfo(5, msg);
                i6 = i12 - 1;
                scanFlags = scanFlags2;
                systemScanTime = systemScanTime2;
                possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps;
            }
            int i13 = 5;
            if (!hasSystemFeature(OppoCustomizeNotificationHelper.Constants.FEATURE_BUSINESS_CUSTOM, 0)) {
                ArrayList<String> uinstallList = PackageManagerCommonSoft.getCustomizUninstallAppList();
                if (uinstallList == null || uinstallList.size() <= 0) {
                    i7 = 5;
                } else {
                    Iterator<String> it2 = uinstallList.iterator();
                    while (it2.hasNext()) {
                        String packagename = it2.next();
                        PackageParser.Package pkg4 = this.mPackages.get(packagename);
                        if (pkg4 != null) {
                            Log.d(TAG, "app is in customize uninstall list, will remove it, " + packagename);
                            removePackageLI(pkg4, true);
                            PackageSetting ps3 = this.mSettings.mPackages.get(packagename);
                            if (ps3 == null || this.mPackages.get(packagename) != null) {
                                i11 = i13;
                            } else {
                                i11 = i13;
                                removePackageDataLIF(ps3, null, null, 0, false);
                            }
                        } else {
                            i11 = i13;
                        }
                        i13 = i11;
                    }
                    i7 = i13;
                }
            } else {
                i7 = 5;
            }
            i8 = 0;
            while (i8 < this.mExpectingBetter.size()) {
                String packageName3 = this.mExpectingBetter.keyAt(i8);
                if (!this.mPackages.containsKey(packageName3)) {
                    File scanFile = this.mExpectingBetter.valueAt(i8);
                    PackageManagerServiceUtils.logCriticalInfo(i7, "Expected better " + packageName3 + " but never showed up; reverting to system");
                    if (FileUtils.contains(privilegedAppDir, scanFile)) {
                        i10 = i8;
                        vendorAppDir4 = vendorAppDir2;
                        privilegedOdmAppDir5 = privilegedOdmAppDir3;
                        odmAppDir4 = oemAppDir;
                        privilegedProductAppDir4 = vendorAppDir3;
                        productAppDir6 = privilegedOdmAppDir4;
                        reparseFlags = this.mDefParseFlags | 16;
                        rescanFlags = scanFlags | 131072 | 262144;
                    } else if (FileUtils.contains(systemAppDir, scanFile)) {
                        int i14 = scanFlags | 131072;
                        i10 = i8;
                        vendorAppDir4 = vendorAppDir2;
                        privilegedOdmAppDir5 = privilegedOdmAppDir3;
                        odmAppDir4 = oemAppDir;
                        privilegedProductAppDir4 = vendorAppDir3;
                        productAppDir6 = privilegedOdmAppDir4;
                        reparseFlags = this.mDefParseFlags | 16;
                        rescanFlags = i14;
                    } else {
                        if (!FileUtils.contains(privilegedVendorAppDir, scanFile)) {
                            privilegedOdmAppDir5 = privilegedOdmAppDir3;
                            if (FileUtils.contains(privilegedOdmAppDir5, scanFile)) {
                                i10 = i8;
                                vendorAppDir4 = vendorAppDir2;
                                odmAppDir4 = oemAppDir;
                                privilegedProductAppDir4 = vendorAppDir3;
                                productAppDir6 = privilegedOdmAppDir4;
                            } else {
                                vendorAppDir4 = vendorAppDir2;
                                if (!FileUtils.contains(vendorAppDir4, scanFile)) {
                                    odmAppDir4 = oemAppDir;
                                    if (FileUtils.contains(odmAppDir4, scanFile)) {
                                        i10 = i8;
                                        privilegedProductAppDir4 = vendorAppDir3;
                                        productAppDir6 = privilegedOdmAppDir4;
                                    } else if (FileUtils.contains(oemAppDir2, scanFile)) {
                                        reparseFlags = this.mDefParseFlags | 16;
                                        oemAppDir2 = oemAppDir2;
                                        i10 = i8;
                                        rescanFlags = scanFlags | 131072 | 524288;
                                        privilegedProductAppDir4 = vendorAppDir3;
                                        productAppDir6 = privilegedOdmAppDir4;
                                    } else {
                                        privilegedProductAppDir4 = vendorAppDir3;
                                        if (FileUtils.contains(privilegedProductAppDir4, scanFile)) {
                                            reparseFlags = this.mDefParseFlags | 16;
                                            oemAppDir2 = oemAppDir2;
                                            rescanFlags = scanFlags | 131072 | 2097152 | 262144;
                                            i10 = i8;
                                            productAppDir6 = privilegedOdmAppDir4;
                                        } else {
                                            i10 = i8;
                                            if (FileUtils.contains(productAppDir3, scanFile)) {
                                                oemAppDir2 = oemAppDir2;
                                                productAppDir3 = productAppDir3;
                                                rescanFlags = scanFlags | 131072 | 2097152;
                                                productAppDir6 = privilegedOdmAppDir4;
                                                reparseFlags = this.mDefParseFlags | 16;
                                            } else {
                                                productAppDir3 = productAppDir3;
                                                if (FileUtils.contains(privilegedProductServicesAppDir3, scanFile)) {
                                                    oemAppDir2 = oemAppDir2;
                                                    privilegedProductServicesAppDir3 = privilegedProductServicesAppDir3;
                                                    rescanFlags = scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144;
                                                    productAppDir6 = privilegedOdmAppDir4;
                                                    reparseFlags = this.mDefParseFlags | 16;
                                                } else {
                                                    privilegedProductServicesAppDir3 = privilegedProductServicesAppDir3;
                                                    if (FileUtils.contains(productServicesAppDir3, scanFile)) {
                                                        oemAppDir2 = oemAppDir2;
                                                        productServicesAppDir3 = productServicesAppDir3;
                                                        rescanFlags = scanFlags | 131072 | DumpState.DUMP_CHANGES;
                                                        productAppDir6 = privilegedOdmAppDir4;
                                                        reparseFlags = this.mDefParseFlags | 16;
                                                    } else {
                                                        productServicesAppDir3 = productServicesAppDir3;
                                                        if (FileUtils.contains(privilegedCustomAppDir3, scanFile)) {
                                                            oemAppDir2 = oemAppDir2;
                                                            privilegedCustomAppDir3 = privilegedCustomAppDir3;
                                                            rescanFlags = scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144;
                                                            productAppDir6 = privilegedOdmAppDir4;
                                                            reparseFlags = this.mDefParseFlags | 16;
                                                        } else {
                                                            privilegedCustomAppDir3 = privilegedCustomAppDir3;
                                                            if (FileUtils.contains(customAppDir3, scanFile)) {
                                                                oemAppDir2 = oemAppDir2;
                                                                customAppDir3 = customAppDir3;
                                                                rescanFlags = scanFlags | 131072 | DumpState.DUMP_CHANGES;
                                                                productAppDir6 = privilegedOdmAppDir4;
                                                                reparseFlags = this.mDefParseFlags | 16;
                                                            } else {
                                                                customAppDir3 = customAppDir3;
                                                                if (FileUtils.contains(oppoEngineerAppDir3, scanFile)) {
                                                                    oemAppDir2 = oemAppDir2;
                                                                    oppoEngineerAppDir3 = oppoEngineerAppDir3;
                                                                    rescanFlags = scanFlags | 131072 | 1048576;
                                                                    productAppDir6 = privilegedOdmAppDir4;
                                                                    reparseFlags = this.mDefParseFlags | 16;
                                                                } else {
                                                                    oppoEngineerAppDir3 = oppoEngineerAppDir3;
                                                                    if (FileUtils.contains(oppoPrivilegeEngineerAppDir3, scanFile)) {
                                                                        oemAppDir2 = oemAppDir2;
                                                                        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir3;
                                                                        rescanFlags = scanFlags | 131072 | 1048576 | 262144;
                                                                        productAppDir6 = privilegedOdmAppDir4;
                                                                        reparseFlags = this.mDefParseFlags | 16;
                                                                    } else {
                                                                        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir3;
                                                                        if (FileUtils.contains(oppoVersionAppDir3, scanFile)) {
                                                                            oemAppDir2 = oemAppDir2;
                                                                            oppoVersionAppDir3 = oppoVersionAppDir3;
                                                                            rescanFlags = scanFlags | 131072 | 2097152;
                                                                            productAppDir6 = privilegedOdmAppDir4;
                                                                            reparseFlags = this.mDefParseFlags | 16;
                                                                        } else {
                                                                            oppoVersionAppDir3 = oppoVersionAppDir3;
                                                                            if (FileUtils.contains(oppoPrivilegeVersionAppDir3, scanFile)) {
                                                                                oemAppDir2 = oemAppDir2;
                                                                                oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir3;
                                                                                rescanFlags = scanFlags | 131072 | 2097152 | 262144;
                                                                                productAppDir6 = privilegedOdmAppDir4;
                                                                                reparseFlags = this.mDefParseFlags | 16;
                                                                            } else {
                                                                                oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir3;
                                                                                if (FileUtils.contains(oppoPrivilegeProductAppDir3, scanFile)) {
                                                                                    oemAppDir2 = oemAppDir2;
                                                                                    oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir3;
                                                                                    rescanFlags = scanFlags | 131072 | 2097152 | 262144;
                                                                                    productAppDir6 = privilegedOdmAppDir4;
                                                                                    reparseFlags = this.mDefParseFlags | 16;
                                                                                } else {
                                                                                    oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir3;
                                                                                    productAppDir6 = privilegedOdmAppDir4;
                                                                                    if (FileUtils.contains(productAppDir6, scanFile)) {
                                                                                        oemAppDir2 = oemAppDir2;
                                                                                        rescanFlags = scanFlags | 131072 | 2097152;
                                                                                        reparseFlags = this.mDefParseFlags | 16;
                                                                                    } else {
                                                                                        Slog.e(TAG, "Ignoring unexpected fallback path " + scanFile);
                                                                                        privilegedProductAppDir3 = vendorAppDir4;
                                                                                        oppoProductAppDir3 = privilegedOdmAppDir5;
                                                                                        i9 = i10;
                                                                                        odmAppDir3 = oemAppDir2;
                                                                                        productAppDir5 = productAppDir3;
                                                                                        productAppDir4 = privilegedProductServicesAppDir3;
                                                                                        privilegedProductServicesAppDir4 = productServicesAppDir3;
                                                                                        productServicesAppDir4 = privilegedCustomAppDir3;
                                                                                        privilegedCustomAppDir4 = customAppDir3;
                                                                                        customAppDir4 = oppoPrivilegeEngineerAppDir3;
                                                                                        oppoPrivilegeEngineerAppDir4 = oppoEngineerAppDir3;
                                                                                        oppoEngineerAppDir4 = oppoPrivilegeVersionAppDir3;
                                                                                        oppoPrivilegeVersionAppDir4 = oppoVersionAppDir3;
                                                                                        oppoVersionAppDir4 = oppoPrivilegeProductAppDir3;
                                                                                        oemAppDir3 = odmAppDir4;
                                                                                        oppoPrivilegeProductAppDir4 = productAppDir6;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    i10 = i8;
                                    odmAppDir4 = oemAppDir;
                                    privilegedProductAppDir4 = vendorAppDir3;
                                    productAppDir6 = privilegedOdmAppDir4;
                                }
                                reparseFlags = this.mDefParseFlags | 16;
                                rescanFlags = scanFlags | 131072 | 1048576;
                            }
                        } else {
                            i10 = i8;
                            vendorAppDir4 = vendorAppDir2;
                            privilegedOdmAppDir5 = privilegedOdmAppDir3;
                            odmAppDir4 = oemAppDir;
                            privilegedProductAppDir4 = vendorAppDir3;
                            productAppDir6 = privilegedOdmAppDir4;
                        }
                        reparseFlags = this.mDefParseFlags | 16;
                        rescanFlags = scanFlags | 131072 | 1048576 | 262144;
                    }
                    this.mSettings.enableSystemPackageLPw(packageName3);
                    odmAppDir3 = oemAppDir2;
                    oemAppDir3 = odmAppDir4;
                    privilegedProductAppDir3 = vendorAppDir4;
                    oppoProductAppDir3 = privilegedOdmAppDir5;
                    i9 = i10;
                    productAppDir5 = productAppDir3;
                    productAppDir4 = privilegedProductServicesAppDir3;
                    privilegedProductServicesAppDir4 = productServicesAppDir3;
                    productServicesAppDir4 = privilegedCustomAppDir3;
                    privilegedCustomAppDir4 = customAppDir3;
                    customAppDir4 = oppoPrivilegeEngineerAppDir3;
                    oppoPrivilegeEngineerAppDir4 = oppoEngineerAppDir3;
                    oppoEngineerAppDir4 = oppoPrivilegeVersionAppDir3;
                    oppoPrivilegeVersionAppDir4 = oppoVersionAppDir3;
                    oppoVersionAppDir4 = oppoPrivilegeProductAppDir3;
                    oppoPrivilegeProductAppDir4 = productAppDir6;
                    try {
                        scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, 0, (UserHandle) null);
                    } catch (PackageManagerException e13) {
                        Slog.e(TAG, "Failed to parse original system package: " + e13.getMessage());
                    }
                } else {
                    i9 = i8;
                    privilegedProductAppDir4 = vendorAppDir3;
                    productAppDir5 = productAppDir3;
                    productAppDir4 = privilegedProductServicesAppDir3;
                    privilegedProductServicesAppDir4 = productServicesAppDir3;
                    productServicesAppDir4 = privilegedCustomAppDir3;
                    privilegedCustomAppDir4 = customAppDir3;
                    customAppDir4 = oppoPrivilegeEngineerAppDir3;
                    oppoPrivilegeEngineerAppDir4 = oppoEngineerAppDir3;
                    oppoEngineerAppDir4 = oppoPrivilegeVersionAppDir3;
                    oppoPrivilegeVersionAppDir4 = oppoVersionAppDir3;
                    oppoVersionAppDir4 = oppoPrivilegeProductAppDir3;
                    oppoPrivilegeProductAppDir4 = privilegedOdmAppDir4;
                    privilegedProductAppDir3 = vendorAppDir2;
                    oppoProductAppDir3 = privilegedOdmAppDir3;
                    oemAppDir3 = oemAppDir;
                    odmAppDir3 = oemAppDir2;
                }
                i8 = i9 + 1;
                vendorAppDir2 = privilegedProductAppDir3;
                privilegedOdmAppDir3 = oppoProductAppDir3;
                vendorAppDir3 = privilegedProductAppDir4;
                privilegedOdmAppDir4 = oppoPrivilegeProductAppDir4;
                i7 = 5;
                oppoPrivilegeProductAppDir3 = oppoVersionAppDir4;
                oppoVersionAppDir3 = oppoPrivilegeVersionAppDir4;
                oppoPrivilegeVersionAppDir3 = oppoEngineerAppDir4;
                oppoEngineerAppDir3 = oppoPrivilegeEngineerAppDir4;
                oppoPrivilegeEngineerAppDir3 = customAppDir4;
                customAppDir3 = privilegedCustomAppDir4;
                privilegedCustomAppDir3 = productServicesAppDir4;
                productServicesAppDir3 = privilegedProductServicesAppDir4;
                privilegedProductServicesAppDir3 = productAppDir4;
                productAppDir3 = productAppDir5;
                oemAppDir2 = odmAppDir3;
                oemAppDir = oemAppDir3;
            }
            clearSellModeIfNeeded();
            setExpDefaultBrowser();
            installSystemStubPackages(stubSystemApps, scanFlags);
            int cachedNonSystemApps = PackageParser.sCachedPackageReadCount.get() - cachedSystemApps;
            long dataScanTime = (SystemClock.uptimeMillis() - systemScanTime) - startTime;
            dataPackagesCount = this.mPackages.size() - systemPackagesCount;
            StringBuilder sb2 = new StringBuilder();
            sb2.append("Finished scanning non-system apps. Time: ");
            sb2.append(dataScanTime);
            sb2.append(" ms, packageCount: ");
            sb2.append(dataPackagesCount);
            sb2.append(" , timePerPackage: ");
            sb2.append(dataPackagesCount != 0 ? 0 : dataScanTime / ((long) dataPackagesCount));
            sb2.append(" , cached: ");
            sb2.append(cachedNonSystemApps);
            Slog.i(TAG, sb2.toString());
            if (this.mIsUpgrade && dataPackagesCount > 0) {
                MetricsLogger.histogram((Context) null, "ota_package_manager_data_app_avg_scan_time", ((int) dataScanTime) / dataPackagesCount);
            }
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
            List<String> changedAbiCodePath = adjustCpuAbisForSharedUserLPw(setting.packages, null);
            if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
                for (i5 = changedAbiCodePath.size() - 1; i5 >= 0; i5--) {
                    try {
                        this.mInstaller.rmdex(changedAbiCodePath.get(i5), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                    } catch (Installer.InstallerException e14) {
                    }
                }
            }
            setting.fixSeInfoLocked();
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        if (iMultitaskNum > 0 && (scandealer = MultiTaskDealer.getDealer(MultiTaskDealer.PACKAGEMANAGER_SCANER)) != null) {
            scandealer.shutdownNow();
        }
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        sdkUpdated = ver.sdkVersion != this.mSdkVersion;
        if (sdkUpdated) {
            Slog.i(TAG, "Platform changed from " + ver.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for internal storage");
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        if (!onlyCore && (this.mPromoteSystemApps || this.mFirstBoot)) {
            for (UserInfo user : sUserManager.getUsers(true)) {
                this.mSettings.applyDefaultPreferredAppsLPw(user.id);
                primeDomainVerificationsLPw(user.id);
            }
        }
        storageFlags = StorageManager.isFileEncryptedNativeOrEmulated() ? 1 : 3;
        if (!isFirstBoot() || this.mIsUpgrade || isBootFromOTA() || !SystemProperties.getBoolean("persist.sys.reconcile.finish", false)) {
            SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
            Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
            storageFlags2 = storageFlags;
            this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
                private final /* synthetic */ List f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void run() {
                    PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
                }
            }, "prepareAppData");
        } else {
            storageFlags2 = storageFlags;
        }
        if (this.mIsUpgrade && !onlyCore) {
            Slog.i(TAG, "Build fingerprint changed; clearing code caches");
            for (i4 = 0; i4 < this.mSettings.mPackages.size(); i4++) {
                PackageSetting ps4 = this.mSettings.mPackages.valueAt(i4);
                if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps4.volumeUuid)) {
                    clearAppDataLIF(ps4.pkg, -1, 39);
                }
            }
            ver.fingerprint = Build.FINGERPRINT;
        }
        if (!onlyCore && this.mIsPreQUpgrade) {
            Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
            size = this.mSettings.mPackages.size();
            for (i3 = 0; i3 < size; i3++) {
                PackageSetting ps5 = this.mSettings.mPackages.valueAt(i3);
                if ((ps5.pkgFlags & 1) == 0) {
                    ps5.disableComponentLPw(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME, 0);
                }
            }
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        try {
            OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        } catch (Exception e15) {
        }
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
            this.mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();
            this.mRequiredInstallerPackage = getRequiredInstallerLPr();
            this.mRequiredUninstallerPackage = getRequiredUninstallerLPr();
            this.mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();
            ComponentName componentName = this.mIntentFilterVerifierComponent;
            if (componentName != null) {
                this.mIntentFilterVerifier = new IntentVerifierProxy(this.mContext, componentName);
            } else {
                this.mIntentFilterVerifier = null;
            }
            this.mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.services", -1);
            this.mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.shared", -1);
        } else {
            this.mRequiredVerifierPackage = null;
            this.mRequiredInstallerPackage = null;
            this.mRequiredUninstallerPackage = null;
            this.mIntentFilterVerifierComponent = null;
            this.mIntentFilterVerifier = null;
            this.mServicesSystemSharedLibraryPackageName = null;
            this.mSharedSystemSharedLibraryPackageName = null;
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
            PackageParser.Package pkg5 = it.next();
            if (!pkg5.isSystem()) {
                int length2 = userIds.length;
                int i15 = 0;
                while (i15 < length2) {
                    int userId = userIds[i15];
                    PackageSetting ps6 = (PackageSetting) pkg5.mExtras;
                    if (ps6 == null || !ps6.getInstantApp(userId)) {
                        pkg = pkg5;
                        storageFlags3 = storageFlags2;
                    } else if (!ps6.getInstalled(userId)) {
                        pkg = pkg5;
                        storageFlags3 = storageFlags2;
                    } else {
                        pkg = pkg5;
                        storageFlags3 = storageFlags2;
                        this.mInstantAppRegistry.addInstantAppLPw(userId, ps6.appId);
                    }
                    i15++;
                    it = it;
                    pkg5 = pkg;
                    storageFlags2 = storageFlags3;
                }
            }
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Set ephemeral resolver: " + instantAppResolverComponent);
            }
            this.mInstantAppResolverConnection = new InstantAppResolverConnection(this.mContext, (ComponentName) instantAppResolverComponent.first, (String) instantAppResolverComponent.second);
            this.mInstantAppResolverSettingsComponent = getInstantAppResolverSettingsLPr((ComponentName) instantAppResolverComponent.first);
            str = null;
        } else {
            str = null;
            this.mInstantAppResolverConnection = null;
            this.mInstantAppResolverSettingsComponent = null;
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages = new HashMap<>();
        length = userIds.length;
        i2 = 0;
        while (i2 < length) {
            int userId2 = userIds[i2];
            userPackages.put(Integer.valueOf(userId2), getInstalledPackages(0, userId2).getList());
            i2++;
            userIds = userIds;
            instantAppResolverComponent = instantAppResolverComponent;
        }
        this.mDexManager.load(userPackages);
        if (this.mIsUpgrade) {
            MetricsLogger.histogram((Context) null, "ota_package_manager_init_time", (int) (SystemClock.uptimeMillis() - startTime));
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable && isDialerPackageAvailable && is_system_app("com.google.android.dialer")) {
            addFeature("com.google.android.apps.dialer.SUPPORTED", 0);
            return;
        }
        return;
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps22 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb3 = new StringBuilder();
        sb3.append("Finished scanning system apps. Time: ");
        sb3.append(systemScanTime);
        sb3.append(" ms, packageCount: ");
        sb3.append(systemPackagesCount);
        sb3.append(" , timePerPackage: ");
        sb3.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb3.append(" , cached: ");
        sb3.append(cachedSystemApps);
        Slog.i(TAG, sb3.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2 = new HashMap<>();
        length = userIds2.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages2);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable2 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
            return;
        }
        return;
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb32 = new StringBuilder();
        sb32.append("Finished scanning system apps. Time: ");
        sb32.append(systemScanTime);
        sb32.append(" ms, packageCount: ");
        sb32.append(systemPackagesCount);
        sb32.append(" , timePerPackage: ");
        sb32.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb32.append(" , cached: ");
        sb32.append(cachedSystemApps);
        Slog.i(TAG, sb32.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22 = new HashMap<>();
        length = userIds22.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages22);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable22 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        oemAppDir = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir4 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir4;
        scanDirTracedLI(oemAppDir4, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        try {
            privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        } catch (IOException e16) {
            privilegedProductAppDir2 = privilegedProductAppDir;
        }
        vendorAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        try {
            productAppDir2 = productAppDir.getCanonicalFile();
        } catch (IOException e17) {
            productAppDir2 = productAppDir;
        }
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        try {
            privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        } catch (IOException e18) {
            privilegedProductServicesAppDir2 = privilegedProductServicesAppDir;
        }
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps2222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb322 = new StringBuilder();
        sb322.append("Finished scanning system apps. Time: ");
        sb322.append(systemScanTime);
        sb322.append(" ms, packageCount: ");
        sb322.append(systemPackagesCount);
        sb322.append(" , timePerPackage: ");
        sb322.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb322.append(" , cached: ");
        sb322.append(cachedSystemApps);
        Slog.i(TAG, sb322.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222 = new HashMap<>();
        length = userIds222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps22222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb3222 = new StringBuilder();
        sb3222.append("Finished scanning system apps. Time: ");
        sb3222.append(systemScanTime);
        sb3222.append(" ms, packageCount: ");
        sb3222.append(systemPackagesCount);
        sb3222.append(" , timePerPackage: ");
        sb3222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb3222.append(" , cached: ");
        sb3222.append(cachedSystemApps);
        Slog.i(TAG, sb3222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2222 = new HashMap<>();
        length = userIds2222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages2222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable2222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb32222 = new StringBuilder();
        sb32222.append("Finished scanning system apps. Time: ");
        sb32222.append(systemScanTime);
        sb32222.append(" ms, packageCount: ");
        sb32222.append(systemPackagesCount);
        sb32222.append(" , timePerPackage: ");
        sb32222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb32222.append(" , cached: ");
        sb32222.append(cachedSystemApps);
        Slog.i(TAG, sb32222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22222 = new HashMap<>();
        length = userIds22222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages22222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable22222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        vendorAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps2222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb322222 = new StringBuilder();
        sb322222.append("Finished scanning system apps. Time: ");
        sb322222.append(systemScanTime);
        sb322222.append(" ms, packageCount: ");
        sb322222.append(systemPackagesCount);
        sb322222.append(" , timePerPackage: ");
        sb322222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb322222.append(" , cached: ");
        sb322222.append(cachedSystemApps);
        Slog.i(TAG, sb322222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222222 = new HashMap<>();
        length = userIds222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps22222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb3222222 = new StringBuilder();
        sb3222222.append("Finished scanning system apps. Time: ");
        sb3222222.append(systemScanTime);
        sb3222222.append(" ms, packageCount: ");
        sb3222222.append(systemPackagesCount);
        sb3222222.append(" , timePerPackage: ");
        sb3222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb3222222.append(" , cached: ");
        sb3222222.append(cachedSystemApps);
        Slog.i(TAG, sb3222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2222222 = new HashMap<>();
        length = userIds2222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages2222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable2222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22222222 = new HashMap<>();
        length = userIds22222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages22222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable22222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        while (i6 >= 0) {
        }
        int i132 = 5;
        if (!hasSystemFeature(OppoCustomizeNotificationHelper.Constants.FEATURE_BUSINESS_CUSTOM, 0)) {
        }
        i8 = 0;
        while (i8 < this.mExpectingBetter.size()) {
        }
        clearSellModeIfNeeded();
        setExpDefaultBrowser();
        installSystemStubPackages(stubSystemApps, scanFlags);
        int cachedNonSystemApps2 = PackageParser.sCachedPackageReadCount.get() - cachedSystemApps;
        long dataScanTime2 = (SystemClock.uptimeMillis() - systemScanTime) - startTime;
        dataPackagesCount = this.mPackages.size() - systemPackagesCount;
        StringBuilder sb22 = new StringBuilder();
        sb22.append("Finished scanning non-system apps. Time: ");
        sb22.append(dataScanTime2);
        sb22.append(" ms, packageCount: ");
        sb22.append(dataPackagesCount);
        sb22.append(" , timePerPackage: ");
        sb22.append(dataPackagesCount != 0 ? 0 : dataScanTime2 / ((long) dataPackagesCount));
        sb22.append(" , cached: ");
        sb22.append(cachedNonSystemApps2);
        Slog.i(TAG, sb22.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_data_app_avg_scan_time", ((int) dataScanTime2) / dataPackagesCount);
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222222222 = new HashMap<>();
        length = userIds222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        vendorAppDir2 = vendorAppDir;
        scanDirTracedLI(vendorAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        try {
            privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
        } catch (IOException e19) {
            privilegedOdmAppDir2 = privilegedOdmAppDir;
        }
        privilegedOdmAppDir3 = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        try {
            odmAppDir2 = odmAppDir.getCanonicalFile();
        } catch (IOException e20) {
            odmAppDir2 = odmAppDir;
        }
        oemAppDir = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir42 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir42;
        scanDirTracedLI(oemAppDir42, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        vendorAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb32222222 = new StringBuilder();
        sb32222222.append("Finished scanning system apps. Time: ");
        sb32222222.append(systemScanTime);
        sb32222222.append(" ms, packageCount: ");
        sb32222222.append(systemPackagesCount);
        sb32222222.append(" , timePerPackage: ");
        sb32222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb32222222.append(" , cached: ");
        sb32222222.append(cachedSystemApps);
        Slog.i(TAG, sb32222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2222222222 = new HashMap<>();
        length = userIds2222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages2222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable2222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps2222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb322222222 = new StringBuilder();
        sb322222222.append("Finished scanning system apps. Time: ");
        sb322222222.append(systemScanTime);
        sb322222222.append(" ms, packageCount: ");
        sb322222222.append(systemPackagesCount);
        sb322222222.append(" , timePerPackage: ");
        sb322222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb322222222.append(" , cached: ");
        sb322222222.append(cachedSystemApps);
        Slog.i(TAG, sb322222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22222222222 = new HashMap<>();
        length = userIds22222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages22222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable22222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps22222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb3222222222 = new StringBuilder();
        sb3222222222.append("Finished scanning system apps. Time: ");
        sb3222222222.append(systemScanTime);
        sb3222222222.append(" ms, packageCount: ");
        sb3222222222.append(systemPackagesCount);
        sb3222222222.append(" , timePerPackage: ");
        sb3222222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb3222222222.append(" , cached: ");
        sb3222222222.append(cachedSystemApps);
        Slog.i(TAG, sb3222222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222222222222 = new HashMap<>();
        length = userIds222222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages222222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable222222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        scanDirTracedLI(privilegedVendorAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        if (EXP_VERSION) {
            String mOPInstalled = SystemProperties.get("persist.sys.oppo.opinstalled", TemperatureProvider.SWITCH_OFF);
            if (mRegion.equals("SG") && mOperator.equals("STARHUB") && mOPInstalled.equals(TemperatureProvider.SWITCH_OFF)) {
                SystemProperties.set("persist.sys.oppo.opinstalled", TemperatureProvider.SWITCH_ON);
            }
            PackageManagerCommonSoft.CopyDataReserveAppsForSimOperatorSwitch();
        }
        File vendorAppDir5 = new File(Environment.getVendorDirectory(), "app");
        try {
            vendorAppDir = vendorAppDir5.getCanonicalFile();
        } catch (IOException e21) {
            vendorAppDir = vendorAppDir5;
        }
        vendorAppDir2 = vendorAppDir;
        scanDirTracedLI(vendorAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
        privilegedOdmAppDir3 = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        odmAppDir2 = odmAppDir.getCanonicalFile();
        oemAppDir = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir422 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir422;
        scanDirTracedLI(oemAppDir422, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        vendorAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps222222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb32222222222 = new StringBuilder();
        sb32222222222.append("Finished scanning system apps. Time: ");
        sb32222222222.append(systemScanTime);
        sb32222222222.append(" ms, packageCount: ");
        sb32222222222.append(systemPackagesCount);
        sb32222222222.append(" , timePerPackage: ");
        sb32222222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb32222222222.append(" , cached: ");
        sb32222222222.append(cachedSystemApps);
        Slog.i(TAG, sb32222222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2222222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2222222222222 = new HashMap<>();
        length = userIds2222222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages2222222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable2222222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps2222222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb322222222222 = new StringBuilder();
        sb322222222222.append("Finished scanning system apps. Time: ");
        sb322222222222.append(systemScanTime);
        sb322222222222.append(" ms, packageCount: ");
        sb322222222222.append(systemPackagesCount);
        sb322222222222.append(" , timePerPackage: ");
        sb322222222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb322222222222.append(" , cached: ");
        sb322222222222.append(cachedSystemApps);
        Slog.i(TAG, sb322222222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22222222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22222222222222 = new HashMap<>();
        length = userIds22222222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages22222222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable22222222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps22222222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb3222222222222 = new StringBuilder();
        sb3222222222222.append("Finished scanning system apps. Time: ");
        sb3222222222222.append(systemScanTime);
        sb3222222222222.append(" ms, packageCount: ");
        sb3222222222222.append(systemPackagesCount);
        sb3222222222222.append(" , timePerPackage: ");
        sb3222222222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb3222222222222.append(" , cached: ");
        sb3222222222222.append(cachedSystemApps);
        Slog.i(TAG, sb3222222222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds222222222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages222222222222222 = new HashMap<>();
        length = userIds222222222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages222222222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable222222222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        privilegedOdmAppDir3 = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        odmAppDir2 = odmAppDir.getCanonicalFile();
        oemAppDir = odmAppDir2;
        scanDirTracedLI(odmAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        File oemAppDir4222 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir4222;
        scanDirTracedLI(oemAppDir4222, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
        privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir2 = privilegedProductAppDir.getCanonicalFile();
        vendorAppDir3 = privilegedProductAppDir2;
        scanDirTracedLI(privilegedProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        productAppDir = new File(Environment.getProductDirectory(), "app");
        productAppDir2 = productAppDir.getCanonicalFile();
        productAppDir3 = productAppDir2;
        scanDirTracedLI(productAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
        privilegedProductServicesAppDir2 = privilegedProductServicesAppDir.getCanonicalFile();
        privilegedProductServicesAppDir3 = privilegedProductServicesAppDir2;
        scanDirTracedLI(privilegedProductServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        productServicesAppDir = new File(Environment.getProductServicesDirectory(), "app");
        productServicesAppDir2 = productServicesAppDir.getCanonicalFile();
        productServicesAppDir3 = productServicesAppDir2;
        scanDirTracedLI(productServicesAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        sPmsExt.scanMoreDirLi(this.mDefParseFlags, scanFlags);
        privilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
        privilegedCustomAppDir2 = privilegedCustomAppDir.getCanonicalFile();
        privilegedCustomAppDir3 = privilegedCustomAppDir2;
        scanDirTracedLI(privilegedCustomAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES | 262144, 0);
        customAppDir = new File(Environment.getOppoCustomDirectory(), "app");
        customAppDir2 = customAppDir.getCanonicalFile();
        customAppDir3 = customAppDir2;
        scanDirTracedLI(customAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | DumpState.DUMP_CHANGES, 0);
        oppoPrivilegeEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
        oppoPrivilegeEngineerAppDir2 = oppoPrivilegeEngineerAppDir.getCanonicalFile();
        oppoPrivilegeEngineerAppDir3 = oppoPrivilegeEngineerAppDir2;
        scanDirTracedLI(oppoPrivilegeEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
        oppoEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "app");
        oppoEngineerAppDir2 = oppoEngineerAppDir.getCanonicalFile();
        oppoEngineerAppDir3 = oppoEngineerAppDir2;
        scanDirTracedLI(oppoEngineerAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
        oppoPrivilegeVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
        oppoPrivilegeVersionAppDir2 = oppoPrivilegeVersionAppDir.getCanonicalFile();
        oppoPrivilegeVersionAppDir3 = oppoPrivilegeVersionAppDir2;
        scanDirTracedLI(oppoPrivilegeVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoVersionAppDir = new File(Environment.getOppoVersionDirectory(), "app");
        oppoVersionAppDir2 = oppoVersionAppDir.getCanonicalFile();
        oppoVersionAppDir3 = oppoVersionAppDir2;
        scanDirTracedLI(oppoVersionAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        oppoPrivilegeProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
        oppoPrivilegeProductAppDir2 = oppoPrivilegeProductAppDir.getCanonicalFile();
        oppoPrivilegeProductAppDir3 = oppoPrivilegeProductAppDir2;
        scanDirTracedLI(oppoPrivilegeProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
        oppoProductAppDir = new File(Environment.getOppoProductDirectory(), "app");
        oppoProductAppDir2 = oppoProductAppDir.getCanonicalFile();
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps222222222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb32222222222222 = new StringBuilder();
        sb32222222222222.append("Finished scanning system apps. Time: ");
        sb32222222222222.append(systemScanTime);
        sb32222222222222.append(" ms, packageCount: ");
        sb32222222222222.append(systemPackagesCount);
        sb32222222222222.append(" , timePerPackage: ");
        sb32222222222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb32222222222222.append(" , cached: ");
        sb32222222222222.append(cachedSystemApps);
        Slog.i(TAG, sb32222222222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds2222222222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2222222222222222 = new HashMap<>();
        length = userIds2222222222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages2222222222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable2222222222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        while (true) {
            try {
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
        privilegedOdmAppDir4 = oppoProductAppDir2;
        scanDirTracedLI(oppoProductAppDir2, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
        PackageManagerCommonSoft.scanCustomDataApp(scanFlags | 128);
        List<String> possiblyDeletedUpdatedSystemApps2222222222222222 = new ArrayList<>();
        stubSystemApps = new ArrayList<>();
        if (!this.mOnlyCore) {
        }
        if (isFirstBoot()) {
        }
        if (isFirstBoot()) {
        }
        OppoOperatorManagerService.copySimTriggeredApps(this.mIsUpgrade, this.mInstaller, this.mInstallLock);
        deleteTempPackageFiles();
        cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb322222222222222 = new StringBuilder();
        sb322222222222222.append("Finished scanning system apps. Time: ");
        sb322222222222222.append(systemScanTime);
        sb322222222222222.append(" ms, packageCount: ");
        sb322222222222222.append(systemPackagesCount);
        sb322222222222222.append(" , timePerPackage: ");
        sb322222222222222.append(systemPackagesCount != 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
        sb322222222222222.append(" , cached: ");
        sb322222222222222.append(cachedSystemApps);
        Slog.i(TAG, sb322222222222222.toString());
        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        this.mComponentResolver.fixProtectedFilterPriorities();
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mWellbeingPackage = getWellbeingPackageName();
        this.mDocumenterPackage = getDocumenterPackageName();
        this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
        this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
        this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
        updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(this.mPackages));
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        scandealer.shutdownNow();
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Phoenix.setBootstage("ANDROID_PMS_SCAN_END");
        SystemProperties.set(SCANSTAGE_PROPERTY, "2");
        sMtkSystemServerIns.addBootEvent("Android:PMS_scan_END");
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        PackageManagerCommonSoft.resetOppoDeriveAbi();
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        ver.sdkVersion = this.mSdkVersion;
        while (r0.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        if (!isFirstBoot()) {
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_OFF);
        Phoenix.updateProcOpbootfrom(isBootFromOTA(), false, isFirstBoot());
        storageFlags2 = storageFlags;
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true), storageFlags2) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU */
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$new$0$PackageManagerService(this.f$1, this.f$2);
            }
        }, "prepareAppData");
        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
        while (i4 < this.mSettings.mPackages.size()) {
        }
        ver.fingerprint = Build.FINGERPRINT;
        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
        size = this.mSettings.mPackages.size();
        while (i3 < size) {
        }
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).deleteOldFreezeInfo();
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        sMtkSystemServerIns.addBootEvent("Android:PMS_READY");
        Phoenix.setBootstage("ANDROID_PMS_READY");
        if (this.mOnlyCore) {
        }
        this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
        int[] userIds22222222222222222 = UserManagerService.getInstance().getUserIds();
        it = this.mPackages.values().iterator();
        while (it.hasNext()) {
        }
        this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages22222222222222222 = new HashMap<>();
        length = userIds22222222222222222.length;
        i2 = 0;
        while (i2 < length) {
        }
        this.mDexManager.load(userPackages22222222222222222);
        if (this.mIsUpgrade) {
        }
        OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).onStart(this, installer, this.mInstallLock);
        this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
        Trace.traceBegin(262144, "GC");
        Runtime.getRuntime().gc();
        Trace.traceEnd(262144);
        this.mInstaller.setWarnIfHeld(this.mPackages);
        PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
        this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
        sPmsExt.initAfterScan(this.mSettings.mPackages);
        Trace.traceEnd(262144);
        isDialerFeatureAvailable = hasSystemFeature("com.google.android.apps.dialer.SUPPORTED", 0);
        boolean isDialerPackageAvailable22222222222222222 = isPackageAvailable("com.google.android.dialer", 0);
        if (!isDialerFeatureAvailable) {
        }
        i8 = i9 + 1;
        vendorAppDir2 = privilegedProductAppDir3;
        privilegedOdmAppDir3 = oppoProductAppDir3;
        vendorAppDir3 = privilegedProductAppDir4;
        privilegedOdmAppDir4 = oppoPrivilegeProductAppDir4;
        i7 = 5;
        oppoPrivilegeProductAppDir3 = oppoVersionAppDir4;
        oppoVersionAppDir3 = oppoPrivilegeVersionAppDir4;
        oppoPrivilegeVersionAppDir3 = oppoEngineerAppDir4;
        oppoEngineerAppDir3 = oppoPrivilegeEngineerAppDir4;
        oppoPrivilegeEngineerAppDir3 = customAppDir4;
        customAppDir3 = privilegedCustomAppDir4;
        privilegedCustomAppDir3 = productServicesAppDir4;
        productServicesAppDir3 = privilegedProductServicesAppDir4;
        privilegedProductServicesAppDir3 = productAppDir4;
        productAppDir3 = productAppDir5;
        oemAppDir2 = odmAppDir3;
        oemAppDir = oemAppDir3;
    }

    public /* synthetic */ void lambda$new$0$PackageManagerService(List deferPackages, int storageFlags) {
        TimingsTraceLog traceLog = new TimingsTraceLog("SystemServerTimingAsync", 262144);
        traceLog.traceBegin("AppDataFixup");
        try {
            this.mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL, 3);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, "Trouble fixing GIDs", e);
        }
        traceLog.traceEnd();
        traceLog.traceBegin("AppDataPrepare");
        if (deferPackages == null || deferPackages.isEmpty()) {
            SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_ON);
            return;
        }
        int count = 0;
        Iterator it = deferPackages.iterator();
        while (it.hasNext()) {
            String pkgName = (String) it.next();
            PackageParser.Package pkg = null;
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.getPackageLPr(pkgName);
                if (ps != null && ps.getInstalled(0)) {
                    pkg = ps.pkg;
                }
            }
            if (pkg != null) {
                synchronized (this.mInstallLock) {
                    prepareAppDataAndMigrateLIF(pkg, 0, storageFlags, true);
                }
                count++;
            }
        }
        SystemProperties.set("persist.sys.reconcile.finish", TemperatureProvider.SWITCH_ON);
        traceLog.traceEnd();
        Slog.i(TAG, "Deferred reconcileAppsData finished " + count + " packages");
    }

    private void installSystemStubPackages(List<String> systemStubPackageNames, int scanFlags) {
        int i = systemStubPackageNames.size();
        while (true) {
            i--;
            if (i < 0) {
                break;
            }
            String packageName = systemStubPackageNames.get(i);
            if (this.mSettings.isDisabledSystemPackageLPr(packageName)) {
                systemStubPackageNames.remove(i);
            } else {
                PackageParser.Package pkg = this.mPackages.get(packageName);
                if (pkg == null) {
                    systemStubPackageNames.remove(i);
                } else {
                    PackageSetting ps = this.mSettings.mPackages.get(packageName);
                    if (ps == null || ps.getEnabled(0) != 3) {
                        try {
                            installStubPackageLI(pkg, 0, scanFlags);
                            ps.setEnabled(0, 0, PLATFORM_PACKAGE_NAME);
                            systemStubPackageNames.remove(i);
                        } catch (PackageManagerException e) {
                            Slog.e(TAG, "Failed to parse uncompressed system package: " + e.getMessage());
                        }
                    } else {
                        systemStubPackageNames.remove(i);
                    }
                }
            }
        }
        for (int i2 = systemStubPackageNames.size() - 1; i2 >= 0; i2 += -1) {
            String pkgName = systemStubPackageNames.get(i2);
            this.mSettings.mPackages.get(pkgName).setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            PackageManagerServiceUtils.logCriticalInfo(6, "Stub disabled; pkg: " + pkgName);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0065, code lost:
        r6 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x0066, code lost:
        if (r4 != null) goto L_0x0068;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x0068, code lost:
        $closeResource(r5, r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x006b, code lost:
        throw r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x00b6, code lost:
        r7 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x00b7, code lost:
        if (r6 != null) goto L_0x00b9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x00b9, code lost:
        $closeResource(r2, r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x00bc, code lost:
        throw r7;
     */
    private boolean enableCompressedPackage(PackageParser.Package stubPkg) {
        int parseFlags = this.mDefParseFlags | Integer.MIN_VALUE | 64;
        synchronized (this.mInstallLock) {
            try {
                PackageFreezer freezer = freezePackage(stubPkg.packageName, "setEnabledSetting");
                PackageParser.Package pkg = installStubPackageLI(stubPkg, parseFlags, 0);
                synchronized (this.mPackages) {
                    prepareAppDataAfterInstallLIF(pkg);
                    try {
                        updateSharedLibrariesLocked(pkg, null, this.mPackages);
                    } catch (PackageManagerException e) {
                        Slog.e(TAG, "updateAllSharedLibrariesLPw failed: ", e);
                    }
                    this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                    this.mSettings.writeLPr();
                }
                if (freezer != null) {
                    $closeResource(null, freezer);
                }
                clearAppDataLIF(pkg, -1, 39);
                this.mDexManager.notifyPackageUpdated(pkg.packageName, pkg.baseCodePath, pkg.splitCodePaths);
            } catch (PackageManagerException e2) {
                try {
                    PackageFreezer freezer2 = freezePackage(stubPkg.packageName, "setEnabledSetting");
                    synchronized (this.mPackages) {
                        enableSystemPackageLPw(stubPkg);
                        installPackageFromSystemLIF(stubPkg.codePath, null, null, null, true);
                        if (freezer2 != null) {
                            $closeResource(null, freezer2);
                        }
                        synchronized (this.mPackages) {
                            PackageSetting stubPs = this.mSettings.mPackages.get(stubPkg.packageName);
                            if (stubPs != null) {
                                stubPs.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                            }
                            this.mSettings.writeLPr();
                            return false;
                        }
                    }
                } catch (PackageManagerException pme) {
                    try {
                        Slog.wtf(TAG, "Failed to restore system package:" + stubPkg.packageName, pme);
                        synchronized (this.mPackages) {
                            PackageSetting stubPs2 = this.mSettings.mPackages.get(stubPkg.packageName);
                            if (stubPs2 != null) {
                                stubPs2.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                            }
                            this.mSettings.writeLPr();
                        }
                    } catch (Throwable th) {
                        th = th;
                    }
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
        return true;
        throw th;
    }

    private static /* synthetic */ void $closeResource(Throwable x0, AutoCloseable x1) {
        if (x0 != null) {
            try {
                x1.close();
            } catch (Throwable th) {
                x0.addSuppressed(th);
            }
        } else {
            x1.close();
        }
    }

    private PackageParser.Package installStubPackageLI(PackageParser.Package stubPkg, int parseFlags, int scanFlags) throws PackageManagerException {
        if (DEBUG_COMPRESSION) {
            Slog.i(TAG, "Uncompressing system stub; pkg: " + stubPkg.packageName);
        }
        File scanFile = decompressPackage(stubPkg.packageName, stubPkg.codePath);
        if (scanFile != null) {
            synchronized (this.mPackages) {
                this.mSettings.disableSystemPackageLPw(stubPkg.packageName, true);
            }
            removePackageLI(stubPkg, true);
            try {
                return scanPackageTracedLI(scanFile, parseFlags, scanFlags, 0, (UserHandle) null);
            } catch (PackageManagerException e) {
                Slog.w(TAG, "Failed to install compressed system package:" + stubPkg.packageName, e);
                removeCodePathLI(scanFile);
                throw e;
            }
        } else {
            throw new PackageManagerException("Unable to decompress stub at " + stubPkg.codePath);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:19:0x0098  */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x00d0  */
    /* JADX WARNING: Removed duplicated region for block: B:37:0x00db A[RETURN] */
    private File decompressPackage(String packageName, String codePath) {
        int ret;
        ErrnoException e;
        File[] compressedFiles = PackageManagerServiceUtils.getCompressedFiles(codePath);
        if (compressedFiles == null || compressedFiles.length == 0) {
            if (DEBUG_COMPRESSION) {
                Slog.i(TAG, "No files to decompress: " + codePath);
            }
            return null;
        }
        File dstCodePath = getNextCodePath(Environment.getDataAppDirectory(null), packageName);
        try {
            Os.mkdir(dstCodePath.getAbsolutePath(), 493);
            Os.chmod(dstCodePath.getAbsolutePath(), 493);
            int length = compressedFiles.length;
            ret = 1;
            int ret2 = 0;
            while (true) {
                if (ret2 >= length) {
                    break;
                }
                try {
                    File srcFile = compressedFiles[ret2];
                    String srcFileName = srcFile.getName();
                    String dstFileName = srcFileName.substring(0, srcFileName.length() - COMPRESSED_EXTENSION.length());
                    ret = PackageManagerServiceUtils.decompressFile(srcFile, new File(dstCodePath, dstFileName));
                    if (ret != 1) {
                        PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", file: " + dstFileName);
                        break;
                    }
                    ret2++;
                } catch (ErrnoException e2) {
                    e = e2;
                    PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", err: " + e.errno);
                    if (ret == 1) {
                    }
                    if (ret == 1) {
                    }
                }
            }
        } catch (ErrnoException e3) {
            e = e3;
            ret = 1;
            PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", err: " + e.errno);
            if (ret == 1) {
            }
            if (ret == 1) {
            }
        }
        if (ret == 1) {
            File libraryRoot = new File(dstCodePath, "lib");
            NativeLibraryHelper.Handle handle = null;
            try {
                handle = NativeLibraryHelper.Handle.create(dstCodePath);
                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, (String) null);
            } catch (IOException e4) {
                PackageManagerServiceUtils.logCriticalInfo(6, "Failed to extract native libraries; pkg: " + packageName);
                ret = -110;
            } catch (Throwable th) {
                IoUtils.closeQuietly(handle);
                throw th;
            }
            IoUtils.closeQuietly(handle);
        }
        if (ret == 1) {
            return dstCodePath;
        }
        if (!dstCodePath.exists()) {
            return null;
        }
        removeCodePathLI(dstCodePath);
        return null;
    }

    @GuardedBy({"mPackages"})
    private void updateInstantAppInstallerLocked(String modifiedPackage) {
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        if (activityInfo == null || activityInfo.getComponentName().getPackageName().equals(modifiedPackage)) {
            setUpInstantAppInstallerActivityLP(getInstantAppInstallerLPr());
        }
    }

    private static File preparePackageParserCache() {
        if (Build.IS_ENG) {
            return null;
        }
        if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
            Slog.i(TAG, "Disabling package parser cache due to system property.");
            return null;
        }
        File cacheBaseDir = Environment.getPackageCacheDirectory();
        if (!FileUtils.createDir(cacheBaseDir)) {
            return null;
        }
        String cacheName = SystemProperties.digestOf(new String[]{"ro.build.fingerprint", "persist.sys.isolated_storage", "sys.isolated_storage_snapshot"});
        File[] listFilesOrEmpty = FileUtils.listFilesOrEmpty(cacheBaseDir);
        for (File cacheDir : listFilesOrEmpty) {
            if (Objects.equals(cacheName, cacheDir.getName())) {
                Slog.d(TAG, "Keeping known cache " + cacheDir.getName());
            } else {
                Slog.d(TAG, "Destroying unknown cache " + cacheDir.getName());
                FileUtils.deleteContentsAndDir(cacheDir);
            }
        }
        File cacheDir2 = FileUtils.createDir(cacheBaseDir, cacheName);
        if (cacheDir2 == null) {
            Slog.wtf(TAG, "Cache directory cannot be created - wiping base dir " + cacheBaseDir);
            FileUtils.deleteContentsAndDir(cacheBaseDir);
            return null;
        } else if (!Build.IS_USERDEBUG || !Build.VERSION.INCREMENTAL.startsWith("eng.")) {
            return cacheDir2;
        } else {
            Slog.w(TAG, "Wiping cache directory because the system partition changed.");
            if (cacheDir2.lastModified() >= new File(Environment.getRootDirectory(), "framework").lastModified()) {
                return cacheDir2;
            }
            FileUtils.deleteContents(cacheBaseDir);
            return FileUtils.createDir(cacheBaseDir, cacheName);
        }
    }

    public boolean isFirstBoot() {
        return this.mFirstBoot;
    }

    public boolean isOnlyCoreApps() {
        return this.mOnlyCore;
    }

    public boolean isDeviceUpgrading() {
        return this.mIsUpgrade || SystemProperties.getBoolean("persist.pm.mock-upgrade", false);
    }

    private String getRequiredButNotReallyRequiredVerifierLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        if (matches.size() == 0) {
            Log.e(TAG, "There should probably be a verifier, but, none were found");
            return null;
        }
        throw new RuntimeException("There must be exactly one verifier; found " + matches);
    }

    private String getRequiredSharedLibraryLPr(String name, int version) {
        String packageName;
        synchronized (this.mPackages) {
            SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(name, (long) version);
            if (libraryInfo != null) {
                packageName = libraryInfo.getPackageName();
                if (packageName == null) {
                    throw new IllegalStateException("Expected a package for shared library " + name);
                }
            } else {
                throw new IllegalStateException("Missing required shared library:" + name);
            }
        }
        return packageName;
    }

    private String getRequiredInstallerLPr() {
        Intent intent = new Intent("android.intent.action.INSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.parse("content://com.example/foo.apk"), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one installer; found " + matches);
        } else if (matches.get(0).activityInfo.applicationInfo.isPrivilegedApp()) {
            return matches.get(0).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The installer must be a privileged app");
        }
    }

    private String getRequiredUninstallerLPr() {
        Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setData(Uri.fromParts("package", "foo.bar", null));
        ResolveInfo resolveInfo = resolveIntent(intent, null, 1835008, 0);
        if (resolveInfo != null && !this.mResolveActivity.name.equals(resolveInfo.getComponentInfo().name)) {
            return resolveInfo.getComponentInfo().packageName;
        }
        throw new RuntimeException("There must be exactly one uninstaller; found " + resolveInfo);
    }

    private String getRequiredPermissionControllerLPr() {
        Intent intent = new Intent("android.intent.action.MANAGE_PERMISSIONS");
        intent.addCategory("android.intent.category.DEFAULT");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one permissions manager; found " + matches);
        } else if (matches.get(0).activityInfo.applicationInfo.isPrivilegedApp()) {
            return matches.get(0).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The permissions manager must be a privileged app");
        }
    }

    private ComponentName getIntentFilterVerifierComponentNameLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        ResolveInfo best = null;
        int N = matches.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo cur = matches.get(i);
            if (checkPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", cur.getComponentInfo().packageName, 0) == 0 && (best == null || cur.priority > best.priority)) {
                best = cur;
            }
        }
        if (best != null) {
            return best.getComponentInfo().getComponentName();
        }
        Slog.w(TAG, "Intent filter verifier not found");
        return null;
    }

    public ComponentName getInstantAppResolverComponent() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Pair<ComponentName, String> instantAppResolver = getInstantAppResolverLPr();
            if (instantAppResolver == null) {
                return null;
            }
            return (ComponentName) instantAppResolver.first;
        }
    }

    private Pair<ComponentName, String> getInstantAppResolverLPr() {
        String[] packageArray = this.mContext.getResources().getStringArray(17236028);
        if (packageArray.length != 0 || Build.IS_DEBUGGABLE) {
            List<ResolveInfo> resolvers = queryIntentServicesInternal(new Intent("android.intent.action.RESOLVE_INSTANT_APP_PACKAGE"), null, (!Build.IS_DEBUGGABLE ? 1048576 : 0) | 786432, 0, Binder.getCallingUid(), false);
            int N = resolvers.size();
            if (N == 0) {
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, "Ephemeral resolver NOT found; no matching intent filters");
                }
                return null;
            }
            Set<String> possiblePackages = new ArraySet<>(Arrays.asList(packageArray));
            for (int i = 0; i < N; i++) {
                ResolveInfo info = resolvers.get(i);
                if (info.serviceInfo != null) {
                    String packageName = info.serviceInfo.packageName;
                    if (possiblePackages.contains(packageName) || Build.IS_DEBUGGABLE) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Ephemeral resolver found; pkg: " + packageName + ", info:" + info);
                        }
                        return new Pair<>(new ComponentName(packageName, info.serviceInfo.name), "android.intent.action.RESOLVE_INSTANT_APP_PACKAGE");
                    } else if (DEBUG_INSTANT) {
                        Slog.d(TAG, "Ephemeral resolver not in allowed package list; pkg: " + packageName + ", info:" + info);
                    }
                }
            }
            if (!DEBUG_INSTANT) {
                return null;
            }
            Slog.v(TAG, "Ephemeral resolver NOT found");
            return null;
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Ephemeral resolver NOT found; empty package list");
        }
        return null;
    }

    @GuardedBy({"mPackages"})
    private ActivityInfo getInstantAppInstallerLPr() {
        String[] orderedActions;
        if (Build.IS_ENG) {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE_TEST", "android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        } else {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        }
        int resolveFlags = 786944 | (!Build.IS_ENG ? 1048576 : 0);
        Intent intent = new Intent();
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = null;
        for (String action : orderedActions) {
            intent.setAction(action);
            matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, resolveFlags, 0);
            if (!matches.isEmpty()) {
                break;
            }
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Instant App installer not found with " + action);
            }
        }
        Iterator<ResolveInfo> iter = matches.iterator();
        while (iter.hasNext()) {
            PackageSetting ps = this.mSettings.mPackages.get(iter.next().activityInfo.packageName);
            if (ps == null || (!ps.getPermissionsState().hasPermission("android.permission.INSTALL_PACKAGES", 0) && !Build.IS_ENG)) {
                iter.remove();
            }
        }
        if (matches.size() == 0) {
            return null;
        }
        if (matches.size() == 1) {
            return (ActivityInfo) matches.get(0).getComponentInfo();
        }
        throw new RuntimeException("There must be at most one ephemeral installer; found " + matches);
    }

    private ComponentName getInstantAppResolverSettingsLPr(ComponentName resolver) {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.intent.action.INSTANT_APP_RESOLVER_SETTINGS").addCategory("android.intent.category.DEFAULT").setPackage(resolver.getPackageName()), null, 786432, 0);
        if (matches.isEmpty()) {
            return null;
        }
        return matches.get(0).getComponentInfo().getComponentName();
    }

    @GuardedBy({"mPackages"})
    private void primeDomainVerificationsLPw(int userId) {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Priming domain verifications in user " + userId);
        }
        Iterator<String> it = SystemConfig.getInstance().getLinkedApps().iterator();
        while (it.hasNext()) {
            String packageName = it.next();
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "Unknown package " + packageName + " in sysconfig <app-link>");
            } else if (!pkg.isSystem()) {
                Slog.w(TAG, "Non-system app '" + packageName + "' in sysconfig <app-link>");
            } else {
                ArraySet<String> domains = null;
                Iterator it2 = pkg.activities.iterator();
                while (it2.hasNext()) {
                    Iterator it3 = ((PackageParser.Activity) it2.next()).intents.iterator();
                    while (it3.hasNext()) {
                        PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it3.next();
                        if (hasValidDomains(filter)) {
                            if (domains == null) {
                                domains = new ArraySet<>();
                            }
                            domains.addAll(filter.getHostsList());
                        }
                    }
                }
                if (domains == null || domains.size() <= 0) {
                    Slog.w(TAG, "Sysconfig <app-link> package '" + packageName + "' does not handle web links");
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "      + " + packageName);
                    }
                    this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domains).setStatus(0);
                    this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                }
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        scheduleWriteSettingsLocked();
    }

    private boolean packageIsBrowser(String packageName, int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo info = list.get(i);
            if (info.priority >= 0 && packageName.equals(info.activityInfo.packageName)) {
                return true;
            }
        }
        return false;
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e) {
            if (!(e instanceof SecurityException) && !(e instanceof IllegalArgumentException)) {
                Slog.wtf(TAG, "Package Manager Crash", e);
            }
            throw e;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean canViewInstantApps(int callingUid, int userId) {
        if (callingUid < 10000 || this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS") == 0) {
            return true;
        }
        if (this.mContext.checkCallingOrSelfPermission("android.permission.VIEW_INSTANT_APPS") != 0) {
            return false;
        }
        ComponentName homeComponent = getDefaultHomeActivity(userId);
        if (homeComponent != null && isCallerSameApp(homeComponent.getPackageName(), callingUid)) {
            return true;
        }
        String str = this.mAppPredictionServicePackage;
        if (str == null || !isCallerSameApp(str, callingUid)) {
            return false;
        }
        return true;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {
        int flags2;
        if (!sUserManager.exists(userId) || ps == null || filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
            return null;
        }
        if ((flags & 8192) == 0 || !ps.isSystem()) {
            flags2 = flags;
        } else {
            flags2 = flags | DumpState.DUMP_CHANGES;
        }
        PackageUserState state = ps.readUserState(userId);
        PackageParser.Package p = ps.pkg;
        if (p != null) {
            PermissionsState permissionsState = ps.getPermissionsState();
            PackageInfo packageInfo = PackageParser.generatePackageInfo(p, (flags2 & 256) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(userId), flags2, ps.firstInstallTime, ps.lastUpdateTime, ArrayUtils.isEmpty(p.requestedPermissions) ? Collections.emptySet() : permissionsState.getPermissions(userId), state, userId);
            if (packageInfo == null || packageInfo.applicationInfo == null) {
                return null;
            }
            ApplicationInfo applicationInfo = packageInfo.applicationInfo;
            String resolveExternalPackageNameLPr = resolveExternalPackageNameLPr(p);
            applicationInfo.packageName = resolveExternalPackageNameLPr;
            packageInfo.packageName = resolveExternalPackageNameLPr;
            return sPmsExt.updatePackageInfoForRemovable(packageInfo);
        } else if ((flags2 & 8192) == 0 || !state.isAvailable(flags2)) {
            return null;
        } else {
            PackageInfo pi = new PackageInfo();
            pi.packageName = ps.name;
            pi.setLongVersionCode(ps.versionCode);
            pi.sharedUserId = ps.sharedUser != null ? ps.sharedUser.name : null;
            pi.firstInstallTime = ps.firstInstallTime;
            pi.lastUpdateTime = ps.lastUpdateTime;
            ApplicationInfo ai = new ApplicationInfo();
            ai.packageName = ps.name;
            ai.uid = UserHandle.getUid(userId, ps.appId);
            ai.primaryCpuAbi = ps.primaryCpuAbiString;
            ai.secondaryCpuAbi = ps.secondaryCpuAbiString;
            ai.setVersionCode(ps.versionCode);
            ai.flags = ps.pkgFlags;
            ai.privateFlags = ps.pkgPrivateFlags;
            pi.applicationInfo = PackageParser.generateApplicationInfo(ai, flags2, state, userId);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "ps.pkg is n/a for [" + ps.name + "]. Provides a minimum info.");
            }
            return pi;
        }
    }

    public void checkPackageStartable(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            boolean userKeyUnlocked = StorageManager.isUserKeyUnlocked(userId);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new SecurityException("Package " + packageName + " was not found!");
                } else if (ps.getInstalled(userId)) {
                    if (this.mSafeMode) {
                        if (!ps.isSystem()) {
                            throw new SecurityException("Package " + packageName + " not a system app!");
                        }
                    }
                    if (this.mFrozenPackages.contains(packageName)) {
                        throw new SecurityException("Package " + packageName + " is currently frozen!");
                    } else if (!userKeyUnlocked) {
                        if (!ps.pkg.applicationInfo.isEncryptionAware()) {
                            throw new SecurityException("Package " + packageName + " is not encryption aware!");
                        }
                    }
                } else {
                    throw new SecurityException("Package " + packageName + " was not installed for user " + userId + "!");
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    public boolean isPackageAvailable(String packageName, int userId) {
        PackageUserState state;
        if (!sUserManager.exists(userId)) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "is package available");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return false;
                }
                if (!(ps == null || (state = ps.readUserState(userId)) == null)) {
                    return PackageParser.isAvailable(state);
                }
            }
            return false;
        }
    }

    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        if (OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).shouldFilterPackage(getNameForUid(Binder.getCallingUid()), packageName, userId)) {
            return null;
        }
        return getPackageInfoInternal(packageName, -1, flags, Binder.getCallingUid(), userId);
    }

    public PackageInfo getPackageInfoVersioned(VersionedPackage versionedPackage, int flags, int userId) {
        return getPackageInfoInternal(versionedPackage.getPackageName(), versionedPackage.getLongVersionCode(), flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private PackageInfo getPackageInfoInternal(String packageName, long versionCode, int flags, int filterCallingUid, int userId) {
        int userId2 = OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).getCorrectUserId(flags, userId, packageName);
        if (OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).shouldFilterPackageInfo(flags, userId2, packageName) || !sUserManager.exists(userId2)) {
            return null;
        }
        int flags2 = updateFlagsForPackage(flags, userId2, packageName);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId2, false, false, "get package info");
        synchronized (this.mPackages) {
            String packageName2 = resolveInternalPackageNameLPr(packageName, versionCode);
            boolean matchFactoryOnly = (2097152 & flags2) != 0;
            if (matchFactoryOnly) {
                if ((flags2 & 1073741824) != 0) {
                    return this.mApexManager.getPackageInfo(packageName2, 2);
                }
                PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(packageName2);
                if (ps != null) {
                    if (filterSharedLibPackageLPr(ps, filterCallingUid, userId2, flags2)) {
                        return null;
                    }
                    if (filterAppAccessLPr(ps, filterCallingUid, userId2)) {
                        return null;
                    }
                    return generatePackageInfo(ps, flags2, userId2);
                }
            }
            PackageParser.Package p = this.mPackages.get(packageName2);
            if (matchFactoryOnly && p != null && !isSystemApp(p)) {
                return null;
            }
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getPackageInfo " + packageName2 + ": " + p);
            }
            if (p != null) {
                PackageSetting ps2 = (PackageSetting) p.mExtras;
                if (filterSharedLibPackageLPr(ps2, filterCallingUid, userId2, flags2)) {
                    return null;
                }
                if (ps2 != null && filterAppAccessLPr(ps2, filterCallingUid, userId2)) {
                    return null;
                }
                return generatePackageInfo((PackageSetting) p.mExtras, flags2, userId2);
            } else if (!matchFactoryOnly && (4202496 & flags2) != 0) {
                PackageSetting ps3 = this.mSettings.mPackages.get(packageName2);
                if (ps3 == null) {
                    return null;
                }
                if (filterSharedLibPackageLPr(ps3, filterCallingUid, userId2, flags2)) {
                    return null;
                }
                if (filterAppAccessLPr(ps3, filterCallingUid, userId2)) {
                    return null;
                }
                return generatePackageInfo(ps3, flags2, userId2);
            } else if (matchFactoryOnly || (1073741824 & flags2) == 0) {
                return OppoFeatureCache.get(IColorFastAppManager.DEFAULT).getMiniProgramPkgInfoIfNeeded(packageName2);
            } else {
                return this.mApexManager.getPackageInfo(packageName2, 1);
            }
        }
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component) {
        if (!isComponentVisibleToInstantApp(component, 1) && !isComponentVisibleToInstantApp(component, 3) && !isComponentVisibleToInstantApp(component, 4)) {
            return false;
        }
        return true;
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component, int type) {
        if (type == 1) {
            PackageParser.Activity activity = this.mComponentResolver.getActivity(component);
            if (activity == null) {
                return false;
            }
            return ((1048576 & activity.info.flags) != 0) && ((2097152 & activity.info.flags) == 0);
        } else if (type == 2) {
            PackageParser.Activity activity2 = this.mComponentResolver.getReceiver(component);
            if (activity2 == null) {
                return false;
            }
            return ((1048576 & activity2.info.flags) != 0) && !((2097152 & activity2.info.flags) == 0);
        } else if (type == 3) {
            PackageParser.Service service = this.mComponentResolver.getService(component);
            return (service == null || (1048576 & service.info.flags) == 0) ? false : true;
        } else if (type == 4) {
            PackageParser.Provider provider = this.mComponentResolver.getProvider(component);
            return (provider == null || (1048576 & provider.info.flags) == 0) ? false : true;
        } else if (type == 0) {
            return isComponentVisibleToInstantApp(component);
        } else {
            return false;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, ComponentName component, int componentType, int userId) {
        if (Process.isIsolated(callingUid)) {
            callingUid = this.mIsolatedOwners.get(callingUid);
        }
        boolean callerIsInstantApp = getInstantAppPackageName(callingUid) != null;
        if (ps == null) {
            return callerIsInstantApp;
        }
        if (isCallerSameApp(ps.name, callingUid)) {
            return false;
        }
        if (callerIsInstantApp) {
            if (ps.getInstantApp(userId)) {
                return true;
            }
            if (component == null) {
                return !ps.pkg.visibleToInstantApps;
            }
            PackageParser.Instrumentation instrumentation = this.mInstrumentation.get(component);
            if (instrumentation == null || !isCallerSameApp(instrumentation.info.targetPackage, callingUid)) {
                return !isComponentVisibleToInstantApp(component, componentType);
            }
            return false;
        } else if (!ps.getInstantApp(userId) || canViewInstantApps(callingUid, userId)) {
            return false;
        } else {
            if (component != null) {
                return true;
            }
            return !this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, int userId) {
        return filterAppAccessLPr(ps, callingUid, null, 0, userId);
    }

    @GuardedBy({"mPackages"})
    private boolean filterSharedLibPackageLPr(PackageSetting ps, int uid, int userId, int flags) {
        int index;
        if ((flags & 67108864) != 0) {
            int appId = UserHandle.getAppId(uid);
            if (appId != 1000 && appId != 2000) {
                if (appId != 0) {
                    if (checkUidPermission("android.permission.INSTALL_PACKAGES", uid) == 0) {
                        return false;
                    }
                }
            }
            return false;
        }
        if (ps != null && ps.pkg != null) {
            if (ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(ps.pkg.staticSharedLibName, ps.pkg.staticSharedLibVersion);
                if (libraryInfo == null) {
                    return false;
                }
                String[] uidPackageNames = getPackagesForUid(UserHandle.getUid(userId, UserHandle.getAppId(uid)));
                if (uidPackageNames == null) {
                    return true;
                }
                for (String uidPackageName : uidPackageNames) {
                    if (ps.name.equals(uidPackageName)) {
                        return false;
                    }
                    PackageSetting uidPs = this.mSettings.getPackageLPr(uidPackageName);
                    if (uidPs != null && (index = ArrayUtils.indexOf(uidPs.usesStaticLibraries, libraryInfo.getName())) >= 0 && uidPs.pkg.usesStaticLibrariesVersions[index] == libraryInfo.getLongVersion()) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }

    public String[] currentToCanonicalPackageNames(String[] names) {
        boolean z;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            for (int i = names.length - 1; i >= 0; i--) {
                PackageSetting ps = this.mSettings.mPackages.get(names[i]);
                boolean translateName = false;
                if (!(ps == null || ps.realName == null)) {
                    if (ps.getInstantApp(callingUserId) && !canViewInstantApps) {
                        if (!this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                            z = false;
                            translateName = z;
                        }
                    }
                    z = true;
                    translateName = z;
                }
                out[i] = translateName ? ps.realName : names[i];
            }
        }
        return out;
    }

    public String[] canonicalToCurrentPackageNames(String[] names) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            boolean z = true;
            int i = names.length - 1;
            while (i >= 0) {
                String cur = this.mSettings.getRenamedPackageLPr(names[i]);
                boolean translateName = false;
                if (cur != null) {
                    PackageSetting ps = this.mSettings.mPackages.get(names[i]);
                    boolean z2 = false;
                    if (!((ps == null || !ps.getInstantApp(callingUserId)) ? false : z) || canViewInstantApps || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        z2 = true;
                    }
                    translateName = z2;
                }
                out[i] = translateName ? cur : names[i];
                i--;
                z = true;
            }
        }
        return out;
    }

    public int getPackageUid(String packageName, int flags, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageUid");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null || !p.isMatch(flags2)) {
                if ((4202496 & flags2) == 0 || (ps = this.mSettings.mPackages.get(packageName)) == null || !ps.isMatch(flags2) || filterAppAccessLPr(ps, callingUid, userId)) {
                    return -1;
                }
                return UserHandle.getUid(userId, ps.appId);
            } else if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, userId)) {
                return -1;
            } else {
                return UserHandle.getUid(userId, p.applicationInfo.uid);
            }
        }
    }

    private boolean hasTargetSdkInUidLowerThan(int uid, int higherTargetSDK) {
        int userId = UserHandle.getUserId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
            boolean z = false;
            if (obj == null) {
                return false;
            }
            if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (!ps.getInstalled(userId)) {
                    return false;
                }
                if (ps.pkg.applicationInfo.targetSdkVersion < higherTargetSDK) {
                    z = true;
                }
                return z;
            } else if (!(obj instanceof SharedUserSetting)) {
                return false;
            } else {
                SharedUserSetting sus = (SharedUserSetting) obj;
                int numPkgs = sus.packages.size();
                for (int i = 0; i < numPkgs; i++) {
                    PackageSetting ps2 = sus.packages.valueAt(i);
                    if (ps2.getInstalled(userId)) {
                        if (ps2.pkg.applicationInfo.targetSdkVersion < higherTargetSDK) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
    }

    public int[] getPackageGids(String packageName, int flags, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageGids");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null && p.isMatch(flags2)) {
                PackageSetting ps2 = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps2, callingUid, userId)) {
                    return null;
                }
                return ps2.getPermissionsState().computeGids(userId);
            } else if ((4202496 & flags2) == 0 || (ps = this.mSettings.mPackages.get(packageName)) == null || !ps.isMatch(flags2) || filterAppAccessLPr(ps, callingUid, userId)) {
                return null;
            } else {
                return ps.getPermissionsState().computeGids(userId);
            }
        }
    }

    public PermissionInfo getPermissionInfo(String name, String packageName, int flags) {
        return this.mPermissionManager.getPermissionInfo(name, packageName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionInfo> queryPermissionsByGroup(String groupName, int flags) {
        List<PermissionInfo> permissionList = this.mPermissionManager.getPermissionInfoByGroup(groupName, flags, getCallingUid());
        if (permissionList == null) {
            return null;
        }
        return new ParceledListSlice<>(permissionList);
    }

    public PermissionGroupInfo getPermissionGroupInfo(String groupName, int flags) {
        return this.mPermissionManager.getPermissionGroupInfo(groupName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionGroupInfo> getAllPermissionGroups(int flags) {
        List<PermissionGroupInfo> permissionList = this.mPermissionManager.getAllPermissionGroups(flags, getCallingUid());
        return permissionList == null ? ParceledListSlice.emptyList() : new ParceledListSlice<>(permissionList);
    }

    @GuardedBy({"mPackages"})
    private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int filterCallingUid, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId) || (ps = this.mSettings.mPackages.get(packageName)) == null || filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags) || filterAppAccessLPr(ps, filterCallingUid, userId)) {
            return null;
        }
        if (ps.pkg == null) {
            PackageInfo pInfo = generatePackageInfo(ps, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        ApplicationInfo ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
        if (ai != null) {
            ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
        }
        return ai;
    }

    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        return OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).fixApplicationInfo(getApplicationInfoInternal(packageName, flags, Binder.getCallingUid(), userId), packageName, flags);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ApplicationInfo getApplicationInfoInternal(String packageName, int flags, int filterCallingUid, int userId) {
        if (OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).shouldFilterPackageInfo(flags, userId, packageName) || !sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForApplication(flags, userId, packageName);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get application info");
        }
        synchronized (this.mPackages) {
            String packageName2 = resolveInternalPackageNameLPr(packageName, -1);
            PackageParser.Package p = this.mPackages.get(packageName2);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getApplicationInfo " + packageName2 + ": " + p);
            }
            if (p != null) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName2);
                if (ps == null) {
                    return null;
                }
                if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                    return null;
                }
                ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags2, ps.readUserState(userId), userId);
                if (ai != null) {
                    ai.packageName = resolveExternalPackageNameLPr(p);
                }
                return sPmsExt.updateApplicationInfoForRemovable(ai);
            }
            if (!PLATFORM_PACKAGE_NAME.equals(packageName2)) {
                if (!"system".equals(packageName2)) {
                    if ((4202496 & flags2) == 0) {
                        return null;
                    }
                    return sPmsExt.updateApplicationInfoForRemovable(generateApplicationInfoFromSettingsLPw(packageName2, flags2, filterCallingUid, userId));
                }
            }
            return this.mAndroidApplication;
        }
    }

    @GuardedBy({"mPackages"})
    private String normalizePackageNameLPr(String packageName) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        return normalizedPackageName != null ? normalizedPackageName : packageName;
    }

    public void deletePreloadsFileCache() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", "deletePreloadsFileCache");
        File dir = Environment.getDataPreloadsFileCacheDirectory();
        Slog.i(TAG, "Deleting preloaded file cache " + dir);
        FileUtils.deleteContents(dir);
    }

    public void freeStorageAndNotify(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", null);
        this.mHandler.post(new Runnable(volumeUuid, freeStorageSize, storageFlags, observer) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Iz1l7RVtATr5Ybl_zHeYuCbGMvA */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IPackageDataObserver f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$freeStorageAndNotify$1$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
            }
        });
    }

    public /* synthetic */ void lambda$freeStorageAndNotify$1$PackageManagerService(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted((String) null, success);
            } catch (RemoteException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", TAG);
        this.mHandler.post(new Runnable(volumeUuid, freeStorageSize, storageFlags, pi) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$gqdNHYJiYM0w_nIH0nGMWWU8yzQ */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IntentSender f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$freeStorage$2$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
            }
        });
    }

    public /* synthetic */ void lambda$freeStorage$2$PackageManagerService(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (pi != null) {
            try {
                pi.sendIntent(null, success ? 1 : 0, null, null, null);
            } catch (IntentSender.SendIntentException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
        long j;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File file = storage.findPathForUuid(volumeUuid);
        if (file.getUsableSpace() < bytes) {
            if (ENABLE_FREE_CACHE_V2) {
                boolean internalVolume = Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid);
                boolean aggressive = (storageFlags & 1) != 0;
                long reservedBytes = storage.getStorageCacheBytes(file, storageFlags);
                if (internalVolume && (aggressive || SystemProperties.getBoolean("persist.sys.preloads.file_cache_expired", false))) {
                    deletePreloadsFileCache();
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                if (internalVolume && aggressive) {
                    FileUtils.deleteContents(this.mCacheDir);
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                try {
                    this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 256);
                } catch (Installer.InstallerException e) {
                }
                if (file.getUsableSpace() < bytes) {
                    if (internalVolume && pruneUnusedStaticSharedLibraries(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "unused_static_shared_lib_min_cache_period", 7200000))) {
                        return;
                    }
                    if (!internalVolume || !this.mInstantAppRegistry.pruneInstalledInstantApps(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "installed_instant_app_min_cache_period", UnixCalendar.WEEK_IN_MILLIS))) {
                        try {
                            j = 604800000;
                            try {
                                this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 768);
                            } catch (Installer.InstallerException e2) {
                            }
                        } catch (Installer.InstallerException e3) {
                            j = 604800000;
                        }
                        if (file.getUsableSpace() < bytes) {
                            if (internalVolume && this.mInstantAppRegistry.pruneUninstalledInstantApps(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "uninstalled_instant_app_min_cache_period", j))) {
                                return;
                            }
                        } else {
                            return;
                        }
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else {
                try {
                    this.mInstaller.freeCache(volumeUuid, bytes, 0, 0);
                } catch (Installer.InstallerException e4) {
                }
                if (file.getUsableSpace() >= bytes) {
                    return;
                }
            }
            throw new IOException("Failed to free " + bytes + " on storage device at " + file);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:44:0x00db, code lost:
        if (r12 == null) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x00dd, code lost:
        r0 = r12.size();
        r7 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x00e3, code lost:
        if (r7 >= r0) goto L_0x010b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00e5, code lost:
        r8 = r12.get(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x00fd, code lost:
        if (deletePackageX(r8.getPackageName(), r8.getLongVersionCode(), 0, 2) != 1) goto L_0x0108;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0105, code lost:
        if (r9.getUsableSpace() < r21) goto L_0x0108;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0107, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0108, code lost:
        r7 = r7 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:?, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:?, code lost:
        return false;
     */
    private boolean pruneUnusedStaticSharedLibraries(long neededSpace, long maxCachePeriod) throws IOException {
        Throwable th;
        long now;
        int[] allUsers;
        StorageManager storage;
        long now2;
        StorageManager storage2;
        PackageManagerService packageManagerService = this;
        StorageManager storage3 = (StorageManager) packageManagerService.mContext.getSystemService(StorageManager.class);
        File volume = storage3.findPathForUuid(StorageManager.UUID_PRIVATE_INTERNAL);
        long now3 = System.currentTimeMillis();
        synchronized (packageManagerService.mPackages) {
            try {
                int[] allUsers2 = sUserManager.getUserIds();
                int libCount = packageManagerService.mSharedLibraries.size();
                int i = 0;
                List<VersionedPackage> packagesToDelete = null;
                while (i < libCount) {
                    try {
                        LongSparseArray<SharedLibraryInfo> versionedLib = packageManagerService.mSharedLibraries.valueAt(i);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            int j = 0;
                            while (true) {
                                if (j >= versionCount) {
                                    allUsers = allUsers2;
                                    storage = storage3;
                                    now = now3;
                                    break;
                                }
                                SharedLibraryInfo libInfo = versionedLib.valueAt(j);
                                if (!libInfo.isStatic()) {
                                    allUsers = allUsers2;
                                    storage = storage3;
                                    now = now3;
                                    break;
                                }
                                VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                String internalPackageName = packageManagerService.resolveInternalPackageNameLPr(declaringPackage.getPackageName(), declaringPackage.getLongVersionCode());
                                PackageSetting ps = packageManagerService.mSettings.getPackageLPr(internalPackageName);
                                if (ps != null) {
                                    storage2 = storage3;
                                    try {
                                        if (now3 - ps.lastUpdateTime < maxCachePeriod) {
                                            now2 = now3;
                                        } else if (ps.pkg.isSystem()) {
                                            now2 = now3;
                                        } else {
                                            if (packagesToDelete == null) {
                                                try {
                                                    packagesToDelete = new ArrayList<>();
                                                } catch (Throwable th2) {
                                                    th = th2;
                                                    while (true) {
                                                        try {
                                                            break;
                                                        } catch (Throwable th3) {
                                                            th = th3;
                                                        }
                                                    }
                                                    throw th;
                                                }
                                            }
                                            now2 = now3;
                                            packagesToDelete.add(new VersionedPackage(internalPackageName, declaringPackage.getLongVersionCode()));
                                        }
                                    } catch (Throwable th4) {
                                        th = th4;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                } else {
                                    storage2 = storage3;
                                    now2 = now3;
                                }
                                j++;
                                packageManagerService = this;
                                storage3 = storage2;
                                allUsers2 = allUsers2;
                                versionedLib = versionedLib;
                                now3 = now2;
                            }
                        } else {
                            allUsers = allUsers2;
                            storage = storage3;
                            now = now3;
                        }
                        i++;
                        packageManagerService = this;
                        storage3 = storage;
                        allUsers2 = allUsers;
                        now3 = now;
                    } catch (Throwable th5) {
                        th = th5;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            } catch (Throwable th6) {
                th = th6;
                while (true) {
                    break;
                }
                throw th;
            }
        }
    }

    private int updateFlags(int flags, int userId) {
        if ((flags & 786432) != 0) {
            return flags;
        }
        if (getUserManagerInternal().isUserUnlockingOrUnlocked(userId)) {
            return flags | 786432;
        }
        return flags | 524288;
    }

    private UserManagerInternal getUserManagerInternal() {
        if (this.mUserManagerInternal == null) {
            this.mUserManagerInternal = (UserManagerInternal) LocalServices.getService(UserManagerInternal.class);
        }
        return this.mUserManagerInternal;
    }

    private ActivityManagerInternal getActivityManagerInternal() {
        if (this.mActivityManagerInternal == null) {
            this.mActivityManagerInternal = (ActivityManagerInternal) LocalServices.getService(ActivityManagerInternal.class);
        }
        return this.mActivityManagerInternal;
    }

    private ActivityTaskManagerInternal getActivityTaskManagerInternal() {
        if (this.mActivityTaskManagerInternal == null) {
            this.mActivityTaskManagerInternal = (ActivityTaskManagerInternal) LocalServices.getService(ActivityTaskManagerInternal.class);
        }
        return this.mActivityTaskManagerInternal;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private DeviceIdleController.LocalService getDeviceIdleController() {
        if (this.mDeviceIdleController == null) {
            this.mDeviceIdleController = (DeviceIdleController.LocalService) LocalServices.getService(DeviceIdleController.LocalService.class);
        }
        return this.mDeviceIdleController;
    }

    private StorageManagerInternal getStorageManagerInternal() {
        if (this.mStorageManagerInternal == null) {
            this.mStorageManagerInternal = (StorageManagerInternal) LocalServices.getService(StorageManagerInternal.class);
        }
        return this.mStorageManagerInternal;
    }

    private int updateFlagsForPackage(int flags, int userId, Object cookie) {
        boolean isCallerSystemUser = UserHandle.getCallingUserId() == 0;
        if ((flags & DumpState.DUMP_CHANGES) != 0) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, !isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId), "MATCH_ANY_USER flag requires INTERACT_ACROSS_USERS permission at " + Debug.getCallers(5));
        } else if ((flags & 8192) != 0 && isCallerSystemUser && sUserManager.hasManagedProfile(0)) {
            flags |= DumpState.DUMP_CHANGES;
        }
        return updateFlags(flags, userId);
    }

    private int updateFlagsForApplication(int flags, int userId, Object cookie) {
        return updateFlagsForPackage(flags, userId, cookie);
    }

    private int updateFlagsForComponent(int flags, int userId, Object cookie) {
        return updateFlags(flags, userId);
    }

    private Intent updateIntentForResolve(Intent intent) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED) {
            intent.addFlags(8);
        }
        return intent;
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, false, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, wantInstantApps, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps, boolean onlyExposedExplicitly) {
        int flags2;
        if (this.mSafeMode) {
            flags |= 1048576;
        }
        if (getInstantAppPackageName(callingUid) != null) {
            if (onlyExposedExplicitly) {
                flags |= DumpState.DUMP_APEX;
            }
            flags2 = flags | DumpState.DUMP_SERVICE_PERMISSIONS | 8388608;
        } else {
            boolean allowMatchInstant = true;
            boolean wantMatchInstant = (flags & 8388608) != 0;
            if (!wantInstantApps && (!wantMatchInstant || !canViewInstantApps(callingUid, userId))) {
                allowMatchInstant = false;
            }
            flags2 = flags & -50331649;
            if (!allowMatchInstant) {
                flags2 &= -8388609;
            }
        }
        return updateFlagsForComponent(flags2, userId, intent);
    }

    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        return getActivityInfoInternal(component, flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ActivityInfo getActivityInfoInternal(ComponentName component, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForComponent(flags, userId, component);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get activity info");
        }
        synchronized (this.mPackages) {
            PackageParser.Activity a = this.mComponentResolver.getActivity(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getActivityInfo " + component + ": " + a);
            }
            int flags3 = OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).adjustFreezeAppFlags(flags2);
            if (a != null && this.mSettings.isEnabledAndMatchLPr(a.info, flags3, userId)) {
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, component, 1, userId)) {
                    return null;
                }
                return PackageParser.generateActivityInfo(a, flags3, ps.readUserState(userId), userId);
            } else if (!this.mResolveComponentName.equals(component)) {
                return null;
            } else {
                return PackageParser.generateActivityInfo(this.mResolveActivity, flags3, new PackageUserState(), userId);
            }
        }
    }

    private boolean isRecentsAccessingChildProfiles(int callingUid, int targetUserId) {
        if (!getActivityTaskManagerInternal().isCallerRecents(callingUid)) {
            return false;
        }
        long token = Binder.clearCallingIdentity();
        try {
            int callingUserId = UserHandle.getUserId(callingUid);
            if (ActivityManager.getCurrentUser() != callingUserId) {
                return false;
            }
            boolean isSameProfileGroup = sUserManager.isSameProfileGroup(callingUserId, targetUserId);
            Binder.restoreCallingIdentity(token);
            return isSameProfileGroup;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public boolean activitySupportsIntent(ComponentName component, Intent intent, String resolvedType) {
        synchronized (this.mPackages) {
            if (component.equals(this.mResolveComponentName)) {
                return true;
            }
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageParser.Activity a = this.mComponentResolver.getActivity(component);
            if (a == null) {
                return false;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return false;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 1, callingUserId)) {
                return false;
            }
            for (int i = 0; i < a.intents.size(); i++) {
                if (((PackageParser.ActivityIntentInfo) a.intents.get(i)).match(intent.getAction(), resolvedType, intent.getScheme(), intent.getData(), intent.getCategories(), TAG) >= 0) {
                    return true;
                }
            }
            return false;
        }
    }

    public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get receiver info");
        synchronized (this.mPackages) {
            PackageParser.Activity a = this.mComponentResolver.getReceiver(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getReceiverInfo " + component + ": " + a);
            }
            if (a == null || !this.mSettings.isEnabledAndMatchLPr(a.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 2, userId)) {
                return null;
            }
            return PackageParser.generateActivityInfo(a, flags2, ps.readUserState(userId), userId);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:15:0x0056, code lost:
        if (r30.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_SHARED_LIBRARIES") != 0) goto L_0x005f;
     */
    public ParceledListSlice<SharedLibraryInfo> getSharedLibraries(String packageName, int flags, int userId) {
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        ArrayList arrayList;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(userId, "userId must be >= 0");
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int flags2 = updateFlagsForPackage(flags, userId, null);
        boolean canSeeStaticLibraries = false;
        int i = 67108864;
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_PACKAGES") != 0) {
                if (!canRequestPackageInstallsInternal(packageName, 67108864, userId, false)) {
                    if (this.mContext.checkCallingOrSelfPermission("android.permission.REQUEST_DELETE_PACKAGES") != 0) {
                    }
                }
            }
        }
        canSeeStaticLibraries = true;
        synchronized (this.mPackages) {
            List<SharedLibraryInfo> result = null;
            int libCount = this.mSharedLibraries.size();
            int i2 = 0;
            while (i2 < libCount) {
                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.valueAt(i2);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    List<SharedLibraryInfo> result2 = result;
                    while (true) {
                        if (j >= versionCount) {
                            break;
                        }
                        SharedLibraryInfo libInfo = versionedLib.valueAt(j);
                        if (!canSeeStaticLibraries && libInfo.isStatic()) {
                            break;
                        }
                        long identity = Binder.clearCallingIdentity();
                        try {
                            if (getPackageInfoVersioned(libInfo.getDeclaringPackage(), flags2 | i, userId) != null) {
                                Binder.restoreCallingIdentity(identity);
                                String path = libInfo.getPath();
                                String packageName2 = libInfo.getPackageName();
                                List allCodePaths = libInfo.getAllCodePaths();
                                String name = libInfo.getName();
                                long longVersion = libInfo.getLongVersion();
                                int type = libInfo.getType();
                                VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                List<VersionedPackage> packagesUsingSharedLibraryLPr = getPackagesUsingSharedLibraryLPr(libInfo, flags2, userId);
                                if (libInfo.getDependencies() == null) {
                                    arrayList = null;
                                } else {
                                    arrayList = new ArrayList(libInfo.getDependencies());
                                }
                                SharedLibraryInfo resLibInfo = new SharedLibraryInfo(path, packageName2, allCodePaths, name, longVersion, type, declaringPackage, packagesUsingSharedLibraryLPr, arrayList);
                                if (result2 == null) {
                                    result2 = new ArrayList<>();
                                }
                                result2.add(resLibInfo);
                            }
                            j++;
                            i = 67108864;
                        } finally {
                            Binder.restoreCallingIdentity(identity);
                        }
                    }
                    result = result2;
                }
                i2++;
                i = 67108864;
            }
            parceledListSlice = result != null ? new ParceledListSlice<>(result) : null;
        }
        return parceledListSlice;
    }

    public ParceledListSlice<SharedLibraryInfo> getDeclaredSharedLibraries(String packageName, int flags, int userId) {
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        PackageManagerService packageManagerService = this;
        packageManagerService.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_SHARED_LIBRARIES", "getDeclaredSharedLibraries");
        int callingUid = Binder.getCallingUid();
        packageManagerService.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "getDeclaredSharedLibraries");
        Preconditions.checkNotNull(packageName, "packageName cannot be null");
        Preconditions.checkArgumentNonnegative(userId, "userId must be >= 0");
        ArrayList arrayList = null;
        if (!sUserManager.exists(userId) || packageManagerService.getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (packageManagerService.mPackages) {
            List<SharedLibraryInfo> result = null;
            int libraryCount = packageManagerService.mSharedLibraries.size();
            int i = 0;
            while (i < libraryCount) {
                LongSparseArray<SharedLibraryInfo> versionedLibrary = packageManagerService.mSharedLibraries.valueAt(i);
                if (versionedLibrary != null) {
                    int versionCount = versionedLibrary.size();
                    int j = 0;
                    List<SharedLibraryInfo> result2 = result;
                    while (j < versionCount) {
                        SharedLibraryInfo libraryInfo = versionedLibrary.valueAt(j);
                        VersionedPackage declaringPackage = libraryInfo.getDeclaringPackage();
                        if (Objects.equals(declaringPackage.getPackageName(), packageName)) {
                            long identity = Binder.clearCallingIdentity();
                            try {
                                if (packageManagerService.getPackageInfoVersioned(declaringPackage, 67108864 | flags, userId) != null) {
                                    Binder.restoreCallingIdentity(identity);
                                    String path = libraryInfo.getPath();
                                    String packageName2 = libraryInfo.getPackageName();
                                    List allCodePaths = libraryInfo.getAllCodePaths();
                                    String name = libraryInfo.getName();
                                    long longVersion = libraryInfo.getLongVersion();
                                    int type = libraryInfo.getType();
                                    VersionedPackage declaringPackage2 = libraryInfo.getDeclaringPackage();
                                    List<VersionedPackage> packagesUsingSharedLibraryLPr = packageManagerService.getPackagesUsingSharedLibraryLPr(libraryInfo, flags, userId);
                                    if (libraryInfo.getDependencies() != null) {
                                        arrayList = new ArrayList(libraryInfo.getDependencies());
                                    }
                                    SharedLibraryInfo resultLibraryInfo = new SharedLibraryInfo(path, packageName2, allCodePaths, name, longVersion, type, declaringPackage2, packagesUsingSharedLibraryLPr, arrayList);
                                    if (result2 == null) {
                                        result2 = new ArrayList<>();
                                    }
                                    result2.add(resultLibraryInfo);
                                }
                            } finally {
                                Binder.restoreCallingIdentity(identity);
                            }
                        }
                        j++;
                        arrayList = null;
                        packageManagerService = this;
                    }
                    result = result2;
                }
                i++;
                arrayList = null;
                packageManagerService = this;
            }
            parceledListSlice = result != null ? new ParceledListSlice<>(result) : null;
        }
        return parceledListSlice;
    }

    @GuardedBy({"mPackages"})
    private List<VersionedPackage> getPackagesUsingSharedLibraryLPr(SharedLibraryInfo libInfo, int flags, int userId) {
        List<VersionedPackage> versionedPackages = null;
        int packageCount = this.mSettings.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            PackageSetting ps = this.mSettings.mPackages.valueAt(i);
            if (ps != null && ps.readUserState(userId).isAvailable(flags)) {
                String libName = libInfo.getName();
                if (libInfo.isStatic()) {
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0 && ps.usesStaticLibrariesVersions[libIdx] == libInfo.getLongVersion()) {
                        if (versionedPackages == null) {
                            versionedPackages = new ArrayList<>();
                        }
                        String dependentPackageName = ps.name;
                        if (ps.pkg != null && ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                            dependentPackageName = ps.pkg.manifestPackageName;
                        }
                        versionedPackages.add(new VersionedPackage(dependentPackageName, ps.versionCode));
                    }
                } else if (ps.pkg != null && (ArrayUtils.contains(ps.pkg.usesLibraries, libName) || ArrayUtils.contains(ps.pkg.usesOptionalLibraries, libName))) {
                    if (versionedPackages == null) {
                        versionedPackages = new ArrayList<>();
                    }
                    versionedPackages.add(new VersionedPackage(ps.name, ps.versionCode));
                }
            }
        }
        return versionedPackages;
    }

    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get service info");
        synchronized (this.mPackages) {
            PackageParser.Service s = this.mComponentResolver.getService(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getServiceInfo " + component + ": " + s);
            }
            if (s == null || !this.mSettings.isEnabledAndMatchLPr(s.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 3, userId)) {
                return null;
            }
            return OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).fixServiceInfo(PackageParser.generateServiceInfo(s, flags2, ps.readUserState(userId), userId), userId, callingUid, s, flags2, ps);
        }
    }

    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get provider info");
        synchronized (this.mPackages) {
            PackageParser.Provider p = this.mComponentResolver.getProvider(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getProviderInfo " + component + ": " + p);
            }
            if (p == null || !this.mSettings.isEnabledAndMatchLPr(p.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 4, userId)) {
                return null;
            }
            return PackageParser.generateProviderInfo(p, flags2, ps.readUserState(userId), userId);
        }
    }

    public ModuleInfo getModuleInfo(String packageName, int flags) {
        return this.mModuleInfoProvider.getModuleInfo(packageName, flags);
    }

    public List<ModuleInfo> getInstalledModules(int flags) {
        return this.mModuleInfoProvider.getInstalledModules(flags);
    }

    public String[] getSystemSharedLibraryNames() {
        synchronized (this.mPackages) {
            Set<String> libs = null;
            int libCount = this.mSharedLibraries.size();
            for (int i = 0; i < libCount; i++) {
                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.valueAt(i);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    while (true) {
                        if (j >= versionCount) {
                            break;
                        }
                        SharedLibraryInfo libraryInfo = versionedLib.valueAt(j);
                        if (!libraryInfo.isStatic()) {
                            if (libs == null) {
                                libs = new ArraySet<>();
                            }
                            libs.add(libraryInfo.getName());
                        } else {
                            PackageSetting ps = this.mSettings.getPackageLPr(libraryInfo.getPackageName());
                            if (ps == null || filterSharedLibPackageLPr(ps, Binder.getCallingUid(), UserHandle.getUserId(Binder.getCallingUid()), 67108864)) {
                                j++;
                            } else {
                                if (libs == null) {
                                    libs = new ArraySet<>();
                                }
                                libs.add(libraryInfo.getName());
                            }
                        }
                    }
                }
            }
            if (libs == null) {
                return null;
            }
            String[] libsArray = new String[libs.size()];
            libs.toArray(libsArray);
            return libsArray;
        }
    }

    public String getServicesSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mServicesSystemSharedLibraryPackageName;
        }
        return str;
    }

    public String getSharedSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mSharedSystemSharedLibraryPackageName;
        }
        return str;
    }

    @GuardedBy({"mPackages"})
    private void updateSequenceNumberLP(PackageSetting pkgSetting, int[] userList) {
        for (int i = userList.length - 1; i >= 0; i--) {
            int userId = userList[i];
            if (!pkgSetting.getInstantApp(userId)) {
                SparseArray<String> changedPackages = this.mChangedPackages.get(userId);
                if (changedPackages == null) {
                    changedPackages = new SparseArray<>();
                    this.mChangedPackages.put(userId, changedPackages);
                }
                Map<String, Integer> sequenceNumbers = this.mChangedPackagesSequenceNumbers.get(userId);
                if (sequenceNumbers == null) {
                    sequenceNumbers = new HashMap();
                    this.mChangedPackagesSequenceNumbers.put(userId, sequenceNumbers);
                }
                Integer sequenceNumber = sequenceNumbers.get(pkgSetting.name);
                if (sequenceNumber != null) {
                    changedPackages.remove(sequenceNumber.intValue());
                }
                changedPackages.put(this.mChangedPackagesSequenceNumber, pkgSetting.name);
                sequenceNumbers.put(pkgSetting.name, Integer.valueOf(this.mChangedPackagesSequenceNumber));
            }
        }
        this.mChangedPackagesSequenceNumber++;
    }

    public ChangedPackages getChangedPackages(int sequenceNumber, int userId) {
        ChangedPackages changedPackages = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (sequenceNumber >= this.mChangedPackagesSequenceNumber) {
                return null;
            }
            SparseArray<String> changedPackages2 = this.mChangedPackages.get(userId);
            if (changedPackages2 == null) {
                return null;
            }
            List<String> packageNames = new ArrayList<>(this.mChangedPackagesSequenceNumber - sequenceNumber);
            for (int i = sequenceNumber; i < this.mChangedPackagesSequenceNumber; i++) {
                String packageName = changedPackages2.get(i);
                if (packageName != null) {
                    packageNames.add(packageName);
                }
            }
            if (!packageNames.isEmpty()) {
                changedPackages = new ChangedPackages(this.mChangedPackagesSequenceNumber, packageNames);
            }
            return changedPackages;
        }
    }

    public ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {
        ArrayList<FeatureInfo> res;
        synchronized (this.mAvailableFeatures) {
            res = new ArrayList<>(this.mAvailableFeatures.size() + 1);
            res.addAll(this.mAvailableFeatures.values());
        }
        FeatureInfo fi = new FeatureInfo();
        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", 0);
        res.add(fi);
        return new ParceledListSlice<>(res);
    }

    public boolean hasSystemFeature(String name, int version) {
        synchronized (this.mAvailableFeatures) {
            FeatureInfo feat = this.mAvailableFeatures.get(name);
            boolean z = false;
            if (feat == null) {
                return false;
            }
            if (feat.version >= version) {
                z = true;
            }
            return z;
        }
    }

    public int checkPermission(String permName, String pkgName, int userId) {
        synchronized (this.mPackages) {
            if (this.mCheckPermissionDelegate == null) {
                return checkPermissionImpl(permName, pkgName, userId);
            }
            return this.mCheckPermissionDelegate.checkPermission(permName, pkgName, userId, new TriFunction() {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$b2Z8hEDt0dbtmX9ytdWFgSa9tc */

                public final Object apply(Object obj, Object obj2, Object obj3) {
                    return Integer.valueOf(PackageManagerService.this.checkPermissionImpl((String) obj, (String) obj2, ((Integer) obj3).intValue()));
                }
            });
        }
    }

    /* access modifiers changed from: private */
    public int checkPermissionImpl(String permName, String pkgName, int userId) {
        return this.mPermissionManager.checkPermission(permName, pkgName, getCallingUid(), userId);
    }

    public int checkUidPermission(String permName, int uid) {
        CtaManagerFactory.getInstance().makeCtaManager().reportPermRequestUsage(permName, uid);
        if (DEBUG_PERMISSIONS) {
            Slog.i(TAG, permName + " UID =" + uid);
        }
        synchronized (this.mPackages) {
            if (this.mCheckPermissionDelegate == null) {
                return checkUidPermissionImpl(permName, uid);
            }
            return this.mCheckPermissionDelegate.checkUidPermission(permName, uid, new BiFunction() {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$XJQWfaGM1EYfvHM2L3JN55XapIQ */

                @Override // java.util.function.BiFunction
                public final Object apply(Object obj, Object obj2) {
                    return Integer.valueOf(PackageManagerService.this.checkUidPermissionImpl((String) obj, ((Integer) obj2).intValue()));
                }
            });
        }
    }

    /* access modifiers changed from: private */
    public int checkUidPermissionImpl(String permName, int uid) {
        synchronized (this.mPackages) {
            if (OppoPackageManagerHelper.revokeShellPermission(this.mContext, permName, uid)) {
                return -1;
            }
            String[] packageNames = getPackagesForUid(uid);
            PackageParser.Package pkg = null;
            int N = packageNames == null ? 0 : packageNames.length;
            int i = 0;
            while (pkg == null && i < N) {
                pkg = this.mPackages.get(packageNames[i]);
                i++;
            }
            return this.mPermissionManager.checkUidPermission(permName, pkg, uid, getCallingUid());
        }
    }

    public boolean isPermissionRevokedByPolicy(String permission, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "isPermissionRevokedByPolicy for user " + userId);
        }
        boolean z = false;
        if (checkPermission(permission, packageName, userId) == 0) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            if (!isCallerSameApp(packageName, callingUid)) {
                return false;
            }
        } else if (isInstantApp(packageName, userId)) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            if ((getPermissionFlags(permission, packageName, userId) & 4) != 0) {
                z = true;
            }
            return z;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public String getPermissionControllerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredPermissionControllerPackage;
        }
        return str;
    }

    /* access modifiers changed from: package-private */
    public String getPackageInstallerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredInstallerPackage;
        }
        return str;
    }

    public boolean inCptWhiteList(int type, String verifyStr) {
        return mCompatibilityHelper.isInWhiteList(type, verifyStr);
    }

    public List<String> getCptListByType(int tag) {
        return mCompatibilityHelper.getCptListByType(tag);
    }

    public void sendCptUpload(String pkgName, String point) {
        PackageInfo pkgInfo = getPackageInfo(pkgName, 0, this.mContext.getUserId());
        if (mCompatibilityHelper.getUploader() != null) {
            mCompatibilityHelper.getUploader().sendToUploadCpt(pkgInfo, point);
        }
    }

    public void sendMapCommonDcsUpload(String logTag, String eventId, Map data) {
        CommonDcsUploader commonDcsUploader = mDcsUploader;
        if (commonDcsUploader != null) {
            commonDcsUploader.sendToCommonDcsUpload(logTag, eventId, data);
        }
    }

    private boolean addDynamicPermission(PermissionInfo info, final boolean async) {
        return this.mPermissionManager.addDynamicPermission(info, async, getCallingUid(), new PermissionManagerServiceInternal.PermissionCallback() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass4 */

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionChanged() {
                if (!async) {
                    PackageManagerService.this.mSettings.writeLPr();
                } else {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }
        });
    }

    public boolean addPermission(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, false);
        }
        return addDynamicPermission;
    }

    public boolean addPermissionAsync(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, true);
        }
        return addDynamicPermission;
    }

    public void removePermission(String permName) {
        this.mPermissionManager.removeDynamicPermission(permName, getCallingUid(), this.mPermissionCallback);
    }

    public void grantRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.grantRuntimePermission(permName, packageName, checkUidPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", Binder.getCallingUid()) == 0, getCallingUid(), userId, this.mPermissionCallback);
    }

    public void revokeRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.revokeRuntimePermission(permName, packageName, checkUidPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", Binder.getCallingUid()) == 0, userId, this.mPermissionCallback);
    }

    public void resetRuntimePermissions() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS", "revokeRuntimePermission");
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 1000 || callingUid == 0)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "resetRuntimePermissions");
        }
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
            int[] userIds = UserManagerService.getInstance().getUserIds();
            for (int userId : userIds) {
                int packageCount = this.mPackages.size();
                for (int i = 0; i < packageCount; i++) {
                    PackageParser.Package pkg = this.mPackages.valueAt(i);
                    if (pkg.mExtras instanceof PackageSetting) {
                        resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
                    }
                }
            }
        }
    }

    public int getPermissionFlags(String permName, String packageName, int userId) {
        return this.mPermissionManager.getPermissionFlags(permName, packageName, getCallingUid(), userId);
    }

    public void updatePermissionFlags(String permName, String packageName, int flagMask, int flagValues, boolean checkAdjustPolicyFlagPermission, int userId) {
        boolean overridePolicy;
        int callingUid = getCallingUid();
        boolean overridePolicy2 = false;
        if (callingUid == 1000 || callingUid == 0) {
            overridePolicy = false;
        } else {
            long callingIdentity = Binder.clearCallingIdentity();
            if ((flagMask & 4) != 0) {
                if (checkAdjustPolicyFlagPermission) {
                    try {
                        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "Need android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY to change policy flags");
                    } catch (Throwable th) {
                        Binder.restoreCallingIdentity(callingIdentity);
                        throw th;
                    }
                } else if (!hasTargetSdkInUidLowerThan(callingUid, 29)) {
                    throw new IllegalArgumentException("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY needs  to be checked for packages targeting 29 or later when changing policy flags");
                }
                overridePolicy2 = true;
            }
            Binder.restoreCallingIdentity(callingIdentity);
            overridePolicy = overridePolicy2;
        }
        this.mPermissionManager.updatePermissionFlags(permName, packageName, flagMask, flagValues, callingUid, userId, overridePolicy, this.mPermissionCallback);
    }

    public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
        synchronized (this.mPackages) {
            if (this.mPermissionManager.updatePermissionFlagsForAllApps(flagMask, flagValues, getCallingUid(), userId, this.mPackages.values(), this.mPermissionCallback)) {
                this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }
    }

    public List<String> getWhitelistedRestrictedPermissions(String packageName, int whitelistFlags, int userId) {
        Preconditions.checkNotNull(packageName);
        Preconditions.checkFlagsArgument(whitelistFlags, 7);
        Preconditions.checkArgumentNonNegative((float) userId, (String) null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS", "getWhitelistedRestrictedPermissions for user " + userId);
        }
        synchronized (this.mPackages) {
            PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
            if (packageSetting == null) {
                Slog.w(TAG, "Unknown package: " + packageName);
                return null;
            }
            PackageParser.Package pkg = packageSetting.pkg;
            boolean isCallerInstallerOnRecord = false;
            boolean isCallerPrivileged = this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") == 0;
            PackageSetting installerPackageSetting = this.mSettings.mPackages.get(packageSetting.installerPackageName);
            if (installerPackageSetting != null && UserHandle.isSameApp(installerPackageSetting.appId, Binder.getCallingUid())) {
                isCallerInstallerOnRecord = true;
            }
            if ((whitelistFlags & 1) != 0) {
                if (!isCallerPrivileged) {
                    throw new SecurityException("Querying system whitelist requires android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if ((whitelistFlags & 6) != 0 && !isCallerPrivileged) {
                if (!isCallerInstallerOnRecord) {
                    throw new SecurityException("Querying upgrade or installer whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if (filterAppAccessLPr(packageSetting, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return null;
            }
            long identity = Binder.clearCallingIdentity();
            try {
                return this.mPermissionManager.getWhitelistedRestrictedPermissions(pkg, whitelistFlags, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public boolean addWhitelistedRestrictedPermission(String packageName, String permission, int whitelistFlags, int userId) {
        Preconditions.checkNotNull(permission);
        if (!checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(permission)) {
            return false;
        }
        List<String> permissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlags, userId);
        if (permissions == null) {
            permissions = new ArrayList(1);
        }
        if (permissions.indexOf(permission) >= 0) {
            return false;
        }
        permissions.add(permission);
        return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlags, userId);
    }

    private boolean checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(String permission) {
        synchronized (this.mPackages) {
            BasePermission bp = this.mPermissionManager.getPermissionTEMP(permission);
            if (bp == null) {
                Slog.w(TAG, "No such permissions: " + permission);
                return false;
            }
            if (bp.isHardOrSoftRestricted() && bp.isImmutablyRestricted()) {
                if (this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") != 0) {
                    throw new SecurityException("Cannot modify whitelisting of an immutably restricted permission: " + permission);
                }
            }
            return true;
        }
    }

    public boolean removeWhitelistedRestrictedPermission(String packageName, String permission, int whitelistFlags, int userId) {
        List<String> permissions;
        Preconditions.checkNotNull(permission);
        if (checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(permission) && (permissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlags, userId)) != null && permissions.remove(permission)) {
            return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlags, userId);
        }
        return false;
    }

    private boolean setWhitelistedRestrictedPermissions(String packageName, List<String> permissions, int whitelistFlag, int userId) {
        Preconditions.checkNotNull(packageName);
        Preconditions.checkFlagsArgument(whitelistFlag, 7);
        Preconditions.checkArgument(Integer.bitCount(whitelistFlag) == 1);
        Preconditions.checkArgumentNonNegative((float) userId, (String) null);
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS", "setWhitelistedRestrictedPermissions for user " + userId);
        }
        synchronized (this.mPackages) {
            PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
            if (packageSetting == null) {
                Slog.w(TAG, "Unknown package: " + packageName);
                return false;
            }
            PackageParser.Package pkg = packageSetting.pkg;
            boolean isCallerPrivileged = this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") == 0;
            PackageSetting installerPackageSetting = this.mSettings.mPackages.get(packageSetting.installerPackageName);
            boolean isCallerInstallerOnRecord = installerPackageSetting != null && UserHandle.isSameApp(installerPackageSetting.appId, Binder.getCallingUid());
            if ((whitelistFlag & 1) != 0) {
                if (!isCallerPrivileged) {
                    throw new SecurityException("Modifying system whitelist requires android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if ((whitelistFlag & 4) != 0) {
                if (!isCallerPrivileged) {
                    if (!isCallerInstallerOnRecord) {
                        throw new SecurityException("Modifying upgrade whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                    }
                }
                List<String> whitelistedPermissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlag, userId);
                if (permissions != null) {
                    if (!permissions.isEmpty()) {
                        int permissionCount = permissions.size();
                        for (int i = 0; i < permissionCount; i++) {
                            if ((whitelistedPermissions == null || !whitelistedPermissions.contains(permissions.get(i))) && !isCallerPrivileged) {
                                throw new SecurityException("Adding to upgrade whitelist requiresandroid.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                            }
                        }
                    }
                }
                if (whitelistedPermissions == null || whitelistedPermissions.isEmpty()) {
                    return true;
                }
            }
            if ((whitelistFlag & 2) != 0 && !isCallerPrivileged) {
                if (!isCallerInstallerOnRecord) {
                    throw new SecurityException("Modifying installer whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if (filterAppAccessLPr(packageSetting, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            long identity = Binder.clearCallingIdentity();
            try {
                this.mPermissionManager.setWhitelistedRestrictedPermissions(pkg, new int[]{userId}, permissions, Process.myUid(), whitelistFlag, this.mPermissionCallback);
                return true;
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    /* JADX INFO: finally extract failed */
    public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "canShowRequestPermissionRationale for user " + userId);
        }
        if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(getPackageUid(packageName, 268435456, userId)) || checkPermission(permissionName, packageName, userId) == 0) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            int flags = getPermissionFlags(permissionName, packageName, userId);
            Binder.restoreCallingIdentity(identity);
            if ((flags & 22) == 0 && (flags & 1) != 0) {
                return true;
            }
            return false;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
            throw th;
        }
    }

    public void addOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS", "addOnPermissionsChangeListener");
        synchronized (this.mPackages) {
            this.mOnPermissionChangeListeners.addListenerLocked(listener);
        }
    }

    public void removeOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                this.mOnPermissionChangeListeners.removeListenerLocked(listener);
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    public boolean isProtectedBroadcast(String actionName) {
        synchronized (this.mProtectedBroadcasts) {
            if (this.mProtectedBroadcasts.contains(actionName)) {
                return true;
            }
            if (actionName == null || (!actionName.startsWith("android.net.netmon.lingerExpired") && !actionName.startsWith("com.android.server.sip.SipWakeupTimer") && !actionName.startsWith("com.android.internal.telephony.data-reconnect") && !actionName.startsWith("android.net.netmon.launchCaptivePortalApp"))) {
                return false;
            }
            return true;
        }
    }

    public int checkSignatures(String pkg1, String pkg2) {
        synchronized (this.mPackages) {
            PackageParser.Package p1 = this.mPackages.get(pkg1);
            PackageParser.Package p2 = this.mPackages.get(pkg2);
            if (!(p1 == null || p1.mExtras == null || p2 == null)) {
                if (p2.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    int callingUserId = UserHandle.getUserId(callingUid);
                    PackageSetting ps2 = (PackageSetting) p2.mExtras;
                    if (!filterAppAccessLPr((PackageSetting) p1.mExtras, callingUid, callingUserId)) {
                        if (!filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                            return PackageManagerServiceUtils.compareSignatures(p1.mSigningDetails.signatures, p2.mSigningDetails.signatures);
                        }
                    }
                    return -4;
                }
            }
            return -4;
        }
    }

    public int checkUidSignatures(int uid1, int uid2) {
        Signature[] s1;
        Signature[] s2;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int appId1 = UserHandle.getAppId(uid1);
        int appId2 = UserHandle.getAppId(uid2);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId1);
            if (obj == null) {
                return -4;
            }
            if (obj instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s1 = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
            } else if (!(obj instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return -4;
                }
                s1 = ps.signatures.mSigningDetails.signatures;
            }
            Object obj2 = this.mSettings.getSettingLPr(appId2);
            if (obj2 == null) {
                return -4;
            }
            if (obj2 instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s2 = ((SharedUserSetting) obj2).signatures.mSigningDetails.signatures;
            } else if (!(obj2 instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps2 = (PackageSetting) obj2;
                if (filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                    return -4;
                }
                s2 = ps2.signatures.mSigningDetails.signatures;
            }
            return PackageManagerServiceUtils.compareSignatures(s1, s2);
        }
    }

    public boolean hasSigningCertificate(String packageName, byte[] certificate, int type) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                if (p.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                        return false;
                    }
                    if (type == 0) {
                        return p.mSigningDetails.hasCertificate(certificate);
                    } else if (type != 1) {
                        return false;
                    } else {
                        return p.mSigningDetails.hasSha256Certificate(certificate);
                    }
                }
            }
            return false;
        }
    }

    public boolean hasUidSigningCertificate(int uid, byte[] certificate, int type) {
        PackageParser.SigningDetails signingDetails;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj == null) {
                return false;
            }
            if (obj instanceof SharedUserSetting) {
                if (getInstantAppPackageName(callingUid) != null) {
                    return false;
                }
                signingDetails = ((SharedUserSetting) obj).signatures.mSigningDetails;
            } else if (!(obj instanceof PackageSetting)) {
                return false;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return false;
                }
                signingDetails = ps.signatures.mSigningDetails;
            }
            if (type == 0) {
                return signingDetails.hasCertificate(certificate);
            } else if (type != 1) {
                return false;
            } else {
                return signingDetails.hasSha256Certificate(certificate);
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void killUid(int appId, int userId, String reason) {
        long identity = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killUid(appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private boolean isCompatSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return isCompatSignatureUpdateNeeded(getSettingsVersionForPackage(scannedPkg));
    }

    private static boolean isCompatSignatureUpdateNeeded(Settings.VersionInfo ver) {
        return ver.databaseVersion < 2;
    }

    private boolean isRecoverSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return isRecoverSignatureUpdateNeeded(getSettingsVersionForPackage(scannedPkg));
    }

    private static boolean isRecoverSignatureUpdateNeeded(Settings.VersionInfo ver) {
        return ver.databaseVersion < 3;
    }

    public List<String> getAllPackages() {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            if (canViewInstantApps(callingUid, callingUserId)) {
                return new ArrayList(this.mPackages.keySet());
            }
            String instantAppPkgName = getInstantAppPackageName(callingUid);
            List<String> result = new ArrayList<>();
            if (instantAppPkgName != null) {
                for (PackageParser.Package pkg : this.mPackages.values()) {
                    if (pkg.visibleToInstantApps) {
                        result.add(pkg.packageName);
                    }
                }
            } else {
                for (PackageParser.Package pkg2 : this.mPackages.values()) {
                    PackageSetting ps = pkg2.mExtras != null ? (PackageSetting) pkg2.mExtras : null;
                    if (ps == null || !ps.getInstantApp(callingUserId) || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        result.add(pkg2.packageName);
                    }
                }
            }
            return result;
        }
    }

    public String[] getPackagesForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        int i = 0;
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int userId = UserHandle.getUserId(uid);
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (!(obj instanceof SharedUserSetting)) {
                if (obj instanceof PackageSetting) {
                    PackageSetting ps = (PackageSetting) obj;
                    if (ps.getInstalled(userId) && !filterAppAccessLPr(ps, callingUid, userId)) {
                        return new String[]{ps.name};
                    }
                }
                return null;
            } else if (isCallerInstantApp) {
                return null;
            } else {
                SharedUserSetting sus = (SharedUserSetting) obj;
                String[] res = new String[sus.packages.size()];
                Iterator<PackageSetting> it = sus.packages.iterator();
                while (it.hasNext()) {
                    PackageSetting ps2 = it.next();
                    if (ps2.getInstalled(userId)) {
                        res[i] = ps2.name;
                        i++;
                    } else {
                        res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                    }
                }
                return res;
            }
        }
    }

    public String getNameForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                SharedUserSetting sus = (SharedUserSetting) obj;
                return sus.name + ":" + sus.userId;
            } else if (!(obj instanceof PackageSetting)) {
                return null;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return null;
                }
                return ps.name;
            }
        }
    }

    public String[] getNamesForUids(int[] uids) {
        if (uids == null || uids.length == 0) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        String[] names = new String[uids.length];
        synchronized (this.mPackages) {
            for (int i = uids.length - 1; i >= 0; i--) {
                Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uids[i]));
                if (obj instanceof SharedUserSetting) {
                    names[i] = "shared:" + ((SharedUserSetting) obj).name;
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = (PackageSetting) obj;
                    if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                        names[i] = null;
                    } else {
                        names[i] = ps.name;
                    }
                } else {
                    names[i] = null;
                }
            }
        }
        return names;
    }

    public int getUidForSharedUser(String sharedUserName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || sharedUserName == null) {
            return -1;
        }
        synchronized (this.mPackages) {
            try {
                SharedUserSetting suid = this.mSettings.getSharedUserLPw(sharedUserName, 0, 0, false);
                if (suid == null) {
                    return -1;
                }
                return suid.userId;
            } catch (PackageManagerException e) {
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public int getFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                return ((SharedUserSetting) obj).pkgFlags;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                return ps.pkgFlags;
            }
        }
    }

    public int getPrivateFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                return ((SharedUserSetting) obj).pkgPrivateFlags;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                return ps.pkgPrivateFlags;
            }
        }
    }

    public boolean isUidPrivileged(int uid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
                while (it.hasNext()) {
                    if (it.next().isPrivileged()) {
                        return true;
                    }
                }
            } else if (obj instanceof PackageSetting) {
                return ((PackageSetting) obj).isPrivileged();
            }
            return false;
        }
    }

    public String[] getAppOpPermissionPackages(String permName) {
        return this.mPermissionManager.getAppOpPermissionPackages(permName);
    }

    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        return OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).fixResolveInfo(resolveIntentInternal(intent, resolvedType, flags, userId, false, Binder.getCallingUid()), userId, intent, resolvedType, flags, false, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ResolveInfo resolveIntentInternal(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
        Throwable th;
        try {
            Trace.traceBegin(262144, "resolveIntent");
            if (!sUserManager.exists(userId)) {
                Trace.traceEnd(262144);
                return null;
            }
            int callingUid = Binder.getCallingUid();
            int flags2 = updateFlagsForResolve(flags, userId, intent, filterCallingUid, resolveForStart);
            try {
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "resolve intent");
                Trace.traceBegin(262144, "queryIntentActivities");
                List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags2, filterCallingUid, userId, resolveForStart, true);
                Trace.traceEnd(262144);
                ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags2, query, userId);
                Trace.traceEnd(262144);
                return bestChoice;
            } catch (Throwable th2) {
                th = th2;
                Trace.traceEnd(262144);
                throw th;
            }
        } catch (Throwable th3) {
            th = th3;
            Trace.traceEnd(262144);
            throw th;
        }
    }

    public ResolveInfo findPersistentPreferredActivity(Intent intent, int userId) {
        ResolveInfo findPersistentPreferredActivityLP;
        if (!UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            throw new SecurityException("findPersistentPreferredActivity can only be run by the system");
        } else if (!sUserManager.exists(userId)) {
            return null;
        } else {
            int callingUid = Binder.getCallingUid();
            Intent intent2 = updateIntentForResolve(intent);
            String resolvedType = intent2.resolveTypeIfNeeded(this.mContext.getContentResolver());
            int flags = updateFlagsForResolve(0, userId, intent2, callingUid, false);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent2, resolvedType, flags, userId);
            synchronized (this.mPackages) {
                findPersistentPreferredActivityLP = findPersistentPreferredActivityLP(intent2, resolvedType, flags, query, false, userId);
            }
            return findPersistentPreferredActivityLP;
        }
    }

    public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            int userId = UserHandle.getCallingUserId();
            if (DEBUG_PREFERRED) {
                Log.v(TAG, "setLastChosenActivity intent=" + intent + " resolvedType=" + resolvedType + " flags=" + flags + " filter=" + filter + " match=" + match + " activity=" + activity);
                filter.dump(new PrintStreamPrinter(System.out), "    ");
            }
            intent.setComponent(null);
            findPreferredActivityNotLocked(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, true, false, userId);
            addPreferredActivityInternal(filter, match, null, activity, false, userId, "Setting last chosen");
        }
    }

    public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int userId = UserHandle.getCallingUserId();
        if (DEBUG_PREFERRED) {
            Log.v(TAG, "Querying last chosen activity for " + intent);
        }
        return findPreferredActivityNotLocked(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, false, false, userId);
    }

    private boolean areWebInstantAppsDisabled(int userId) {
        return this.mWebInstantAppsDisabled.get(userId);
    }

    private boolean isInstantAppResolutionAllowed(Intent intent, List<ResolveInfo> resolvedActivities, int userId, boolean skipPackageCheck) {
        int status;
        if (this.mInstantAppResolverConnection == null || this.mInstantAppInstallerActivity == null || intent.getComponent() != null || (intent.getFlags() & 512) != 0) {
            return false;
        }
        if (!(skipPackageCheck || intent.getPackage() == null)) {
            return false;
        }
        if (!intent.isWebIntent()) {
            if (!(resolvedActivities == null || resolvedActivities.size() == 0) || (intent.getFlags() & 2048) == 0) {
                return false;
            }
        } else if (intent.getData() == null || TextUtils.isEmpty(intent.getData().getHost()) || areWebInstantAppsDisabled(userId)) {
            return false;
        }
        synchronized (this.mPackages) {
            int count = resolvedActivities == null ? 0 : resolvedActivities.size();
            for (int n = 0; n < count; n++) {
                ResolveInfo info = resolvedActivities.get(n);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    if (!info.handleAllWebDataURI && ((status = (int) (getDomainVerificationStatusLPr(ps, userId) >> 32)) == 2 || status == 4)) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "DENY instant app; pkg: " + packageName + ", status: " + status);
                        }
                        return false;
                    } else if (ps.getInstantApp(userId)) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "DENY instant app installed; pkg: " + packageName);
                        }
                        return false;
                    }
                }
            }
            return true;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(20, new InstantAppRequest(responseObj, origIntent, resolvedType, callingPackage, userId, verificationBundle, false)));
    }

    private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
        int i;
        boolean z;
        if (query != null) {
            int N = query.size();
            if (N == 1) {
                return query.get(0);
            }
            if (N > 1) {
                boolean debug = (intent.getFlags() & 8) != 0;
                ResolveInfo r0 = query.get(0);
                ResolveInfo r1 = query.get(1);
                if (DEBUG_INTENT_MATCHING || debug) {
                    Slog.v(TAG, r0.activityInfo.name + "=" + r0.priority + " vs " + r1.activityInfo.name + "=" + r1.priority);
                }
                if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder) {
                    i = 0;
                } else if (r0.isDefault != r1.isDefault) {
                    i = 0;
                } else {
                    ResolveInfo forceResolveInfo = OppoFeatureCache.get(IColorDefaultAppPolicyManager.DEFAULT).getForceAppBeforeChooseBestActivity(intent, query);
                    if (forceResolveInfo != null) {
                        return forceResolveInfo;
                    }
                    ResolveInfo defaultResolveInfo = OppoFeatureCache.get(IColorDefaultAppPolicyManager.DEFAULT).getDefaultAppAfterChooseBestActivity(intent, query, findPreferredActivityNotLocked(intent, resolvedType, flags, query, r0.priority, true, false, debug, userId));
                    if (defaultResolveInfo != null) {
                        return defaultResolveInfo;
                    }
                    if (query.size() == 0) {
                        return null;
                    }
                    for (int i2 = 0; i2 < query.size(); i2++) {
                        ResolveInfo ri = query.get(i2);
                        if (ri.activityInfo.applicationInfo.isInstantApp()) {
                            if (((int) (getDomainVerificationStatusLPr(this.mSettings.mPackages.get(ri.activityInfo.packageName), userId) >> 32)) != 4) {
                                return ri;
                            }
                        }
                    }
                    ResolveInfo ri2 = new ResolveInfo(this.mResolveInfo);
                    ri2.activityInfo = new ActivityInfo(ri2.activityInfo);
                    ri2.activityInfo.labelRes = ResolverActivity.getLabelRes(intent.getAction());
                    String intentPackage = intent.getPackage();
                    if (TextUtils.isEmpty(intentPackage) || !allHavePackage(query, intentPackage)) {
                        z = true;
                    } else {
                        ApplicationInfo appi = query.get(0).activityInfo.applicationInfo;
                        ri2.resolvePackageName = intentPackage;
                        if (userNeedsBadging(userId)) {
                            z = true;
                            ri2.noResourceId = true;
                        } else {
                            z = true;
                            ri2.icon = appi.icon;
                        }
                        ri2.iconResourceId = appi.icon;
                        ri2.labelRes = appi.labelRes;
                    }
                    ri2.activityInfo.applicationInfo = new ApplicationInfo(ri2.activityInfo.applicationInfo);
                    if (userId != 0) {
                        ri2.activityInfo.applicationInfo.uid = UserHandle.getUid(userId, UserHandle.getAppId(ri2.activityInfo.applicationInfo.uid));
                    }
                    if (ri2.activityInfo.metaData == null) {
                        ri2.activityInfo.metaData = new Bundle();
                    }
                    ri2.activityInfo.metaData.putBoolean("android.dock_home", z);
                    return ri2;
                }
                return query.get(i);
            }
        }
        return null;
    }

    private boolean allHavePackage(List<ResolveInfo> list, String packageName) {
        if (ArrayUtils.isEmpty(list)) {
            return false;
        }
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo ri = list.get(i);
            ActivityInfo ai = ri != null ? ri.activityInfo : null;
            if (ai == null || !packageName.equals(ai.packageName)) {
                return false;
            }
        }
        return true;
    }

    @GuardedBy({"mPackages"})
    private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
        List<PersistentPreferredActivity> pprefs;
        PackageManagerService packageManagerService = this;
        int i = flags;
        int N = query.size();
        PersistentPreferredIntentResolver ppir = packageManagerService.mSettings.mPersistentPreferredActivities.get(userId);
        if (DEBUG_PREFERRED || debug) {
            Slog.v(TAG, "Looking for presistent preferred activities...");
        }
        int i2 = 0;
        if (ppir != null) {
            pprefs = ppir.queryIntent(intent, resolvedType, (65536 & i) != 0, userId);
        } else {
            pprefs = null;
        }
        if (pprefs == null || pprefs.size() <= 0) {
            return null;
        }
        int M = pprefs.size();
        int i3 = 0;
        while (i3 < M) {
            PersistentPreferredActivity ppa = pprefs.get(i3);
            if (DEBUG_PREFERRED || debug) {
                StringBuilder sb = new StringBuilder();
                sb.append("Checking PersistentPreferredActivity ds=");
                sb.append(ppa.countDataSchemes() > 0 ? ppa.getDataScheme(i2) : "<none>");
                sb.append("\n  component=");
                sb.append(ppa.mComponent);
                Slog.v(TAG, sb.toString());
                ppa.dump(new LogPrinter(2, TAG, 3), "  ");
            }
            ActivityInfo ai = packageManagerService.getActivityInfo(ppa.mComponent, i | 512, userId);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Found persistent preferred activity:");
                if (ai != null) {
                    ai.dump(new LogPrinter(2, TAG, 3), "  ");
                } else {
                    Slog.v(TAG, "  null");
                }
            }
            if (ai != null) {
                for (int j = 0; j < N; j++) {
                    ResolveInfo ri = query.get(j);
                    if (ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) && ri.activityInfo.name.equals(ai.name)) {
                        if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Returning persistent preferred activity: " + ri.activityInfo.packageName + SliceClientPermissions.SliceAuthority.DELIMITER + ri.activityInfo.name);
                        }
                        return ri;
                    }
                }
                continue;
            }
            i3++;
            i2 = 0;
            packageManagerService = this;
            i = flags;
        }
        return null;
    }

    private boolean isHomeIntent(Intent intent) {
        return "android.intent.action.MAIN".equals(intent.getAction()) && intent.hasCategory("android.intent.category.HOME") && intent.hasCategory("android.intent.category.DEFAULT");
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x0328, code lost:
        if (r41 == false) goto L_0x0364;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x032a, code lost:
        r4.removeFilter(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x0330, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x0351;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:0x0332, code lost:
        r33 = r2;
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Removing match " + r5.mPref.mComponent);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x0351, code lost:
        r33 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x0355, code lost:
        r13 = r37;
        r21 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x035b, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x035c, code lost:
        r21 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x0364, code lost:
        r33 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:161:0x0368, code lost:
        if (r40 == false) goto L_0x0480;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x0370, code lost:
        if (r5.mPref.sameSet(r38, r1) != false) goto L_0x0480;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x0378, code lost:
        if (r5.mPref.isSuperset(r38, r1) == false) goto L_0x03de;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x037a, code lost:
        if (r1 != false) goto L_0x03cb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x037e, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x039e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x0380, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Result set changed, but PreferredActivity is still valid as only non-preferred components were removed for " + r6 + " type " + r36);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x039e, code lost:
        r0 = new com.android.server.pm.PreferredActivity(r5, r5.mPref.mMatch, r5.mPref.discardObsoleteComponents(r38), r5.mPref.mComponent, r5.mPref.mAlways);
        r4.removeFilter(r5);
        r4.addFilter(r0);
        r6 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x03cd, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x03da;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x03cf, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Do not remove preferred activity for launcher during SetupWizard");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x03de, code lost:
        if (r3 == false) goto L_0x0401;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x03e0, code lost:
        r2 = r37;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x03e3, code lost:
        if (r2 != -1) goto L_0x04da;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:?, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "remove pa k = " + r18);
        r13 = r18;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x0401, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Result set changed, dropping preferred activity for " + r6 + " type " + r36);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x0423, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x043f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:183:0x0425, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Removing preferred activity since set changed " + r5.mPref.mComponent);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x043f, code lost:
        r4.removeFilter(r5);
        r4.addFilter(new com.android.server.pm.PreferredActivity(r5, r5.mPref.mMatch, null, r5.mPref.mComponent, false));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x0460, code lost:
        if (1 == 0) goto L_0x0476;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x0464, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x0470;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:0x0466, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Preferred activity bookkeeping changed; writing restrictions");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x0472, code lost:
        scheduleWritePackageRestrictionsLocked(r43);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:195:0x0479, code lost:
        return null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x047b, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x0482, code lost:
        r6 = r21;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:0x0486, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED != false) goto L_0x048e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:203:0x0488, code lost:
        if (r42 == false) goto L_0x048b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:0x048e, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Returning preferred activity: " + r13.activityInfo.packageName + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r13.activityInfo.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x04b7, code lost:
        if (r6 == false) goto L_0x04c7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:209:0x04bb, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x04c4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:210:0x04bd, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Preferred activity bookkeeping changed; writing restrictions");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:211:0x04c4, code lost:
        scheduleWritePackageRestrictionsLocked(r43);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:213:0x04c8, code lost:
        return r13;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x04c9, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:215:0x04ca, code lost:
        r21 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:261:0x05c4, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED != false) goto L_0x05c8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:262:0x05c6, code lost:
        if (r42 == false) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:263:0x05c8, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "No preferred activity to return");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:268:0x05d6, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:285:?, code lost:
        return null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:286:?, code lost:
        return null;
     */
    /* JADX WARNING: Removed duplicated region for block: B:132:0x02a1  */
    /* JADX WARNING: Removed duplicated region for block: B:133:0x02b2  */
    /* JADX WARNING: Removed duplicated region for block: B:140:0x02c8  */
    /* JADX WARNING: Removed duplicated region for block: B:143:0x02fa  */
    /* JADX WARNING: Removed duplicated region for block: B:253:0x05aa  */
    public ResolveInfo findPreferredActivityNotLocked(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
        Throwable th;
        List<PreferredActivity> prefs;
        boolean changed;
        Throwable th2;
        boolean containsDefaultPkg;
        int k;
        List<PreferredActivity> prefs2;
        int M;
        int i;
        PreferredActivity pa;
        boolean containsDefaultPkg2;
        int N;
        int match;
        int k2;
        ActivityInfo ai;
        String str;
        int callingUid;
        int k3;
        ResolveInfo pri;
        ResolveInfo ri;
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid2 = Binder.getCallingUid();
        boolean isDeviceProvisioned = Settings.Global.getInt(this.mContext.getContentResolver(), "device_provisioned", 0) == 1;
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid2, false);
        Intent intent2 = updateIntentForResolve(intent);
        synchronized (this.mPackages) {
            try {
                ResolveInfo pri2 = findPersistentPreferredActivityLP(intent2, resolvedType, flags2, query, debug, userId);
                if (pri2 != null) {
                    try {
                        return pri2;
                    } catch (Throwable th3) {
                        th = th3;
                        throw th;
                    }
                } else {
                    int k4 = -1;
                    boolean isDefaultAppEnabled = OppoFeatureCache.get(IColorDefaultAppPolicyManager.DEFAULT).isDefaultAppEnabled(intent2);
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Looking for preferred activities...");
                    }
                    if (pir != null) {
                        prefs = pir.queryIntent(intent2, resolvedType, (65536 & flags2) != 0, userId);
                    } else {
                        prefs = null;
                    }
                    if (prefs != null && prefs.size() > 0) {
                        boolean changed2 = false;
                        int match2 = 0;
                        try {
                            if (DEBUG_PREFERRED || debug) {
                                Slog.v(TAG, "Figuring out best match...");
                            }
                            int N2 = query.size();
                            int j = 0;
                            while (j < N2) {
                                try {
                                    ResolveInfo ri2 = query.get(j);
                                    if (DEBUG_PREFERRED || debug) {
                                        pri = pri2;
                                        k3 = k4;
                                        try {
                                            StringBuilder sb = new StringBuilder();
                                            changed = changed2;
                                            try {
                                                sb.append("Match for ");
                                                ri = ri2;
                                                callingUid = callingUid2;
                                                try {
                                                    sb.append(ri.activityInfo);
                                                    sb.append(": 0x");
                                                    sb.append(Integer.toHexString(match2));
                                                    Slog.v(TAG, sb.toString());
                                                } catch (Throwable th4) {
                                                    th2 = th4;
                                                    if (changed) {
                                                    }
                                                    throw th2;
                                                }
                                            } catch (Throwable th5) {
                                                th2 = th5;
                                                if (changed) {
                                                }
                                                throw th2;
                                            }
                                        } catch (Throwable th6) {
                                            th2 = th6;
                                            changed = changed2;
                                            if (changed) {
                                                if (DEBUG_PREFERRED) {
                                                    Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                }
                                                scheduleWritePackageRestrictionsLocked(userId);
                                            }
                                            throw th2;
                                        }
                                    } else {
                                        pri = pri2;
                                        k3 = k4;
                                        changed = changed2;
                                        callingUid = callingUid2;
                                        ri = ri2;
                                    }
                                    if (ri.match > match2) {
                                        match2 = ri.match;
                                    }
                                    j++;
                                    pri2 = pri;
                                    k4 = k3;
                                    changed2 = changed;
                                    callingUid2 = callingUid;
                                } catch (Throwable th7) {
                                    th2 = th7;
                                    changed = changed2;
                                    if (changed) {
                                    }
                                    throw th2;
                                }
                            }
                            changed = changed2;
                            try {
                                if (DEBUG_PREFERRED || debug) {
                                    Slog.v(TAG, "Best match: 0x" + Integer.toHexString(match2));
                                }
                                int match3 = 268369920 & match2;
                                if (!isDefaultAppEnabled || !OppoFeatureCache.get(IColorDefaultAppPolicyManager.DEFAULT).isQueryListContainsDefaultPkg(query)) {
                                    containsDefaultPkg = false;
                                } else {
                                    containsDefaultPkg = true;
                                }
                                int M2 = prefs.size();
                                int i2 = 0;
                                int k5 = k4;
                                while (i2 < M2) {
                                    try {
                                        PreferredActivity pa2 = prefs.get(i2);
                                        if (!DEBUG_PREFERRED) {
                                            if (!debug) {
                                                prefs2 = prefs;
                                                M = M2;
                                                i = i2;
                                                pa = pa2;
                                                k = k5;
                                                if (pa.mPref.mMatch == match3 && !containsDefaultPkg) {
                                                    try {
                                                        if (!DEBUG_PREFERRED) {
                                                            if (debug) {
                                                            }
                                                            N = N2;
                                                            match = match3;
                                                            containsDefaultPkg2 = containsDefaultPkg;
                                                            k2 = k;
                                                        }
                                                        Slog.v(TAG, "Skipping bad match " + Integer.toHexString(pa.mPref.mMatch));
                                                        N = N2;
                                                        match = match3;
                                                        containsDefaultPkg2 = containsDefaultPkg;
                                                        k2 = k;
                                                    } catch (Throwable th8) {
                                                        th2 = th8;
                                                        if (changed) {
                                                        }
                                                        throw th2;
                                                    }
                                                } else if (always || pa.mPref.mAlways) {
                                                    ai = getActivityInfo(pa.mPref.mComponent, flags2 | 512 | 524288 | 262144, userId);
                                                    if (!DEBUG_PREFERRED || debug) {
                                                        Slog.v(TAG, "Found preferred activity:");
                                                        if (ai == null) {
                                                            match = match3;
                                                            ai.dump(new LogPrinter(2, TAG, 3), "  ");
                                                        } else {
                                                            match = match3;
                                                            Slog.v(TAG, "  null");
                                                        }
                                                    } else {
                                                        match = match3;
                                                    }
                                                    boolean excludeSetupWizardHomeActivity = !isHomeIntent(intent2) && !isDeviceProvisioned;
                                                    if (ai == null) {
                                                        int j2 = 0;
                                                        while (true) {
                                                            if (j2 >= N2) {
                                                                N = N2;
                                                                containsDefaultPkg2 = containsDefaultPkg;
                                                                k2 = k;
                                                                break;
                                                            }
                                                            ResolveInfo ri3 = query.get(j2);
                                                            N = N2;
                                                            if (ri3.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) && ri3.activityInfo.name.equals(ai.name)) {
                                                                break;
                                                            }
                                                            j2++;
                                                            N2 = N;
                                                        }
                                                    } else if (excludeSetupWizardHomeActivity) {
                                                        N = N2;
                                                        containsDefaultPkg2 = containsDefaultPkg;
                                                        k2 = k;
                                                    } else {
                                                        Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                                                        pir.removeFilter(pa);
                                                        k5 = k;
                                                        N = N2;
                                                        containsDefaultPkg2 = containsDefaultPkg;
                                                        changed = true;
                                                        i2 = i + 1;
                                                        M2 = M;
                                                        prefs = prefs2;
                                                        match3 = match;
                                                        N2 = N;
                                                        containsDefaultPkg = containsDefaultPkg2;
                                                    }
                                                } else {
                                                    if (!DEBUG_PREFERRED) {
                                                        if (debug) {
                                                        }
                                                        N = N2;
                                                        match = match3;
                                                        containsDefaultPkg2 = containsDefaultPkg;
                                                        k2 = k;
                                                    }
                                                    Slog.v(TAG, "Skipping mAlways=false entry");
                                                    N = N2;
                                                    match = match3;
                                                    containsDefaultPkg2 = containsDefaultPkg;
                                                    k2 = k;
                                                }
                                                k5 = k2;
                                                i2 = i + 1;
                                                M2 = M;
                                                prefs = prefs2;
                                                match3 = match;
                                                N2 = N;
                                                containsDefaultPkg = containsDefaultPkg2;
                                            }
                                        }
                                        M = M2;
                                        StringBuilder sb2 = new StringBuilder();
                                        prefs2 = prefs;
                                        try {
                                            sb2.append("Checking PreferredActivity ds=");
                                            if (pa2.countDataSchemes() > 0) {
                                                pa = pa2;
                                                i = i2;
                                                try {
                                                    str = pa.getDataScheme(0);
                                                } catch (Throwable th9) {
                                                    th2 = th9;
                                                }
                                            } else {
                                                pa = pa2;
                                                i = i2;
                                                str = "<none>";
                                            }
                                            sb2.append(str);
                                            sb2.append("\n  component=");
                                            sb2.append(pa.mPref.mComponent);
                                            Slog.v(TAG, sb2.toString());
                                            k = k5;
                                        } catch (Throwable th10) {
                                            th2 = th10;
                                            if (changed) {
                                            }
                                            throw th2;
                                        }
                                        try {
                                            pa.dump(new LogPrinter(2, TAG, 3), "  ");
                                            if (pa.mPref.mMatch == match3) {
                                            }
                                            if (always) {
                                            }
                                            ai = getActivityInfo(pa.mPref.mComponent, flags2 | 512 | 524288 | 262144, userId);
                                            if (!DEBUG_PREFERRED) {
                                            }
                                            Slog.v(TAG, "Found preferred activity:");
                                            if (ai == null) {
                                            }
                                            if (!isHomeIntent(intent2)) {
                                            }
                                            if (ai == null) {
                                            }
                                        } catch (Throwable th11) {
                                            th2 = th11;
                                            if (changed) {
                                            }
                                            throw th2;
                                        }
                                    } catch (Throwable th12) {
                                        th2 = th12;
                                        if (changed) {
                                        }
                                        throw th2;
                                    }
                                }
                                if (k5 != -1) {
                                    try {
                                        PreferredActivity rpa = prefs.get(k5);
                                        Slog.i(TAG, "Result set changed, dropping preferred activity for " + intent2 + " type " + resolvedType);
                                        if (DEBUG_PREFERRED) {
                                            Slog.v(TAG, "Removing preferred activity since set changed " + rpa.mPref.mComponent);
                                        }
                                        pir.removeFilter(rpa);
                                        pir.addFilter(new PreferredActivity(rpa, rpa.mPref.mMatch, null, rpa.mPref.mComponent, false));
                                        if (1 != 0) {
                                            if (DEBUG_PREFERRED) {
                                                Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                            }
                                            scheduleWritePackageRestrictionsLocked(userId);
                                        }
                                        return null;
                                    } catch (Throwable th13) {
                                        th2 = th13;
                                        if (changed) {
                                        }
                                        throw th2;
                                    }
                                } else if (changed) {
                                    if (DEBUG_PREFERRED) {
                                        Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                    }
                                    scheduleWritePackageRestrictionsLocked(userId);
                                }
                            } catch (Throwable th14) {
                                th2 = th14;
                                if (changed) {
                                }
                                throw th2;
                            }
                        } catch (Throwable th15) {
                            th2 = th15;
                            changed = false;
                            if (changed) {
                            }
                            throw th2;
                        }
                    }
                }
            } catch (Throwable th16) {
                th = th16;
                throw th;
            }
        }
    }

    public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
        boolean z = true;
        if (matches != null) {
            int size = matches.size();
            for (int i = 0; i < size; i++) {
                if (matches.get(i).getTargetUserId() == targetUserId) {
                    return true;
                }
            }
        }
        if (!intent.hasWebURI()) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        UserInfo parent = getProfileParent(sourceUserId);
        synchronized (this.mPackages) {
            if (getCrossProfileDomainPreferredLpr(intent, resolvedType, updateFlagsForResolve(0, parent.id, intent, callingUid, false), sourceUserId, parent.id) == null) {
                z = false;
            }
        }
        return z;
    }

    private UserInfo getProfileParent(int userId) {
        long identity = Binder.clearCallingIdentity();
        try {
            return sUserManager.getProfileParent(userId);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private List<CrossProfileIntentFilter> getMatchingCrossProfileIntentFilters(Intent intent, String resolvedType, int userId) {
        CrossProfileIntentResolver resolver = this.mSettings.mCrossProfileIntentResolvers.get(userId);
        if (resolver != null) {
            return resolver.queryIntent(intent, resolvedType, false, userId);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
        try {
            Trace.traceBegin(262144, "queryIntentActivities");
            return new ParceledListSlice<>(queryIntentActivitiesInternal(intent, resolvedType, flags, userId));
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private String getInstantAppPackageName(int callingUid) {
        synchronized (this.mPackages) {
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(callingUid));
            String str = null;
            if (!(obj instanceof PackageSetting)) {
                return null;
            }
            PackageSetting ps = (PackageSetting) obj;
            if (ps.getInstantApp(UserHandle.getUserId(callingUid))) {
                str = ps.pkg.packageName;
            }
            return str;
        }
    }

    public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, Binder.getCallingUid(), userId, false, true);
    }

    /* JADX INFO: Multiple debug info for r0v25 'pkg'  java.util.List<android.content.pm.ResolveInfo>: [D('xpResolveInfo' android.content.pm.ResolveInfo), D('result' java.util.List<android.content.pm.ResolveInfo>)] */
    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    /* JADX WARNING: Removed duplicated region for block: B:114:0x01ee A[Catch:{ all -> 0x02ca }] */
    /* JADX WARNING: Removed duplicated region for block: B:157:0x02bb  */
    private List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart, boolean allowDynamicSplits) {
        Intent intent2;
        ComponentName comp;
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        String instantAppPkgName;
        int flags2;
        Intent intent3;
        List<ResolveInfo> result;
        boolean addInstant;
        boolean isVisibleToUser;
        boolean sortResult;
        CrossProfileDomainInfo xpDomainInfo;
        ResolveInfo xpResolveInfo;
        Intent intent4;
        int i;
        PackageManagerService packageManagerService;
        int flags3;
        ComponentName comp2;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        String instantAppPkgName2 = getInstantAppPackageName(filterCallingUid);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "query intent activities");
        String pkgName = intent.getPackage();
        ComponentName comp3 = intent.getComponent();
        if (comp3 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp3;
        } else {
            Intent intent5 = intent.getSelector();
            comp = intent5.getComponent();
            intent2 = intent5;
        }
        int flags4 = updateFlagsForResolve(OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).adjustFreezeAppFlags(flags), userId, intent2, filterCallingUid, resolveForStart, (comp == null && pkgName == null) ? false : true);
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ActivityInfo ai = getActivityInfo(comp, flags4, userId);
            if (ai != null) {
                boolean matchInstantApp = (8388608 & flags4) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags4) != 0;
                boolean matchExplicitlyVisibleOnly = (33554432 & flags4) != 0;
                boolean isCallerInstantApp = instantAppPkgName2 != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName2);
                flags3 = flags4;
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                comp2 = comp;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (!(!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (!isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !(isTargetVisibleToInstantApp && (ai.flags & 2097152) == 0))))))) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.activityInfo = ai;
                    list.add(ri);
                }
            } else {
                flags3 = flags4;
                comp2 = comp;
            }
            return applyPostResolutionFilter(list, instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
        }
        boolean xpDomainInfo2 = false;
        boolean addInstant2 = false;
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            if (pkgName == null) {
                try {
                    List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent2, resolvedType, userId);
                    ResolveInfo xpResolveInfo2 = querySkipCurrentProfileIntents(matchingFilters, intent2, resolvedType, flags4, userId);
                    if (xpResolveInfo2 != null) {
                        try {
                            List<ResolveInfo> xpResult = new ArrayList<>(1);
                            xpResult.add(xpResolveInfo2);
                            arrayMap = arrayMap2;
                            try {
                                List<ResolveInfo> applyPostResolutionFilter = applyPostResolutionFilter(filterIfNotSystemUser(xpResult, userId), instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
                                return applyPostResolutionFilter;
                            } catch (Throwable th2) {
                                th = th2;
                                throw th;
                            }
                        } catch (Throwable th3) {
                            th = th3;
                            arrayMap = arrayMap2;
                            throw th;
                        }
                    } else {
                        arrayMap = arrayMap2;
                        try {
                            try {
                                List<ResolveInfo> result2 = filterIfNotSystemUser(this.mComponentResolver.queryActivities(intent2, resolvedType, flags4, userId), userId);
                                addInstant = isInstantAppResolutionAllowed(intent2, result2, userId, false);
                                try {
                                    isVisibleToUser = false;
                                    result = result2;
                                    flags2 = flags4;
                                } catch (Throwable th4) {
                                    th = th4;
                                    throw th;
                                }
                                try {
                                    ResolveInfo xpResolveInfo3 = queryCrossProfileIntents(matchingFilters, intent2, resolvedType, flags4, userId, hasNonNegativePriority(result2));
                                    if (xpResolveInfo3 != null) {
                                        try {
                                            if (isUserEnabled(xpResolveInfo3.targetUserId)) {
                                                if (filterIfNotSystemUser(Collections.singletonList(xpResolveInfo3), userId).size() > 0) {
                                                    isVisibleToUser = true;
                                                }
                                                if (isVisibleToUser) {
                                                    result.add(xpResolveInfo3);
                                                    sortResult = true;
                                                    if (!intent2.hasWebURI()) {
                                                        UserInfo parent = getProfileParent(userId);
                                                        if (parent != null) {
                                                            try {
                                                                xpResolveInfo = xpResolveInfo3;
                                                                xpDomainInfo = getCrossProfileDomainPreferredLpr(intent2, resolvedType, flags2, userId, parent.id);
                                                            } catch (Throwable th5) {
                                                                th = th5;
                                                                throw th;
                                                            }
                                                        } else {
                                                            xpResolveInfo = xpResolveInfo3;
                                                            xpDomainInfo = null;
                                                        }
                                                        if (xpDomainInfo != null) {
                                                            if (xpResolveInfo != null) {
                                                                result.remove(xpResolveInfo);
                                                            }
                                                            try {
                                                                if (result.size() != 0 || addInstant) {
                                                                    intent4 = intent2;
                                                                    instantAppPkgName = instantAppPkgName2;
                                                                    i = userId;
                                                                    packageManagerService = this;
                                                                } else {
                                                                    result.add(xpDomainInfo.resolveInfo);
                                                                    try {
                                                                        List<ResolveInfo> applyPostResolutionFilter2 = applyPostResolutionFilter(result, instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
                                                                        return applyPostResolutionFilter2;
                                                                    } catch (Throwable th6) {
                                                                        th = th6;
                                                                        throw th;
                                                                    }
                                                                }
                                                            } catch (Throwable th7) {
                                                                th = th7;
                                                                throw th;
                                                            }
                                                        } else {
                                                            intent4 = intent2;
                                                            instantAppPkgName = instantAppPkgName2;
                                                            i = userId;
                                                            packageManagerService = this;
                                                            try {
                                                                if (result.size() <= 1 && !addInstant) {
                                                                    List<ResolveInfo> applyPostResolutionFilter3 = applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent4);
                                                                    return applyPostResolutionFilter3;
                                                                }
                                                            } catch (Throwable th8) {
                                                                th = th8;
                                                                throw th;
                                                            }
                                                        }
                                                        intent3 = intent4;
                                                        try {
                                                            xpDomainInfo2 = true;
                                                            result = filterCandidatesWithDomainPreferredActivitiesLPr(intent4, flags2, result, xpDomainInfo, userId);
                                                        } catch (Throwable th9) {
                                                            th = th9;
                                                            throw th;
                                                        }
                                                    } else {
                                                        instantAppPkgName = instantAppPkgName2;
                                                        intent3 = intent2;
                                                        xpDomainInfo2 = sortResult;
                                                    }
                                                    addInstant2 = addInstant;
                                                }
                                            }
                                        } catch (Throwable th10) {
                                            th = th10;
                                            throw th;
                                        }
                                    }
                                    sortResult = false;
                                } catch (Throwable th11) {
                                    th = th11;
                                    throw th;
                                }
                            } catch (Throwable th12) {
                                th = th12;
                                throw th;
                            }
                            try {
                                if (!intent2.hasWebURI()) {
                                }
                                addInstant2 = addInstant;
                            } catch (Throwable th13) {
                                th = th13;
                                throw th;
                            }
                        } catch (Throwable th14) {
                            th = th14;
                            throw th;
                        }
                    }
                } catch (Throwable th15) {
                    th = th15;
                    arrayMap = arrayMap2;
                    throw th;
                }
            } else {
                flags2 = flags4;
                arrayMap = arrayMap2;
                instantAppPkgName = instantAppPkgName2;
                intent3 = intent2;
                try {
                    PackageParser.Package pkg = this.mPackages.get(pkgName);
                    List<ResolveInfo> result3 = null;
                    if (pkg != null) {
                        try {
                            result3 = filterIfNotSystemUser(this.mComponentResolver.queryActivities(intent3, resolvedType, flags2, pkg.activities, userId), userId);
                        } catch (Throwable th16) {
                            th = th16;
                            throw th;
                        }
                    }
                    if (result3 != null) {
                        if (result3.size() != 0) {
                            result = result3;
                        }
                    }
                    addInstant2 = isInstantAppResolutionAllowed(intent3, null, userId, true);
                    if (result3 == null) {
                        result = new ArrayList<>();
                    } else {
                        result = result3;
                    }
                } catch (Throwable th17) {
                    th = th17;
                    throw th;
                }
            }
            if (addInstant2) {
                result = maybeAddInstantAppInstaller(result, intent3, resolvedType, flags2, userId, resolveForStart);
            }
            if (xpDomainInfo2) {
                Collections.sort(result, ComponentResolver.RESOLVE_PRIORITY_SORTER);
            }
            return applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent3);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:27:0x00a6  */
    /* JADX WARNING: Removed duplicated region for block: B:30:0x00e9  */
    /* JADX WARNING: Removed duplicated region for block: B:41:0x0138  */
    /* JADX WARNING: Removed duplicated region for block: B:49:0x016a  */
    /* JADX WARNING: Removed duplicated region for block: B:52:0x0176  */
    private List<ResolveInfo> maybeAddInstantAppInstaller(List<ResolveInfo> result, Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart) {
        ResolveInfo localInstantApp;
        int status;
        InstantAppRequest requestObject;
        PackageSetting ps;
        ResolveInfo ephemeralInstaller;
        if (!((flags & 8388608) != 0)) {
            List<ResolveInfo> instantApps = this.mComponentResolver.queryActivities(intent, resolvedType, 8388608 | flags | 64 | DumpState.DUMP_SERVICE_PERMISSIONS, userId);
            for (int i = instantApps.size() - 1; i >= 0; i--) {
                ResolveInfo info = instantApps.get(i);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps2 = this.mSettings.mPackages.get(packageName);
                if (ps2.getInstantApp(userId)) {
                    if (((int) (getDomainVerificationStatusLPr(ps2, userId) >> 32)) == 3) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Instant app marked to never run; pkg: " + packageName);
                        }
                        localInstantApp = null;
                        status = 1;
                    } else {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Found installed instant app; pkg: " + packageName);
                        }
                        localInstantApp = info;
                        status = 0;
                    }
                    if (status == 0) {
                        requestObject = null;
                    } else if (localInstantApp == null) {
                        Trace.traceBegin(262144, "resolveEphemeral");
                        InstantAppRequest auxiliaryResponse = InstantAppResolver.doInstantAppResolutionPhaseOne(this.mInstantAppResolverConnection, new InstantAppRequest((AuxiliaryResolveInfo) null, intent, resolvedType, (String) null, userId, (Bundle) null, resolveForStart));
                        Trace.traceEnd(262144);
                        requestObject = auxiliaryResponse;
                    } else {
                        ApplicationInfo ai = localInstantApp.activityInfo.applicationInfo;
                        requestObject = new AuxiliaryResolveInfo((ComponentName) null, ai.packageName, ai.longVersionCode, (String) null);
                    }
                    if ((!intent.isWebIntent() && requestObject == null) || (ps = this.mSettings.mPackages.get(this.mInstantAppInstallerActivity.packageName)) == null || !ps.readUserState(userId).isEnabled(this.mInstantAppInstallerActivity, 0)) {
                        return result;
                    }
                    ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
                    ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(userId), userId);
                    ephemeralInstaller.match = 5799936;
                    ephemeralInstaller.filter = new IntentFilter();
                    if (intent.getAction() != null) {
                        ephemeralInstaller.filter.addAction(intent.getAction());
                    }
                    if (!(intent.getData() == null || intent.getData().getPath() == null)) {
                        ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
                    }
                    ephemeralInstaller.isInstantAppAvailable = true;
                    ephemeralInstaller.isDefault = true;
                    ephemeralInstaller.auxiliaryInfo = requestObject;
                    if (DEBUG_INSTANT) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    result.add(ephemeralInstaller);
                    if (mColorPmsEx != null) {
                        mColorPmsEx.sortSystemAppInData(result);
                    }
                    return result;
                }
            }
        }
        localInstantApp = null;
        status = 0;
        if (status == 0) {
        }
        if (!intent.isWebIntent()) {
        }
        ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
        ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(userId), userId);
        ephemeralInstaller.match = 5799936;
        ephemeralInstaller.filter = new IntentFilter();
        if (intent.getAction() != null) {
        }
        ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
        ephemeralInstaller.isInstantAppAvailable = true;
        ephemeralInstaller.isDefault = true;
        ephemeralInstaller.auxiliaryInfo = requestObject;
        if (DEBUG_INSTANT) {
        }
        result.add(ephemeralInstaller);
        if (mColorPmsEx != null) {
        }
        return result;
    }

    /* access modifiers changed from: private */
    public static class CrossProfileDomainInfo {
        int bestDomainVerificationStatus;
        ResolveInfo resolveInfo;

        private CrossProfileDomainInfo() {
        }
    }

    private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
        List<ResolveInfo> resultTargetUser;
        if (!sUserManager.hasUserRestriction("allow_parent_profile_app_linking", sourceUserId)) {
            return null;
        }
        List<ResolveInfo> resultTargetUser2 = this.mComponentResolver.queryActivities(intent, resolvedType, flags, parentUserId);
        if (resultTargetUser2 == null) {
            return null;
        }
        if (resultTargetUser2.isEmpty()) {
            return null;
        }
        CrossProfileDomainInfo result = null;
        int size = resultTargetUser2.size();
        int i = 0;
        while (i < size) {
            ResolveInfo riTargetUser = resultTargetUser2.get(i);
            if (riTargetUser.handleAllWebDataURI) {
                resultTargetUser = resultTargetUser2;
            } else {
                PackageSetting ps = this.mSettings.mPackages.get(riTargetUser.activityInfo.packageName);
                if (ps == null) {
                    resultTargetUser = resultTargetUser2;
                } else {
                    int status = (int) (getDomainVerificationStatusLPr(ps, parentUserId) >> 32);
                    if (result == null) {
                        resultTargetUser = resultTargetUser2;
                        CrossProfileDomainInfo result2 = new CrossProfileDomainInfo();
                        result2.resolveInfo = createForwardingResolveInfoUnchecked(new IntentFilter(), sourceUserId, parentUserId);
                        result2.bestDomainVerificationStatus = status;
                        result = result2;
                    } else {
                        resultTargetUser = resultTargetUser2;
                        result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
                    }
                }
            }
            i++;
            resultTargetUser2 = resultTargetUser;
        }
        if (result == null || result.bestDomainVerificationStatus != 3) {
            return result;
        }
        return null;
    }

    private int bestDomainVerificationStatus(int status1, int status2) {
        if (status1 == 3) {
            return status2;
        }
        if (status2 == 3) {
            return status1;
        }
        return (int) MathUtils.max(status1, status2);
    }

    private boolean isUserEnabled(int userId) {
        long callingId = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            return userInfo != null && userInfo.isEnabled();
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private List<ResolveInfo> filterIfNotSystemUser(List<ResolveInfo> resolveInfos, int userId) {
        if (userId == 0) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            if ((resolveInfos.get(i).activityInfo.flags & 536870912) != 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private List<ResolveInfo> applyPostResolutionFilter(List<ResolveInfo> resolveInfos, String ephemeralPkgName, boolean allowDynamicSplits, int filterCallingUid, boolean resolveForStart, int userId, Intent intent) {
        boolean blockInstant = intent.isWebIntent() && areWebInstantAppsDisabled(userId);
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            if (!info.isInstantAppAvailable || !blockInstant) {
                if (allowDynamicSplits && info.activityInfo != null && info.activityInfo.splitName != null) {
                    if (!ArrayUtils.contains(info.activityInfo.applicationInfo.splitNames, info.activityInfo.splitName)) {
                        if (this.mInstantAppInstallerActivity == null) {
                            if (DEBUG_INSTALL) {
                                Slog.v(TAG, "No installer - not adding it to the ResolveInfo list");
                            }
                            resolveInfos.remove(i);
                        } else if (!blockInstant || !isInstantApp(info.activityInfo.packageName, userId)) {
                            if (DEBUG_INSTALL) {
                                Slog.v(TAG, "Adding installer to the ResolveInfo list");
                            }
                            ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                            installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(findInstallFailureActivity(info.activityInfo.packageName, filterCallingUid, userId), info.activityInfo.packageName, info.activityInfo.applicationInfo.longVersionCode, info.activityInfo.splitName);
                            installerInfo.filter = new IntentFilter();
                            installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                            installerInfo.labelRes = info.resolveLabelResId();
                            installerInfo.icon = info.resolveIconResId();
                            installerInfo.isInstantAppAvailable = true;
                            resolveInfos.set(i, installerInfo);
                        } else {
                            resolveInfos.remove(i);
                        }
                    }
                }
                if (ephemeralPkgName != null && !ephemeralPkgName.equals(info.activityInfo.packageName) && ((!resolveForStart || !((intent.isWebIntent() || (intent.getFlags() & 2048) != 0) && intent.getPackage() == null && intent.getComponent() == null)) && (info.activityInfo.applicationInfo.isInstantApp() || (info.activityInfo.flags & 1048576) == 0))) {
                    resolveInfos.remove(i);
                }
            } else {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private ComponentName findInstallFailureActivity(String packageName, int filterCallingUid, int userId) {
        Intent failureActivityIntent = new Intent("android.intent.action.INSTALL_FAILURE");
        failureActivityIntent.setPackage(packageName);
        List<ResolveInfo> result = queryIntentActivitiesInternal(failureActivityIntent, null, 0, filterCallingUid, userId, false, false);
        int NR = result.size();
        if (NR <= 0) {
            return null;
        }
        for (int i = 0; i < NR; i++) {
            ResolveInfo info = result.get(i);
            if (info.activityInfo.splitName == null) {
                return new ComponentName(packageName, info.activityInfo.name);
            }
        }
        return null;
    }

    private boolean hasNonNegativePriority(List<ResolveInfo> resolveInfos) {
        return resolveInfos.size() > 0 && resolveInfos.get(0).priority >= 0;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:110:0x0258, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED != false) goto L_0x025e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x025c, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_0x02a1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x025e, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Filtered results with preferred activities. New candidates count: " + r0.size());
        r0 = r0.iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x0280, code lost:
        if (r0.hasNext() == false) goto L_0x02a1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x0282, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "  + " + r0.next().activityInfo);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x02a1, code lost:
        return r0;
     */
    private List<ResolveInfo> filterCandidatesWithDomainPreferredActivitiesLPr(Intent intent, int matchFlags, List<ResolveInfo> candidates, CrossProfileDomainInfo xpDomainInfo, int userId) {
        Throwable th;
        int maxMatchPrio;
        PackageManagerService packageManagerService = this;
        List<ResolveInfo> list = candidates;
        int i = userId;
        boolean debug = (intent.getFlags() & 8) != 0;
        if (DEBUG_PREFERRED || DEBUG_DOMAIN_VERIFICATION) {
            Slog.v(TAG, "Filtering results with preferred activities. Candidates count: " + candidates.size());
        }
        ArrayList<ResolveInfo> result = new ArrayList<>();
        ArrayList<ResolveInfo> alwaysList = new ArrayList<>();
        ArrayList<ResolveInfo> undefinedList = new ArrayList<>();
        ArrayList<ResolveInfo> alwaysAskList = new ArrayList<>();
        ArrayList<ResolveInfo> neverList = new ArrayList<>();
        ArrayList<ResolveInfo> matchAllList = new ArrayList<>();
        synchronized (packageManagerService.mPackages) {
            try {
                int n = 0;
                for (int count = candidates.size(); n < count; count = count) {
                    try {
                        ResolveInfo info = list.get(n);
                        PackageSetting ps = packageManagerService.mSettings.mPackages.get(info.activityInfo.packageName);
                        if (ps != null) {
                            if (info.handleAllWebDataURI) {
                                matchAllList.add(info);
                            } else {
                                long packedStatus = packageManagerService.getDomainVerificationStatusLPr(ps, i);
                                int status = (int) (packedStatus >> 32);
                                int linkGeneration = (int) (packedStatus & -1);
                                if (status == 2) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + always: " + info.activityInfo.packageName + " : linkgen=" + linkGeneration);
                                    }
                                    info.preferredOrder = linkGeneration;
                                    alwaysList.add(info);
                                } else if (status == 3) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + never: " + info.activityInfo.packageName);
                                    }
                                    neverList.add(info);
                                } else if (status == 4) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + always-ask: " + info.activityInfo.packageName);
                                    }
                                    alwaysAskList.add(info);
                                } else {
                                    if (status != 0) {
                                        if (status != 1) {
                                        }
                                    }
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + ask: " + info.activityInfo.packageName);
                                    }
                                    undefinedList.add(info);
                                }
                            }
                        }
                        n++;
                        packageManagerService = this;
                        list = candidates;
                        i = userId;
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
                boolean includeBrowser = false;
                if (alwaysList.size() > 0) {
                    result.addAll(alwaysList);
                } else {
                    result.addAll(undefinedList);
                    if (!(xpDomainInfo == null || xpDomainInfo.bestDomainVerificationStatus == 3)) {
                        result.add(xpDomainInfo.resolveInfo);
                    }
                    includeBrowser = true;
                }
                if (alwaysAskList.size() > 0) {
                    Iterator<ResolveInfo> it = result.iterator();
                    while (it.hasNext()) {
                        it.next().preferredOrder = 0;
                    }
                    result.addAll(alwaysAskList);
                    includeBrowser = true;
                }
                if (includeBrowser) {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "   ...including browsers in candidate set");
                    }
                    if ((matchFlags & 131072) != 0) {
                        result.addAll(matchAllList);
                    } else {
                        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
                        ResolveInfo defaultBrowserMatch = null;
                        int numCandidates = matchAllList.size();
                        int maxMatchPrio2 = 0;
                        int n2 = 0;
                        while (n2 < numCandidates) {
                            ResolveInfo info2 = matchAllList.get(n2);
                            if (info2.priority > maxMatchPrio2) {
                                maxMatchPrio2 = info2.priority;
                            }
                            if (info2.activityInfo.packageName.equals(defaultBrowserPackageName)) {
                                if (defaultBrowserMatch != null) {
                                    maxMatchPrio = maxMatchPrio2;
                                    if (defaultBrowserMatch.priority >= info2.priority) {
                                    }
                                } else {
                                    maxMatchPrio = maxMatchPrio2;
                                }
                                if (debug) {
                                    Slog.v(TAG, "Considering default browser match " + info2);
                                }
                                defaultBrowserMatch = info2;
                            } else {
                                maxMatchPrio = maxMatchPrio2;
                            }
                            n2++;
                            maxMatchPrio2 = maxMatchPrio;
                        }
                        if (defaultBrowserMatch == null || defaultBrowserMatch.priority < maxMatchPrio2 || TextUtils.isEmpty(defaultBrowserPackageName)) {
                            result.addAll(matchAllList);
                        } else {
                            if (debug) {
                                Slog.v(TAG, "Default browser match " + defaultBrowserMatch);
                            }
                            result.add(defaultBrowserMatch);
                        }
                    }
                    if (result.size() == 0) {
                        try {
                            result.addAll(candidates);
                            result.removeAll(neverList);
                        } catch (Throwable th3) {
                            th = th3;
                            throw th;
                        }
                    }
                }
            } catch (Throwable th4) {
                th = th4;
                throw th;
            }
        }
    }

    private long getDomainVerificationStatusLPr(PackageSetting ps, int userId) {
        long result = ps.getDomainVerificationStatusForUser(userId);
        if ((result >> 32) != 0 || ps.getIntentFilterVerificationInfo() == null) {
            return result;
        }
        return ((long) ps.getIntentFilterVerificationInfo().getStatus()) << 32;
    }

    private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
        ResolveInfo resolveInfo;
        if (matchingFilters == null) {
            return null;
        }
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            if (!((filter.getFlags() & 2) == 0 || (resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId)) == null)) {
                return resolveInfo;
            }
        }
        return null;
    }

    private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId, boolean matchInCurrentProfile) {
        if (matchingFilters == null) {
            return null;
        }
        SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            int targetUserId = filter.getTargetUserId();
            boolean skipCurrentProfileIfNoMatchFound = false;
            boolean skipCurrentProfile = (filter.getFlags() & 2) != 0;
            if ((filter.getFlags() & 4) != 0) {
                skipCurrentProfileIfNoMatchFound = true;
            }
            if (!skipCurrentProfile && !alreadyTriedUserIds.get(targetUserId) && (!skipCurrentProfileIfNoMatchFound || !matchInCurrentProfile)) {
                ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                if (resolveInfo != null) {
                    return resolveInfo;
                }
                alreadyTriedUserIds.put(targetUserId, true);
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfo(CrossProfileIntentFilter filter, Intent intent, String resolvedType, int flags, int sourceUserId) {
        int targetUserId = filter.getTargetUserId();
        List<ResolveInfo> resultTargetUser = this.mComponentResolver.queryActivities(intent, resolvedType, flags, targetUserId);
        if (resultTargetUser == null || !isUserEnabled(targetUserId)) {
            return null;
        }
        for (int i = resultTargetUser.size() - 1; i >= 0; i--) {
            if ((resultTargetUser.get(i).activityInfo.applicationInfo.flags & 1073741824) == 0) {
                return createForwardingResolveInfoUnchecked(filter, sourceUserId, targetUserId);
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfoUnchecked(IntentFilter filter, int sourceUserId, int targetUserId) {
        String className;
        ResolveInfo forwardingResolveInfo = new ResolveInfo();
        long ident = Binder.clearCallingIdentity();
        try {
            boolean targetIsProfile = sUserManager.getUserInfo(targetUserId).isManagedProfile();
            if (targetIsProfile) {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE;
            } else {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_PARENT;
            }
            ActivityInfo forwardingActivityInfo = getActivityInfo(new ComponentName(this.mAndroidApplication.packageName, className), 0, sourceUserId);
            if (!targetIsProfile) {
                forwardingActivityInfo.showUserIcon = targetUserId;
                forwardingResolveInfo.noResourceId = true;
            }
            forwardingResolveInfo.activityInfo = forwardingActivityInfo;
            forwardingResolveInfo.priority = 0;
            forwardingResolveInfo.preferredOrder = 0;
            forwardingResolveInfo.match = 0;
            forwardingResolveInfo.isDefault = true;
            forwardingResolveInfo.filter = filter;
            forwardingResolveInfo.targetUserId = targetUserId;
            return forwardingResolveInfo;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentActivityOptionsInternal(caller, specifics, specificTypes, intent, resolvedType, flags, userId));
    }

    /* JADX WARNING: Code restructure failed: missing block: B:33:0x00df, code lost:
        if (r10 == null) goto L_0x00e2;
     */
    private List<ResolveInfo> queryIntentActivityOptionsInternal(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        String resultsAction;
        int specificsPos;
        String resultsAction2;
        Iterator<String> it;
        String resultsAction3;
        int specificsPos2;
        String resultsAction4;
        int callingUid;
        String str;
        ActivityInfo ai;
        ResolveInfo ri;
        Intent[] intentArr = specifics;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid2 = Binder.getCallingUid();
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid2, false);
        this.mPermissionManager.enforceCrossUserPermission(callingUid2, userId, false, false, "query intent activity options");
        String resultsAction5 = intent.getAction();
        List<ResolveInfo> results = queryIntentActivitiesInternal(intent, resolvedType, flags2 | 64, userId);
        String str2 = ": ";
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Query " + intent + str2 + results);
        }
        int specificsPos3 = 0;
        if (intentArr != null) {
            int i = 0;
            while (i < intentArr.length) {
                Intent sintent = intentArr[i];
                if (sintent == null) {
                    resultsAction4 = resultsAction5;
                    callingUid = callingUid2;
                } else {
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i + str2 + sintent);
                    }
                    String action = sintent.getAction();
                    if (resultsAction5 != null && resultsAction5.equals(action)) {
                        action = null;
                    }
                    ResolveInfo ri2 = null;
                    ComponentName comp = sintent.getComponent();
                    if (comp == null) {
                        ResolveInfo ri3 = resolveIntent(sintent, specificTypes != null ? specificTypes[i] : null, flags2, userId);
                        if (ri3 == null) {
                            resultsAction4 = resultsAction5;
                            callingUid = callingUid2;
                        } else {
                            callingUid = callingUid2;
                            ResolveInfo resolveInfo = this.mResolveInfo;
                            ai = ri3.activityInfo;
                            ri2 = ri3;
                            resultsAction4 = resultsAction5;
                            comp = new ComponentName(ai.applicationInfo.packageName, ai.name);
                        }
                    } else {
                        resultsAction4 = resultsAction5;
                        callingUid = callingUid2;
                        ai = getActivityInfo(comp, flags2, userId);
                    }
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i + str2 + ai);
                    }
                    int N = results.size();
                    int j = specificsPos3;
                    while (j < N) {
                        ResolveInfo sri = results.get(j);
                        if ((sri.activityInfo.name.equals(comp.getClassName()) && sri.activityInfo.applicationInfo.packageName.equals(comp.getPackageName())) || (action != null && sri.filter.matchAction(action))) {
                            results.remove(j);
                            if (DEBUG_INTENT_MATCHING) {
                                Log.v(TAG, "Removing duplicate item from " + j + " due to specific " + specificsPos3);
                            }
                            if (ri2 == null) {
                                ri2 = sri;
                            }
                            j--;
                            N--;
                        }
                        j++;
                        str2 = str2;
                    }
                    str = str2;
                    if (ri2 == null) {
                        ri = new ResolveInfo();
                        ri.activityInfo = ai;
                    } else {
                        ri = ri2;
                    }
                    results.add(specificsPos3, ri);
                    ri.specificIndex = i;
                    specificsPos3++;
                    i++;
                    intentArr = specifics;
                    str2 = str;
                    callingUid2 = callingUid;
                    resultsAction5 = resultsAction4;
                }
                str = str2;
                i++;
                intentArr = specifics;
                str2 = str;
                callingUid2 = callingUid;
                resultsAction5 = resultsAction4;
            }
            resultsAction = resultsAction5;
        } else {
            resultsAction = resultsAction5;
        }
        int N2 = results.size();
        int i2 = specificsPos3;
        while (i2 < N2 - 1) {
            ResolveInfo rii = results.get(i2);
            if (rii.filter == null || (it = rii.filter.actionsIterator()) == null) {
                specificsPos = specificsPos3;
                resultsAction2 = resultsAction;
            } else {
                while (it.hasNext()) {
                    String action2 = it.next();
                    if (resultsAction != null) {
                        resultsAction3 = resultsAction;
                        if (resultsAction3.equals(action2)) {
                            resultsAction = resultsAction3;
                        }
                    } else {
                        resultsAction3 = resultsAction;
                    }
                    int j2 = i2 + 1;
                    while (j2 < N2) {
                        ResolveInfo rij = results.get(j2);
                        if (rij.filter == null || !rij.filter.hasAction(action2)) {
                            specificsPos2 = specificsPos3;
                        } else {
                            results.remove(j2);
                            if (DEBUG_INTENT_MATCHING) {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Removing duplicate item from ");
                                sb.append(j2);
                                specificsPos2 = specificsPos3;
                                sb.append(" due to action ");
                                sb.append(action2);
                                sb.append(" at ");
                                sb.append(i2);
                                Log.v(TAG, sb.toString());
                            } else {
                                specificsPos2 = specificsPos3;
                            }
                            j2--;
                            N2--;
                        }
                        j2++;
                        specificsPos3 = specificsPos2;
                    }
                    resultsAction = resultsAction3;
                }
                specificsPos = specificsPos3;
                resultsAction2 = resultsAction;
                if ((flags2 & 64) == 0) {
                    rii.filter = null;
                }
            }
            i2++;
            resultsAction = resultsAction2;
            specificsPos3 = specificsPos;
        }
        if (caller != null) {
            int N3 = results.size();
            int i3 = 0;
            while (true) {
                if (i3 >= N3) {
                    break;
                }
                ActivityInfo ainfo = results.get(i3).activityInfo;
                if (caller.getPackageName().equals(ainfo.applicationInfo.packageName) && caller.getClassName().equals(ainfo.name)) {
                    results.remove(i3);
                    break;
                }
                i3++;
            }
        }
        if ((flags2 & 64) == 0) {
            int N4 = results.size();
            for (int i4 = 0; i4 < N4; i4++) {
                results.get(i4).filter = null;
            }
        }
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Result: " + results);
        }
        return results;
    }

    public ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
        return OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).fixIntentReceivers(Binder.getCallingUid(), new ParceledListSlice<>(queryIntentReceiversInternal(intent, resolvedType, flags, userId, false)), intent, resolvedType, flags, userId, false);
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Removed duplicated region for block: B:57:0x00c8  */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x00d9  */
    public List<ResolveInfo> queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) {
        Intent intent2;
        ComponentName comp;
        boolean isTargetExplicitlyVisibleToInstantApp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ActivityInfo ai = getReceiverInfo(comp, flags2, userId);
            if (ai != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean matchExplicitlyVisibleOnly = (33554432 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (isTargetVisibleToInstantApp) {
                    if ((ai.flags & 2097152) == 0) {
                        isTargetExplicitlyVisibleToInstantApp = true;
                        if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                            ResolveInfo ri = new ResolveInfo();
                            ri.activityInfo = ai;
                            list.add(ri);
                        }
                    }
                }
                isTargetExplicitlyVisibleToInstantApp = false;
                if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                }
            }
            return applyPostResolutionFilter(list, instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
        }
        synchronized (this.mPackages) {
            String pkgName = intent2.getPackage();
            if (pkgName == null) {
                return applyPostResolutionFilter(this.mComponentResolver.queryReceivers(intent2, resolvedType, flags2, userId), instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
            }
            PackageParser.Package pkg = this.mPackages.get(pkgName);
            if (pkg != null) {
                return applyPostResolutionFilter(this.mComponentResolver.queryReceivers(intent2, resolvedType, flags2, pkg.receivers, userId), instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
            }
            return Collections.emptyList();
        }
    }

    public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
        return resolveServiceInternal(intent, resolvedType, flags, userId, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
        List<ResolveInfo> query;
        if (sUserManager.exists(userId) && (query = queryIntentServicesInternal(intent, resolvedType, updateFlagsForResolve(flags, userId, intent, callingUid, false), userId, callingUid, false)) != null && query.size() >= 1) {
            return query.get(0);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
        int callingUid = Binder.getCallingUid();
        return OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).fixIntentServices(new ParceledListSlice<>(queryIntentServicesInternal(intent, resolvedType, flags, userId, callingUid, false)), userId, intent, resolvedType, flags, callingUid, false);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid, boolean includeInstantApps) {
        Intent intent2;
        ComponentName comp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, includeInstantApps);
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ServiceInfo si = getServiceInfo(comp, flags2, userId);
            if (si != null) {
                boolean blockResolution = false;
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (si.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (si.flags & 1048576) == 0;
                if (!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp))) {
                    blockResolution = true;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.serviceInfo = si;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            try {
                String pkgName = intent2.getPackage();
                if (pkgName == null) {
                    return applyPostServiceResolutionFilter(this.mComponentResolver.queryServices(intent2, resolvedType, flags2, userId), instantAppPkgName);
                }
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg != null) {
                    return applyPostServiceResolutionFilter(this.mComponentResolver.queryServices(intent2, resolvedType, flags2, pkg.services, userId), instantAppPkgName);
                }
                return Collections.emptyList();
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostServiceResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.serviceInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.serviceInfo.packageName)) {
                if (isEphemeralApp || (info.serviceInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.serviceInfo.splitName != null && !ArrayUtils.contains(info.serviceInfo.applicationInfo.splitNames, info.serviceInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo((ComponentName) null, info.serviceInfo.packageName, info.serviceInfo.applicationInfo.longVersionCode, info.serviceInfo.splitName);
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
        return OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).fixIntentContentProviders(Binder.getCallingUid(), userId, new ParceledListSlice<>(queryIntentContentProvidersInternal(intent, resolvedType, flags, userId)), intent, resolvedType, flags);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private List<ResolveInfo> queryIntentContentProvidersInternal(Intent intent, String resolvedType, int flags, int userId) {
        Intent intent2;
        ComponentName comp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ProviderInfo pi = getProviderInfo(comp, flags2, userId);
            if (pi != null) {
                boolean blockResolution = false;
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (pi.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (pi.flags & 1048576) == 0;
                if (!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp))) {
                    blockResolution = true;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.providerInfo = pi;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            try {
                String pkgName = intent2.getPackage();
                if (pkgName == null) {
                    return applyPostContentProviderResolutionFilter(this.mComponentResolver.queryProviders(intent2, resolvedType, flags2, userId), instantAppPkgName);
                }
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg != null) {
                    return applyPostContentProviderResolutionFilter(this.mComponentResolver.queryProviders(intent2, resolvedType, flags2, pkg.providers, userId), instantAppPkgName);
                }
                return Collections.emptyList();
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostContentProviderResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.providerInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.providerInfo.packageName)) {
                if (isEphemeralApp || (info.providerInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.providerInfo.splitName != null && !ArrayUtils.contains(info.providerInfo.applicationInfo.splitNames, info.providerInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo((ComponentName) null, info.providerInfo.packageName, info.providerInfo.applicationInfo.longVersionCode, info.providerInfo.splitName);
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
        ArrayList<PackageInfo> list;
        ParceledListSlice<PackageInfo> parceledListSlice;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForPackage(flags, userId, null);
        boolean listFactory = true;
        boolean listUninstalled = (4202496 & flags2) != 0;
        boolean listApex = (1073741824 & flags2) != 0;
        if ((2097152 & flags2) == 0) {
            listFactory = false;
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed packages");
        boolean isSystemCaller = OppoFeatureCache.get(IColorSecurePayManager.DEFAULT).isSystemAppCall();
        synchronized (this.mPackages) {
            if (listUninstalled) {
                list = new ArrayList<>(this.mSettings.mPackages.size());
                for (PackageSetting ps : this.mSettings.mPackages.values()) {
                    if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                        if (!filterAppAccessLPr(ps, callingUid, userId)) {
                            PackageInfo pi = generatePackageInfo(ps, flags2, userId);
                            if (pi != null) {
                                if (!needHideAppList(pi.packageName, isSystemCaller, DEBUG_INSTALL)) {
                                    list.add(pi);
                                }
                            }
                        }
                    }
                }
            } else {
                list = new ArrayList<>(this.mPackages.size());
                for (PackageParser.Package p : this.mPackages.values()) {
                    PackageSetting ps2 = (PackageSetting) p.mExtras;
                    if (!filterSharedLibPackageLPr(ps2, callingUid, userId, flags2)) {
                        if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                            PackageInfo pi2 = generatePackageInfo((PackageSetting) p.mExtras, flags2, userId);
                            if (pi2 != null) {
                                if (!needHideAppList(pi2.packageName, isSystemCaller, DEBUG_INSTALL)) {
                                    list.add(pi2);
                                }
                            }
                        }
                    }
                }
            }
            if (listApex) {
                if (listFactory) {
                    list.addAll(this.mApexManager.getFactoryPackages());
                } else {
                    list.addAll(this.mApexManager.getActivePackages());
                }
                if (listUninstalled) {
                    list.addAll(this.mApexManager.getInactivePackages());
                }
            }
            OppoPackageManagerHelper.filterThirdMarketAsUser(this.mContext, this, flags2, list, this.mHandler, userId);
            parceledListSlice = new ParceledListSlice<>(list);
        }
        return parceledListSlice;
    }

    private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
        PackageInfo pi;
        int numMatch = 0;
        PermissionsState permissionsState = ps.getPermissionsState();
        for (int i = 0; i < permissions.length; i++) {
            if (permissionsState.hasPermission(permissions[i], userId)) {
                tmp[i] = true;
                numMatch++;
            } else {
                tmp[i] = false;
            }
        }
        if (!(numMatch == 0 || (pi = generatePackageInfo(ps, flags, userId)) == null)) {
            if ((flags & 4096) == 0) {
                if (numMatch == permissions.length) {
                    pi.requestedPermissions = permissions;
                } else {
                    pi.requestedPermissions = new String[numMatch];
                    int numMatch2 = 0;
                    for (int i2 = 0; i2 < permissions.length; i2++) {
                        if (tmp[i2]) {
                            pi.requestedPermissions[numMatch2] = permissions[i2];
                            numMatch2++;
                        }
                    }
                }
            }
            list.add(pi);
        }
    }

    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:39:0x0096 */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:10:0x0037 */
    /* JADX WARN: Type inference failed for: r4v0 */
    /* JADX WARN: Type inference failed for: r4v1 */
    /* JADX WARN: Type inference failed for: r4v8 */
    public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        ArrayMap<String, PackageParser.Package> arrayMap2;
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForPackage(flags, userId, permissions);
        ArrayMap<String, PackageParser.Package> arrayMap3 = 1;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "get packages holding permissions");
        boolean listUninstalled = (flags2 & 4202496) != 0;
        ArrayMap<String, PackageParser.Package> arrayMap4 = this.mPackages;
        synchronized (arrayMap4) {
            try {
                ArrayList<PackageInfo> list = new ArrayList<>();
                boolean[] tmpBools = new boolean[permissions.length];
                if (listUninstalled) {
                    for (PackageSetting ps : this.mSettings.mPackages.values()) {
                        addPackageHoldingPermissions(list, ps, permissions, tmpBools, flags2, userId);
                    }
                    arrayMap2 = arrayMap4;
                } else {
                    for (PackageParser.Package pkg : this.mPackages.values()) {
                        PackageSetting ps2 = (PackageSetting) pkg.mExtras;
                        if (ps2 != null) {
                            arrayMap3 = arrayMap4;
                            addPackageHoldingPermissions(list, ps2, permissions, tmpBools, flags2, userId);
                        } else {
                            arrayMap3 = arrayMap4;
                        }
                        arrayMap4 = arrayMap3;
                    }
                    arrayMap2 = arrayMap4;
                }
                ParceledListSlice<PackageInfo> parceledListSlice = new ParceledListSlice<>(list);
                return parceledListSlice;
            } catch (Throwable th) {
                th = th;
                arrayMap = arrayMap3;
                throw th;
            }
        }
    }

    public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        return new ParceledListSlice<>(getInstalledApplicationsListInternal(flags, userId, Binder.getCallingUid()));
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private List<ApplicationInfo> getInstalledApplicationsListInternal(int flags, int userId, int callingUid) {
        ArrayList<ApplicationInfo> list;
        ApplicationInfo ai;
        if (getInstantAppPackageName(callingUid) != null) {
            return Collections.emptyList();
        }
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int flags2 = updateFlagsForApplication(flags, userId, null);
        boolean listUninstalled = (4202496 & flags2) != 0;
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed application info");
        boolean isSystemCaller = OppoFeatureCache.get(IColorSecurePayManager.DEFAULT).isSystemAppCall();
        synchronized (this.mPackages) {
            if (listUninstalled) {
                list = new ArrayList<>(this.mSettings.mPackages.size());
                for (PackageSetting ps : this.mSettings.mPackages.values()) {
                    int effectiveFlags = flags2;
                    if (ps.isSystem()) {
                        effectiveFlags |= DumpState.DUMP_CHANGES;
                    }
                    if (ps.pkg == null) {
                        ai = generateApplicationInfoFromSettingsLPw(ps.name, callingUid, effectiveFlags, userId);
                    } else if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                        if (!filterAppAccessLPr(ps, callingUid, userId)) {
                            ai = PackageParser.generateApplicationInfo(ps.pkg, effectiveFlags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
                            }
                        }
                    }
                    if (ai != null) {
                        if (!needHideAppList(ai.packageName, isSystemCaller, DEBUG_INSTALL)) {
                            list.add(ai);
                        }
                    }
                }
            } else {
                list = new ArrayList<>(this.mPackages.size());
                for (PackageParser.Package p : this.mPackages.values()) {
                    if (p.mExtras != null) {
                        PackageSetting ps2 = (PackageSetting) p.mExtras;
                        if (!filterSharedLibPackageLPr(ps2, Binder.getCallingUid(), userId, flags2)) {
                            if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                ApplicationInfo ai2 = PackageParser.generateApplicationInfo(p, flags2, ps2.readUserState(userId), userId);
                                if (ai2 != null) {
                                    ApplicationInfo ai3 = sPmsExt.updateApplicationInfoForRemovable(ai2);
                                    if (!sPmsExt.needSkipAppInfo(ai3)) {
                                        ai3.packageName = resolveExternalPackageNameLPr(p);
                                        if (!needHideAppList(ai3.packageName, isSystemCaller, DEBUG_INSTALL)) {
                                            list.add(ai3);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return list;
    }

    public ParceledListSlice<InstantAppInfo> getInstantApps(int userId) {
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getEphemeralApplications");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getEphemeralApplications");
        synchronized (this.mPackages) {
            List<InstantAppInfo> instantApps = this.mInstantAppRegistry.getInstantAppsLPr(userId);
            if (instantApps == null) {
                return null;
            }
            return new ParceledListSlice<>(instantApps);
        }
    }

    public boolean isInstantApp(String packageName, int userId) {
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "isInstantApp");
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            this.mPackages.get(packageName);
            if (!(ps != null && (isCallerSameApp(packageName, callingUid) || canViewInstantApps(callingUid, userId) || this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId)))) {
                return false;
            }
            return ps.getInstantApp(userId);
        }
    }

    public byte[] getInstantAppCookie(String packageName, int userId) {
        byte[] instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.getInstantAppCookieLPw(packageName, userId);
        }
        return instantAppCookieLPw;
    }

    public boolean setInstantAppCookie(String packageName, byte[] cookie, int userId) {
        boolean instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "setInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return false;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.setInstantAppCookieLPw(packageName, cookie, userId);
        }
        return instantAppCookieLPw;
    }

    public Bitmap getInstantAppIcon(String packageName, int userId) {
        Bitmap instantAppIconLPw;
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppIcon");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppIcon");
        synchronized (this.mPackages) {
            instantAppIconLPw = this.mInstantAppRegistry.getInstantAppIconLPw(packageName, userId);
        }
        return instantAppIconLPw;
    }

    private boolean isCallerSameApp(String packageName, int uid) {
        PackageParser.Package pkg = this.mPackages.get(packageName);
        return pkg != null && UserHandle.getAppId(uid) == pkg.applicationInfo.uid;
    }

    public ParceledListSlice<ApplicationInfo> getPersistentApplications(int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(getPersistentApplicationsInternal(flags));
    }

    private List<ApplicationInfo> getPersistentApplicationsInternal(int flags) {
        PackageSetting ps;
        ApplicationInfo ai;
        ArrayList<ApplicationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            int userId = UserHandle.getCallingUserId();
            for (PackageParser.Package p : this.mPackages.values()) {
                if (p.applicationInfo != null) {
                    boolean matchesAware = true;
                    boolean matchesUnaware = (262144 & flags) != 0 && !p.applicationInfo.isDirectBootAware();
                    if ((524288 & flags) == 0 || !p.applicationInfo.isDirectBootAware()) {
                        matchesAware = false;
                    }
                    if ((p.applicationInfo.flags & 8) != 0 && ((!this.mSafeMode || isSystemApp(p)) && !(!(matchesUnaware || matchesAware) || (ps = this.mSettings.mPackages.get(p.packageName)) == null || (ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId)) == null))) {
                        finalList.add(ai);
                    }
                }
            }
        }
        return finalList;
    }

    public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
        return resolveContentProviderInternal(name, flags, userId);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ProviderInfo resolveContentProviderInternal(String name, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        AppFrozenWhiteListHelper.getInstance(this.mContext).processWhiteFrozenComponent(this, name, userId);
        int flags2 = updateFlagsForComponent(flags, userId, name);
        int callingUid = Binder.getCallingUid();
        ProviderInfo providerInfo = this.mComponentResolver.queryProvider(name, flags2, userId);
        if (providerInfo == null || !this.mSettings.isEnabledAndMatchLPr(providerInfo, flags2, userId)) {
            return null;
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(providerInfo.packageName), callingUid, new ComponentName(providerInfo.packageName, providerInfo.name), 4, userId)) {
                return null;
            }
            return providerInfo;
        }
    }

    @Deprecated
    public void querySyncProviders(List<String> outNames, List<ProviderInfo> outInfo) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            this.mComponentResolver.querySyncProviders(outNames, outInfo, this.mSafeMode, UserHandle.getCallingUserId());
        }
    }

    public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags, String metaDataKey) {
        int userId;
        ArrayList<ProviderInfo> finalList;
        PackageManagerService packageManagerService = this;
        int callingUid = Binder.getCallingUid();
        if (processName != null) {
            userId = UserHandle.getUserId(uid);
        } else {
            userId = UserHandle.getCallingUserId();
        }
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = packageManagerService.updateFlagsForComponent(flags, userId, processName);
        List<ProviderInfo> matchList = packageManagerService.mComponentResolver.queryProviders(processName, metaDataKey, uid, flags2, userId);
        int listSize = matchList == null ? 0 : matchList.size();
        synchronized (packageManagerService.mPackages) {
            finalList = null;
            int i = 0;
            while (i < listSize) {
                ProviderInfo providerInfo = matchList.get(i);
                if (packageManagerService.mSettings.isEnabledAndMatchLPr(providerInfo, flags2, userId)) {
                    if (!filterAppAccessLPr(packageManagerService.mSettings.mPackages.get(providerInfo.packageName), callingUid, new ComponentName(providerInfo.packageName, providerInfo.name), 4, userId)) {
                        if (finalList == null) {
                            finalList = new ArrayList<>(listSize - i);
                        }
                        finalList.add(providerInfo);
                    }
                }
                i++;
                packageManagerService = this;
            }
        }
        if (finalList == null) {
            return ParceledListSlice.emptyList();
        }
        finalList.sort(sProviderInitOrderSorter);
        return new ParceledListSlice<>(finalList);
    }

    public InstrumentationInfo getInstrumentationInfo(ComponentName component, int flags) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 0, callingUserId)) {
                return null;
            }
            return PackageParser.generateInstrumentationInfo(this.mInstrumentation.get(component), flags);
        }
    }

    public ParceledListSlice<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr(this.mSettings.mPackages.get(targetPackage), callingUid, UserHandle.getUserId(callingUid))) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(queryInstrumentationInternal(targetPackage, flags));
    }

    private List<InstrumentationInfo> queryInstrumentationInternal(String targetPackage, int flags) {
        InstrumentationInfo ii;
        ArrayList<InstrumentationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageParser.Instrumentation p : this.mInstrumentation.values()) {
                if ((targetPackage == null || targetPackage.equals(p.info.targetPackage)) && (ii = PackageParser.generateInstrumentationInfo(p, flags)) != null) {
                    finalList.add(ii);
                }
            }
        }
        return finalList;
    }

    public void scanDirTracedLI(File scanDir, int parseFlags, int scanFlags, long currentTime) {
        Trace.traceBegin(262144, "scanDir [" + scanDir.getAbsolutePath() + "]");
        try {
            scanDirLI(scanDir, parseFlags, scanFlags, currentTime);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime) {
        int i = iMultitaskNum;
        if (i > 0) {
            scanDirLI_oppo(scanDir, parseFlags, scanFlags, currentTime, i);
        } else {
            scanDirLI_android(scanDir, parseFlags, scanFlags, currentTime);
        }
    }

    /* JADX INFO: Multiple debug info for r12v4 'parseResult'  com.android.server.pm.ParallelPackageParser$ParseResult: [D('parseResult' com.android.server.pm.ParallelPackageParser$ParseResult), D('files' java.io.File[])] */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0099, code lost:
        if (r5.isDirectory() != false) goto L_0x009b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x00a3, code lost:
        if (com.android.server.pm.PackageInstallerService.isStageName(r5.getName()) == false) goto L_0x00a7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:21:0x00a6, code lost:
        r7 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x00a8, code lost:
        if (r7 != false) goto L_0x00ab;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x00ad, code lost:
        if (com.android.server.pm.PackageManagerService.EXP_VERSION == false) goto L_0x00ec;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:27:0x00b7, code lost:
        if (r5.getName().startsWith("EXPOP_") == false) goto L_0x00ec;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x00bb, code lost:
        if (com.android.server.pm.PackageManagerService.mOperator == null) goto L_0x00e9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x00c6, code lost:
        if (com.android.server.pm.PackageManagerService.mOperator.equals("oppo") == false) goto L_0x00c9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:33:0x00e7, code lost:
        if (r5.getName().startsWith("EXPOP_" + com.android.server.pm.PackageManagerService.mOperator + com.android.server.pm.PackageManagerService.STATIC_SHARED_LIB_DELIMITER) != false) goto L_0x00ec;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x00ec, code lost:
        r1.submit(r5, r22);
        r4 = r4 + 1;
     */
    /* JADX WARNING: Removed duplicated region for block: B:114:0x0253 A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:88:0x024e  */
    private void scanDirLI_android(File scanDir, int parseFlags, int scanFlags, long currentTime) {
        Throwable th;
        Throwable th2;
        boolean isPackage;
        File[] files;
        ParallelPackageParser.ParseResult parseResult;
        boolean z;
        int errorCode;
        int errorCode2;
        String str;
        PackageManagerException e;
        PackageManagerException ex;
        Throwable th3;
        File[] files2 = scanDir.listFiles();
        if (ArrayUtils.isEmpty(files2)) {
            Log.d(TAG, "No files in app dir " + scanDir);
            return;
        }
        Thread.currentThread().setPriority(10);
        Slog.i(TAG, "start scanDirLI=" + scanDir);
        if (DEBUG_PACKAGE_SCANNING) {
            Log.d(TAG, "Scanning app dir " + scanDir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags));
        }
        ParallelPackageParser parallelPackageParser = new ParallelPackageParser(this.mSeparateProcesses, this.mOnlyCore, this.mMetrics, this.mCacheDir, this.mParallelPackageParserCallback);
        try {
            int length = files2.length;
            int fileCount = 0;
            int fileCount2 = 0;
            while (true) {
                isPackage = true;
                if (fileCount2 >= length) {
                    break;
                }
                try {
                    File file = files2[fileCount2];
                    if (!PackageParser.isApkFile(file)) {
                        try {
                        } catch (Throwable th4) {
                            th3 = th4;
                            th = th3;
                            try {
                                throw th;
                            } catch (Throwable th5) {
                                $closeResource(th, parallelPackageParser);
                                throw th5;
                            }
                        }
                    }
                } catch (Throwable th6) {
                    th3 = th6;
                    th = th3;
                    throw th;
                }
                fileCount2++;
            }
            if (DEBUG_PACKAGE_SCANNING) {
                Slog.i(TAG, "parallelPackageParser.submit done for " + scanDir + "  packageCount=" + fileCount);
            }
            int fileCount3 = fileCount;
            while (fileCount3 > 0) {
                try {
                    ParallelPackageParser.ParseResult parseResult2 = parallelPackageParser.take();
                    Throwable throwable = parseResult2.throwable;
                    if (throwable == null) {
                        if (parseResult2.pkg.applicationInfo.isStaticSharedLibrary()) {
                            renameStaticSharedLibraryPackage(parseResult2.pkg);
                        }
                        if (true == isPackage) {
                            try {
                                str = ": ";
                                errorCode2 = 1;
                                files = files2;
                                parseResult = parseResult2;
                                z = isPackage;
                                try {
                                    scanPackageChildLI(parseResult2.pkg, parseFlags, scanFlags, currentTime, null);
                                } catch (PackageManagerException e2) {
                                    e = e2;
                                }
                            } catch (PackageManagerException e3) {
                                e = e3;
                                str = ": ";
                                z = isPackage;
                                files = files2;
                                parseResult = parseResult2;
                                try {
                                    errorCode2 = e.error;
                                    Slog.w(TAG, "Failed to scan " + parseResult.scanFile + str + e.getMessage());
                                    if (isFirstBoot() || isBootFromOTA()) {
                                        Slog.e(TAG, "Failed to scan " + parseResult.scanFile + " at first boot and we try again");
                                        try {
                                            try {
                                                scanPackageChildLI(parseResult.pkg, parseFlags, scanFlags, currentTime, null);
                                            } catch (PackageManagerException e4) {
                                                ex = e4;
                                            }
                                        } catch (PackageManagerException e5) {
                                            ex = e5;
                                            PackageManagerServiceUtils.logCriticalInfo(6, "Fatal exception happened on first-boot " + parseResult.scanFile + ex.toString());
                                            errorCode = errorCode2;
                                            PackageManagerServiceUtils.logCriticalInfo(5, "Deleting invalid package at " + parseResult.scanFile);
                                            if (!isFirstBoot()) {
                                            }
                                            fileCount3--;
                                            isPackage = z;
                                            files2 = files;
                                        }
                                    }
                                    errorCode = errorCode2;
                                    PackageManagerServiceUtils.logCriticalInfo(5, "Deleting invalid package at " + parseResult.scanFile);
                                    if (!isFirstBoot()) {
                                    }
                                    fileCount3--;
                                    isPackage = z;
                                    files2 = files;
                                } catch (Throwable th7) {
                                    th = th7;
                                    throw th;
                                }
                            }
                        } else {
                            errorCode2 = 1;
                            z = isPackage;
                            files = files2;
                            parseResult = parseResult2;
                        }
                        errorCode = errorCode2;
                    } else {
                        z = isPackage;
                        files = files2;
                        parseResult = parseResult2;
                        if (throwable instanceof PackageParser.PackageParserException) {
                            PackageParser.PackageParserException e6 = (PackageParser.PackageParserException) throwable;
                            errorCode = e6.error;
                            Slog.w(TAG, "Failed to parse " + parseResult.scanFile + ": " + e6.getMessage());
                        } else {
                            throw new IllegalStateException("Unexpected exception occurred while parsing " + parseResult.scanFile, throwable);
                        }
                    }
                    if ((131072 & scanFlags) == 0 && errorCode != z) {
                        PackageManagerServiceUtils.logCriticalInfo(5, "Deleting invalid package at " + parseResult.scanFile);
                        if (!isFirstBoot()) {
                            removeCodePathLI(parseResult.scanFile);
                        }
                    }
                    fileCount3--;
                    isPackage = z;
                    files2 = files;
                } catch (Throwable th8) {
                    th2 = th8;
                    th = th2;
                    throw th;
                }
            }
            $closeResource(null, parallelPackageParser);
            Slog.i(TAG, "finish scanDirLI=" + scanDir);
        } catch (Throwable th9) {
            th2 = th9;
            th = th2;
            throw th;
        }
    }

    private void scanDirLI_oppo(File scanDir, final int parseFlags, final int scanFlags, final long currentTime, int iMultitaskNum2) {
        File[] files = scanDir.listFiles();
        if (ArrayUtils.isEmpty(files)) {
            Log.d(TAG, "No files in app dir " + scanDir);
            return;
        }
        MtkSystemServer mtkSystemServer = sMtkSystemServerIns;
        mtkSystemServer.addBootEvent("Android:PMS_scan_data:" + scanDir.getPath().toString());
        if (DEBUG_PACKAGE_SCANNING) {
            Log.d(TAG, "Scanning app dir " + scanDir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags));
        }
        Slog.i("PackageManager_MultiTaskDealer", "start scanDirLI=" + scanDir + ". total thread:" + iMultitaskNum2);
        MultiTaskDealer scandealer = MultiTaskDealer.startDealer(MultiTaskDealer.PACKAGEMANAGER_SCANER, iMultitaskNum2);
        int fileCount = 0;
        int length = files.length;
        for (int i = 0; i < length; i++) {
            final File file = files[i];
            if ((PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName())) {
                if (EXP_VERSION && file.getName().startsWith("EXPOP_")) {
                    String str = mOperator;
                    if (str != null && !str.equals("oppo")) {
                        String name = file.getName();
                        if (!name.startsWith("EXPOP_" + mOperator + STATIC_SHARED_LIB_DELIMITER)) {
                        }
                    }
                }
                int fileCount2 = fileCount + 1;
                Runnable scanTask = new Runnable() {
                    /* class com.android.server.pm.PackageManagerService.AnonymousClass5 */

                    public void run() {
                        int errorCode = 1;
                        PackageParser pp = new PackageParser();
                        PackageParser.Package pkg = null;
                        try {
                            pp.setSeparateProcesses(PackageManagerService.this.mSeparateProcesses);
                            pp.setOnlyCoreApps(PackageManagerService.this.mOnlyCore);
                            pp.setDisplayMetrics(PackageManagerService.this.mMetrics);
                            pp.setCacheDir(PackageManagerService.this.mCacheDir);
                            pp.setCallback(PackageManagerService.this.mParallelPackageParserCallback);
                            pkg = pp.parsePackage(file, parseFlags, true);
                            if (PackageManagerService.isCustomApiSupported && PackageManagerCommonSoft.getAllInstallSysAppList().contains(pkg.applicationInfo.packageName)) {
                                pkg.applicationInfo.flags |= 1;
                                if (PackageManagerCommonSoft.getPrivInstallSysAppList().contains(pkg.applicationInfo.packageName)) {
                                    pkg.applicationInfo.privateFlags |= 8;
                                }
                            }
                        } catch (Throwable e) {
                            if (e instanceof PackageParser.PackageParserException) {
                                PackageParser.PackageParserException ppe = (PackageParser.PackageParserException) e;
                                errorCode = ppe.error;
                                Slog.e("PackageManager_MultiTaskDealer", "Failed to parse " + file + ": " + ppe.getMessage());
                            } else {
                                throw new IllegalStateException("Unexpected exception occurred while parsing " + file, e);
                            }
                        }
                        if (errorCode == 1 && pkg != null) {
                            try {
                                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                                    PackageManagerService.renameStaticSharedLibraryPackage(pkg);
                                }
                                PackageManagerService.this.scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, null);
                            } catch (PackageManagerException e2) {
                                errorCode = e2.error;
                                Slog.e("PackageManager_MultiTaskDealer", "Failed to scan " + file + ": " + e2.getMessage());
                                if (PackageManagerService.this.isFirstBoot() || PackageManagerService.this.isBootFromOTA()) {
                                    Slog.e("PackageManager_MultiTaskDealer", "Failed to scan " + file + " at first boot and we try again");
                                    try {
                                        PackageManagerService.this.scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, null);
                                    } catch (PackageManagerException ex) {
                                        PackageManagerServiceUtils.logCriticalInfo(6, "Fatal exception happened on first-boot " + file + ex.toString());
                                    }
                                }
                            }
                        }
                        if ((parseFlags & 16) == 0 && errorCode == -2) {
                            PackageManagerServiceUtils.logCriticalInfo(5, "Deleting invalid package at " + file);
                            if (!PackageManagerService.this.isFirstBoot()) {
                                PackageManagerService.this.removeCodePathLI(file);
                            }
                        }
                    }
                };
                if (scandealer != null) {
                    scandealer.addTask(scanTask);
                } else {
                    scanTask.run();
                }
                fileCount = fileCount2;
            }
        }
        if (scandealer != null) {
            scandealer.waitAll();
        }
        Slog.i("PackageManager_MultiTaskDealer", "finish scanDirLI=" + scanDir + "  packageCount=" + fileCount);
    }

    public static void reportSettingsProblem(int priority, String msg) {
        PackageManagerServiceUtils.logCriticalInfo(priority, msg);
    }

    private void collectCertificatesLI(PackageSetting ps, PackageParser.Package pkg, boolean forceCollect, boolean skipVerify) throws PackageManagerException {
        long lastModifiedTime = this.mIsPreNMR1Upgrade ? new File(pkg.codePath).lastModified() : PackageManagerServiceUtils.getLastModifiedTime(pkg);
        Settings.VersionInfo settingsVersionForPackage = getSettingsVersionForPackage(pkg);
        if (ps == null || forceCollect || !ps.codePathString.equals(pkg.codePath) || ps.timeStamp != lastModifiedTime || isCompatSignatureUpdateNeeded(settingsVersionForPackage) || isRecoverSignatureUpdateNeeded(settingsVersionForPackage)) {
            StringBuilder sb = new StringBuilder();
            sb.append(pkg.codePath);
            sb.append(" changed; collecting certs");
            sb.append(forceCollect ? " (forced)" : "");
            Slog.i(TAG, sb.toString());
        } else if (ps.signatures.mSigningDetails.signatures == null || ps.signatures.mSigningDetails.signatures.length == 0 || ps.signatures.mSigningDetails.signatureSchemeVersion == 0) {
            Slog.w(TAG, "PackageSetting for " + ps.name + " is missing signatures.  Collecting certs again to recover them.");
        } else {
            pkg.mSigningDetails = new PackageParser.SigningDetails(ps.signatures.mSigningDetails);
            return;
        }
        try {
            Trace.traceBegin(262144, "collectCertificates");
            PackageParser.collectCertificates(pkg, skipVerify);
            Trace.traceEnd(262144);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable th) {
            Trace.traceEnd(262144);
            throw th;
        }
    }

    private void maybeClearProfilesForUpgradesLI(PackageSetting originalPkgSetting, PackageParser.Package currentPkg) {
        if (originalPkgSetting != null && isDeviceUpgrading() && originalPkgSetting.versionCode != ((long) currentPkg.mVersionCode)) {
            clearAppProfilesLIF(currentPkg, -1);
            if (DEBUG_INSTALL) {
                Slog.d(TAG, originalPkgSetting.name + " clear profile due to version change " + originalPkgSetting.versionCode + " != " + currentPkg.mVersionCode);
            }
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    public PackageParser.Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        Trace.traceBegin(262144, "scanPackage [" + scanFile.toString() + "]");
        try {
            return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Parsing: " + scanFile);
        }
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(this.mSeparateProcesses);
        pp.setOnlyCoreApps(this.mOnlyCore);
        pp.setDisplayMetrics(this.mMetrics);
        pp.setCallback(this.mPackageParserCallback);
        Trace.traceBegin(262144, "parsePackage");
        try {
            PackageParser.Package pkg = pp.parsePackage(scanFile, parseFlags);
            Trace.traceEnd(262144);
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                renameStaticSharedLibraryPackage(pkg);
            }
            return scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable pkg2) {
            Trace.traceEnd(262144);
            throw pkg2;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package scanPackageChildLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        int scanFlags2;
        if ((scanFlags & 1024) != 0) {
            scanFlags2 = scanFlags & -1025;
        } else if (pkg.childPackages == null || pkg.childPackages.size() <= 0) {
            scanFlags2 = scanFlags;
        } else {
            scanFlags2 = scanFlags | 1024;
        }
        mCompatibilityHelper.customizePackageIfNeeded(pkg);
        File scanFile = new File(pkg.codePath);
        int childCount = 0;
        boolean isSystemApp = true;
        if (!((scanFile.toString().contains("/system/app") || scanFile.toString().contains("/system/priv-app") || scanFile.toString().contains("/oem/app") || scanFile.toString().contains("/vendor/app") || scanFile.toString().contains(VENDOR_OVERLAY_DIR) || scanFile.toString().contains("/product/app") || scanFile.toString().contains("/product/priv-app")) || scanFile.toString().contains("/extra/app") || scanFile.toString().contains("/extra/priv-app")) && !scanFile.toString().contains("/oppo_product/app") && !scanFile.toString().contains("/oppo_product/priv-app") && !scanFile.toString().contains("/oppo_engineering/app") && !scanFile.toString().contains("/oppo_engineering/priv-app") && !scanFile.toString().contains("/oppo_version/app") && !scanFile.toString().contains("/oppo_version/priv-app")) {
            isSystemApp = false;
        }
        if (isSystemApp && PackageManagerCommonSoft.isSystemAppNameInBlackList(pkg.packageName)) {
            throw new PackageManagerException(-2, "PackageManagerCommonSoft system fiter this app by name");
        } else if (isSystemApp && PackageManagerCommonSoft.isSystemAppPathInBlackList(scanFile.toString())) {
            throw new PackageManagerException(-2, "PackageManagerCommonSoft system fiter this app by path");
        } else if (!isSystemApp || !OppoOperatorManagerService.isInSimTriggeredSystemBlackList(pkg.packageName)) {
            interceptScanSellModeIfNeeded(pkg.packageName);
            if (!new OppoNfcPackageFilter().filterPackage(pkg.packageName, scanFile.toString())) {
                PackageParser.Package scannedPkg = addForInitLI(pkg, parseFlags, scanFlags2, currentTime, user);
                if (pkg.childPackages != null) {
                    childCount = pkg.childPackages.size();
                }
                for (int i = 0; i < childCount; i++) {
                    addForInitLI((PackageParser.Package) pkg.childPackages.get(i), parseFlags, scanFlags2, currentTime, user);
                }
                if ((scanFlags2 & 1024) != 0) {
                    return scanPackageChildLI(pkg, parseFlags, scanFlags2, currentTime, user);
                }
                return scannedPkg;
            }
            Log.i(TAG, "!!! so skip nfc pkg.packageName = " + pkg.packageName + "  scanFile.toString() = " + scanFile.toString());
            throw new PackageManagerException(-2, "this is not supported nfc app");
        } else {
            throw new PackageManagerException(-2, "OppoOperatorManagerService system fiter this app by name");
        }
    }

    private boolean canSkipForcedPackageVerification(PackageParser.Package pkg) {
        if (!canSkipForcedApkVerification(pkg.baseCodePath)) {
            return false;
        }
        if (ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            return true;
        }
        for (int i = 0; i < pkg.splitCodePaths.length; i++) {
            if (!canSkipForcedApkVerification(pkg.splitCodePaths[i])) {
                return false;
            }
        }
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0021, code lost:
        r1 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0022, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Error in fsverity check. Fallback to full apk verification.", r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0029, code lost:
        return false;
     */
    /* JADX WARNING: Removed duplicated region for block: B:17:0x0021 A[ExcHandler: InstallerException | IOException | DigestException | NoSuchAlgorithmException (r1v1 'e' java.lang.Exception A[CUSTOM_DECLARE]), Splitter:B:15:0x0020] */
    private boolean canSkipForcedApkVerification(String apkPath) {
        if (!PackageManagerServiceUtils.isLegacyApkVerityEnabled()) {
            return VerityUtils.hasFsverity(apkPath);
        }
        byte[] rootHashObserved = VerityUtils.generateApkVerityRootHash(apkPath);
        if (rootHashObserved == null) {
            return false;
        }
        synchronized (this.mInstallLock) {
            this.mInstaller.assertFsverityRootHashMatches(apkPath, rootHashObserved);
        }
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:101:0x020a, code lost:
        if (r0 == false) goto L_0x0278;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x020c, code lost:
        r1 = r38.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x020e, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:?, code lost:
        r38.mPackages.remove(r3.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x0216, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x0217, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, "System package updated; name: " + r3.name + "; " + r3.versionCode + " --> " + r39.getLongVersionCode() + "; " + r3.codePathString + " --> " + r39.codePath);
        createInstallArgsForExisting(r3.codePathString, r3.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r3)).cleanUpResourcesLI();
        r4 = r38.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x0268, code lost:
        monitor-enter(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:?, code lost:
        r38.mSettings.enableSystemPackageLPw(r3.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x0270, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x0278, code lost:
        if (r0 == false) goto L_0x02b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x027a, code lost:
        if (r11 == false) goto L_0x02b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x027c, code lost:
        if (r0 == false) goto L_0x027f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x02b7, code lost:
        throw new com.android.server.pm.PackageManagerException(5, "Package " + r39.packageName + " at " + r39.codePath + " ignored: updated version " + r3.versionCode + " better than this " + r39.getLongVersionCode());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x02ba, code lost:
        if (r38.mIsUpgrade == false) goto L_0x02be;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x02bc, code lost:
        if (r0 != false) goto L_0x02c4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x02c2, code lost:
        if (com.android.server.pm.PackageManagerServiceUtils.isApkVerificationForced(r33) == false) goto L_0x02c6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x02c4, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x02c6, code lost:
        r1 = r35;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x02c9, code lost:
        if (r0 != false) goto L_0x02d5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x02cb, code lost:
        if (r1 == false) goto L_0x02d7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x02d1, code lost:
        if (canSkipForcedPackageVerification(r39) == false) goto L_0x02d7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x02d5, code lost:
        r35 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x02d7, code lost:
        collectCertificatesLI(r3, r39, r1, r35);
        maybeClearProfilesForUpgradesLI(r3, r39);
        r16 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x02e1, code lost:
        if (r0 == false) goto L_0x0430;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:139:0x02e3, code lost:
        if (r11 != false) goto L_0x0430;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x02e5, code lost:
        if (r11 == false) goto L_0x0430;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x02eb, code lost:
        if (r3.isSystem() != false) goto L_0x0428;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x02f8, code lost:
        if (r39.mSigningDetails.checkCapability(r3.signatures.mSigningDetails, 1) != false) goto L_0x0380;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:146:0x0306, code lost:
        if (r3.signatures.mSigningDetails.checkCapability(r39.mSigningDetails, 8) != false) goto L_0x0377;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x0308, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, "System package signature mismatch; name: " + r3.name);
        r4 = freezePackage(r39.packageName, "scanPackageInternalLI");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x0329, code lost:
        r11 = r39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:?, code lost:
        deletePackageLIF(r39.packageName, null, true, null, 0, null, false, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x0354, code lost:
        if (r4 == null) goto L_0x035a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:0x0356, code lost:
        $closeResource(null, r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x035a, code lost:
        r8 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x035f, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x0360, code lost:
        r1 = r4;
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x0364, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x0365, code lost:
        r1 = r4;
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:?, code lost:
        throw r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x036f, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x0371, code lost:
        if (r1 != null) goto L_0x0373;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x0373, code lost:
        $closeResource(r2, r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:167:0x0376, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x0377, code lost:
        r36 = r3;
        r8 = true;
        r11 = r39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x0380, code lost:
        r36 = r3;
        r8 = true;
        r11 = r39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x0388, code lost:
        if (r0 == false) goto L_0x03e3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x038a, code lost:
        r1 = new java.lang.StringBuilder();
        r1.append("System package enabled; name: ");
        r2 = r36;
        r1.append(r2.name);
        r1.append("; ");
        r1.append(r2.versionCode);
        r1.append(" --> ");
        r1.append(r39.getLongVersionCode());
        r1.append("; ");
        r1.append(r2.codePathString);
        r1.append(" --> ");
        r1.append(r11.codePath);
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, r1.toString());
        r1 = createInstallArgsForExisting(r2.codePathString, r2.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r2));
        r3 = r38.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x03da, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:?, code lost:
        r1.cleanUpResourcesLI();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x03de, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x03e3, code lost:
        r16 = true;
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, "System package disabled; name: " + r36.name + "; old: " + r36.codePathString + " @ " + r36.versionCode + "; new: " + r11.codePath + " @ " + r11.codePath);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x0428, code lost:
        r2 = r3;
        r8 = true;
        r11 = r39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x0430, code lost:
        r2 = r3;
        r8 = true;
        r11 = r39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x0438, code lost:
        r1 = scanPackageNewLI(r39, r40, r41 | 2, r42, r44);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x044a, code lost:
        if (r1.success == false) goto L_0x049e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x044c, code lost:
        r2 = r38.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x044e, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x044f, code lost:
        r3 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:?, code lost:
        r0 = r1.pkgSetting.name;
        r4 = reconcilePackagesLocked(new com.android.server.pm.PackageManagerService.ReconcileRequest(java.util.Collections.singletonMap(r0, r1), r38.mSharedLibraries, r38.mPackages, java.util.Collections.singletonMap(r0, getSettingsVersionForPackage(r39)), java.util.Collections.singletonMap(r0, getSharedLibLatestVersionSetting(r1)), null), r38.mSettings.mKeySetManagerService);
        r3 = optimisticallyRegisterAppId(r1);
        commitReconciledScanResultLocked(r4.get(r0));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x0492, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x0494, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x0495, code lost:
        if (r3 != false) goto L_0x0497;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:198:0x0497, code lost:
        cleanUpAppIdCreation(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x049b, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:201:0x049d, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:0x049e, code lost:
        if (r16 == false) goto L_0x04af;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:203:0x04a0, code lost:
        r2 = r38.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:204:0x04a2, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:?, code lost:
        r38.mSettings.disableSystemPackageLPw(r11.packageName, r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x04aa, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:213:0x04b3, code lost:
        return r1.pkgSetting.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:0x04b8, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x01da, code lost:
        if (r11 == false) goto L_0x01e8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x01e4, code lost:
        if (r3.codePathString.equals(r39.codePath) != false) goto L_0x01e8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x01e6, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x01e8, code lost:
        r0 = r35;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x01eb, code lost:
        if (r11 == false) goto L_0x01f9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x01f5, code lost:
        if (r39.getLongVersionCode() < r3.versionCode) goto L_0x01f9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01f7, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x01f9, code lost:
        r0 = r35;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x01fc, code lost:
        if (r0 == false) goto L_0x0206;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x01fe, code lost:
        if (r11 == false) goto L_0x0206;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x0200, code lost:
        if (r0 == false) goto L_0x0206;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x0202, code lost:
        if (r0 == false) goto L_0x0206;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x0204, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x0206, code lost:
        r0 = r35;
     */
    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package addForInitLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        String disabledPkgName;
        SharedUserSetting sharedUserSetting;
        boolean skipVerify;
        PackageSetting disabledPkgSetting;
        PackageSetting originalPkgSetting;
        PackageSetting originalPkgSetting2;
        PackageSetting installedPkgSetting;
        boolean scanSystemPartition = (parseFlags & 16) != 0 || (sPmsExt.isRemovableSysApp(pkg.packageName) && !pkg.codePath.startsWith("/data/"));
        pkg.setApplicationVolumeUuid(pkg.volumeUuid);
        pkg.setApplicationInfoCodePath(pkg.codePath);
        pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
        pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
        pkg.setApplicationInfoResourcePath(pkg.codePath);
        pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
        pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
        synchronized (this.mPackages) {
            String renamedPkgName = this.mSettings.getRenamedPackageLPr(pkg.mRealPackage);
            String realPkgName = getRealPackageName(pkg, renamedPkgName);
            if (realPkgName != null) {
                ensurePackageRenamed(pkg, renamedPkgName);
            }
            PackageSetting originalPkgSetting3 = getOriginalPackageLocked(pkg, renamedPkgName);
            PackageSetting installedPkgSetting2 = this.mSettings.getPackageLPr(pkg.packageName);
            PackageSetting pkgSetting = originalPkgSetting3 == null ? installedPkgSetting2 : originalPkgSetting3;
            boolean pkgAlreadyExists = pkgSetting != null;
            String disabledPkgName2 = pkgAlreadyExists ? pkgSetting.name : pkg.packageName;
            PackageSetting disabledPkgSetting2 = this.mSettings.getDisabledSystemPkgLPr(disabledPkgName2);
            boolean isSystemPkgUpdated = disabledPkgSetting2 != null;
            if (DEBUG_INSTALL && isSystemPkgUpdated) {
                Slog.d(TAG, "updatedPkg = " + disabledPkgSetting2);
            }
            if (sPmsExt.needSkipScanning(pkg, disabledPkgSetting2, pkgSetting)) {
                return null;
            }
            if (pkg.mSharedUserId != null) {
                disabledPkgName = disabledPkgName2;
                sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
            } else {
                disabledPkgName = disabledPkgName2;
                sharedUserSetting = null;
            }
            if (!(!DEBUG_PACKAGE_SCANNING || (Integer.MIN_VALUE & parseFlags) == 0 || sharedUserSetting == null)) {
                Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + sharedUserSetting.userId + "): packages=" + sharedUserSetting.packages);
            }
            if (!scanSystemPartition) {
                disabledPkgSetting = disabledPkgSetting2;
                originalPkgSetting = pkgSetting;
                skipVerify = false;
            } else if (isSystemPkgUpdated) {
                int scannedChildCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
                int disabledChildCount = disabledPkgSetting2.childPackageNames != null ? disabledPkgSetting2.childPackageNames.size() : 0;
                int i = 0;
                while (i < disabledChildCount) {
                    String disabledChildPackageName = (String) disabledPkgSetting2.childPackageNames.get(i);
                    boolean disabledPackageAvailable = false;
                    int j = 0;
                    while (true) {
                        if (j >= scannedChildCount) {
                            originalPkgSetting2 = originalPkgSetting3;
                            installedPkgSetting = installedPkgSetting2;
                            break;
                        }
                        originalPkgSetting2 = originalPkgSetting3;
                        installedPkgSetting = installedPkgSetting2;
                        if (((PackageParser.Package) pkg.childPackages.get(j)).packageName.equals(disabledChildPackageName)) {
                            disabledPackageAvailable = true;
                            break;
                        }
                        j++;
                        originalPkgSetting3 = originalPkgSetting2;
                        installedPkgSetting2 = installedPkgSetting;
                    }
                    if (!disabledPackageAvailable) {
                        this.mSettings.removeDisabledSystemPackageLPw(disabledChildPackageName);
                    }
                    i++;
                    realPkgName = realPkgName;
                    originalPkgSetting3 = originalPkgSetting2;
                    installedPkgSetting2 = installedPkgSetting;
                }
                disabledPkgSetting = disabledPkgSetting2;
                skipVerify = false;
                originalPkgSetting = pkgSetting;
                ScanRequest request = new ScanRequest(pkg, sharedUserSetting, null, disabledPkgSetting, null, null, null, parseFlags, scanFlags, pkg == this.mPlatformPackage, user);
                applyPolicy(pkg, parseFlags, scanFlags, this.mPlatformPackage);
                ScanResult scanResult = scanPackageOnlyLI(request, this.mFactoryTest, -1);
                if (scanResult.existingSettingCopied && scanResult.request.pkgSetting != null) {
                    scanResult.request.pkgSetting.updateFrom(scanResult.pkgSetting);
                }
            } else {
                disabledPkgSetting = disabledPkgSetting2;
                originalPkgSetting = pkgSetting;
                skipVerify = false;
            }
        }
        while (true) {
        }
    }

    /* access modifiers changed from: private */
    public static void renameStaticSharedLibraryPackage(PackageParser.Package pkg) {
        pkg.setPackageName(pkg.packageName + STATIC_SHARED_LIB_DELIMITER + pkg.staticSharedLibVersion);
    }

    static String fixProcessName(String defProcessName, String processName) {
        if (processName == null) {
            return defProcessName;
        }
        return (!DEBUG_PROCESS_SPLIT || !OppoFeatureCache.get(IColorMergedProcessSplitManager.DEFAULT).isAppProcessNeedSplit(processName)) ? processName : defProcessName;
    }

    private static void enforceSystemOrRoot(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0) {
            throw new SecurityException(message);
        }
    }

    private static void enforceSystemOrRootOrShell(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0 && uid != 2000) {
            throw new SecurityException(message);
        }
    }

    public void performFstrimIfNeeded() {
        long interval;
        boolean dexOptDialogShown;
        enforceSystemOrRoot("Only the system can request fstrim");
        try {
            IStorageManager sm = PackageHelper.getStorageManager();
            if (sm != null) {
                boolean doTrim = false;
                if (Environment.isWhiteListMcp()) {
                    Log.e(TAG, "isWhiteListMcp,true!");
                    interval = Settings.Global.getLong(this.mContext.getContentResolver(), "fstrim_mandatory_interval", 86400000);
                } else {
                    interval = Settings.Global.getLong(this.mContext.getContentResolver(), "fstrim_mandatory_interval", DEFAULT_MANDATORY_FSTRIM_INTERVAL);
                }
                if (interval > 0) {
                    long timeSinceLast = System.currentTimeMillis() - sm.lastMaintenance();
                    if (timeSinceLast > interval) {
                        doTrim = true;
                        Slog.w(TAG, "No disk maintenance in " + timeSinceLast + "; running immediately");
                    }
                }
                if (doTrim) {
                    synchronized (this.mPackages) {
                        dexOptDialogShown = this.mDexOptDialogShown;
                    }
                    if (!isFirstBoot() && dexOptDialogShown) {
                        try {
                            ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039493), true);
                        } catch (RemoteException e) {
                        }
                    }
                    sm.runMaintenance();
                    return;
                }
                return;
            }
            Slog.e(TAG, "storageManager service unavailable!");
        } catch (RemoteException e2) {
        }
    }

    public void updatePackagesIfNeeded() {
        List<PackageParser.Package> pkgs;
        List<PackageParser.Package> persistkgs;
        enforceSystemOrRoot("Only the system can request package update");
        boolean causeUpgrade = isDeviceUpgrading();
        boolean causeFirstBoot = isFirstBoot() || this.mIsPreNUpgrade;
        boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
        if (!causeUpgrade && !causeFirstBoot && !causePrunedCache) {
            return;
        }
        if (!new File("/data/app/packages.xml").exists() || !causeFirstBoot) {
            if (isBootFromOTA()) {
                synchronized (this.mPackages) {
                    Phoenix.setBootstage("ANDROID_PMS_DEXOPT_PERSISTPKGS_START");
                    persistkgs = PackageManagerServiceUtils.getPersistPackagesForDexopt(this.mPackages.values(), this);
                    Phoenix.setBootstage("ANDROID_PMS_DEXOPT_PERSISTPKGS_END");
                }
                performDexOptUpgrade(persistkgs, this.mIsPreNUpgrade, 0, false);
            }
            synchronized (this.mPackages) {
                pkgs = PackageManagerServiceUtils.getPackagesForDexopt(this.mPackages.values(), this);
            }
            long startTime = System.nanoTime();
            Phoenix.setBootstage("ANDROID_PMS_DEXOPT_START");
            int[] stats = performDexOptUpgrade(pkgs, this.mIsPreNUpgrade, causeFirstBoot ? 0 : 1, false);
            Phoenix.setBootstage("ANDROID_PMS_DEXOPT_END");
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_dexopted", stats[0]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_skipped", stats[1]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_failed", stats[2]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_total", getOptimizablePackages().size());
            MetricsLogger.histogram(this.mContext, "opt_dialog_time_s", (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime));
        }
    }

    private static String getPrebuildProfilePath(PackageParser.Package pkg) {
        return pkg.baseCodePath + ".prof";
    }

    /* JADX WARNING: Removed duplicated region for block: B:42:0x0109  */
    /* JADX WARNING: Removed duplicated region for block: B:46:0x012c  */
    private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, int compilationReason, boolean bootComplete) {
        Iterator<PackageParser.Package> it;
        Exception e;
        int numberOfPackagesVisited = 0;
        int numberOfPackagesOptimized = 0;
        int numberOfPackagesSkipped = 0;
        int numberOfPackagesFailed = 0;
        int numberOfPackagesToDexopt = pkgs.size();
        Iterator<PackageParser.Package> it2 = pkgs.iterator();
        while (it2.hasNext()) {
            PackageParser.Package pkg = it2.next();
            int numberOfPackagesVisited2 = numberOfPackagesVisited + 1;
            boolean useProfileForDexopt = false;
            if (!isFirstBoot() && !isDeviceUpgrading()) {
                it = it2;
            } else if (isSystemApp(pkg)) {
                File profileFile = new File(getPrebuildProfilePath(pkg));
                if (profileFile.exists()) {
                    try {
                        if (!this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                            Log.e(TAG, "Installer failed to copy system profile!");
                        }
                    } catch (Exception e2) {
                        Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + StringUtils.SPACE, e2);
                    }
                    it = it2;
                } else {
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                    if (disabledPs == null || !disabledPs.pkg.isStub) {
                        it = it2;
                    } else {
                        File profileFile2 = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, ""));
                        if (profileFile2.exists()) {
                            try {
                                it = it2;
                                try {
                                    if (!this.mInstaller.copySystemProfile(profileFile2.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                                        Log.e(TAG, "Failed to copy system profile for stub package!");
                                    } else {
                                        useProfileForDexopt = true;
                                    }
                                } catch (Exception e3) {
                                    e = e3;
                                    Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + StringUtils.SPACE, e);
                                    if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
                                    }
                                }
                            } catch (Exception e4) {
                                e = e4;
                                it = it2;
                                Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + StringUtils.SPACE, e);
                                if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
                                }
                            }
                        } else {
                            it = it2;
                        }
                    }
                }
            } else {
                it = it2;
            }
            if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
                if (DEBUG_DEXOPT) {
                    Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
                }
                numberOfPackagesSkipped++;
                numberOfPackagesVisited = numberOfPackagesVisited2;
                it2 = it;
            } else {
                if (DEBUG_DEXOPT) {
                    Log.i(TAG, "Updating app " + numberOfPackagesVisited2 + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
                }
                if (showDialog) {
                    try {
                        ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039491, Integer.valueOf(numberOfPackagesVisited2), Integer.valueOf(numberOfPackagesToDexopt)), true);
                    } catch (RemoteException e5) {
                    }
                    synchronized (this.mPackages) {
                        this.mDexOptDialogShown = true;
                    }
                }
                int pkgCompilationReason = compilationReason;
                if (useProfileForDexopt) {
                    pkgCompilationReason = 3;
                }
                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {
                    this.mArtManagerService.compileLayouts(pkg);
                }
                int dexoptFlags = bootComplete ? 4 : 0;
                if (compilationReason == 0) {
                    dexoptFlags |= 1024;
                }
                int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, dexoptFlags));
                if (primaryDexOptStaus == -1) {
                    numberOfPackagesFailed++;
                } else if (primaryDexOptStaus == 0) {
                    numberOfPackagesSkipped++;
                } else if (primaryDexOptStaus != 1) {
                    Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                } else {
                    numberOfPackagesOptimized++;
                }
                numberOfPackagesVisited = numberOfPackagesVisited2;
                it2 = it;
            }
        }
        return new int[]{numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed};
    }

    public void notifyPackageUse(String packageName, int reason) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (getInstantAppPackageName(callingUid) != null) {
                if (!isCallerSameApp(packageName, callingUid)) {
                    return;
                }
            } else if (isInstantApp(packageName, callingUserId)) {
                return;
            }
            notifyPackageUseLocked(packageName, reason);
        }
    }

    private static Handler getFirstUseHandler() {
        if (sFirstUseHandler == null) {
            synchronized (sFirstUseLock) {
                if (sFirstUseHandler == null) {
                    sFirstUseThread = new HandlerThread("first_use_thread");
                    sFirstUseThread.start();
                    sFirstUseHandler = new Handler(sFirstUseThread.getLooper());
                }
            }
        }
        return sFirstUseHandler;
    }

    public static void processFirstUseActivity(PackageManagerService pm, final String packageName) {
        getFirstUseHandler().post(new Runnable() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass6 */

            public void run() {
                PackageManagerService.handleFirstUseActivity(PackageManagerService.this, packageName);
            }
        });
    }

    public static void handleFirstUseActivity(PackageManagerService pm, String packageName) {
        boolean success = pm.performDexOptMode(packageName, true, "speed-profile", false, true, null);
        Slog.d(TAG, "FirstUseActivity packageName = " + packageName + " is compiled using filter speed-profile, success = " + success);
        PinnerService pinnerService = (PinnerService) LocalServices.getService(PinnerService.class);
        if (pinnerService != null) {
            Log.i(TAG, "FirstUseActivity Pinning optimized code " + packageName);
            ArraySet<String> packages = new ArraySet<>();
            packages.add(packageName);
            pinnerService.update(packages, false);
        }
    }

    @GuardedBy({"mPackages"})
    public PackageManagerInternal.CheckPermissionDelegate getCheckPermissionDelegateLocked() {
        return this.mCheckPermissionDelegate;
    }

    @GuardedBy({"mPackages"})
    public void setCheckPermissionDelegateLocked(PackageManagerInternal.CheckPermissionDelegate delegate) {
        this.mCheckPermissionDelegate = delegate;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private void notifyPackageUseLocked(final String packageName, int reason) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            if (DEBUG_INSTALL) {
                Slog.d(TAG, reason + StringUtils.SPACE + p.mLastPackageUsageTimeInMills[reason] + StringUtils.SPACE + inCptWhiteList(CompatibilityHelper.DO_FRAME_OPT, packageName) + StringUtils.SPACE + packageName);
            }
            if (reason == 0 && p.mLastPackageUsageTimeInMills[reason] <= 0 && inCptWhiteList(CompatibilityHelper.DO_FRAME_OPT, packageName)) {
                this.mHandler.postDelayed(new Runnable() {
                    /* class com.android.server.pm.PackageManagerService.AnonymousClass7 */

                    public void run() {
                        PackageManagerService.processFirstUseActivity(PackageManagerService.this, packageName);
                    }
                }, 9000);
            }
            p.mLastPackageUsageTimeInMills[reason] = System.currentTimeMillis();
        }
    }

    public void notifyDexLoad(String loadingPackageName, List<String> classLoaderNames, List<String> classPaths, String loaderIsa) {
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(loadingPackageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Loading a package that does not exist for the calling user. package=" + loadingPackageName + ", user=" + userId);
            return;
        }
        boolean isFront = ai.processName.equals(SystemProperties.get("debug.junk.process.name", ""));
        boolean needBgDexopt = SystemProperties.getBoolean("persist.sys.oppo.bgdex2oat_enabled", true);
        Map<String, PackageDexUsage.DexUseInfo> dexUseInfoMapBeforeNotify = this.mDexManager.getPackageUseInfoOrDefault(loadingPackageName).getDexUseInfoMap();
        String dexPath = classPaths.get(0);
        boolean backgroundDexopt = needBgDexopt && (dexUseInfoMapBeforeNotify.isEmpty() || dexUseInfoMapBeforeNotify.get(dexPath) == null);
        this.mDexManager.notifyDexLoad(ai, classLoaderNames, classPaths, loaderIsa, userId);
        Map<String, PackageDexUsage.DexUseInfo> dexUseInfoMapAfterNotify = this.mDexManager.getPackageUseInfoOrDefault(loadingPackageName).getDexUseInfoMap();
        if (!backgroundDexopt || loadingPackageName == null || !isFront) {
            if (DEBUG_DEXOPT) {
                StringBuilder sb = new StringBuilder();
                sb.append("notifyDexLoad loadingPackageName: ");
                sb.append(loadingPackageName);
                sb.append(",(dexUseInfoMap BeforeNotify (");
                sb.append(dexPath);
                sb.append(") is null? :");
                sb.append(dexUseInfoMapBeforeNotify.get(dexPath) == null);
                sb.append(",(dexUseInfoMap AfterNotify (");
                sb.append(dexPath);
                sb.append(") is null? :");
                sb.append(dexUseInfoMapAfterNotify.get(dexPath) == null);
                sb.append(",  backgroundDexopt: ");
                sb.append(backgroundDexopt);
                Slog.w(TAG, sb.toString());
            }
        } else if (dexUseInfoMapAfterNotify.get(dexPath) != null) {
            doBackgroundDexopt(ai, loadingPackageName, dexPath, dexUseInfoMapAfterNotify.get(dexPath));
        }
    }

    private static Handler getBgDexoptHandler() {
        if (sBgDexoptHandler == null) {
            sBgDexoptThread = new HandlerThread("bgdexopt");
            sBgDexoptThread.start();
            sBgDexoptHandler = new Handler(sBgDexoptThread.getLooper());
        }
        return sBgDexoptHandler;
    }

    private void doBackgroundDexopt(final ApplicationInfo ai, final String loadingPackageName, final String path, final PackageDexUsage.DexUseInfo dexUseInfo) {
        getBgDexoptHandler().post(new Runnable() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass8 */

            public void run() {
                Set<String> unusedPackages = PackageManagerService.this.getUnusedPackages(JobStatus.NO_LATEST_RUNTIME);
                boolean downgrade = true;
                int i = 0;
                boolean shouldDowngrade = Environment.getDataDirectory().getUsableSpace() < 2 * StorageManager.from(PackageManagerService.this.mContext).getStorageLowBytes(Environment.getDataDirectory());
                if (!unusedPackages.contains(loadingPackageName) || !shouldDowngrade) {
                    downgrade = false;
                }
                if (downgrade) {
                    i = 32;
                }
                SystemProperties.set("oppo.dex.thread.number", "4");
                Slog.i(PackageManagerService.TAG, path + " Background Dexopt for secondary dex begin!");
                if (PackageManagerService.this.mPackageDexOptimizer.dexOptSecondaryDexPath(ai, path, dexUseInfo, new DexoptOptions(loadingPackageName, 3, i | 5 | 8 | 2)) != -1) {
                    Slog.i(PackageManagerService.TAG, path + " Background Dexopt for secondary dex success!");
                }
            }
        });
    }

    public void registerDexModule(String packageName, String dexModulePath, boolean isSharedModule, IDexModuleRegisterCallback callback) {
        DexManager.RegisterDexModuleResult result;
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(packageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Registering a dex module for a package that does not exist for the calling user. package=" + packageName + ", user=" + userId);
            result = new DexManager.RegisterDexModuleResult(false, "Package not installed");
        } else {
            result = this.mDexManager.registerDexModule(ai, dexModulePath, isSharedModule, userId);
        }
        if (callback != null) {
            this.mHandler.post(new Runnable(callback, dexModulePath, result) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$opO5Lt6aW9gAx6B5CGlW6sAaX8 */
                private final /* synthetic */ IDexModuleRegisterCallback f$0;
                private final /* synthetic */ String f$1;
                private final /* synthetic */ DexManager.RegisterDexModuleResult f$2;

                {
                    this.f$0 = r1;
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void run() {
                    PackageManagerService.lambda$registerDexModule$3(this.f$0, this.f$1, this.f$2);
                }
            });
        }
    }

    static /* synthetic */ void lambda$registerDexModule$3(IDexModuleRegisterCallback callback, String dexModulePath, DexManager.RegisterDexModuleResult result) {
        try {
            callback.onDexModuleRegistered(dexModulePath, result.success, result.message);
        } catch (RemoteException e) {
            Slog.w(TAG, "Failed to callback after module registration " + dexModulePath, e);
        }
    }

    public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
        int i = 0;
        int i2 = (force ? 2 : 0) | (checkProfiles ? 1 : 0);
        if (bootComplete) {
            i = 4;
        }
        return performDexOpt(new DexoptOptions(packageName, -1, targetCompilerFilter, splitName, i | i2));
    }

    public int performDexOptWithStatusByOption(DexoptOptions option) {
        return performDexOptWithStatus(option);
    }

    public boolean performDexOptSecondary(String packageName, String compilerFilter, boolean force) {
        return performDexOpt(new DexoptOptions(packageName, compilerFilter, (force ? 2 : 0) | 13));
    }

    public boolean compileLayouts(String packageName) {
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                return false;
            }
            return this.mViewCompiler.compileLayouts(pkg);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean performDexOpt(DexoptOptions options) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || isInstantApp(options.getPackageName(), UserHandle.getCallingUserId())) {
            return false;
        }
        if (options.isDexoptOnlySecondaryDex()) {
            return this.mDexManager.dexoptSecondaryDex(options);
        }
        if (performDexOptWithStatus(options) != -1) {
            return true;
        }
        return false;
    }

    /* access modifiers changed from: package-private */
    public int performDexOptWithStatus(DexoptOptions options) {
        return performDexOptTraced(options);
    }

    private int performDexOptTraced(DexoptOptions options) {
        MtkSystemServer mtkSystemServer = sMtkSystemServerIns;
        mtkSystemServer.addBootEvent("PMS:performDexOpt:" + options.getPackageName());
        Trace.traceBegin(262144, "dexopt");
        try {
            return performDexOptInternal(options);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private int performDexOptInternal(DexoptOptions options) {
        int performDexOptInternalWithDependenciesLI;
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(options.getPackageName());
            if (p == null) {
                return -1;
            }
            this.mPackageUsage.maybeWriteAsync(this.mPackages);
            this.mCompilerStats.maybeWriteAsync();
            long callingId = Binder.clearCallingIdentity();
            try {
                synchronized (this.mInstallLock) {
                    performDexOptInternalWithDependenciesLI = performDexOptInternalWithDependenciesLI(p, options);
                }
                return performDexOptInternalWithDependenciesLI;
            } finally {
                Binder.restoreCallingIdentity(callingId);
            }
        }
    }

    public ArraySet<String> getOptimizablePackages() {
        ArraySet<String> pkgs = new ArraySet<>();
        synchronized (this.mPackages) {
            for (PackageParser.Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p.packageName);
                }
            }
        }
        return pkgs;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:16:0x0063, code lost:
        if (r4 == null) goto L_0x0044;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0066, code lost:
        r1.performDexOpt(r4, r9, getOrCreateCompilerPackageStats(r4), r11.mDexManager.getPackageUseInfoOrDefault(r4.packageName), r2);
     */
    private int performDexOptInternalWithDependenciesLI(PackageParser.Package p, DexoptOptions options) {
        PackageDexOptimizer.ForcedUpdatePackageDexOptimizer pdo;
        Throwable th;
        if (options.isForce()) {
            pdo = new PackageDexOptimizer.ForcedUpdatePackageDexOptimizer(this.mPackageDexOptimizer);
        } else {
            pdo = this.mPackageDexOptimizer;
        }
        Collection<SharedLibraryInfo> deps = findSharedLibraries(p);
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(p.applicationInfo);
        if (!deps.isEmpty()) {
            DexoptOptions libraryOptions = new DexoptOptions(options.getPackageName(), options.getCompilationReason(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | 64);
            for (SharedLibraryInfo info : deps) {
                synchronized (this.mPackages) {
                    try {
                        PackageParser.Package depPackage = this.mPackages.get(info.getPackageName());
                        try {
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        throw th;
                    }
                }
            }
        }
        return pdo.performDexOpt(p, instructionSets, getOrCreateCompilerPackageStats(p), this.mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
    }

    public void reconcileSecondaryDexFiles(String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && !isInstantApp(packageName, UserHandle.getCallingUserId())) {
            this.mDexManager.reconcileSecondaryDexFiles(packageName);
        }
    }

    /* access modifiers changed from: package-private */
    public DexManager getDexManager() {
        return this.mDexManager;
    }

    public boolean runBackgroundDexoptJob(List<String> packageNames) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        enforceSystemOrRootOrShell("runBackgroundDexoptJob");
        long identity = Binder.clearCallingIdentity();
        try {
            return BackgroundDexOptService.runIdleOptimizationsNow(this, this.mContext, packageNames);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private static List<SharedLibraryInfo> findSharedLibraries(PackageParser.Package p) {
        if (p.usesLibraryInfos == null) {
            return Collections.emptyList();
        }
        ArrayList<SharedLibraryInfo> retValue = new ArrayList<>();
        Set<String> collectedNames = new HashSet<>();
        Iterator it = p.usesLibraryInfos.iterator();
        while (it.hasNext()) {
            findSharedLibrariesRecursive((SharedLibraryInfo) it.next(), retValue, collectedNames);
        }
        return retValue;
    }

    private static void findSharedLibrariesRecursive(SharedLibraryInfo info, ArrayList<SharedLibraryInfo> collected, Set<String> collectedNames) {
        if (!collectedNames.contains(info.getName())) {
            collectedNames.add(info.getName());
            collected.add(info);
            if (info.getDependencies() != null) {
                for (SharedLibraryInfo dep : info.getDependencies()) {
                    findSharedLibrariesRecursive(dep, collected, collectedNames);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public List<PackageParser.Package> findSharedNonSystemLibraries(PackageParser.Package pkg) {
        List<SharedLibraryInfo> deps = findSharedLibraries(pkg);
        if (deps.isEmpty()) {
            return Collections.emptyList();
        }
        ArrayList<PackageParser.Package> retValue = new ArrayList<>();
        synchronized (this.mPackages) {
            for (SharedLibraryInfo info : deps) {
                PackageParser.Package depPackage = this.mPackages.get(info.getPackageName());
                if (depPackage != null) {
                    retValue.add(depPackage);
                }
            }
        }
        return retValue;
    }

    private SharedLibraryInfo getSharedLibraryInfoLPr(String name, long version) {
        return getSharedLibraryInfo(name, version, this.mSharedLibraries, null);
    }

    private static SharedLibraryInfo getSharedLibraryInfo(String name, long version, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) {
        if (newLibraries != null) {
            LongSparseArray<SharedLibraryInfo> versionedLib = newLibraries.get(name);
            SharedLibraryInfo info = null;
            if (versionedLib != null) {
                info = versionedLib.get(version);
            }
            if (info != null) {
                return info;
            }
        }
        LongSparseArray<SharedLibraryInfo> versionedLib2 = existingLibraries.get(name);
        if (versionedLib2 == null) {
            return null;
        }
        return versionedLib2.get(version);
    }

    private SharedLibraryInfo getLatestSharedLibraVersionLPr(PackageParser.Package pkg) {
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(pkg.staticSharedLibName);
        if (versionedLib == null) {
            return null;
        }
        long previousLibVersion = -1;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            long libVersion = versionedLib.keyAt(i);
            if (libVersion < pkg.staticSharedLibVersion) {
                previousLibVersion = Math.max(previousLibVersion, libVersion);
            }
        }
        if (previousLibVersion >= 0) {
            return versionedLib.get(previousLibVersion);
        }
        return null;
    }

    private PackageSetting getSharedLibLatestVersionSetting(ScanResult scanResult) {
        PackageSetting sharedLibPackage = null;
        synchronized (this.mPackages) {
            SharedLibraryInfo latestSharedLibraVersionLPr = getLatestSharedLibraVersionLPr(scanResult.pkgSetting.pkg);
            if (latestSharedLibraVersionLPr != null) {
                sharedLibPackage = this.mSettings.getPackageLPr(latestSharedLibraVersionLPr.getPackageName());
            }
        }
        return sharedLibPackage;
    }

    public void shutdown() {
        this.mPackageUsage.writeNow(this.mPackages);
        this.mCompilerStats.writeNow();
        this.mDexManager.writePackageDexUsageNow();
        PackageWatchdog.getInstance(this.mContext).writeNow();
        CtaManagerFactory.getInstance().makeCtaManager().shutdown();
        synchronized (this.mPackages) {
            if (this.mHandler.hasMessages(14)) {
                this.mHandler.removeMessages(14);
                Iterator<Integer> it = this.mDirtyUsers.iterator();
                while (it.hasNext()) {
                    this.mSettings.writePackageRestrictionsLPr(it.next().intValue());
                }
                this.mDirtyUsers.clear();
            }
        }
    }

    public void dumpProfiles(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        int callingUid = Binder.getCallingUid();
        if (callingUid == 2000 || callingUid == 0 || callingUid == pkg.applicationInfo.uid) {
            synchronized (this.mInstallLock) {
                Trace.traceBegin(262144, "dump profiles");
                this.mArtManagerService.dumpProfiles(pkg);
                Trace.traceEnd(262144);
            }
            return;
        }
        throw new SecurityException("dumpProfiles");
    }

    public void forceDexOpt(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("forceDexOpt");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        synchronized (this.mInstallLock) {
            Trace.traceBegin(262144, "dexopt");
            int res = performDexOptInternalWithDependenciesLI(pkg, new DexoptOptions(packageName, PackageManagerServiceCompilerMapping.getDefaultCompilerFilter(), 6));
            Trace.traceEnd(262144);
            if (res != 1) {
                throw new IllegalStateException("Failed to dexopt: " + res);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, PackageParser.Package newPkg) {
        if ((oldPkg.pkgFlags & 1) == 0) {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package not in system partition");
            return false;
        } else if (this.mPackages.get(oldPkg.name) == null) {
            return true;
        } else {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package still exists");
            return false;
        }
    }

    /* access modifiers changed from: package-private */
    @GuardedBy({"mInstallLock"})
    public void removeCodePathLI(File codePath) {
        if (codePath.isDirectory()) {
            try {
                this.mInstaller.rmPackageDir(codePath.getAbsolutePath());
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, "Failed to remove code path", e);
            }
        } else {
            codePath.delete();
        }
    }

    private int[] resolveUserIds(int userId) {
        if (userId == -1) {
            return sUserManager.getUserIds();
        }
        return new int[]{userId};
    }

    private void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        clearAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            clearAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
        clearAppProfilesLIF(pkg, -1);
    }

    private void clearAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        int[] resolveUserIds = resolveUserIds(userId);
        for (int realUserId : resolveUserIds) {
            try {
                this.mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
        }
    }

    private void destroyAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void destroyAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        int[] resolveUserIds = resolveUserIds(userId);
        for (int realUserId : resolveUserIds) {
            try {
                this.mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
            this.mDexManager.notifyPackageDataDestroyed(pkg.packageName, userId);
        }
    }

    private void destroyAppProfilesLIF(PackageParser.Package pkg) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppProfilesLeafLIF(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppProfilesLeafLIF((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void destroyAppProfilesLeafLIF(PackageParser.Package pkg) {
        try {
            this.mInstaller.destroyAppProfiles(pkg.packageName);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
        }
    }

    private void clearAppProfilesLIF(PackageParser.Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        this.mArtManagerService.clearAppProfiles(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mArtManagerService.clearAppProfiles((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void setInstallAndUpdateTime(PackageParser.Package pkg, long firstInstallTime, long lastUpdateTime) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            ps.firstInstallTime = firstInstallTime;
            ps.lastUpdateTime = lastUpdateTime;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                ps2.firstInstallTime = firstInstallTime;
                ps2.lastUpdateTime = lastUpdateTime;
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void applyDefiningSharedLibraryUpdateLocked(PackageParser.Package pkg, SharedLibraryInfo libInfo, BiConsumer<SharedLibraryInfo, SharedLibraryInfo> action) {
        if (!pkg.isLibrary()) {
            return;
        }
        if (pkg.staticSharedLibName != null) {
            SharedLibraryInfo definedLibrary = getSharedLibraryInfoLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
            if (definedLibrary != null) {
                action.accept(definedLibrary, libInfo);
                return;
            }
            return;
        }
        Iterator it = pkg.libraryNames.iterator();
        while (it.hasNext()) {
            SharedLibraryInfo definedLibrary2 = getSharedLibraryInfoLPr((String) it.next(), -1);
            if (definedLibrary2 != null) {
                action.accept(definedLibrary2, libInfo);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void addSharedLibraryLPr(PackageParser.Package pkg, Set<String> usesLibraryFiles, SharedLibraryInfo libInfo, PackageParser.Package changingLib) {
        if (libInfo.getPath() != null) {
            usesLibraryFiles.add(libInfo.getPath());
            return;
        }
        PackageParser.Package p = this.mPackages.get(libInfo.getPackageName());
        if (changingLib != null && changingLib.packageName.equals(libInfo.getPackageName()) && (p == null || p.packageName.equals(changingLib.packageName))) {
            p = changingLib;
        }
        if (p != null) {
            usesLibraryFiles.addAll(p.getAllCodePaths());
            applyDefiningSharedLibraryUpdateLocked(pkg, libInfo, $$Lambda$PackageManagerService$xJ_pDKPvSH0lgOwva8xeI2zJ2ns.INSTANCE);
            if (p.usesLibraryFiles != null) {
                Collections.addAll(usesLibraryFiles, p.usesLibraryFiles);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void updateSharedLibrariesLocked(PackageParser.Package pkg, PackageParser.Package changingLib, Map<String, PackageParser.Package> availablePackages) throws PackageManagerException {
        executeSharedLibrariesUpdateLPr(pkg, changingLib, collectSharedLibraryInfos(pkg, availablePackages, this.mSharedLibraries, null));
    }

    private static ArrayList<SharedLibraryInfo> collectSharedLibraryInfos(PackageParser.Package pkg, Map<String, PackageParser.Package> availablePackages, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) throws PackageManagerException {
        if (pkg == null) {
            return null;
        }
        ArrayList<SharedLibraryInfo> usesLibraryInfos = null;
        if (pkg.usesLibraries != null) {
            usesLibraryInfos = collectSharedLibraryInfos(pkg.usesLibraries, null, null, pkg.packageName, true, pkg.applicationInfo.targetSdkVersion, null, availablePackages, existingLibraries, newLibraries);
        }
        if (pkg.usesStaticLibraries != null) {
            usesLibraryInfos = collectSharedLibraryInfos(pkg.usesStaticLibraries, pkg.usesStaticLibrariesVersions, pkg.usesStaticLibrariesCertDigests, pkg.packageName, true, pkg.applicationInfo.targetSdkVersion, usesLibraryInfos, availablePackages, existingLibraries, newLibraries);
        }
        if (pkg.usesOptionalLibraries != null) {
            return collectSharedLibraryInfos(pkg.usesOptionalLibraries, null, null, pkg.packageName, false, pkg.applicationInfo.targetSdkVersion, usesLibraryInfos, availablePackages, existingLibraries, newLibraries);
        }
        return usesLibraryInfos;
    }

    private void executeSharedLibrariesUpdateLPr(PackageParser.Package pkg, PackageParser.Package changingLib, ArrayList<SharedLibraryInfo> usesLibraryInfos) {
        applyDefiningSharedLibraryUpdateLocked(pkg, null, $$Lambda$PackageManagerService$JUo3M6zuPH65x1voKjSOJvOMHRw.INSTANCE);
        if (usesLibraryInfos != null) {
            pkg.usesLibraryInfos = usesLibraryInfos;
            Set<String> usesLibraryFiles = new LinkedHashSet<>();
            Iterator<SharedLibraryInfo> it = usesLibraryInfos.iterator();
            while (it.hasNext()) {
                addSharedLibraryLPr(pkg, usesLibraryFiles, it.next(), changingLib);
            }
            pkg.usesLibraryFiles = (String[]) usesLibraryFiles.toArray(new String[usesLibraryFiles.size()]);
            return;
        }
        pkg.usesLibraryInfos = null;
        pkg.usesLibraryFiles = null;
    }

    @GuardedBy({"mPackages"})
    private static ArrayList<SharedLibraryInfo> collectSharedLibraryInfos(List<String> requestedLibraries, long[] requiredVersions, String[][] requiredCertDigests, String packageName, boolean required, int targetSdk, ArrayList<SharedLibraryInfo> outUsedLibraries, Map<String, PackageParser.Package> availablePackages, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) throws PackageManagerException {
        long libVersion;
        int libCount;
        String[] strArr;
        int libCount2 = requestedLibraries.size();
        int i = 0;
        ArrayList<SharedLibraryInfo> outUsedLibraries2 = outUsedLibraries;
        while (i < libCount2) {
            String libName = requestedLibraries.get(i);
            if (requiredVersions != null) {
                libVersion = requiredVersions[i];
            } else {
                libVersion = -1;
            }
            SharedLibraryInfo libraryInfo = getSharedLibraryInfo(libName, libVersion, existingLibraries, newLibraries);
            if (libraryInfo != null) {
                if (requiredVersions == null || requiredCertDigests == null) {
                    libCount = libCount2;
                } else if (libraryInfo.getLongVersion() == requiredVersions[i]) {
                    PackageParser.Package libPkg = availablePackages.get(libraryInfo.getPackageName());
                    if (libPkg != null) {
                        String[] expectedCertDigests = requiredCertDigests[i];
                        libCount = libCount2;
                        if (expectedCertDigests.length > 1) {
                            if (targetSdk >= 27) {
                                strArr = PackageUtils.computeSignaturesSha256Digests(libPkg.mSigningDetails.signatures);
                            } else {
                                strArr = PackageUtils.computeSignaturesSha256Digests(new Signature[]{libPkg.mSigningDetails.signatures[0]});
                            }
                            String[] libCertDigests = strArr;
                            if (expectedCertDigests.length == libCertDigests.length) {
                                Arrays.sort(libCertDigests);
                                Arrays.sort(expectedCertDigests);
                                int certCount = libCertDigests.length;
                                int j = 0;
                                while (j < certCount) {
                                    if (libCertDigests[j].equalsIgnoreCase(expectedCertDigests[j])) {
                                        j++;
                                        libCertDigests = libCertDigests;
                                    } else {
                                        throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                                    }
                                }
                            } else {
                                throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                            }
                        } else if (!libPkg.mSigningDetails.hasSha256Certificate(ByteStringUtils.fromHexToByteArray(expectedCertDigests[0]))) {
                            throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                        }
                    } else {
                        throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared library; failing!");
                    }
                } else {
                    throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared library " + libName + " version " + libraryInfo.getLongVersion() + "; failing!");
                }
                if (outUsedLibraries2 == null) {
                    outUsedLibraries2 = new ArrayList<>();
                }
                outUsedLibraries2.add(libraryInfo);
            } else if (!required) {
                if (DEBUG_SHARED_LIBRARIES) {
                    Slog.i(TAG, "Package " + packageName + " desires unavailable shared library " + libName + "; ignoring!");
                }
                libCount = libCount2;
            } else {
                throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable shared library " + libName + "; failing!");
            }
            i++;
            libCount2 = libCount;
        }
        return outUsedLibraries2;
    }

    private static boolean hasString(List<String> list, List<String> which) {
        if (list == null || which == null) {
            return false;
        }
        for (int i = list.size() - 1; i >= 0; i--) {
            for (int j = which.size() - 1; j >= 0; j--) {
                if (which.get(j).equals(list.get(i))) {
                    return true;
                }
            }
        }
        return false;
    }

    @GuardedBy({"mPackages"})
    private ArrayList<PackageParser.Package> updateAllSharedLibrariesLocked(PackageParser.Package updatedPkg, Map<String, PackageParser.Package> availablePackages) {
        ArrayList<PackageParser.Package> needsUpdating;
        int i;
        ArrayList<PackageParser.Package> resultList;
        ArraySet<String> descendants;
        ArrayList<PackageParser.Package> resultList2;
        ArrayList<PackageParser.Package> resultList3 = null;
        ArraySet<String> descendants2 = null;
        if (updatedPkg != null) {
            ArrayList<PackageParser.Package> needsUpdating2 = new ArrayList<>(1);
            needsUpdating2.add(updatedPkg);
            needsUpdating = needsUpdating2;
        } else {
            needsUpdating = null;
        }
        do {
            PackageParser.Package changingPkg = needsUpdating == null ? null : needsUpdating.remove(0);
            int i2 = this.mPackages.size() - 1;
            while (i2 >= 0) {
                PackageParser.Package pkg = this.mPackages.valueAt(i2);
                if (changingPkg == null || hasString(pkg.usesLibraries, changingPkg.libraryNames) || hasString(pkg.usesOptionalLibraries, changingPkg.libraryNames) || ArrayUtils.contains(pkg.usesStaticLibraries, changingPkg.staticSharedLibName)) {
                    if (resultList3 == null) {
                        resultList = new ArrayList<>();
                    } else {
                        resultList = resultList3;
                    }
                    resultList.add(pkg);
                    if (changingPkg != null) {
                        if (descendants2 == null) {
                            descendants2 = new ArraySet<>();
                        }
                        if (!descendants2.contains(pkg.packageName)) {
                            descendants2.add(pkg.packageName);
                            needsUpdating.add(pkg);
                        }
                        descendants = descendants2;
                    } else {
                        descendants = descendants2;
                    }
                    try {
                        updateSharedLibrariesLocked(pkg, changingPkg, availablePackages);
                        resultList2 = resultList;
                        i = i2;
                    } catch (PackageManagerException e) {
                        if (!pkg.isSystem() || pkg.isUpdatedSystemApp()) {
                            resultList2 = resultList;
                            i = i2;
                            deletePackageLIF(pkg.packageName, null, true, sUserManager.getUserIds(), pkg.isUpdatedSystemApp() ? 1 : 0, null, true, null);
                        } else {
                            resultList2 = resultList;
                            i = i2;
                        }
                        Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
                    }
                    descendants2 = descendants;
                    resultList3 = resultList2;
                } else {
                    i = i2;
                }
                i2 = i - 1;
            }
            if (needsUpdating == null) {
                break;
            }
        } while (needsUpdating.size() > 0);
        return resultList3;
    }

    /* JADX INFO: finally extract failed */
    @GuardedBy({"mInstallLock", "mPackages"})
    private List<ScanResult> scanPackageTracedLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        int scanFlags2;
        Trace.traceBegin(262144, "scanPackage");
        if ((scanFlags & 1024) != 0) {
            scanFlags2 = scanFlags & -1025;
        } else if (pkg.childPackages == null || pkg.childPackages.size() <= 0) {
            scanFlags2 = scanFlags;
        } else {
            scanFlags2 = scanFlags | 1024;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        List<ScanResult> scanResults = new ArrayList<>(childCount + 1);
        try {
            scanResults.add(scanPackageNewLI(pkg, parseFlags, scanFlags2, currentTime, user));
            for (int i = 0; i < childCount; i++) {
                scanResults.add(scanPackageNewLI((PackageParser.Package) pkg.childPackages.get(i), parseFlags, scanFlags2, currentTime, user));
            }
            Trace.traceEnd(262144);
            if ((scanFlags2 & 1024) != 0) {
                return scanPackageTracedLI(pkg, parseFlags, scanFlags2, currentTime, user);
            }
            return scanResults;
        } catch (Throwable th) {
            Trace.traceEnd(262144);
            throw th;
        }
    }

    /* access modifiers changed from: private */
    public static class ScanResult {
        public final List<String> changedAbiCodePath;
        public final List<SharedLibraryInfo> dynamicSharedLibraryInfos;
        public final boolean existingSettingCopied;
        public final PackageSetting pkgSetting;
        public final ScanRequest request;
        public final SharedLibraryInfo staticSharedLibraryInfo;
        public final boolean success;

        public ScanResult(ScanRequest request2, boolean success2, PackageSetting pkgSetting2, List<String> changedAbiCodePath2, boolean existingSettingCopied2, SharedLibraryInfo staticSharedLibraryInfo2, List<SharedLibraryInfo> dynamicSharedLibraryInfos2) {
            this.request = request2;
            this.success = success2;
            this.pkgSetting = pkgSetting2;
            this.changedAbiCodePath = changedAbiCodePath2;
            this.existingSettingCopied = existingSettingCopied2;
            this.staticSharedLibraryInfo = staticSharedLibraryInfo2;
            this.dynamicSharedLibraryInfos = dynamicSharedLibraryInfos2;
        }
    }

    /* access modifiers changed from: private */
    public static class ScanRequest {
        public final PackageSetting disabledPkgSetting;
        public final boolean isPlatformPackage;
        public final PackageParser.Package oldPkg;
        public final PackageSetting oldPkgSetting;
        public final PackageSetting originalPkgSetting;
        public final int parseFlags;
        public final PackageParser.Package pkg;
        public final PackageSetting pkgSetting;
        public final String realPkgName;
        public final int scanFlags;
        public final SharedUserSetting sharedUserSetting;
        public final UserHandle user;

        public ScanRequest(PackageParser.Package pkg2, SharedUserSetting sharedUserSetting2, PackageParser.Package oldPkg2, PackageSetting pkgSetting2, PackageSetting disabledPkgSetting2, PackageSetting originalPkgSetting2, String realPkgName2, int parseFlags2, int scanFlags2, boolean isPlatformPackage2, UserHandle user2) {
            this.pkg = pkg2;
            this.oldPkg = oldPkg2;
            this.pkgSetting = pkgSetting2;
            this.sharedUserSetting = sharedUserSetting2;
            this.oldPkgSetting = pkgSetting2 == null ? null : new PackageSetting(pkgSetting2);
            this.disabledPkgSetting = disabledPkgSetting2;
            this.originalPkgSetting = originalPkgSetting2;
            this.realPkgName = realPkgName2;
            this.parseFlags = parseFlags2;
            this.scanFlags = scanFlags2;
            this.isPlatformPackage = isPlatformPackage2;
            this.user = user2;
        }
    }

    private int adjustScanFlags(int scanFlags, PackageSetting pkgSetting, PackageSetting disabledPkgSetting, UserHandle user, PackageParser.Package pkg) {
        PackageSetting systemPkgSetting;
        if ((scanFlags & 4) == 0 || disabledPkgSetting != null || pkgSetting == null || !pkgSetting.isSystem()) {
            systemPkgSetting = disabledPkgSetting;
        } else {
            systemPkgSetting = pkgSetting;
        }
        if (systemPkgSetting != null) {
            scanFlags |= 131072;
            if ((systemPkgSetting.pkgPrivateFlags & 8) != 0) {
                scanFlags |= 262144;
            }
            if ((131072 & systemPkgSetting.pkgPrivateFlags) != 0) {
                scanFlags |= 524288;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 262144) != 0) {
                scanFlags |= 1048576;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 524288) != 0) {
                scanFlags |= 2097152;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 2097152) != 0) {
                scanFlags |= DumpState.DUMP_CHANGES;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 1073741824) != 0) {
                scanFlags |= 8388608;
            }
        }
        if (pkgSetting != null) {
            int userId = user == null ? 0 : user.getIdentifier();
            if (pkgSetting.getInstantApp(userId)) {
                scanFlags |= 16384;
            }
            if (pkgSetting.getVirtulalPreload(userId)) {
                scanFlags |= 65536;
            }
        }
        boolean skipVendorPrivilegeScan = (1048576 & scanFlags) != 0 && SystemProperties.getInt("ro.vndk.version", 28) < 28;
        if ((scanFlags & 262144) == 0 && !pkg.isPrivileged() && pkg.mSharedUserId != null && !skipVendorPrivilegeScan) {
            SharedUserSetting sharedUserSetting = null;
            try {
                sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
            } catch (PackageManagerException e) {
            }
            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                synchronized (this.mPackages) {
                    if (PackageManagerServiceUtils.compareSignatures(this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME).signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) != 0) {
                        scanFlags |= 262144;
                    }
                }
            }
        }
        return scanFlags;
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private ScanResult scanPackageNewLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        String renamedPkgName = this.mSettings.getRenamedPackageLPr(pkg.mRealPackage);
        String realPkgName = getRealPackageName(pkg, renamedPkgName);
        if (realPkgName != null) {
            ensurePackageRenamed(pkg, renamedPkgName);
        }
        PackageSetting originalPkgSetting = getOriginalPackageLocked(pkg, renamedPkgName);
        PackageSetting pkgSetting = this.mSettings.getPackageLPr(pkg.packageName);
        PackageSetting disabledPkgSetting = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
        if (this.mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        int scanFlags2 = adjustScanFlags(scanFlags, pkgSetting, disabledPkgSetting, user, pkg);
        synchronized (this.mPackages) {
            try {
                applyPolicy(pkg, parseFlags, scanFlags2, this.mPlatformPackage);
                assertPackageIsValid(pkg, parseFlags, scanFlags2);
                SharedUserSetting sharedUserSetting = null;
                if (pkg.mSharedUserId != null) {
                    try {
                        sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
                        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags) != 0) {
                            Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + sharedUserSetting.userId + "): packages=" + sharedUserSetting.packages);
                        }
                    } catch (Throwable th) {
                        th = th;
                        throw th;
                    }
                }
                PackageParser.Package r6 = pkgSetting == null ? null : pkgSetting.pkg;
                boolean z = pkg == this.mPlatformPackage;
                try {
                    return scanPackageOnlyLI(new ScanRequest(pkg, sharedUserSetting, r6, pkgSetting, disabledPkgSetting, originalPkgSetting, realPkgName, parseFlags, scanFlags2, z, user), this.mFactoryTest, currentTime);
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
    }

    private boolean optimisticallyRegisterAppId(ScanResult result) throws PackageManagerException {
        if (!result.existingSettingCopied) {
            return this.mSettings.registerAppIdLPw(result.pkgSetting);
        }
        return false;
    }

    private void cleanUpAppIdCreation(ScanResult result) {
        if (result.pkgSetting.appId > 0) {
            this.mSettings.removeAppIdLPw(result.pkgSetting.appId);
        }
    }

    @GuardedBy({"mPackages", "mInstallLock"})
    private void commitReconciledScanResultLocked(ReconciledPackage reconciledPkg) {
        PackageSetting pkgSetting;
        String realPkgName;
        PackageSetting pkgSetting2;
        String realPkgName2;
        PackageSetting pkgSetting3;
        ScanResult result = reconciledPkg.scanResult;
        ScanRequest request = result.request;
        PackageParser.Package pkg = request.pkg;
        PackageParser.Package oldPkg = request.oldPkg;
        int parseFlags = request.parseFlags;
        int scanFlags = request.scanFlags;
        PackageSetting oldPkgSetting = request.oldPkgSetting;
        PackageSetting originalPkgSetting = request.originalPkgSetting;
        UserHandle user = request.user;
        String realPkgName3 = request.realPkgName;
        List<String> changedAbiCodePath = result.changedAbiCodePath;
        if (!(request.pkgSetting == null || request.pkgSetting.sharedUser == null || request.pkgSetting.sharedUser == result.pkgSetting.sharedUser)) {
            request.pkgSetting.sharedUser.removePackage(request.pkgSetting);
        }
        if (result.existingSettingCopied) {
            PackageSetting pkgSetting4 = request.pkgSetting;
            pkgSetting4.updateFrom(result.pkgSetting);
            pkg.mExtras = pkgSetting4;
            pkgSetting = pkgSetting4;
        } else {
            PackageSetting pkgSetting5 = result.pkgSetting;
            if (originalPkgSetting != null) {
                pkgSetting3 = pkgSetting5;
                this.mSettings.addRenamedPackageLPw(pkg.packageName, originalPkgSetting.name);
            } else {
                pkgSetting3 = pkgSetting5;
            }
            if (originalPkgSetting != null && (scanFlags & 1024) == 0) {
                this.mTransferedPackages.add(originalPkgSetting.name);
            }
            pkgSetting = pkgSetting3;
        }
        if (pkgSetting.sharedUser != null) {
            pkgSetting.sharedUser.addPackage(pkgSetting);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        this.mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);
        if ((scanFlags & 1024) == 0 && realPkgName3 != null) {
            this.mTransferedPackages.add(pkg.packageName);
        }
        if (reconciledPkg.collectedSharedLibraryInfos != null) {
            executeSharedLibrariesUpdateLPr(pkg, null, reconciledPkg.collectedSharedLibraryInfos);
        }
        KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
        if (reconciledPkg.removeAppKeySetData) {
            ksms.removeAppKeySetDataLPw(pkg.packageName);
        }
        if (reconciledPkg.sharedUserSignaturesChanged) {
            pkgSetting.sharedUser.signaturesChanged = Boolean.TRUE;
            pkgSetting.sharedUser.signatures.mSigningDetails = reconciledPkg.signingDetails;
        }
        pkgSetting.signatures.mSigningDetails = reconciledPkg.signingDetails;
        if ((scanFlags & 1024) != 0 || pkg.mAdoptPermissions == null) {
            pkgSetting2 = pkgSetting;
            realPkgName = realPkgName3;
        } else {
            int i = pkg.mAdoptPermissions.size() - 1;
            while (i >= 0) {
                String origName = (String) pkg.mAdoptPermissions.get(i);
                PackageSetting orig = this.mSettings.getPackageLPr(origName);
                if (orig == null) {
                    realPkgName2 = realPkgName3;
                } else if (verifyPackageUpdateLPr(orig, pkg)) {
                    StringBuilder sb = new StringBuilder();
                    realPkgName2 = realPkgName3;
                    sb.append("Adopting permissions from ");
                    sb.append(origName);
                    sb.append(" to ");
                    sb.append(pkg.packageName);
                    Slog.i(TAG, sb.toString());
                    this.mSettings.mPermissions.transferPermissions(origName, pkg.packageName);
                } else {
                    realPkgName2 = realPkgName3;
                }
                i--;
                pkgSetting = pkgSetting;
                realPkgName3 = realPkgName2;
            }
            pkgSetting2 = pkgSetting;
            realPkgName = realPkgName3;
        }
        if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
            for (int i2 = changedAbiCodePath.size() - 1; i2 >= 0; i2--) {
                try {
                    this.mInstaller.rmdex(changedAbiCodePath.get(i2), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                } catch (Installer.InstallerException e) {
                }
            }
        }
        if ((scanFlags & 1024) == 0) {
            boolean z = false;
            int userId = user == null ? 0 : user.getIdentifier();
            if ((Integer.MIN_VALUE & parseFlags) != 0) {
                z = true;
            }
            commitPackageSettings(pkg, oldPkg, pkgSetting2, scanFlags, z, reconciledPkg);
            if (pkgSetting2.getInstantApp(userId)) {
                this.mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting2.appId);
            }
        } else if (oldPkgSetting != null) {
            synchronized (this.mPackages) {
                this.mSettings.mPackages.put(oldPkgSetting.name, oldPkgSetting);
            }
        }
    }

    private static String getRealPackageName(PackageParser.Package pkg, String renamedPkgName) {
        if (isPackageRenamed(pkg, renamedPkgName)) {
            return pkg.mRealPackage;
        }
        return null;
    }

    private static boolean isPackageRenamed(PackageParser.Package pkg, String renamedPkgName) {
        return pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPkgName);
    }

    @GuardedBy({"mPackages"})
    private PackageSetting getOriginalPackageLocked(PackageParser.Package pkg, String renamedPkgName) {
        if (!isPackageRenamed(pkg, renamedPkgName)) {
            return null;
        }
        for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
            PackageSetting originalPs = this.mSettings.getPackageLPr((String) pkg.mOriginalPackages.get(i));
            if (originalPs != null && verifyPackageUpdateLPr(originalPs, pkg)) {
                if (originalPs.sharedUser != null) {
                    if (!originalPs.sharedUser.name.equals(pkg.mSharedUserId)) {
                        Slog.w(TAG, "Unable to migrate data from " + originalPs.name + " to " + pkg.packageName + ": old uid " + originalPs.sharedUser.name + " differs from " + pkg.mSharedUserId);
                    }
                } else if (DEBUG_UPGRADE) {
                    Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + originalPs.name);
                }
                return originalPs;
            }
        }
        return null;
    }

    private static void ensurePackageRenamed(PackageParser.Package pkg, String renamedPackageName) {
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPackageName) && !pkg.packageName.equals(renamedPackageName)) {
            pkg.setPackageName(renamedPackageName);
        }
    }

    @GuardedBy({"mInstallLock"})
    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime) throws PackageManagerException {
        String secondaryCpuAbiFromSettings;
        String primaryCpuAbiFromSettings;
        boolean isPlatformPackage;
        String str;
        String secondaryCpuAbiFromSettings2;
        String str2;
        String primaryCpuAbiFromSettings2;
        PackageSetting pkgSetting;
        String str3;
        String str4;
        List<SharedLibraryInfo> dynamicSharedLibraryInfos;
        String primaryCpuAbiFromSettings3;
        String secondaryCpuAbiFromSettings3;
        String str5;
        String str6;
        PackageParser.Package pkg = request.pkg;
        PackageSetting pkgSetting2 = request.pkgSetting;
        PackageSetting disabledPkgSetting = request.disabledPkgSetting;
        PackageSetting originalPkgSetting = request.originalPkgSetting;
        int parseFlags = request.parseFlags;
        int scanFlags = request.scanFlags;
        String realPkgName = request.realPkgName;
        SharedUserSetting sharedUserSetting = request.sharedUserSetting;
        UserHandle user = request.user;
        boolean isPlatformPackage2 = request.isPlatformPackage;
        List<String> changedAbiCodePath = null;
        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags) != 0) {
            Log.d(TAG, "Scanning package " + pkg.packageName);
        }
        new File(pkg.codePath);
        File destCodeFile = new File(pkg.applicationInfo.getCodePath());
        File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
        boolean needToDeriveAbi = (scanFlags & 8192) != 0;
        if (needToDeriveAbi) {
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = null;
        } else if (pkgSetting2 != null) {
            secondaryCpuAbiFromSettings = pkgSetting2.primaryCpuAbiString;
            primaryCpuAbiFromSettings = pkgSetting2.secondaryCpuAbiString;
        } else {
            needToDeriveAbi = true;
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = null;
        }
        if (!(pkgSetting2 == null || pkgSetting2.sharedUser == sharedUserSetting)) {
            StringBuilder sb = new StringBuilder();
            sb.append("Package ");
            sb.append(pkg.packageName);
            sb.append(" shared user changed from ");
            if (pkgSetting2.sharedUser != null) {
                str5 = pkgSetting2.sharedUser.name;
            } else {
                str5 = "<nothing>";
            }
            sb.append(str5);
            sb.append(" to ");
            if (sharedUserSetting != null) {
                str6 = sharedUserSetting.name;
            } else {
                str6 = "<nothing>";
            }
            sb.append(str6);
            sb.append("; replacing with new");
            reportSettingsProblem(5, sb.toString());
            pkgSetting2 = null;
        }
        String[] usesStaticLibraries = null;
        if (pkg.usesStaticLibraries != null) {
            usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];
            pkg.usesStaticLibraries.toArray(usesStaticLibraries);
        }
        boolean createNewPackage = pkgSetting2 == null;
        if (createNewPackage) {
            String parentPackageName = pkg.parentPackage != null ? pkg.parentPackage.packageName : null;
            boolean instantApp = (scanFlags & 16384) != 0;
            boolean virtualPreload = (65536 & scanFlags) != 0;
            String str7 = pkg.packageName;
            str2 = " to ";
            String str8 = pkg.applicationInfo.nativeLibraryRootDir;
            String str9 = pkg.applicationInfo.primaryCpuAbi;
            String str10 = pkg.applicationInfo.secondaryCpuAbi;
            long j = (long) pkg.mVersionCode;
            int i = pkg.applicationInfo.flags;
            int i2 = pkg.applicationInfo.privateFlags;
            List childPackageNames = pkg.getChildPackageNames();
            UserManagerService instance = UserManagerService.getInstance();
            long[] jArr = pkg.usesStaticLibrariesVersions;
            secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            str = TAG;
            isPlatformPackage = isPlatformPackage2;
            pkgSetting = Settings.createNewSetting(str7, originalPkgSetting, disabledPkgSetting, realPkgName, sharedUserSetting, destCodeFile, destResourceFile, str8, str9, str10, j, i, i2, user, true, instantApp, virtualPreload, parentPackageName, childPackageNames, instance, usesStaticLibraries, jArr);
            primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
        } else {
            str2 = " to ";
            secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            str = TAG;
            isPlatformPackage = isPlatformPackage2;
            PackageSetting pkgSetting3 = new PackageSetting(pkgSetting2);
            pkgSetting3.pkg = pkg;
            primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
            Settings.updatePackageSetting(pkgSetting3, disabledPkgSetting, sharedUserSetting, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
            pkgSetting = pkgSetting3;
        }
        if (createNewPackage && originalPkgSetting != null) {
            pkg.setPackageName(originalPkgSetting.name);
            reportSettingsProblem(5, "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name);
        }
        int userId = user == null ? 0 : user.getIdentifier();
        if (!createNewPackage) {
            setInstantAppForUser(pkgSetting, userId, (scanFlags & 16384) != 0, (32768 & scanFlags) != 0);
        }
        if (!(disabledPkgSetting == null && ((scanFlags & 4) == 0 || pkgSetting == null || !pkgSetting.isSystem()))) {
            pkg.applicationInfo.flags |= 128;
        }
        pkg.applicationInfo.seInfo = SELinuxMMAC.getSeInfo(pkg, sharedUserSetting != null ? sharedUserSetting.isPrivileged() | pkg.isPrivileged() : pkg.isPrivileged(), pkg.applicationInfo.targetSandboxVersion, (sharedUserSetting == null || sharedUserSetting.packages.size() == 0) ? pkg.applicationInfo.targetSdkVersion : sharedUserSetting.seInfoTargetSdkVersion);
        pkg.applicationInfo.seInfoUser = SELinuxUtil.assignSeinfoUser(pkgSetting.readUserState(userId == -1 ? 0 : userId));
        pkg.mExtras = pkgSetting;
        pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
        if (!isPlatformPackage) {
            pkg.applicationInfo.initForUser(0);
        }
        String cpuAbiOverride = PackageManagerServiceUtils.deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
        if ((scanFlags & 4) == 0) {
            if (needToDeriveAbi) {
                primaryCpuAbiFromSettings3 = primaryCpuAbiFromSettings2;
                secondaryCpuAbiFromSettings3 = secondaryCpuAbiFromSettings2;
                str3 = str;
            } else if (PackageManagerCommonSoft.ShouldOppoDerivePackageAbi(pkg.packageName)) {
                primaryCpuAbiFromSettings3 = primaryCpuAbiFromSettings2;
                secondaryCpuAbiFromSettings3 = secondaryCpuAbiFromSettings2;
                str3 = str;
            } else {
                pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings2;
                pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings2;
                setNativeLibraryPaths(pkg, sAppLib32InstallDir);
                if (DEBUG_ABI_SELECTION) {
                    str3 = str;
                    Slog.i(str3, "Using ABIS and native lib paths from settings : " + pkg.packageName + StringUtils.SPACE + pkg.applicationInfo.primaryCpuAbi + ", " + pkg.applicationInfo.secondaryCpuAbi);
                    secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings2;
                    primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings2;
                } else {
                    str3 = str;
                    secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings2;
                    primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings2;
                }
            }
            secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings3;
            primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings3;
            Trace.traceBegin(262144, "derivePackageAbi");
            derivePackageAbi(pkg, cpuAbiOverride, !pkg.isLibrary());
            Trace.traceEnd(262144);
            if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
                setBundledAppAbisAndRoots(pkg, pkgSetting);
                setNativeLibraryPaths(pkg, sAppLib32InstallDir);
            }
        } else {
            str3 = str;
            if ((scanFlags & 256) != 0) {
                pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
                pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
            }
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        }
        if (isPlatformPackage) {
            pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
        }
        if ((scanFlags & 1) == 0 && (scanFlags & 4) != 0 && cpuAbiOverride == null && pkg.packageName != null) {
            Slog.w(str3, "Ignoring persisted ABI override " + cpuAbiOverride + " for package " + pkg.packageName);
        }
        pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
        pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
        pkg.cpuAbiOverride = cpuAbiOverride;
        if (DEBUG_ABI_SELECTION) {
            Slog.d(str3, "Resolved nativeLibraryRoot for " + pkg.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
        }
        pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
        if (DEBUG_ABI_SELECTION) {
            Log.d(str3, "Abis for package[" + pkg.packageName + "] are primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
        }
        if ((scanFlags & 16) == 0 && pkgSetting.sharedUser != null) {
            changedAbiCodePath = adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
        }
        if (isUnderFactoryTest && pkg.requestedPermissions.contains("android.permission.FACTORY_TEST")) {
            pkg.applicationInfo.flags |= 16;
        }
        if (isSystemApp(pkg)) {
            pkgSetting.isOrphaned = true;
        }
        long scanFileTime = PackageManagerServiceUtils.getLastModifiedTime(pkg);
        if (currentTime != 0) {
            str4 = str3;
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.lastUpdateTime = currentTime;
                pkgSetting.firstInstallTime = currentTime;
            } else if ((scanFlags & 8) != 0) {
                pkgSetting.lastUpdateTime = currentTime;
            }
        } else {
            str4 = str3;
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.lastUpdateTime = scanFileTime;
                pkgSetting.firstInstallTime = scanFileTime;
            } else if (!((parseFlags & 16) == 0 || scanFileTime == pkgSetting.timeStamp)) {
                pkgSetting.lastUpdateTime = scanFileTime;
            }
        }
        pkgSetting.setTimeStamp(scanFileTime);
        pkgSetting.pkg = pkg;
        pkgSetting.pkgFlags = pkg.applicationInfo.flags;
        if (pkg.getLongVersionCode() != pkgSetting.versionCode) {
            pkgSetting.versionCode = pkg.getLongVersionCode();
        }
        String volumeUuid = pkg.applicationInfo.volumeUuid;
        if (!Objects.equals(volumeUuid, pkgSetting.volumeUuid)) {
            StringBuilder sb2 = new StringBuilder();
            sb2.append("Update");
            sb2.append(pkgSetting.isSystem() ? " system" : "");
            sb2.append(" package ");
            sb2.append(pkg.packageName);
            sb2.append(" volume from ");
            sb2.append(pkgSetting.volumeUuid);
            sb2.append(str2);
            sb2.append(volumeUuid);
            Slog.i(str4, sb2.toString());
            pkgSetting.volumeUuid = volumeUuid;
        }
        SharedLibraryInfo staticSharedLibraryInfo = !TextUtils.isEmpty(pkg.staticSharedLibName) ? SharedLibraryInfo.createForStatic(pkg) : null;
        if (!ArrayUtils.isEmpty(pkg.libraryNames)) {
            List<SharedLibraryInfo> dynamicSharedLibraryInfos2 = new ArrayList<>(pkg.libraryNames.size());
            for (Iterator it = pkg.libraryNames.iterator(); it.hasNext(); it = it) {
                dynamicSharedLibraryInfos2.add(SharedLibraryInfo.createForDynamic(pkg, (String) it.next()));
            }
            dynamicSharedLibraryInfos = dynamicSharedLibraryInfos2;
        } else {
            dynamicSharedLibraryInfos = null;
        }
        return new ScanResult(request, true, pkgSetting, changedAbiCodePath, !createNewPackage, staticSharedLibraryInfo, dynamicSharedLibraryInfos);
    }

    private static boolean apkHasCode(String fileName) {
        StrictJarFile jarFile = null;
        boolean z = false;
        try {
            jarFile = new StrictJarFile(fileName, false, false);
            if (jarFile.findEntry("classes.dex") != null) {
                z = true;
            }
            try {
                jarFile.close();
            } catch (IOException e) {
            }
            return z;
        } catch (IOException e2) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e3) {
                }
            }
            return false;
        } catch (Throwable th) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e4) {
                }
            }
            throw th;
        }
    }

    private static void assertCodePolicy(PackageParser.Package pkg) throws PackageManagerException {
        if (((pkg.applicationInfo.flags & 4) != 0) && !apkHasCode(pkg.baseCodePath)) {
            throw new PackageManagerException(-2, "Package " + pkg.baseCodePath + " code is missing");
        } else if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            for (int i = 0; i < pkg.splitCodePaths.length; i++) {
                if (((pkg.splitFlags[i] & 4) != 0) && !apkHasCode(pkg.splitCodePaths[i])) {
                    throw new PackageManagerException(-2, "Package " + pkg.splitCodePaths[i] + " code is missing");
                }
            }
        }
    }

    private static void applyPolicy(PackageParser.Package pkg, int parseFlags, int scanFlags, PackageParser.Package platformPkg) {
        if ((scanFlags & 131072) != 0) {
            pkg.applicationInfo.flags |= 1;
            if (pkg.applicationInfo.isDirectBootAware()) {
                Iterator it = pkg.services.iterator();
                while (it.hasNext()) {
                    PackageParser.Service s = (PackageParser.Service) it.next();
                    ServiceInfo serviceInfo = s.info;
                    s.info.directBootAware = true;
                    serviceInfo.encryptionAware = true;
                }
                Iterator it2 = pkg.providers.iterator();
                while (it2.hasNext()) {
                    PackageParser.Provider p = (PackageParser.Provider) it2.next();
                    ProviderInfo providerInfo = p.info;
                    p.info.directBootAware = true;
                    providerInfo.encryptionAware = true;
                }
                Iterator it3 = pkg.activities.iterator();
                while (it3.hasNext()) {
                    PackageParser.Activity a = (PackageParser.Activity) it3.next();
                    ActivityInfo activityInfo = a.info;
                    a.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
                Iterator it4 = pkg.receivers.iterator();
                while (it4.hasNext()) {
                    PackageParser.Activity r = (PackageParser.Activity) it4.next();
                    ActivityInfo activityInfo2 = r.info;
                    r.info.directBootAware = true;
                    activityInfo2.encryptionAware = true;
                }
            }
            if (PackageManagerServiceUtils.compressedFileExists(pkg.codePath)) {
                pkg.isStub = true;
            }
        } else {
            pkg.coreApp = false;
            pkg.applicationInfo.flags &= -9;
            pkg.applicationInfo.privateFlags &= -33;
            pkg.applicationInfo.privateFlags &= -65;
            pkg.protectedBroadcasts = null;
            if (pkg.permissionGroups != null && pkg.permissionGroups.size() > 0) {
                for (int i = pkg.permissionGroups.size() - 1; i >= 0; i--) {
                    ((PackageParser.PermissionGroup) pkg.permissionGroups.get(i)).info.priority = 0;
                }
            }
        }
        if ((scanFlags & 262144) == 0) {
            if (pkg.receivers != null) {
                for (int i2 = pkg.receivers.size() - 1; i2 >= 0; i2--) {
                    PackageParser.Activity receiver = (PackageParser.Activity) pkg.receivers.get(i2);
                    if ((receiver.info.flags & 1073741824) != 0) {
                        receiver.info.exported = false;
                    }
                }
            }
            if (pkg.services != null) {
                for (int i3 = pkg.services.size() - 1; i3 >= 0; i3--) {
                    PackageParser.Service service = (PackageParser.Service) pkg.services.get(i3);
                    if ((service.info.flags & 1073741824) != 0) {
                        service.info.exported = false;
                    }
                }
            }
            if (pkg.providers != null) {
                for (int i4 = pkg.providers.size() - 1; i4 >= 0; i4--) {
                    PackageParser.Provider provider = (PackageParser.Provider) pkg.providers.get(i4);
                    if ((provider.info.flags & 1073741824) != 0) {
                        provider.info.exported = false;
                    }
                }
            }
        }
        if ((scanFlags & 262144) != 0) {
            pkg.applicationInfo.privateFlags |= 8;
        }
        if ((scanFlags & 524288) != 0) {
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags = 131072 | applicationInfo.privateFlags;
        }
        if ((scanFlags & 1048576) != 0) {
            ApplicationInfo applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.privateFlags = 262144 | applicationInfo2.privateFlags;
        }
        if ((scanFlags & 2097152) != 0) {
            ApplicationInfo applicationInfo3 = pkg.applicationInfo;
            applicationInfo3.privateFlags = 524288 | applicationInfo3.privateFlags;
        }
        if ((4194304 & scanFlags) != 0) {
            ApplicationInfo applicationInfo4 = pkg.applicationInfo;
            applicationInfo4.privateFlags = 2097152 | applicationInfo4.privateFlags;
        }
        if ((8388608 & scanFlags) != 0) {
            pkg.applicationInfo.privateFlags |= 1073741824;
        }
        if (PLATFORM_PACKAGE_NAME.equals(pkg.packageName) || (platformPkg != null && PackageManagerServiceUtils.compareSignatures(platformPkg.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
            ApplicationInfo applicationInfo5 = pkg.applicationInfo;
            applicationInfo5.privateFlags = 1048576 | applicationInfo5.privateFlags;
        }
        if (mColorPmsEx != null) {
            mColorPmsEx.extendApplyPolicy(pkg, parseFlags, scanFlags, platformPkg);
        }
        if (!isSystemApp(pkg)) {
            pkg.mOriginalPackages = null;
            pkg.mRealPackage = null;
            pkg.mAdoptPermissions = null;
        }
        PackageBackwardCompatibility.modifySharedLibraries(pkg);
    }

    private static <T> T assertNotNull(T object, String message) throws PackageManagerException {
        if (object != null) {
            return object;
        }
        throw new PackageManagerException(-110, message);
    }

    private void assertPackageIsValid(PackageParser.Package pkg, int parseFlags, int scanFlags) throws PackageManagerException {
        Throwable th;
        PackageSetting targetPkgSetting;
        if ((parseFlags & 64) != 0) {
            assertCodePolicy(pkg);
        }
        if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) {
            throw new PackageManagerException(-2, "Code and resource paths haven't been set correctly");
        }
        boolean isFirstBootOrUpgrade = true;
        boolean isUserInstall = (scanFlags & 16) == 0;
        if ((scanFlags & 8192) == 0) {
            isFirstBootOrUpgrade = false;
        }
        if ((isUserInstall || isFirstBootOrUpgrade) && this.mApexManager.isApexPackage(pkg.packageName)) {
            throw new PackageManagerException(-5, pkg.packageName + " is an APEX package and can't be installed as an APK.");
        }
        this.mSettings.mKeySetManagerService.assertScannedPackageValid(pkg);
        synchronized (this.mPackages) {
            try {
                if (pkg.packageName.equals(PLATFORM_PACKAGE_NAME)) {
                    try {
                        if (this.mAndroidApplication != null) {
                            Slog.w(TAG, "*************************************************");
                            Slog.w(TAG, "Core android package being redefined.  Skipping.");
                            Slog.w(TAG, " codePath=" + pkg.codePath);
                            Slog.w(TAG, "*************************************************");
                            throw new PackageManagerException(-5, "Core android package being redefined.  Skipping.");
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
                sPmsExt.checkMtkResPkg(pkg);
                if ((scanFlags & 4) != 0 || !this.mPackages.containsKey(pkg.packageName)) {
                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                        if ((scanFlags & 4) == 0 && this.mPackages.containsKey(pkg.manifestPackageName)) {
                            throw new PackageManagerException("Duplicate static shared lib provider package");
                        } else if (pkg.applicationInfo.targetSdkVersion < 26) {
                            throw new PackageManagerException("Packages declaring static-shared libs must target O SDK or higher");
                        } else if ((scanFlags & 16384) != 0) {
                            throw new PackageManagerException("Packages declaring static-shared libs cannot be instant apps");
                        } else if (!ArrayUtils.isEmpty(pkg.mOriginalPackages)) {
                            throw new PackageManagerException("Packages declaring static-shared libs cannot be renamed");
                        } else if (!ArrayUtils.isEmpty(pkg.childPackages)) {
                            throw new PackageManagerException("Packages declaring static-shared libs cannot have child packages");
                        } else if (!ArrayUtils.isEmpty(pkg.libraryNames)) {
                            throw new PackageManagerException("Packages declaring static-shared libs cannot declare dynamic libs");
                        } else if (pkg.mSharedUserId != null) {
                            throw new PackageManagerException("Packages declaring static-shared libs cannot declare shared users");
                        } else if (!pkg.activities.isEmpty()) {
                            throw new PackageManagerException("Static shared libs cannot declare activities");
                        } else if (!pkg.services.isEmpty()) {
                            throw new PackageManagerException("Static shared libs cannot declare services");
                        } else if (!pkg.providers.isEmpty()) {
                            throw new PackageManagerException("Static shared libs cannot declare content providers");
                        } else if (!pkg.receivers.isEmpty()) {
                            throw new PackageManagerException("Static shared libs cannot declare broadcast receivers");
                        } else if (!pkg.permissionGroups.isEmpty()) {
                            throw new PackageManagerException("Static shared libs cannot declare permission groups");
                        } else if (!pkg.permissions.isEmpty()) {
                            throw new PackageManagerException("Static shared libs cannot declare permissions");
                        } else if (pkg.protectedBroadcasts != null) {
                            throw new PackageManagerException("Static shared libs cannot declare protected broadcasts");
                        } else if (pkg.mOverlayTarget == null) {
                            long minVersionCode = Long.MIN_VALUE;
                            long maxVersionCode = JobStatus.NO_LATEST_RUNTIME;
                            LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(pkg.staticSharedLibName);
                            if (versionedLib != null) {
                                int versionCount = versionedLib.size();
                                int i = 0;
                                while (true) {
                                    if (i >= versionCount) {
                                        break;
                                    }
                                    SharedLibraryInfo libInfo = versionedLib.valueAt(i);
                                    long libVersionCode = libInfo.getDeclaringPackage().getLongVersionCode();
                                    try {
                                        if (libInfo.getLongVersion() >= pkg.staticSharedLibVersion) {
                                            if (libInfo.getLongVersion() <= pkg.staticSharedLibVersion) {
                                                maxVersionCode = libVersionCode;
                                                minVersionCode = libVersionCode;
                                                break;
                                            }
                                            maxVersionCode = Math.min(maxVersionCode, libVersionCode - 1);
                                            minVersionCode = minVersionCode;
                                        } else {
                                            minVersionCode = Math.max(minVersionCode, libVersionCode + 1);
                                        }
                                        i++;
                                        isUserInstall = isUserInstall;
                                    } catch (Throwable th3) {
                                        th = th3;
                                        throw th;
                                    }
                                }
                            }
                            if (pkg.getLongVersionCode() < minVersionCode || pkg.getLongVersionCode() > maxVersionCode) {
                                throw new PackageManagerException("Static shared lib version codes must be ordered as lib versions");
                            }
                        } else {
                            throw new PackageManagerException("Static shared libs cannot be overlay targets");
                        }
                    }
                    if (pkg.childPackages != null && !pkg.childPackages.isEmpty()) {
                        if ((262144 & scanFlags) != 0) {
                            int childCount = pkg.childPackages.size();
                            for (int i2 = 0; i2 < childCount; i2++) {
                                if (this.mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName, ((PackageParser.Package) pkg.childPackages.get(i2)).packageName)) {
                                    throw new PackageManagerException("Can't override child of another disabled app. Ignoring package " + pkg.packageName);
                                }
                            }
                        } else {
                            throw new PackageManagerException("Only privileged apps can add child packages. Ignoring package " + pkg.packageName);
                        }
                    }
                    if ((scanFlags & 128) != 0) {
                        if (this.mExpectingBetter.containsKey(pkg.packageName)) {
                            PackageManagerServiceUtils.logCriticalInfo(5, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
                        } else {
                            PackageSetting known = this.mSettings.getPackageLPr(pkg.packageName);
                            if (known != null) {
                                if (DEBUG_PACKAGE_SCANNING) {
                                    Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                                }
                                if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                                    throw new PackageManagerException(-23, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                                }
                            } else {
                                Log.d(TAG, "assertPackageIsValid ignoring" + pkg.packageName);
                            }
                        }
                    }
                    if ((scanFlags & 4) != 0) {
                        this.mComponentResolver.assertProvidersNotDefined(pkg);
                    }
                    if (!pkg.isPrivileged() && pkg.mSharedUserId != null) {
                        SharedUserSetting sharedUserSetting = null;
                        try {
                            sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
                        } catch (PackageManagerException e) {
                        }
                        if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                            PackageSetting platformPkgSetting = this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME);
                            if (!(platformPkgSetting.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(platformPkgSetting.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                throw new PackageManagerException("Apps that share a user with a privileged app must themselves be marked as privileged. " + pkg.packageName + " shares privileged user " + pkg.mSharedUserId + ".");
                            }
                        }
                    }
                    if (pkg.mOverlayTarget != null) {
                        if ((131072 & scanFlags) != 0) {
                            if ((parseFlags & 16) == 0) {
                                PackageSetting previousPkg = (PackageSetting) assertNotNull(this.mSettings.getPackageLPr(pkg.packageName), "previous package state not present");
                                PackageParser.Package ppkg = previousPkg.pkg;
                                if (ppkg == null) {
                                    try {
                                        ppkg = new PackageParser().parsePackage(previousPkg.codePath, parseFlags | 16);
                                    } catch (PackageParser.PackageParserException e2) {
                                        Slog.w(TAG, "failed to parse " + previousPkg.codePath, e2);
                                    }
                                }
                                if (ppkg != null && ppkg.mOverlayIsStatic) {
                                    throw new PackageManagerException("Overlay " + pkg.packageName + " is static and cannot be upgraded.");
                                } else if (pkg.mOverlayIsStatic) {
                                    throw new PackageManagerException("Overlay " + pkg.packageName + " cannot be upgraded into a static overlay.");
                                }
                            }
                        } else if (!pkg.mOverlayIsStatic) {
                            if (pkg.applicationInfo.targetSdkVersion < 29) {
                                PackageSetting platformPkgSetting2 = this.mSettings.getPackageLPr(PLATFORM_PACKAGE_NAME);
                                if (!(platformPkgSetting2.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(platformPkgSetting2.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                    throw new PackageManagerException("Overlay " + pkg.packageName + " must target Q or later, or be signed with the platform certificate");
                                }
                            }
                            if (!(pkg.mOverlayTargetName != null || (targetPkgSetting = this.mSettings.getPackageLPr(pkg.mOverlayTarget)) == null || targetPkgSetting.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(targetPkgSetting.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                throw new PackageManagerException("Overlay " + pkg.packageName + " and target " + pkg.mOverlayTarget + " signed with different certificates, and the overlay lacks <overlay android:targetName>");
                            }
                        } else {
                            throw new PackageManagerException("Overlay " + pkg.packageName + " is static but not pre-installed.");
                        }
                    }
                    return;
                }
                throw new PackageManagerException(-5, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
            } catch (Throwable th4) {
                th = th4;
                throw th;
            }
        }
    }

    @GuardedBy({"mPackages"})
    private boolean addBuiltInSharedLibraryLocked(String path, String name) {
        if (nonStaticSharedLibExistsLocked(name)) {
            return false;
        }
        commitSharedLibraryInfoLocked(new SharedLibraryInfo(path, null, null, name, -1, 0, new VersionedPackage(PLATFORM_PACKAGE_NAME, 0L), null, null));
        return true;
    }

    @GuardedBy({"mPackages"})
    private boolean nonStaticSharedLibExistsLocked(String name) {
        return sharedLibExists(name, -1, this.mSharedLibraries);
    }

    private static boolean sharedLibExists(String name, long version, Map<String, LongSparseArray<SharedLibraryInfo>> librarySource) {
        LongSparseArray<SharedLibraryInfo> versionedLib = librarySource.get(name);
        if (versionedLib == null || versionedLib.indexOfKey(version) < 0) {
            return false;
        }
        return true;
    }

    @GuardedBy({"mPackages"})
    private void commitSharedLibraryInfoLocked(SharedLibraryInfo libraryInfo) {
        String name = libraryInfo.getName();
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            versionedLib = new LongSparseArray<>();
            this.mSharedLibraries.put(name, versionedLib);
        }
        String declaringPackageName = libraryInfo.getDeclaringPackage().getPackageName();
        if (libraryInfo.getType() == 2) {
            this.mStaticLibsByDeclaringPackage.put(declaringPackageName, versionedLib);
        }
        versionedLib.put(libraryInfo.getLongVersion(), libraryInfo);
    }

    private boolean removeSharedLibraryLPw(String name, long version) {
        int libIdx;
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null || (libIdx = versionedLib.indexOfKey(version)) < 0) {
            return false;
        }
        SharedLibraryInfo libraryInfo = versionedLib.valueAt(libIdx);
        versionedLib.remove(version);
        if (versionedLib.size() > 0) {
            return true;
        }
        this.mSharedLibraries.remove(name);
        if (libraryInfo.getType() != 2) {
            return true;
        }
        this.mStaticLibsByDeclaringPackage.remove(libraryInfo.getDeclaringPackage().getPackageName());
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:111:0x02c6, code lost:
        r0 = th;
     */
    private void commitPackageSettings(PackageParser.Package pkg, PackageParser.Package oldPkg, PackageSetting pkgSetting, int scanFlags, boolean chatty, ReconciledPackage reconciledPkg) {
        Throwable th;
        String pkgName = pkg.packageName;
        ComponentName componentName = this.mCustomResolverComponentName;
        if (componentName != null && componentName.getPackageName().equals(pkg.packageName)) {
            setUpCustomResolverActivity(pkg);
        }
        if (pkg.packageName.equals(PLATFORM_PACKAGE_NAME)) {
            synchronized (this.mPackages) {
                if ((scanFlags & 1024) == 0) {
                    this.mPlatformPackage = pkg;
                    pkg.mVersionCode = this.mSdkVersion;
                    pkg.mVersionCodeMajor = 0;
                    this.mAndroidApplication = pkg.applicationInfo;
                    if (!this.mResolverReplaced) {
                        this.mResolveActivity.applicationInfo = this.mAndroidApplication;
                        this.mResolveActivity.name = ResolverActivity.class.getName();
                        this.mResolveActivity.packageName = this.mAndroidApplication.packageName;
                        this.mResolveActivity.processName = "system:ui";
                        this.mResolveActivity.launchMode = 0;
                        this.mResolveActivity.documentLaunchMode = 3;
                        this.mResolveActivity.flags = 32;
                        this.mResolveActivity.theme = 16974374;
                        this.mResolveActivity.exported = true;
                        this.mResolveActivity.enabled = true;
                        this.mResolveActivity.resizeMode = 2;
                        this.mResolveActivity.configChanges = 3504;
                        this.mResolveInfo.activityInfo = this.mResolveActivity;
                        this.mResolveInfo.priority = 0;
                        this.mResolveInfo.preferredOrder = 0;
                        this.mResolveInfo.match = 0;
                        this.mResolveComponentName = new ComponentName(this.mAndroidApplication.packageName, this.mResolveActivity.name);
                    }
                }
            }
        }
        ArrayList<PackageParser.Package> clientLibPkgs = null;
        synchronized (this.mPackages) {
            if (!ArrayUtils.isEmpty(reconciledPkg.allowedSharedLibraryInfos)) {
                for (SharedLibraryInfo info : reconciledPkg.allowedSharedLibraryInfos) {
                    commitSharedLibraryInfoLocked(info);
                }
                Map<String, PackageParser.Package> combinedPackages = reconciledPkg.getCombinedPackages();
                try {
                    updateSharedLibrariesLocked(pkg, null, combinedPackages);
                } catch (PackageManagerException e) {
                    Slog.e(TAG, "updateSharedLibrariesLPr failed: ", e);
                }
                if ((scanFlags & 16) == 0) {
                    clientLibPkgs = updateAllSharedLibrariesLocked(pkg, combinedPackages);
                }
            }
        }
        if (reconciledPkg.installResult != null) {
            reconciledPkg.installResult.libraryConsumers = clientLibPkgs;
        }
        if ((scanFlags & 16) == 0 && (scanFlags & 2048) == 0 && (scanFlags & 4096) == 0) {
            checkPackageFrozen(pkgName);
        }
        if (clientLibPkgs != null) {
            for (int i = 0; i < clientLibPkgs.size(); i++) {
                PackageParser.Package clientPkg = clientLibPkgs.get(i);
                killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
            }
        }
        Trace.traceBegin(262144, "updateSettings");
        synchronized (this.mPackages) {
            try {
                try {
                    this.mSettings.insertPackageSettingLPw(pkgSetting, pkg);
                    this.mPackages.put(pkg.applicationInfo.packageName, pkg);
                    this.mSettings.mKeySetManagerService.addScannedPackageLPw(pkg);
                    this.mComponentResolver.addAllComponents(pkg, chatty);
                    if ((scanFlags & 16384) != 0) {
                        Slog.w(TAG, "Permission groups from package " + pkg.packageName + " ignored: instant apps cannot define new permission groups.");
                    } else {
                        this.mPermissionManager.addAllPermissionGroups(pkg, chatty);
                    }
                    if ((scanFlags & 16384) != 0) {
                        Slog.w(TAG, "Permissions from package " + pkg.packageName + " ignored: instant apps cannot define new permissions.");
                    } else {
                        this.mPermissionManager.addAllPermissions(pkg, chatty);
                    }
                    StringBuilder r = null;
                    int i2 = 0;
                    for (int collectionSize = pkg.instrumentation.size(); i2 < collectionSize; collectionSize = collectionSize) {
                        PackageParser.Instrumentation a = (PackageParser.Instrumentation) pkg.instrumentation.get(i2);
                        a.info.packageName = pkg.applicationInfo.packageName;
                        a.info.sourceDir = pkg.applicationInfo.sourceDir;
                        a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;
                        a.info.splitNames = pkg.splitNames;
                        a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;
                        a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;
                        a.info.splitDependencies = pkg.applicationInfo.splitDependencies;
                        a.info.dataDir = pkg.applicationInfo.dataDir;
                        a.info.deviceProtectedDataDir = pkg.applicationInfo.deviceProtectedDataDir;
                        a.info.credentialProtectedDataDir = pkg.applicationInfo.credentialProtectedDataDir;
                        a.info.primaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                        a.info.secondaryCpuAbi = pkg.applicationInfo.secondaryCpuAbi;
                        a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;
                        a.info.secondaryNativeLibraryDir = pkg.applicationInfo.secondaryNativeLibraryDir;
                        this.mInstrumentation.put(a.getComponentName(), a);
                        if (chatty) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(a.info.name);
                        }
                        i2++;
                    }
                    if (r != null && DEBUG_PACKAGE_SCANNING) {
                        Log.d(TAG, "  Instrumentation: " + ((Object) r));
                    }
                    if (pkg.protectedBroadcasts != null) {
                        int collectionSize2 = pkg.protectedBroadcasts.size();
                        synchronized (this.mProtectedBroadcasts) {
                            for (int i3 = 0; i3 < collectionSize2; i3++) {
                                this.mProtectedBroadcasts.add((String) pkg.protectedBroadcasts.get(i3));
                            }
                        }
                    }
                    if (oldPkg != null) {
                        AsyncTask.execute(new Runnable(pkg, oldPkg, new ArrayList<>(this.mPackages.keySet())) {
                            /* class com.android.server.pm.$$Lambda$PackageManagerService$flUQp0qTsxUQY0aupDT6UsHb48I */
                            private final /* synthetic */ PackageParser.Package f$1;
                            private final /* synthetic */ PackageParser.Package f$2;
                            private final /* synthetic */ ArrayList f$3;

                            {
                                this.f$1 = r2;
                                this.f$2 = r3;
                                this.f$3 = r4;
                            }

                            public final void run() {
                                PackageManagerService.this.lambda$commitPackageSettings$6$PackageManagerService(this.f$1, this.f$2, this.f$3);
                            }
                        });
                    }
                    Trace.traceEnd(262144);
                    return;
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
        while (true) {
        }
    }

    public /* synthetic */ void lambda$commitPackageSettings$6$PackageManagerService(PackageParser.Package pkg, PackageParser.Package oldPkg, ArrayList allPackageNames) {
        this.mPermissionManager.revokeRuntimePermissionsIfGroupChanged(pkg, oldPkg, allPackageNames, this.mPermissionCallback);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:7:0x003a, code lost:
        if (r17.codePath.contains(android.os.OppoBaseEnvironment.getResourceDirectory().getAbsolutePath() + "/del-app") != false) goto L_0x003c;
     */
    /* JADX WARNING: Removed duplicated region for block: B:15:0x006e  */
    /* JADX WARNING: Removed duplicated region for block: B:55:0x011f  */
    private static void derivePackageAbi(PackageParser.Package pkg, String cpuAbiOverride, boolean extractLibs) throws PackageManagerException {
        boolean extractLibs2;
        NativeLibraryHelper.Handle handle;
        int copyRet;
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        if (!isSystemApp(pkg) || pkg.isUpdatedSystemApp()) {
            if (pkg.codePath != null) {
            }
            extractLibs2 = extractLibs;
            String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
            boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
            handle = null;
            handle = NativeLibraryHelper.Handle.create(pkg);
            File nativeLibraryRoot = new File(nativeLibraryRootStr);
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
            if (!isMultiArch(pkg.applicationInfo)) {
                if (pkg.cpuAbiOverride != null && !"-".equals(pkg.cpuAbiOverride)) {
                    Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
                }
                int abi32 = -114;
                int abi64 = -114;
                if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                    if (extractLibs2) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                if (abi32 < 0 || !pkg.isLibrary() || !extractLibs2) {
                    maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
                    if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                        if (extractLibs2) {
                            Trace.traceBegin(262144, "copyNativeBinaries");
                            abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                        } else {
                            Trace.traceBegin(262144, "findSupportedAbi");
                            abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                        }
                        Trace.traceEnd(262144);
                    }
                    maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
                    if (abi64 >= 0) {
                        if (!extractLibs2 || !pkg.isLibrary()) {
                            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
                        } else {
                            throw new PackageManagerException(-110, "Shared library native lib extraction not supported");
                        }
                    }
                    if (abi32 >= 0) {
                        String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                        if (abi64 < 0) {
                            pkg.applicationInfo.primaryCpuAbi = abi;
                        } else if (pkg.use32bitAbi) {
                            pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                            pkg.applicationInfo.primaryCpuAbi = abi;
                        } else {
                            pkg.applicationInfo.secondaryCpuAbi = abi;
                        }
                    }
                } else {
                    throw new PackageManagerException(-110, "Shared library native lib extraction not supported");
                }
            } else {
                String[] abiList = cpuAbiOverride != null ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
                boolean needsRenderScriptOverride = false;
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                    abiList = Build.SUPPORTED_32_BIT_ABIS;
                    needsRenderScriptOverride = true;
                }
                if (extractLibs2) {
                    Trace.traceBegin(262144, "copyNativeBinaries");
                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
                } else {
                    Trace.traceBegin(262144, "findSupportedAbi");
                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
                }
                Trace.traceEnd(262144);
                if (copyRet < 0 && copyRet != -114) {
                    throw new PackageManagerException(-110, "Error unpackaging native libs for app, errorCode=" + copyRet);
                } else if (copyRet >= 0) {
                    if (!pkg.isLibrary()) {
                        pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
                    } else {
                        throw new PackageManagerException(-110, "Shared library with native libs must be multiarch");
                    }
                } else if (copyRet == -114 && cpuAbiOverride != null) {
                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
                } else if (needsRenderScriptOverride) {
                    pkg.applicationInfo.primaryCpuAbi = abiList[0];
                }
            }
            IoUtils.closeQuietly(handle);
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        }
        extractLibs2 = false;
        String nativeLibraryRootStr2 = pkg.applicationInfo.nativeLibraryRootDir;
        boolean useIsaSpecificSubdirs2 = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
        handle = null;
        try {
            handle = NativeLibraryHelper.Handle.create(pkg);
            File nativeLibraryRoot2 = new File(nativeLibraryRootStr2);
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
            if (!isMultiArch(pkg.applicationInfo)) {
            }
        } catch (IOException ioe) {
            Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
        } catch (Throwable th) {
            IoUtils.closeQuietly(handle);
            throw th;
        }
        IoUtils.closeQuietly(handle);
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
    }

    private static List<String> adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, PackageParser.Package scannedPackage) {
        String adjustedAbi;
        List<String> changedAbiCodePath = null;
        String requiredInstructionSet = null;
        if (!(scannedPackage == null || scannedPackage.applicationInfo.primaryCpuAbi == null)) {
            requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
        }
        PackageSetting requirer = null;
        for (PackageSetting ps : packagesForUser) {
            if ((scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) && ps.primaryCpuAbiString != null) {
                String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
                if (requiredInstructionSet != null && !instructionSet.equals(requiredInstructionSet)) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Instruction set mismatch, ");
                    sb.append(requirer == null ? "[caller]" : requirer);
                    sb.append(" requires ");
                    sb.append(requiredInstructionSet);
                    sb.append(" whereas ");
                    sb.append(ps);
                    sb.append(" requires ");
                    sb.append(instructionSet);
                    Slog.w(TAG, sb.toString());
                }
                if (requiredInstructionSet == null) {
                    requiredInstructionSet = instructionSet;
                    requirer = ps;
                }
            }
        }
        if (requiredInstructionSet != null) {
            if (requirer != null) {
                adjustedAbi = requirer.primaryCpuAbiString;
                if (scannedPackage != null) {
                    scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
                }
            } else {
                adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
            }
            for (PackageSetting ps2 : packagesForUser) {
                if ((scannedPackage == null || !scannedPackage.packageName.equals(ps2.name)) && ps2.primaryCpuAbiString == null) {
                    ps2.primaryCpuAbiString = adjustedAbi;
                    if (!(ps2.pkg == null || ps2.pkg.applicationInfo == null || TextUtils.equals(adjustedAbi, ps2.pkg.applicationInfo.primaryCpuAbi))) {
                        ps2.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                        if (DEBUG_ABI_SELECTION) {
                            StringBuilder sb2 = new StringBuilder();
                            sb2.append("Adjusting ABI for ");
                            sb2.append(ps2.name);
                            sb2.append(" to ");
                            sb2.append(adjustedAbi);
                            sb2.append(" (requirer=");
                            PackageParser.Package r8 = "null";
                            sb2.append(requirer != null ? requirer.pkg : r8);
                            sb2.append(", scannedPackage=");
                            if (scannedPackage != null) {
                                r8 = scannedPackage;
                            }
                            sb2.append(r8);
                            sb2.append(")");
                            Slog.i(TAG, sb2.toString());
                        }
                        if (changedAbiCodePath == null) {
                            changedAbiCodePath = new ArrayList<>();
                        }
                        changedAbiCodePath.add(ps2.codePathString);
                    }
                }
            }
        }
        return changedAbiCodePath;
    }

    private void setUpCustomResolverActivity(PackageParser.Package pkg) {
        synchronized (this.mPackages) {
            this.mResolverReplaced = true;
            this.mResolveActivity.applicationInfo = pkg.applicationInfo;
            this.mResolveActivity.name = this.mCustomResolverComponentName.getClassName();
            this.mResolveActivity.packageName = pkg.applicationInfo.packageName;
            this.mResolveActivity.processName = pkg.applicationInfo.packageName;
            this.mResolveActivity.launchMode = 0;
            this.mResolveActivity.flags = 288;
            this.mResolveActivity.theme = 0;
            this.mResolveActivity.exported = true;
            this.mResolveActivity.enabled = true;
            this.mResolveInfo.activityInfo = this.mResolveActivity;
            this.mResolveInfo.priority = 0;
            this.mResolveInfo.preferredOrder = 0;
            this.mResolveInfo.match = 0;
            this.mResolveComponentName = this.mCustomResolverComponentName;
            Slog.i(TAG, "Replacing default ResolverActivity with custom activity: " + this.mResolveComponentName);
        }
    }

    private void setUpInstantAppInstallerActivityLP(ActivityInfo installerActivity) {
        if (installerActivity == null) {
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Clear ephemeral installer activity");
            }
            this.mInstantAppInstallerActivity = null;
            return;
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Set ephemeral installer activity: " + installerActivity.getComponentName());
        }
        this.mInstantAppInstallerActivity = installerActivity;
        this.mInstantAppInstallerActivity.flags |= 288;
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        activityInfo.exported = true;
        activityInfo.enabled = true;
        ResolveInfo resolveInfo = this.mInstantAppInstallerInfo;
        resolveInfo.activityInfo = activityInfo;
        resolveInfo.priority = 1;
        resolveInfo.preferredOrder = 1;
        resolveInfo.isDefault = true;
        resolveInfo.match = 5799936;
    }

    private static String calculateBundledApkRoot(String codePathString) {
        File codeRoot;
        File codePath = new File(codePathString);
        if (FileUtils.contains(Environment.getRootDirectory(), codePath)) {
            codeRoot = Environment.getRootDirectory();
        } else if (FileUtils.contains(Environment.getOemDirectory(), codePath)) {
            codeRoot = Environment.getOemDirectory();
        } else if (FileUtils.contains(Environment.getVendorDirectory(), codePath)) {
            codeRoot = Environment.getVendorDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else if (FileUtils.contains(Environment.getProductDirectory(), codePath)) {
            codeRoot = Environment.getProductDirectory();
        } else if (FileUtils.contains(Environment.getProductServicesDirectory(), codePath)) {
            codeRoot = Environment.getProductServicesDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else {
            try {
                File f = codePath.getCanonicalFile();
                File parent = f.getParentFile();
                while (true) {
                    File tmp = parent.getParentFile();
                    if (tmp == null) {
                        break;
                    }
                    f = parent;
                    parent = tmp;
                }
                Slog.w(TAG, "Unrecognized code path " + codePath + " - using " + f);
                codeRoot = f;
            } catch (IOException e) {
                Slog.w(TAG, "Can't canonicalize code path " + codePath);
                return Environment.getRootDirectory().getPath();
            }
        }
        return codeRoot.getPath();
    }

    private static void setNativeLibraryPaths(PackageParser.Package pkg, File appLib32InstallDir) {
        ApplicationInfo info = pkg.applicationInfo;
        String codePath = pkg.codePath;
        File codeFile = new File(codePath);
        boolean bundledApp = info.isSystemApp() && !info.isUpdatedSystemApp();
        info.nativeLibraryRootDir = null;
        info.nativeLibraryRootRequiresIsa = false;
        info.nativeLibraryDir = null;
        info.secondaryNativeLibraryDir = null;
        String secondaryLibDir = "lib";
        if (PackageParser.isApkFile(codeFile)) {
            if (bundledApp) {
                String apkRoot = calculateBundledApkRoot(info.sourceDir);
                boolean is64Bit = VMRuntime.is64BitInstructionSet(InstructionSets.getPrimaryInstructionSet(info));
                String apkName = deriveCodePathName(codePath);
                info.nativeLibraryRootDir = Environment.buildPath(new File(apkRoot), new String[]{is64Bit ? "lib64" : secondaryLibDir, apkName}).getAbsolutePath();
                if (info.secondaryCpuAbi != null) {
                    if (!is64Bit) {
                        secondaryLibDir = "lib64";
                    }
                    info.secondaryNativeLibraryDir = Environment.buildPath(new File(apkRoot), new String[]{secondaryLibDir, apkName}).getAbsolutePath();
                }
            } else {
                info.nativeLibraryRootDir = new File(appLib32InstallDir, deriveCodePathName(codePath)).getAbsolutePath();
            }
            info.nativeLibraryRootRequiresIsa = false;
            info.nativeLibraryDir = info.nativeLibraryRootDir;
        } else if (!sPmsExt.updateNativeLibDir(info, codePath)) {
            info.nativeLibraryRootDir = new File(codeFile, secondaryLibDir).getAbsolutePath();
            info.nativeLibraryRootRequiresIsa = true;
            info.nativeLibraryDir = new File(info.nativeLibraryRootDir, InstructionSets.getPrimaryInstructionSet(info)).getAbsolutePath();
            if (info.secondaryCpuAbi != null) {
                info.secondaryNativeLibraryDir = new File(info.nativeLibraryRootDir, VMRuntime.getInstructionSet(info.secondaryCpuAbi)).getAbsolutePath();
            }
        }
        if (!info.isSystemApp() && info.nativeLibraryDir != null && !info.nativeLibraryDir.contains(".tmp")) {
            mCompatibilityHelper.customizeNativeLibrariesIfNeeded(pkg);
        }
    }

    private static void setBundledAppAbisAndRoots(PackageParser.Package pkg, PackageSetting pkgSetting) {
        setBundledAppAbi(pkg, calculateBundledApkRoot(pkg.applicationInfo.sourceDir), deriveCodePathName(pkg.applicationInfo.getCodePath()));
        if (pkgSetting != null) {
            pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
            pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        }
    }

    /* JADX INFO: Multiple debug info for r4v20 boolean: [D('isa' java.lang.String), D('has32BitLibs' boolean)] */
    private static void setBundledAppAbi(PackageParser.Package pkg, String apkRoot, String apkName) {
        boolean has64BitLibs;
        boolean has64BitLibs2;
        File codeFile = new File(pkg.codePath);
        if (PackageParser.isApkFile(codeFile)) {
            has64BitLibs = new File(apkRoot, new File("lib64", apkName).getPath()).exists();
            has64BitLibs2 = new File(apkRoot, new File("lib", apkName).getPath()).exists();
        } else {
            File rootDir = new File(codeFile, "lib");
            if (ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0])) {
                has64BitLibs = false;
            } else {
                has64BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0])).exists();
            }
            if (ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0])) {
                has64BitLibs2 = false;
            } else {
                has64BitLibs2 = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0])).exists();
            }
        }
        if (has64BitLibs && !has64BitLibs2) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has64BitLibs2 && !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (!has64BitLibs2 || !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else {
            if ((pkg.applicationInfo.flags & Integer.MIN_VALUE) == 0) {
                Slog.e(TAG, "Package " + pkg + " has multiple bundled libs, but is not multiarch.");
            }
            if (VMRuntime.is64BitInstructionSet(InstructionSets.getPreferredInstructionSet())) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
                pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
                return;
            }
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        }
    }

    private void killApplication(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, -1, reason);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void killApplication(String pkgName, int appId, int userId, String reason) {
        long token = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killApplication(pkgName, appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    private void removePackageLI(PackageParser.Package pkg, boolean chatty) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            removePackageLI(ps.name, chatty);
        } else if (DEBUG_REMOVE && chatty) {
            Log.d(TAG, "Not removing package " + pkg.packageName + "; mExtras == null");
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                removePackageLI(ps2.name, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removePackageLI(String packageName, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + packageName);
        }
        synchronized (this.mPackages) {
            PackageParser.Package removedPackage = this.mPackages.remove(packageName);
            if (removedPackage != null) {
                cleanPackageDataStructuresLILPw(removedPackage, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removeInstalledPackageLI(PackageParser.Package pkg, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + pkg.applicationInfo.packageName);
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i);
                this.mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        this.mComponentResolver.removeAllComponents(pkg, chatty);
        this.mPermissionManager.removeAllPermissions(pkg, chatty);
        int instrumentationSize = pkg.instrumentation.size();
        StringBuilder r = null;
        for (int i = 0; i < instrumentationSize; i++) {
            PackageParser.Instrumentation a = (PackageParser.Instrumentation) pkg.instrumentation.get(i);
            this.mInstrumentation.remove(a.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Instrumentation: " + ((Object) r));
        }
        StringBuilder r2 = null;
        if (!((pkg.applicationInfo.flags & 1) == 0 || pkg.libraryNames == null)) {
            int libraryNamesSize = pkg.libraryNames.size();
            for (int i2 = 0; i2 < libraryNamesSize; i2++) {
                String name = (String) pkg.libraryNames.get(i2);
                if (removeSharedLibraryLPw(name, 0) && DEBUG_REMOVE && chatty) {
                    if (r2 == null) {
                        r2 = new StringBuilder(256);
                    } else {
                        r2.append(' ');
                    }
                    r2.append(name);
                }
            }
        }
        StringBuilder r3 = null;
        if (pkg.staticSharedLibName != null && removeSharedLibraryLPw(pkg.staticSharedLibName, pkg.staticSharedLibVersion) && DEBUG_REMOVE && chatty) {
            if (0 == 0) {
                r3 = new StringBuilder(256);
            } else {
                r3.append(' ');
            }
            r3.append(pkg.staticSharedLibName);
        }
        if (r3 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Libraries: " + ((Object) r3));
        }
    }

    @Override // com.android.server.pm.PackageSender
    public void sendPackageBroadcast(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        this.mHandler.post(new Runnable(userIds, action, pkg, extras, flags, targetPkg, finishedReceiver, instantUserIds) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$O5iApY07YeJyXA8KUFVcxpCf1NI */
            private final /* synthetic */ int[] f$1;
            private final /* synthetic */ String f$2;
            private final /* synthetic */ String f$3;
            private final /* synthetic */ Bundle f$4;
            private final /* synthetic */ int f$5;
            private final /* synthetic */ String f$6;
            private final /* synthetic */ IIntentReceiver f$7;
            private final /* synthetic */ int[] f$8;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
                this.f$6 = r7;
                this.f$7 = r8;
                this.f$8 = r9;
            }

            public final void run() {
                PackageManagerService.this.lambda$sendPackageBroadcast$7$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6, this.f$7, this.f$8);
            }
        });
    }

    public /* synthetic */ void lambda$sendPackageBroadcast$7$PackageManagerService(int[] userIds, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] instantUserIds) {
        int[] resolvedUserIds;
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                if (userIds == null) {
                    resolvedUserIds = am.getRunningUserIds();
                } else {
                    resolvedUserIds = userIds;
                }
                doSendBroadcast(am, action, pkg, extras, flags, targetPkg, finishedReceiver, resolvedUserIds, false);
                if (instantUserIds != null && instantUserIds != EMPTY_INT_ARRAY) {
                    doSendBroadcast(am, action, pkg, extras, flags, targetPkg, finishedReceiver, instantUserIds, true);
                }
            }
        } catch (RemoteException e) {
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0022, code lost:
        if (r0 < 0) goto L_0x002c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0024, code lost:
        r2[r0].onPackageAdded(r4, r5);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x002c, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x001f, code lost:
        r0 = r2.length - 1;
     */
    @Override // com.android.server.pm.PackageSender
    public void notifyPackageAdded(String packageName, int uid) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0022, code lost:
        if (r0 < 0) goto L_0x002c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0024, code lost:
        r2[r0].onPackageChanged(r4, r5);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x002c, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x001f, code lost:
        r0 = r2.length - 1;
     */
    @Override // com.android.server.pm.PackageSender
    public void notifyPackageChanged(String packageName, int uid) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            }
        }
    }

    static /* synthetic */ int lambda$static$8(ProviderInfo p1, ProviderInfo p2) {
        int v1 = p1.initOrder;
        int v2 = p2.initOrder;
        if (v1 > v2) {
            return -1;
        }
        return v1 < v2 ? 1 : 0;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0022, code lost:
        if (r0 < 0) goto L_0x002c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0024, code lost:
        r2[r0].onPackageRemoved(r4, r5);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x002c, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x001f, code lost:
        r0 = r2.length - 1;
     */
    @Override // com.android.server.pm.PackageSender
    public void notifyPackageRemoved(String packageName, int uid) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            }
        }
    }

    private void doSendBroadcast(IActivityManager am, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, boolean isInstantApp) throws RemoteException {
        int id;
        String str = action;
        String str2 = pkg;
        int length = userIds.length;
        boolean z = false;
        int i = 0;
        while (i < length) {
            int id2 = userIds[i];
            String[] requiredPermissions = null;
            Intent intent = new Intent(str, str2 != null ? Uri.fromParts("package", str2, null) : null);
            int id3 = OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).fixIntentAndUserId(id2, intent, str2);
            if (isInstantApp) {
                requiredPermissions = INSTANT_APP_BROADCAST_PERMISSION;
            }
            if (extras != null) {
                intent.putExtras(extras);
            }
            if (targetPkg != null) {
                intent.setPackage(targetPkg);
            }
            int uid = intent.getIntExtra("android.intent.extra.UID", -1);
            if (uid > 0 && UserHandle.getUserId(uid) != id3) {
                intent.putExtra("android.intent.extra.UID", UserHandle.getUid(id3, UserHandle.getAppId(uid)));
            }
            intent.putExtra("android.intent.extra.user_handle", id3);
            intent.addFlags(flags | 67108864);
            if ("android.intent.action.PACKAGE_REMOVED".equals(str)) {
                String callingPackage = OppoPackageManagerHelper.getProcessNameByPid(OppoPackageManagerHelper.sPid);
                String str3 = "";
                if (callingPackage == null || callingPackage == str3) {
                    callingPackage = getNameForUid(OppoPackageManagerHelper.sUid);
                }
                if (callingPackage != null) {
                    str3 = callingPackage;
                }
                intent.putExtra(OppoPackageManagerHelper.OPPO_EXTRA_PKG_NAME, str3);
                PackageInfo tempInfo = OppoPackageManagerHelper.sDeleteInfo;
                if (tempInfo != null) {
                    intent.putExtra(OppoPackageManagerHelper.OPPO_EXTRA_VERSION_NAME, tempInfo.versionName);
                    intent.putExtra(OppoPackageManagerHelper.OPPO_EXTRA_VERSION_CODE, tempInfo.versionCode);
                    OppoPackageManagerHelper.resetDeleteInfo();
                }
            }
            doSendBroadcastBase(am, intent, action, intent.getAction() != null ? intent.getAction() : str, pkg, targetPkg, this, finishedReceiver, id3);
            if (DEBUG_BROADCASTS) {
                RuntimeException here = new RuntimeException("here");
                here.fillInStackTrace();
                StringBuilder sb = new StringBuilder();
                sb.append("Sending to user ");
                id = id3;
                sb.append(id);
                sb.append(": ");
                sb.append(intent.toShortString(z, true, z, z));
                sb.append(StringUtils.SPACE);
                sb.append(intent.getExtras());
                Slog.d(TAG, sb.toString(), here);
            } else {
                id = id3;
            }
            am.broadcastIntent((IApplicationThread) null, intent, (String) null, finishedReceiver, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, finishedReceiver != null ? true : z, false, id);
            postDoSendBroadcast(am, finishedReceiver, targetPkg, intent.getAction() != null ? intent.getAction() : action, intent, id);
            i++;
            str = action;
            z = z;
            str2 = pkg;
        }
    }

    private boolean isExternalMediaAvailable() {
        return this.mMediaMounted || Environment.isExternalStorageEmulated();
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private int fixUpInstallReason(String installerPackageName, int installerUid, int installReason) {
        if (checkUidPermission("android.permission.INSTALL_PACKAGES", installerUid) == 0) {
            return installReason;
        }
        String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(UserHandle.getUserId(installerUid));
        if (ownerPackage != null && ownerPackage.equals(installerPackageName)) {
            return 1;
        }
        if (installReason == 1) {
            return 0;
        }
        return installReason;
    }

    /* access modifiers changed from: package-private */
    public void installStage(ActiveInstallSession activeInstallSession) {
        if (DEBUG_INSTANT && (activeInstallSession.getSessionParams().installFlags & 2048) != 0) {
            Slog.d(TAG, "Ephemeral install of " + activeInstallSession.getPackageName());
        }
        boolean isInstallSourceEnable = false;
        if (hasSystemFeature(OppoCustomizeNotificationHelper.Constants.FEATURE_BUSINESS_CUSTOM, 0)) {
            OppoCutomizeManagerInternal customizeMgr = getOppoCutomizeManagerInternal();
            if (customizeMgr != null) {
                isInstallSourceEnable = customizeMgr.isInstallSourceEnable();
            }
            if (isInstallSourceEnable) {
                List<String> pkgwhitelist = customizeMgr.getInstallSourceList();
                if (activeInstallSession.mInstallerUid == getUidForSharedUser("oppo.uid.nearme")) {
                    if (pkgwhitelist == null || !pkgwhitelist.contains("com.oppo.market")) {
                        Slog.d(TAG, "0.com.oppo.market : " + activeInstallSession.mInstallerUid + "  is not allow to install !!!");
                        try {
                            if (activeInstallSession.mObserver != null) {
                                activeInstallSession.mObserver.onPackageInstalled("", -111, (String) null, (Bundle) null);
                            }
                        } catch (RemoteException e) {
                        }
                        customizeMgr.sendBroadcastForArmy();
                        return;
                    }
                    Slog.d(TAG, "com.oppo.market has added to white list");
                } else if ("com.android.packageinstaller".equals(activeInstallSession.getInstallerPackageName())) {
                    Slog.d(TAG, "1.packageinstaller : " + activeInstallSession.getInstallerPackageName() + "  always allow to install");
                } else if (pkgwhitelist != null && pkgwhitelist.contains(activeInstallSession.getInstallerPackageName())) {
                    Slog.d(TAG, "2.market's uid = " + activeInstallSession.getInstallerPackageName() + "  and allow to install");
                } else if (activeInstallSession.mInstallerUid == 1000) {
                    Slog.d(TAG, "3.system uid always allow to install!!");
                } else {
                    Slog.d(TAG, "4.app come from the market uid =  " + activeInstallSession.mInstallerUid + "  is not allow to install !!!");
                    try {
                        if (activeInstallSession.mObserver != null) {
                            activeInstallSession.mObserver.onPackageInstalled("", -111, (String) null, (Bundle) null);
                        }
                    } catch (RemoteException e2) {
                    }
                    customizeMgr.sendBroadcastForArmy();
                    return;
                }
            }
        }
        Message msg = this.mHandler.obtainMessage(5);
        InstallParams params = new InstallParams(activeInstallSession);
        params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));
        params.installParamsEx = OppoBasePackageManagerService.InstallParamsEx.initInstallParamsEx(activeInstallSession.getSessionParams());
        msg.obj = params;
        Trace.asyncTraceBegin(262144, "installStage", System.identityHashCode(msg.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
        this.mHandler.sendMessage(msg);
    }

    /* access modifiers changed from: package-private */
    public void installStage(List<ActiveInstallSession> children) throws PackageManagerException {
        Message msg = this.mHandler.obtainMessage(5);
        MultiPackageInstallParams params = new MultiPackageInstallParams(UserHandle.ALL, children);
        params.setTraceMethod("installStageMultiPackage").setTraceCookie(System.identityHashCode(params));
        msg.obj = params;
        Trace.asyncTraceBegin(262144, "installStageMultiPackage", System.identityHashCode(msg.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
        this.mHandler.sendMessage(msg);
    }

    private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
        boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
        boolean isInstantApp = pkgSetting.getInstantApp(userId);
        sendPackageAddedForNewUsers(packageName, isSystem, false, pkgSetting.appId, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
        PackageInstaller.SessionInfo info = new PackageInstaller.SessionInfo();
        info.installReason = pkgSetting.getInstallReason(userId);
        info.appPackageName = packageName;
        sendSessionCommitBroadcast(info, userId);
        sPmsExt.onPackageAdded(packageName, pkgSetting, userId);
    }

    @Override // com.android.server.pm.PackageSender
    public void sendPackageAddedForNewUsers(String packageName, boolean sendBootCompleted, boolean includeStopped, int appId, int[] userIds, int[] instantUserIds) {
        if (!ArrayUtils.isEmpty(userIds) || !ArrayUtils.isEmpty(instantUserIds)) {
            Bundle extras = new Bundle(1);
            extras.putInt("android.intent.extra.UID", UserHandle.getUid(ArrayUtils.isEmpty(userIds) ? instantUserIds[0] : userIds[0], appId));
            sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, userIds, instantUserIds);
            if (sendBootCompleted && !ArrayUtils.isEmpty(userIds)) {
                this.mHandler.post(new Runnable(userIds, packageName, includeStopped) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$4R9Zu2zflm9xqt9wOD23IIJnqLs */
                    private final /* synthetic */ int[] f$1;
                    private final /* synthetic */ String f$2;
                    private final /* synthetic */ boolean f$3;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                    }

                    public final void run() {
                        PackageManagerService.this.lambda$sendPackageAddedForNewUsers$9$PackageManagerService(this.f$1, this.f$2, this.f$3);
                    }
                });
            }
        }
    }

    public /* synthetic */ void lambda$sendPackageAddedForNewUsers$9$PackageManagerService(int[] userIds, String packageName, boolean includeStopped) {
        for (int userId : userIds) {
            sendBootCompletedBroadcastToSystemApp(packageName, includeStopped, userId);
        }
    }

    private void sendBootCompletedBroadcastToSystemApp(String packageName, boolean includeStopped, int userId) {
        RemoteException e;
        if (this.mUserManagerInternal.isUserRunning(userId)) {
            IActivityManager am = ActivityManager.getService();
            try {
                Intent lockedBcIntent = new Intent("android.intent.action.LOCKED_BOOT_COMPLETED").setPackage(packageName);
                if (includeStopped) {
                    lockedBcIntent.addFlags(32);
                }
                String[] requiredPermissions = {"android.permission.RECEIVE_BOOT_COMPLETED"};
                try {
                    am.broadcastIntent((IApplicationThread) null, lockedBcIntent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, false, false, userId);
                    try {
                        if (this.mUserManagerInternal.isUserUnlockingOrUnlocked(userId)) {
                            Intent bcIntent = new Intent("android.intent.action.BOOT_COMPLETED").setPackage(packageName);
                            if (includeStopped) {
                                bcIntent.addFlags(32);
                            }
                            am.broadcastIntent((IApplicationThread) null, bcIntent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, false, false, userId);
                        }
                    } catch (RemoteException e2) {
                        e = e2;
                        throw e.rethrowFromSystemServer();
                    }
                } catch (RemoteException e3) {
                    e = e3;
                    throw e.rethrowFromSystemServer();
                }
            } catch (RemoteException e4) {
                e = e4;
                throw e.rethrowFromSystemServer();
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:57:0x010d, code lost:
        if (r4 == false) goto L_0x0117;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x010f, code lost:
        sendPackageAddedForUser(r13, r7, r15);
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x0116, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x0117, code lost:
        if (r5 == false) goto L_0x012d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x0119, code lost:
        killApplication(r13, android.os.UserHandle.getUid(r15, r7.appId), "hiding pkg");
        sendApplicationHiddenForUser(r13, r7, r15);
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x012c, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x012d, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0131, code lost:
        return false;
     */
    public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
        permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, true, "setApplicationHiddenSetting for user " + userId);
        if (!hidden || !isPackageDeviceAdmin(packageName, userId)) {
            long callingId = Binder.clearCallingIdentity();
            boolean sendAdded = false;
            boolean sendRemoved = false;
            try {
                synchronized (this.mPackages) {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting == null) {
                        return false;
                    }
                    if (filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                        Slog.w(TAG, "Cannot hide package: android");
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else if (OppoFeatureCache.get(IColorForbidHideOrDisableManager.DEFAULT).isPackageForbidHidden(hidden, packageName)) {
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else {
                        PackageParser.Package pkg = this.mPackages.get(packageName);
                        if (pkg != null && pkg.staticSharedLibName != null) {
                            Slog.w(TAG, "Cannot hide package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if (hidden && !UserHandle.isSameApp(callingUid, pkgSetting.appId) && this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                            Slog.w(TAG, "Not hiding protected package: " + packageName);
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if (pkgSetting.getHidden(userId) != hidden) {
                            pkgSetting.setHidden(hidden, userId);
                            this.mSettings.writePackageRestrictionsLPr(userId);
                            if (hidden) {
                                sendRemoved = true;
                            } else {
                                sendAdded = true;
                            }
                        }
                    }
                }
            } finally {
                Binder.restoreCallingIdentity(callingId);
            }
        } else {
            Slog.w(TAG, "Not hiding package " + packageName + ": has active device admin");
            return false;
        }
    }

    public void setSystemAppHiddenUntilInstalled(String packageName, boolean hidden) {
        enforceSystemOrPhoneCaller("setSystemAppHiddenUntilInstalled");
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                if (pkgSetting.isSystem()) {
                    PackageParser.Package pkg = pkgSetting.pkg;
                    if (!(pkg == null || pkg.applicationInfo == null)) {
                        pkg.applicationInfo.hiddenUntilInstalled = hidden;
                    }
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(packageName);
                    if (disabledPs != null) {
                        PackageParser.Package pkg2 = disabledPs.pkg;
                        if (!(pkg2 == null || pkg2.applicationInfo == null)) {
                            pkg2.applicationInfo.hiddenUntilInstalled = hidden;
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:13:0x0026, code lost:
        r0 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x002b, code lost:
        if (r11 == false) goto L_0x003c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:?, code lost:
        installExistingPackageAsUser(r10, r12, com.android.server.pm.DumpState.DUMP_CHANGES, 3, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x003b, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x003c, code lost:
        deletePackageVersioned(new android.content.pm.VersionedPackage(r10, -1), new android.content.pm.PackageManager.LegacyPackageDeleteObserver((android.content.pm.IPackageDeleteObserver) null).getBinder(), r12, 4);
        android.os.Binder.restoreCallingIdentity(r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:21:0x0054, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x0055, code lost:
        r2 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x0056, code lost:
        android.os.Binder.restoreCallingIdentity(r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0059, code lost:
        throw r2;
     */
    public boolean setSystemAppInstallState(String packageName, boolean installed, int userId) {
        enforceSystemOrPhoneCaller("setSystemAppInstallState");
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                if (pkgSetting.isSystem()) {
                    if (pkgSetting.getInstalled(userId) == installed) {
                        return false;
                    }
                }
            }
            return false;
        }
    }

    private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        info.removedPackage = packageName;
        info.installerPackageName = pkgSetting.installerPackageName;
        info.removedUsers = new int[]{userId};
        info.broadcastUsers = new int[]{userId};
        info.uid = UserHandle.getUid(userId, pkgSetting.appId);
        info.sendPackageRemovedBroadcasts(true);
    }

    private void sendDistractingPackagesChanged(String[] pkgList, int[] uidList, int userId, int distractionFlags) {
        Bundle extras = new Bundle(3);
        extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
        extras.putIntArray("android.intent.extra.changed_uid_list", uidList);
        extras.putInt("android.intent.extra.distraction_restrictions", distractionFlags);
        sendPackageBroadcast("android.intent.action.DISTRACTING_PACKAGES_CHANGED", null, extras, 1073741824, null, null, new int[]{userId}, null);
    }

    private void sendPackagesSuspendedForUser(String[] pkgList, int[] uidList, int userId, boolean suspended, PersistableBundle launcherExtras) {
        String str;
        Bundle extras = new Bundle(3);
        extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
        extras.putIntArray("android.intent.extra.changed_uid_list", uidList);
        if (launcherExtras != null) {
            extras.putBundle("android.intent.extra.LAUNCHER_EXTRAS", new Bundle(launcherExtras.deepCopy()));
        }
        if (suspended) {
            str = "android.intent.action.PACKAGES_SUSPENDED";
        } else {
            str = "android.intent.action.PACKAGES_UNSUSPENDED";
        }
        sendPackageBroadcast(str, null, extras, 1073741824, null, null, new int[]{userId}, null);
    }

    public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
        permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, false, "getApplicationHidden for user " + userId);
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    return true;
                }
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    Binder.restoreCallingIdentity(callingId);
                    return true;
                }
                boolean hidden = ps.getHidden(userId);
                Binder.restoreCallingIdentity(callingId);
                return hidden;
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions) {
        return installExistingPackageAsUser(packageName, userId, installFlags, installReason, whiteListedPermissions, null);
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:101:?, code lost:
        prepareAppDataAfterInstallLIF(r0.pkg);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x01c0, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x01c5, code lost:
        android.common.OppoFeatureCache.get(com.android.server.am.IColorMultiAppManager.DEFAULT).handleInstallApp(r24, r23);
        sendPackageAddedForUser(r23, r0, r24);
        r6 = r22.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x01d5, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:?, code lost:
        updateSequenceNumberLP(r0, new int[]{r24});
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x01df, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x01e0, code lost:
        r6 = createPackageInstalledInfo(1);
        r6.pkg = r0.pkg;
        r6.newUsers = new int[]{r24};
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x01f3, code lost:
        if (r28 != null) goto L_0x01f7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x01f5, code lost:
        r14 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x01f7, code lost:
        r14 = new com.android.server.pm.PackageManagerService.PostInstallData(null, r6, new com.android.server.pm.$$Lambda$PackageManagerService$TfnapVkUze7EtdWImq0cww0iVcc(r22, r6, r28));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x0202, code lost:
        restoreAndPostInstall(r24, r6, r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x020a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x020e, code lost:
        android.os.Binder.restoreCallingIdentity(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0213, code lost:
        return 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x0228, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x019e, code lost:
        if (r13 == false) goto L_0x020c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x01a3, code lost:
        if ((4194304 & r25) == 0) goto L_0x01ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01a7, code lost:
        if (r0.pkg == null) goto L_0x01ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x01a9, code lost:
        r5 = r0.pkg.requestedPermissions;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x01ae, code lost:
        r5 = r27;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:?, code lost:
        setWhitelistedRestrictedPermissions(r23, r5, 2, r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x01b6, code lost:
        if (r0.pkg == null) goto L_0x01c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x01b8, code lost:
        r6 = r22.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x01ba, code lost:
        monitor-enter(r6);
     */
    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions, IntentSender intentSender) {
        Throwable th;
        boolean installed;
        boolean installed2;
        if (DEBUG_INSTALL) {
            Log.v(TAG, "installExistingPackageAsUser package=" + packageName + " userId=" + userId + " installFlags=" + installFlags + " installReason=" + installReason + " whiteListedPermissions=" + whiteListedPermissions);
        }
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") == 0 || this.mContext.checkCallingOrSelfPermission("com.android.permission.INSTALL_EXISTING_PACKAGES") == 0) {
            this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "installExistingPackage for user " + userId);
            if (isUserRestricted(userId, "no_install_apps")) {
                return -111;
            }
            long callingId = Binder.clearCallingIdentity();
            boolean instantApp = (installFlags & 2048) != 0;
            boolean fullApp = (installFlags & 16384) != 0;
            try {
                synchronized (this.mPackages) {
                    try {
                        PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                        if (pkgSetting == null) {
                            try {
                                Binder.restoreCallingIdentity(callingId);
                                return -3;
                            } catch (Throwable th2) {
                                th = th2;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th3) {
                                        th = th3;
                                    }
                                }
                                throw th;
                            }
                        } else {
                            if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {
                                try {
                                    boolean installAllowed = false;
                                    int[] userIds = sUserManager.getUserIds();
                                    installed = false;
                                    try {
                                        int length = userIds.length;
                                        int i = 0;
                                        while (true) {
                                            if (i >= length) {
                                                break;
                                            }
                                            installAllowed = !pkgSetting.getInstantApp(userIds[i]);
                                            if (installAllowed) {
                                                break;
                                            }
                                            i++;
                                            userIds = userIds;
                                        }
                                        if (!installAllowed) {
                                            Binder.restoreCallingIdentity(callingId);
                                            return -3;
                                        }
                                    } catch (Throwable th4) {
                                        th = th4;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                } catch (Throwable th5) {
                                    th = th5;
                                    while (true) {
                                        break;
                                    }
                                    throw th;
                                }
                            } else {
                                installed = false;
                            }
                            try {
                                boolean pkgUninstAbnormal = !OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).isMultiApp(userId, packageName) && 999 == userId && pkgSetting.getInstalled(userId);
                                if (DEBUG_PMS) {
                                    StringBuilder sb = new StringBuilder();
                                    try {
                                        sb.append("multi app pkgUninstAbnormal ");
                                        sb.append(pkgUninstAbnormal);
                                        Slog.d(TAG, sb.toString());
                                    } catch (Throwable th6) {
                                        th = th6;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                }
                                if (pkgSetting.getInstalled(userId)) {
                                    if (!pkgUninstAbnormal) {
                                        if (!fullApp || !pkgSetting.getInstantApp(userId)) {
                                            installed2 = installed;
                                        } else {
                                            installed2 = true;
                                        }
                                        setInstantAppForUser(pkgSetting, userId, instantApp, fullApp);
                                    }
                                }
                                pkgSetting.setInstalled(true, userId);
                                pkgSetting.setHidden(false, userId);
                                pkgSetting.setInstallReason(installReason, userId);
                                this.mSettings.writePackageRestrictionsLPr(userId);
                                this.mSettings.writeKernelMappingLPr(pkgSetting);
                                installed2 = true;
                                try {
                                    setInstantAppForUser(pkgSetting, userId, instantApp, fullApp);
                                } catch (Throwable th7) {
                                    th = th7;
                                    while (true) {
                                        break;
                                    }
                                    throw th;
                                }
                            } catch (Throwable th8) {
                                th = th8;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        }
                    } catch (Throwable th9) {
                        th = th9;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            } catch (Throwable th10) {
                Throwable th11 = th10;
                Binder.restoreCallingIdentity(callingId);
                throw th11;
            }
        } else {
            throw new SecurityException("Neither user " + callingUid + " nor current process has android.permission.INSTALL_PACKAGES.");
        }
    }

    public /* synthetic */ void lambda$installExistingPackageAsUser$10$PackageManagerService(PackageInstalledInfo res, IntentSender intentSender) {
        onRestoreComplete(res.returnCode, this.mContext, intentSender);
    }

    static void onRestoreComplete(int returnCode, Context context, IntentSender target) {
        Intent fillIn = new Intent();
        fillIn.putExtra("android.content.pm.extra.STATUS", PackageManager.installStatusToPublicStatus(returnCode));
        try {
            target.sendIntent(context, 0, fillIn, null, null);
        } catch (IntentSender.SendIntentException e) {
        }
    }

    static void setInstantAppForUser(PackageSetting pkgSetting, int userId, boolean instantApp, boolean fullApp) {
        if (!(instantApp || fullApp)) {
            return;
        }
        if (userId == -1) {
            int[] userIds = sUserManager.getUserIds();
            for (int currentUserId : userIds) {
                if (instantApp && !pkgSetting.getInstantApp(currentUserId)) {
                    pkgSetting.setInstantApp(true, currentUserId);
                } else if (fullApp && pkgSetting.getInstantApp(currentUserId)) {
                    pkgSetting.setInstantApp(false, currentUserId);
                }
            }
        } else if (instantApp && !pkgSetting.getInstantApp(userId)) {
            pkgSetting.setInstantApp(true, userId);
        } else if (fullApp && pkgSetting.getInstantApp(userId)) {
            pkgSetting.setInstantApp(false, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isUserRestricted(int userId, String restrictionKey) {
        if (!sUserManager.getUserRestrictions(userId).getBoolean(restrictionKey, false)) {
            return false;
        }
        Log.w(TAG, "User is restricted: " + restrictionKey);
        return true;
    }

    public String[] setDistractingPackageRestrictionsAsUser(String[] packageNames, int restrictionFlags, int userId) {
        boolean[] canRestrict;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "setDistractingPackageRestrictionsAsUser");
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000 || UserHandle.getUserId(callingUid) == userId) {
            Preconditions.checkNotNull(packageNames, "packageNames cannot be null");
            List<String> changedPackagesList = new ArrayList<>(packageNames.length);
            IntArray changedUids = new IntArray(packageNames.length);
            List<String> unactionedPackages = new ArrayList<>(packageNames.length);
            if (restrictionFlags != 0) {
                canRestrict = canSuspendPackageForUserInternal(packageNames, userId);
            } else {
                canRestrict = null;
            }
            for (int i = 0; i < packageNames.length; i++) {
                String packageName = packageNames[i];
                synchronized (this.mPackages) {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting != null) {
                        if (!filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                            if (canRestrict == null || canRestrict[i]) {
                                synchronized (this.mPackages) {
                                    if (restrictionFlags != pkgSetting.getDistractionFlags(userId)) {
                                        pkgSetting.setDistractionFlags(restrictionFlags, userId);
                                        changedPackagesList.add(packageName);
                                        changedUids.add(UserHandle.getUid(userId, pkgSetting.appId));
                                    }
                                }
                            } else {
                                unactionedPackages.add(packageName);
                            }
                        }
                    }
                    Slog.w(TAG, "Could not find package setting for package: " + packageName + ". Skipping...");
                    unactionedPackages.add(packageName);
                }
            }
            if (!changedPackagesList.isEmpty()) {
                sendDistractingPackagesChanged((String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]), changedUids.toArray(), userId, restrictionFlags);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(userId);
                }
            }
            return (String[]) unactionedPackages.toArray(new String[0]);
        }
        throw new SecurityException("Calling uid " + callingUid + " cannot call for user " + userId);
    }

    private void enforceCanSetPackagesSuspendedAsUser(String callingPackage, int callingUid, int userId, String callingMethod) {
        if (callingUid != 0 && callingUid != 1000) {
            String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(userId);
            boolean allowedShell = false;
            if (ownerPackage == null) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", callingMethod);
                int packageUid = getPackageUid(callingPackage, 0, userId);
                boolean allowedPackageUid = packageUid == callingUid;
                if (callingUid == 2000 && UserHandle.isSameApp(packageUid, callingUid)) {
                    allowedShell = true;
                }
                if (!allowedShell && !allowedPackageUid) {
                    throw new SecurityException("Calling package " + callingPackage + " in user " + userId + " does not belong to calling uid " + callingUid);
                }
            } else if (getPackageUid(ownerPackage, 0, userId) != callingUid) {
                throw new UnsupportedOperationException("Cannot suspend/unsuspend packages. User " + userId + " has an active DO or PO");
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:26:0x009c, code lost:
        if (r0 == null) goto L_0x00ab;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x00a0, code lost:
        if (r0[r14] != false) goto L_0x00ab;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x00a2, code lost:
        r15.add(r13);
        r18 = r3;
        r19 = r14;
        r8 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x00ab, code lost:
        r11 = r20.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x00ad, code lost:
        monitor-enter(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x00ae, code lost:
        r18 = r3;
        r19 = r14;
        r8 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:?, code lost:
        r0.setSuspended(r22, r26, r25, r23, r24, r27);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x00c7, code lost:
        monitor-exit(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:0x00c8, code lost:
        r0.add(r13);
        r0.add(android.os.UserHandle.getUid(r27, r0.appId));
     */
    public String[] setPackagesSuspendedAsUser(String[] packageNames, boolean suspended, PersistableBundle appExtras, PersistableBundle launcherExtras, SuspendDialogInfo dialogInfo, String callingPackage, int userId) {
        boolean[] canSuspend;
        int i;
        int callingUid;
        List<String> unactionedPackages;
        String packageName;
        String[] strArr = packageNames;
        String str = callingPackage;
        int callingUid2 = Binder.getCallingUid();
        enforceCanSetPackagesSuspendedAsUser(str, callingUid2, userId, "setPackagesSuspendedAsUser");
        if (ArrayUtils.isEmpty(packageNames)) {
            return strArr;
        }
        List<String> changedPackagesList = new ArrayList<>(strArr.length);
        IntArray changedUids = new IntArray(strArr.length);
        List<String> unactionedPackages2 = new ArrayList<>(strArr.length);
        if (suspended) {
            canSuspend = canSuspendPackageForUserInternal(strArr, userId);
        } else {
            canSuspend = null;
        }
        int i2 = 0;
        while (i2 < strArr.length) {
            String packageName2 = strArr[i2];
            if (str.equals(packageName2)) {
                StringBuilder sb = new StringBuilder();
                sb.append("Calling package: ");
                sb.append(str);
                sb.append(" trying to ");
                sb.append(suspended ? "" : "un");
                sb.append("suspend itself. Ignoring");
                Slog.w(TAG, sb.toString());
                unactionedPackages2.add(packageName2);
                callingUid = callingUid2;
                i = i2;
                unactionedPackages = unactionedPackages2;
            } else {
                synchronized (this.mPackages) {
                    try {
                        PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName2);
                        if (pkgSetting == null) {
                            callingUid = callingUid2;
                            packageName = packageName2;
                            i = i2;
                            unactionedPackages = unactionedPackages2;
                        } else if (filterAppAccessLPr(pkgSetting, callingUid2, userId)) {
                            callingUid = callingUid2;
                            packageName = packageName2;
                            i = i2;
                            unactionedPackages = unactionedPackages2;
                        }
                        Slog.w(TAG, "Could not find package setting for package: " + packageName + ". Skipping suspending/un-suspending.");
                        unactionedPackages.add(packageName);
                    } catch (Throwable th) {
                        th = th;
                        throw th;
                    }
                }
            }
            i2 = i + 1;
            str = callingPackage;
            unactionedPackages2 = unactionedPackages;
            callingUid2 = callingUid;
            strArr = packageNames;
        }
        if (!changedPackagesList.isEmpty()) {
            String[] changedPackages = (String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]);
            sendPackagesSuspendedForUser(changedPackages, changedUids.toArray(), userId, suspended, launcherExtras);
            sendMyPackageSuspendedOrUnsuspended(changedPackages, suspended, appExtras, userId);
            synchronized (this.mPackages) {
                scheduleWritePackageRestrictionsLocked(userId);
            }
        }
        return (String[]) unactionedPackages2.toArray(new String[unactionedPackages2.size()]);
    }

    public PersistableBundle getSuspendedPackageAppExtras(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getPackageUid(packageName, 0, userId) == callingUid) {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new IllegalArgumentException("Unknown target package: " + packageName);
                }
                PackageUserState packageUserState = ps.readUserState(userId);
                if (!packageUserState.suspended) {
                    return null;
                }
                return packageUserState.suspendedAppExtras;
            }
        }
        throw new SecurityException("Calling package " + packageName + " does not belong to calling uid " + callingUid);
    }

    private void sendMyPackageSuspendedOrUnsuspended(String[] affectedPackages, boolean suspended, PersistableBundle appExtras, int userId) {
        String action;
        Bundle intentExtras = new Bundle();
        if (suspended) {
            if (appExtras != null) {
                intentExtras.putBundle("android.intent.extra.SUSPENDED_PACKAGE_EXTRAS", new Bundle(appExtras.deepCopy()));
            }
            action = "android.intent.action.MY_PACKAGE_SUSPENDED";
        } else {
            action = "android.intent.action.MY_PACKAGE_UNSUSPENDED";
        }
        this.mHandler.post(new Runnable(suspended, userId, affectedPackages, action, intentExtras) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$DDEdx4T7lBdRoOE_C9OxDTETyB0 */
            private final /* synthetic */ boolean f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ String[] f$3;
            private final /* synthetic */ String f$4;
            private final /* synthetic */ Bundle f$5;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$sendMyPackageSuspendedOrUnsuspended$11$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5);
            }
        });
    }

    public /* synthetic */ void lambda$sendMyPackageSuspendedOrUnsuspended$11$PackageManagerService(boolean suspended, int userId, String[] affectedPackages, String action, Bundle intentExtras) {
        try {
            IActivityManager am = ActivityManager.getService();
            if (am == null) {
                StringBuilder sb = new StringBuilder();
                sb.append("IActivityManager null. Cannot send MY_PACKAGE_ ");
                sb.append(suspended ? "" : "UN");
                sb.append("SUSPENDED broadcasts");
                Slog.wtf(TAG, sb.toString());
                return;
            }
            int[] targetUserIds = {userId};
            for (String packageName : affectedPackages) {
                doSendBroadcast(am, action, null, intentExtras, DumpState.DUMP_SERVICE_PERMISSIONS, packageName, null, targetUserIds, false);
            }
        } catch (RemoteException e) {
        }
    }

    public boolean isPackageSuspendedForUser(String packageName, int userId) {
        boolean suspended;
        int callingUid = Binder.getCallingUid();
        PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
        permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, false, "isPackageSuspendedForUser for user " + userId);
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                throw new IllegalArgumentException("Unknown target package: " + packageName);
            }
            suspended = ps.getSuspended(userId);
        }
        return suspended;
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForSuspendingPackage(String packageName, int affectedUser) {
        int[] userIds = affectedUser == -1 ? sUserManager.getUserIds() : new int[]{affectedUser};
        for (int userId : userIds) {
            Objects.requireNonNull(packageName);
            unsuspendForSuspendingPackages(new Predicate(packageName) {
                /* class com.android.server.pm.$$Lambda$S4BXTl5Ly3EHhXAReFCtlz2B8eo */
                private final /* synthetic */ String f$0;

                {
                    this.f$0 = r1;
                }

                @Override // java.util.function.Predicate
                public final boolean test(Object obj) {
                    return this.f$0.equals((String) obj);
                }
            }, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForNonSystemSuspendingPackages(ArraySet<Integer> userIds) {
        int sz = userIds.size();
        for (int i = 0; i < sz; i++) {
            unsuspendForSuspendingPackages($$Lambda$PackageManagerService$5hSpumAE5maEOgUlkeKZ3EJQUOU.INSTANCE, userIds.valueAt(i).intValue());
        }
    }

    static /* synthetic */ boolean lambda$unsuspendForNonSystemSuspendingPackages$12(String suspendingPackage) {
        return !PLATFORM_PACKAGE_NAME.equals(suspendingPackage);
    }

    private void unsuspendForSuspendingPackages(Predicate<String> packagePredicate, int userId) {
        List<String> affectedPackages = new ArrayList<>();
        IntArray affectedUids = new IntArray();
        synchronized (this.mPackages) {
            for (PackageSetting ps : this.mSettings.mPackages.values()) {
                PackageUserState pus = ps.readUserState(userId);
                if (pus.suspended && packagePredicate.test(pus.suspendingPackage)) {
                    ps.setSuspended(false, null, null, null, null, userId);
                    affectedPackages.add(ps.name);
                    affectedUids.add(UserHandle.getUid(userId, ps.getAppId()));
                }
            }
        }
        if (!affectedPackages.isEmpty()) {
            String[] packageArray = (String[]) affectedPackages.toArray(new String[affectedPackages.size()]);
            sendMyPackageSuspendedOrUnsuspended(packageArray, false, null, userId);
            sendPackagesSuspendedForUser(packageArray, affectedUids.toArray(), userId, false, null);
            this.mSettings.writePackageRestrictionsLPr(userId);
        }
    }

    public String[] getUnsuspendablePackagesForUser(String[] packageNames, int userId) {
        Preconditions.checkNotNull("packageNames cannot be null", packageNames);
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "getUnsuspendablePackagesForUser");
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) == userId) {
            ArraySet<String> unactionablePackages = new ArraySet<>();
            boolean[] canSuspend = canSuspendPackageForUserInternal(packageNames, userId);
            for (int i = 0; i < packageNames.length; i++) {
                if (!canSuspend[i]) {
                    unactionablePackages.add(packageNames[i]);
                }
            }
            return (String[]) unactionablePackages.toArray(new String[unactionablePackages.size()]);
        }
        throw new SecurityException("Calling uid " + callingUid + " cannot query getUnsuspendablePackagesForUser for user " + userId);
    }

    private boolean[] canSuspendPackageForUserInternal(String[] packageNames, int userId) {
        boolean[] canSuspend = new boolean[packageNames.length];
        long callingId = Binder.clearCallingIdentity();
        try {
            String activeLauncherPackageName = getActiveLauncherPackageName(userId);
            String dialerPackageName = getDefaultDialerPackageName(userId);
            for (int i = 0; i < packageNames.length; i++) {
                canSuspend[i] = false;
                String packageName = packageNames[i];
                if (isPackageDeviceAdmin(packageName, userId)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": has an active device admin");
                } else if (packageName.equals(activeLauncherPackageName)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": contains the active launcher");
                } else if (packageName.equals(this.mRequiredInstallerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package installation");
                } else if (packageName.equals(this.mRequiredUninstallerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package uninstallation");
                } else if (packageName.equals(this.mRequiredVerifierPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package verification");
                } else if (packageName.equals(dialerPackageName)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": is the default dialer");
                } else if (packageName.equals(this.mRequiredPermissionControllerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for permissions management");
                } else {
                    synchronized (this.mPackages) {
                        if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": protected package");
                        } else {
                            PackageParser.Package pkg = this.mPackages.get(packageName);
                            if (pkg != null && pkg.applicationInfo.isStaticSharedLibrary()) {
                                Slog.w(TAG, "Cannot suspend package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                            } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                                Slog.w(TAG, "Cannot suspend the platform package: " + packageName);
                            } else {
                                canSuspend[i] = true;
                            }
                        }
                    }
                }
            }
            return canSuspend;
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private String getActiveLauncherPackageName(int userId) {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        ResolveInfo resolveInfo = resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 65536, userId);
        if (resolveInfo == null) {
            return null;
        }
        return resolveInfo.activityInfo.packageName;
    }

    private String getDefaultDialerPackageName(int userId) {
        PackageManagerInternal.DefaultDialerProvider provider;
        synchronized (this.mPackages) {
            provider = this.mDefaultDialerProvider;
        }
        if (provider != null) {
            return provider.getDefaultDialer(userId);
        }
        Slog.e(TAG, "mDefaultDialerProvider is null");
        return null;
    }

    public void verifyPendingInstall(int id, int verificationCode) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(15);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCode, Binder.getCallingUid());
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can extend verification timeouts");
        PackageVerificationState state = this.mPendingVerification.get(id);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCodeAtTimeout, Binder.getCallingUid());
        if (millisecondsToDelay > AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT) {
            millisecondsToDelay = AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT;
        }
        if (millisecondsToDelay < 0) {
            millisecondsToDelay = 0;
        }
        if (!(verificationCodeAtTimeout == 1 || verificationCodeAtTimeout == -1)) {
        }
        if (state != null && !state.timeoutExtended()) {
            state.extendTimeout();
            Message msg = this.mHandler.obtainMessage(15);
            msg.arg1 = id;
            msg.obj = response;
            this.mHandler.sendMessageDelayed(msg, millisecondsToDelay);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void broadcastPackageVerified(int verificationId, Uri packageUri, int verificationCode, UserHandle user) {
        Intent intent = new Intent("android.intent.action.PACKAGE_VERIFIED");
        intent.setDataAndType(packageUri, PACKAGE_MIME_TYPE);
        intent.addFlags(1);
        intent.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
        intent.putExtra("android.content.pm.extra.VERIFICATION_RESULT", verificationCode);
        this.mContext.sendBroadcastAsUser(intent, user, "android.permission.PACKAGE_VERIFICATION_AGENT");
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ComponentName matchComponentForVerifier(String packageName, List<ResolveInfo> receivers) {
        if (packageName == null) {
            return null;
        }
        ActivityInfo targetReceiver = null;
        int NR = receivers.size();
        int i = 0;
        while (true) {
            if (i >= NR) {
                break;
            }
            ResolveInfo info = receivers.get(i);
            if (info.activityInfo != null && packageName.equals(info.activityInfo.packageName)) {
                targetReceiver = info.activityInfo;
                break;
            }
            i++;
        }
        if (targetReceiver == null) {
            return null;
        }
        return new ComponentName(targetReceiver.packageName, targetReceiver.name);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private List<ComponentName> matchVerifiers(PackageInfoLite pkgInfo, List<ResolveInfo> receivers, PackageVerificationState verificationState) {
        int verifierUid;
        if (pkgInfo.verifiers.length == 0) {
            return null;
        }
        int N = pkgInfo.verifiers.length;
        List<ComponentName> sufficientVerifiers = new ArrayList<>(N + 1);
        for (int i = 0; i < N; i++) {
            VerifierInfo verifierInfo = pkgInfo.verifiers[i];
            ComponentName comp = matchComponentForVerifier(verifierInfo.packageName, receivers);
            if (!(comp == null || (verifierUid = getUidForVerifier(verifierInfo)) == -1)) {
                if (DEBUG_VERIFY) {
                    Slog.d(TAG, "Added sufficient verifier " + verifierInfo.packageName + " with the correct signature");
                }
                sufficientVerifiers.add(comp);
                verificationState.addSufficientVerifier(verifierUid);
            }
        }
        return sufficientVerifiers;
    }

    private int getUidForVerifier(VerifierInfo verifierInfo) {
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(verifierInfo.packageName);
            if (pkg == null) {
                return -1;
            }
            if (pkg.mSigningDetails.signatures.length != 1) {
                Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " has more than one signature; ignoring");
                return -1;
            }
            try {
                if (!Arrays.equals(verifierInfo.publicKey.getEncoded(), pkg.mSigningDetails.signatures[0].getPublicKey().getEncoded())) {
                    Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " does not have the expected public key; ignoring");
                    return -1;
                }
                return pkg.applicationInfo.uid;
            } catch (CertificateException e) {
                return -1;
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void setEnableRollbackCode(int token, int enableRollbackCode) {
        Message msg = this.mHandler.obtainMessage(21);
        msg.arg1 = token;
        msg.arg2 = enableRollbackCode;
        this.mHandler.sendMessage(msg);
    }

    public void finishPackageInstall(int token, boolean didLaunch) {
        enforceSystemOrRoot("Only the system is allowed to finish installs");
        if (DEBUG_INSTALL) {
            Slog.v(TAG, "BM finishing package install for " + token);
        }
        Trace.asyncTraceEnd(262144, "restore", token);
        this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, didLaunch ? 1 : 0));
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private long getVerificationTimeout() {
        return Settings.Global.getLong(this.mContext.getContentResolver(), "verifier_timeout", 10000);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private int getDefaultVerificationResponse(UserHandle user) {
        if (sUserManager.hasUserRestriction("ensure_verify_apps", user.getIdentifier())) {
            return -1;
        }
        return Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_default_response", 1);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean isVerificationEnabled(int userId, int installFlags, int installerUid) {
        ActivityInfo activityInfo;
        if ((524288 & installFlags) != 0) {
            return false;
        }
        boolean ensureVerifyAppsEnabled = isUserRestricted(userId, "ensure_verify_apps");
        if ((installFlags & 32) != 0) {
            if (ActivityManager.isRunningInTestHarness()) {
                return false;
            }
            if (ensureVerifyAppsEnabled) {
                return true;
            }
            if (Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_verify_adb_installs", 1) == 0) {
                return false;
            }
        } else if (!((installFlags & 2048) == 0 || (activityInfo = this.mInstantAppInstallerActivity) == null || !activityInfo.packageName.equals(this.mRequiredVerifierPackage))) {
            try {
                ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(installerUid, this.mRequiredVerifierPackage);
                if (DEBUG_VERIFY) {
                    Slog.i(TAG, "disable verification for instant app");
                }
                return false;
            } catch (SecurityException e) {
            }
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        if (Settings.Global.getInt(this.mContext.getContentResolver(), "package_verifier_enable", 1) == 1) {
            return true;
        }
        return false;
    }

    public void verifyIntentFilter(int id, int verificationCode, List<String> failedDomains) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", "Only intentfilter verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(18);
        IntentFilterVerificationResponse response = new IntentFilterVerificationResponse(Binder.getCallingUid(), verificationCode, failedDomains);
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public int getIntentVerificationStatus(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) != userId) {
            Context context = this.mContext;
            context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getIntentVerificationStatus" + userId);
        }
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                }
            }
            return 0;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x002f, code lost:
        if (r3 == false) goto L_0x0034;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0031, code lost:
        scheduleWritePackageRestrictionsLocked(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x0034, code lost:
        return r3;
     */
    public boolean updateIntentVerificationStatus(String packageName, int status, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            boolean result = this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, status, userId);
        }
    }

    public ParceledListSlice<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                return ParceledListSlice.emptyList();
            }
            return new ParceledListSlice<>(this.mSettings.getIntentFilterVerificationsLPr(packageName));
        }
    }

    public ParceledListSlice<IntentFilter> getAllIntentFilters(String packageName) {
        if (TextUtils.isEmpty(packageName)) {
            return ParceledListSlice.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg != null) {
                if (pkg.activities != null) {
                    if (pkg.mExtras == null) {
                        return ParceledListSlice.emptyList();
                    } else if (filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                        return ParceledListSlice.emptyList();
                    } else {
                        int count = pkg.activities.size();
                        ArrayList<IntentFilter> result = new ArrayList<>();
                        for (int n = 0; n < count; n++) {
                            PackageParser.Activity activity = (PackageParser.Activity) pkg.activities.get(n);
                            if (activity.intents != null && activity.intents.size() > 0) {
                                result.addAll(activity.intents);
                            }
                        }
                        return new ParceledListSlice<>(result);
                    }
                }
            }
            return ParceledListSlice.emptyList();
        }
    }

    public boolean setDefaultBrowserPackageName(String packageName, int userId) {
        PackageManagerInternal.DefaultBrowserProvider provider;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (userId == -1) {
            return false;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultBrowserProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "mDefaultBrowserProvider is null");
            return false;
        } else if (!provider.setDefaultBrowser(packageName, userId)) {
            return false;
        } else {
            if (packageName == null) {
                return true;
            }
            synchronized (this.mPackages) {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
            }
            return true;
        }
    }

    private void setDefaultBrowserAsyncLPw(String packageName, int userId) {
        if (userId != -1) {
            PackageManagerInternal.DefaultBrowserProvider defaultBrowserProvider = this.mDefaultBrowserProvider;
            if (defaultBrowserProvider == null) {
                Slog.e(TAG, "mDefaultBrowserProvider is null");
                return;
            }
            defaultBrowserProvider.setDefaultBrowserAsync(packageName, userId);
            if (packageName != null) {
                synchronized (this.mPackages) {
                    this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
                }
            }
        }
    }

    public String getDefaultBrowserPackageName(int userId) {
        PackageManagerInternal.DefaultBrowserProvider provider;
        if (!OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).shouldSkipPermissionCheck() && UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultBrowserProvider;
        }
        if (provider != null) {
            return provider.getDefaultBrowser(userId);
        }
        Slog.e(TAG, "mDefaultBrowserProvider is null");
        return null;
    }

    private int getUnknownSourcesSettings() {
        return Settings.Secure.getInt(this.mContext.getContentResolver(), "install_non_market_apps", -1);
    }

    public void setInstallerPackageName(String targetPackage, String installerPackageName) {
        PackageSetting installerPackageSetting;
        Signature[] callerSignature;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                PackageSetting targetPackageSetting = this.mSettings.mPackages.get(targetPackage);
                if (targetPackageSetting == null || filterAppAccessLPr(targetPackageSetting, callingUid, UserHandle.getUserId(callingUid))) {
                    throw new IllegalArgumentException("Unknown target package: " + targetPackage);
                }
                PackageSetting targetInstallerPkgSetting = null;
                if (installerPackageName != null) {
                    installerPackageSetting = this.mSettings.mPackages.get(installerPackageName);
                    if (installerPackageSetting == null) {
                        throw new IllegalArgumentException("Unknown installer package: " + installerPackageName);
                    }
                } else {
                    installerPackageSetting = null;
                }
                Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(callingUid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        callerSignature = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
                    } else if (obj instanceof PackageSetting) {
                        callerSignature = ((PackageSetting) obj).signatures.mSigningDetails.signatures;
                    } else {
                        throw new SecurityException("Bad object " + obj + " for uid " + callingUid);
                    }
                    if (installerPackageSetting != null) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, installerPackageSetting.signatures.mSigningDetails.signatures) != 0) {
                            throw new SecurityException("Caller does not have same cert as new installer package " + installerPackageName);
                        }
                    }
                    String targetInstallerPackageName = targetPackageSetting.installerPackageName;
                    if (targetInstallerPackageName != null) {
                        targetInstallerPkgSetting = this.mSettings.mPackages.get(targetInstallerPackageName);
                    }
                    if (targetInstallerPkgSetting != null) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, targetInstallerPkgSetting.signatures.mSigningDetails.signatures) != 0) {
                            throw new SecurityException("Caller does not have same cert as old installer package " + targetInstallerPackageName);
                        }
                    } else if (this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") != 0) {
                        EventLog.writeEvent(1397638484, "150857253", Integer.valueOf(callingUid), "");
                        if (getUidTargetSdkVersionLockedLPr(callingUid) > 29) {
                            throw new SecurityException("Neither user " + callingUid + " nor current process has android.permission.INSTALL_PACKAGES");
                        }
                        return;
                    }
                    targetPackageSetting.installerPackageName = installerPackageName;
                    if (installerPackageName != null) {
                        this.mSettings.mInstallerPackages.add(installerPackageName);
                    }
                    scheduleWriteSettingsLocked();
                    return;
                }
                throw new SecurityException("Unknown calling UID: " + callingUid);
            }
        }
    }

    public void setApplicationCategoryHint(String packageName, int categoryHint, String callerPackageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(Binder.getCallingUid(), callerPackageName);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (filterAppAccessLPr(ps, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (!Objects.equals(callerPackageName, ps.installerPackageName)) {
                    throw new IllegalArgumentException("Calling package " + callerPackageName + " is not installer for " + packageName);
                } else if (ps.categoryHint != categoryHint) {
                    ps.categoryHint = categoryHint;
                    scheduleWriteSettingsLocked();
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void processPendingInstall(InstallArgs args, int currentStatus) {
        if (args.mMultiPackageInstallParams != null) {
            args.mMultiPackageInstallParams.tryProcessInstallRequest(args, currentStatus);
            return;
        }
        PackageInstalledInfo res = createPackageInstalledInfo(currentStatus);
        boolean z = true;
        if (res.returnCode != 1) {
            z = false;
        }
        processInstallRequestsAsync(z, Collections.singletonList(new InstallRequest(args, res)));
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void processInstallRequestsAsync(boolean success, List<InstallRequest> installRequests) {
        this.mHandler.post(new Runnable(success, installRequests) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$S4WxZjKnT0iu1kmEXSrs7BiizN4 */
            private final /* synthetic */ boolean f$1;
            private final /* synthetic */ List f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.this.lambda$processInstallRequestsAsync$13$PackageManagerService(this.f$1, this.f$2);
            }
        });
    }

    public /* synthetic */ void lambda$processInstallRequestsAsync$13$PackageManagerService(boolean success, List installRequests) {
        if (success) {
            Iterator it = installRequests.iterator();
            while (it.hasNext()) {
                InstallRequest request = (InstallRequest) it.next();
                request.args.doPreInstall(request.installResult.returnCode);
            }
            synchronized (this.mInstallLock) {
                installPackagesTracedLI(installRequests);
            }
            Iterator it2 = installRequests.iterator();
            while (it2.hasNext()) {
                InstallRequest request2 = (InstallRequest) it2.next();
                request2.args.doPostInstall(request2.installResult.returnCode, request2.installResult.uid);
                if (mColorPmsEx != null) {
                    mColorPmsEx.sendUpdateExtraAppInfoMessage(request2.installResult, request2.args.installArgsEx, request2.args, this.mHandler);
                }
            }
        }
        Iterator it3 = installRequests.iterator();
        while (it3.hasNext()) {
            InstallRequest request3 = (InstallRequest) it3.next();
            restoreAndPostInstall(request3.args.user.getIdentifier(), request3.installResult, new PostInstallData(request3.args, request3.installResult, null));
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private PackageInstalledInfo createPackageInstalledInfo(int currentStatus) {
        PackageInstalledInfo res = new PackageInstalledInfo();
        res.setReturnCode(currentStatus);
        res.uid = -1;
        res.pkg = null;
        res.removedInfo = null;
        return res;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:82:0x017a, code lost:
        r5 = 262144;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:?, code lost:
        r19.snapshotAndRestoreUserData(r12, r0, r21, r22, r11, r9);
     */
    /* JADX WARNING: Removed duplicated region for block: B:107:? A[RETURN, SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:99:0x01bd  */
    private void restoreAndPostInstall(int userId, PackageInstalledInfo res, PostInstallData data) {
        int userId2;
        long j;
        Throwable th;
        long ceDataInode;
        int appId;
        int userId3;
        if (DEBUG_INSTALL) {
            StringBuilder sb = new StringBuilder();
            sb.append("restoreAndPostInstall userId=");
            sb.append(userId);
            sb.append(" package=");
            sb.append(res.pkg != null ? res.pkg.packageName : null);
            Log.v(TAG, sb.toString());
        }
        if (!(res == null || data == null)) {
            OidtPackageManagerHelper.getInstance().detectInstallForOIDT(this.mContext, res, data.args);
        }
        boolean update = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
        boolean doRestore = !update && (32768 & (res.pkg == null ? 0 : res.pkg.applicationInfo.flags)) != 0;
        if (this.mNextInstallToken < 0) {
            this.mNextInstallToken = 1;
        }
        int token = this.mNextInstallToken;
        this.mNextInstallToken = token + 1;
        if (data != null) {
            this.mRunningInstalls.put(token, data);
        } else if (DEBUG_INSTALL) {
            Log.v(TAG, "No post-install required for " + token);
        }
        if (DEBUG_INSTALL) {
            Log.v(TAG, "+ starting restore round-trip " + token);
        }
        if (res.returnCode != 1 || !doRestore) {
            userId2 = userId;
        } else {
            IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD));
            if (bm != null) {
                if (userId == -1) {
                    userId3 = 0;
                } else {
                    userId3 = userId;
                }
                if (DEBUG_INSTALL) {
                    Log.v(TAG, "token " + token + " to BM for possible restore for user " + userId3);
                }
                Trace.asyncTraceBegin(262144, "restore", token);
                try {
                    if (bm.isBackupServiceActive(userId3)) {
                        bm.restoreAtInstallForUser(userId3, res.pkg.applicationInfo.packageName, token);
                    } else {
                        doRestore = false;
                    }
                } catch (RemoteException e) {
                } catch (Exception e2) {
                    Slog.e(TAG, "Exception trying to enqueue restore", e2);
                    doRestore = false;
                }
                userId2 = userId3;
            } else {
                Slog.e(TAG, "Backup Manager not found!");
                doRestore = false;
                userId2 = userId;
            }
        }
        if (res.returnCode != 1 || doRestore || !update) {
            j = 262144;
        } else {
            IRollbackManager rm = IRollbackManager.Stub.asInterface(ServiceManager.getService("rollback"));
            String packageName = res.pkg.applicationInfo.packageName;
            String seInfo = res.pkg.applicationInfo.seInfo;
            int[] allUsers = sUserManager.getUserIds();
            synchronized (this.mSettings) {
                try {
                    PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                    if (ps != null) {
                        try {
                            appId = ps.appId;
                            ceDataInode = ps.getCeDataInode(userId2);
                        } catch (Throwable th2) {
                            th = th2;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                            }
                            throw th;
                        }
                    } else {
                        appId = -1;
                        ceDataInode = -1;
                    }
                    try {
                        int[] installedUsers = ps.queryInstalledUsers(allUsers, true);
                        try {
                        } catch (Throwable th4) {
                            th = th4;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } catch (Throwable th5) {
                        th = th5;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                } catch (Throwable th6) {
                    th = th6;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        }
        if (doRestore) {
            if (DEBUG_INSTALL) {
                Log.v(TAG, "No restore - queue post-install for " + token);
            }
            Trace.asyncTraceBegin(j, "postInstall", token);
            this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, 0));
            return;
        }
        return;
        doRestore = true;
        if (doRestore) {
        }
    }

    /* access modifiers changed from: package-private */
    public void notifyFirstLaunch(String packageName, String installerPackage, int userId) {
        this.mHandler.post(new Runnable(packageName, userId, installerPackage) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$gBfmUwr3vJpLKJEYBEtR1vtJLQ */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ String f$3;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
            }

            public final void run() {
                PackageManagerService.this.lambda$notifyFirstLaunch$14$PackageManagerService(this.f$1, this.f$2, this.f$3);
            }
        });
    }

    public /* synthetic */ void lambda$notifyFirstLaunch$14$PackageManagerService(String packageName, int userId, String installerPackage) {
        for (int i = 0; i < this.mRunningInstalls.size(); i++) {
            PostInstallData data = this.mRunningInstalls.valueAt(i);
            if (data.res.returnCode == 1 && packageName.equals(data.res.pkg.applicationInfo.packageName)) {
                for (int uIndex = 0; uIndex < data.res.newUsers.length; uIndex++) {
                    if (userId == data.res.newUsers[uIndex]) {
                        if (DEBUG_BACKUP) {
                            Slog.i(TAG, "Package " + packageName + " being restored so deferring FIRST_LAUNCH");
                            return;
                        } else {
                            return;
                        }
                    }
                }
                continue;
            }
        }
        if (DEBUG_BACKUP) {
            Slog.i(TAG, "Package " + packageName + " sending normal FIRST_LAUNCH");
        }
        boolean isInstantApp = isInstantApp(packageName, userId);
        sendFirstLaunchBroadcast(packageName, installerPackage, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
    }

    private void sendFirstLaunchBroadcast(String pkgName, String installerPkg, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast("android.intent.action.PACKAGE_FIRST_LAUNCH", pkgName, null, 0, installerPkg, null, userIds, instantUserIds);
    }

    /* access modifiers changed from: private */
    public abstract class HandlerParams {
        private final UserHandle mUser;
        int traceCookie;
        String traceMethod;

        /* access modifiers changed from: package-private */
        public abstract void handleReturnCode();

        /* access modifiers changed from: package-private */
        public abstract void handleStartCopy();

        HandlerParams(UserHandle user) {
            this.mUser = user;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.mUser;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getRollbackUser() {
            if (this.mUser == UserHandle.ALL) {
                return UserHandle.SYSTEM;
            }
            return this.mUser;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceMethod(String traceMethod2) {
            this.traceMethod = traceMethod2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceCookie(int traceCookie2) {
            this.traceCookie = traceCookie2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public final void startCopy() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.i(PackageManagerService.TAG, "startCopy " + this.mUser + ": " + this);
            }
            handleStartCopy();
            handleReturnCode();
        }
    }

    /* access modifiers changed from: package-private */
    public static class OriginInfo {
        final boolean existing;
        final File file;
        final File resolvedFile;
        final String resolvedPath;
        final boolean staged;

        static OriginInfo fromNothing() {
            return new OriginInfo(null, false, false);
        }

        static OriginInfo fromUntrustedFile(File file2) {
            return new OriginInfo(file2, false, false);
        }

        static OriginInfo fromExistingFile(File file2) {
            return new OriginInfo(file2, false, true);
        }

        static OriginInfo fromStagedFile(File file2) {
            return new OriginInfo(file2, true, false);
        }

        private OriginInfo(File file2, boolean staged2, boolean existing2) {
            this.file = file2;
            this.staged = staged2;
            this.existing = existing2;
            if (file2 != null) {
                this.resolvedPath = file2.getAbsolutePath();
                this.resolvedFile = file2;
                return;
            }
            this.resolvedPath = null;
            this.resolvedFile = null;
        }
    }

    /* access modifiers changed from: package-private */
    public static class MoveInfo {
        final int appId;
        final String dataAppName;
        final String fromUuid;
        final int moveId;
        final String packageName;
        final String seinfo;
        final int targetSdkVersion;
        final String toUuid;

        public MoveInfo(int moveId2, String fromUuid2, String toUuid2, String packageName2, String dataAppName2, int appId2, String seinfo2, int targetSdkVersion2) {
            this.moveId = moveId2;
            this.fromUuid = fromUuid2;
            this.toUuid = toUuid2;
            this.packageName = packageName2;
            this.dataAppName = dataAppName2;
            this.appId = appId2;
            this.seinfo = seinfo2;
            this.targetSdkVersion = targetSdkVersion2;
        }
    }

    /* access modifiers changed from: package-private */
    public static class VerificationInfo {
        public static final int NO_UID = -1;
        final int installerUid;
        final int originatingUid;
        final Uri originatingUri;
        final Uri referrer;

        VerificationInfo(Uri originatingUri2, Uri referrer2, int originatingUid2, int installerUid2) {
            this.originatingUri = originatingUri2;
            this.referrer = referrer2;
            this.originatingUid = originatingUid2;
            this.installerUid = installerUid2;
        }
    }

    /* access modifiers changed from: package-private */
    public class MultiPackageInstallParams extends HandlerParams {
        private final ArrayList<InstallParams> mChildParams;
        private final Map<InstallArgs, Integer> mCurrentState;
        private int mRet = 1;

        MultiPackageInstallParams(UserHandle user, List<ActiveInstallSession> activeInstallSessions) throws PackageManagerException {
            super(user);
            if (activeInstallSessions.size() != 0) {
                this.mChildParams = new ArrayList<>(activeInstallSessions.size());
                for (int i = 0; i < activeInstallSessions.size(); i++) {
                    InstallParams childParams = new InstallParams(activeInstallSessions.get(i));
                    childParams.mParentInstallParams = this;
                    this.mChildParams.add(childParams);
                }
                this.mCurrentState = new ArrayMap(this.mChildParams.size());
                return;
            }
            throw new PackageManagerException("No child sessions found!");
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleStartCopy() {
            Iterator<InstallParams> it = this.mChildParams.iterator();
            while (it.hasNext()) {
                InstallParams params = it.next();
                params.handleStartCopy();
                if (params.mRet != 1) {
                    this.mRet = params.mRet;
                }
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleReturnCode() {
            Iterator<InstallParams> it = this.mChildParams.iterator();
            while (it.hasNext()) {
                InstallParams params = it.next();
                params.handleReturnCode();
                if (params.mRet != 1) {
                    this.mRet = params.mRet;
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void tryProcessInstallRequest(InstallArgs args, int currentStatus) {
            boolean z;
            this.mCurrentState.put(args, Integer.valueOf(currentStatus));
            if (this.mCurrentState.size() == this.mChildParams.size()) {
                int completeStatus = 1;
                Iterator<Integer> it = this.mCurrentState.values().iterator();
                while (true) {
                    z = true;
                    if (!it.hasNext()) {
                        break;
                    }
                    Integer status = it.next();
                    if (status.intValue() != 0) {
                        if (status.intValue() != 1) {
                            completeStatus = status.intValue();
                            break;
                        }
                    } else {
                        return;
                    }
                }
                List<InstallRequest> installRequests = new ArrayList<>(this.mCurrentState.size());
                for (Map.Entry<InstallArgs, Integer> entry : this.mCurrentState.entrySet()) {
                    installRequests.add(new InstallRequest(entry.getKey(), PackageManagerService.this.createPackageInstalledInfo(completeStatus)));
                }
                PackageManagerService packageManagerService = PackageManagerService.this;
                if (completeStatus != 1) {
                    z = false;
                }
                packageManagerService.processInstallRequestsAsync(z, installRequests);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public class InstallParams extends HandlerParams {
        final String[] grantedRuntimePermissions;
        int installFlags;
        OppoBasePackageManagerService.InstallParamsEx installParamsEx;
        final int installReason;
        final String installerPackageName;
        private InstallArgs mArgs;
        private boolean mEnableRollbackCompleted;
        MultiPackageInstallParams mParentInstallParams;
        int mRet;
        private boolean mVerificationCompleted;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final String packageAbiOverride;
        final long requiredInstalledVersionCode;
        final PackageParser.SigningDetails signingDetails;
        final VerificationInfo verificationInfo;
        final String volumeUuid;
        final List<String> whitelistedRestrictedPermissions;

        InstallParams(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, VerificationInfo verificationInfo2, UserHandle user, String packageAbiOverride2, String[] grantedPermissions, List<String> whitelistedRestrictedPermissions2, PackageParser.SigningDetails signingDetails2, int installReason2, long requiredInstalledVersionCode2) {
            super(user);
            this.origin = origin2;
            this.move = move2;
            this.observer = observer2;
            this.installFlags = installFlags2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.verificationInfo = verificationInfo2;
            this.packageAbiOverride = packageAbiOverride2;
            this.grantedRuntimePermissions = grantedPermissions;
            this.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions2;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
            this.requiredInstalledVersionCode = requiredInstalledVersionCode2;
        }

        InstallParams(ActiveInstallSession activeInstallSession) {
            super(activeInstallSession.getUser());
            if (PackageManagerService.DEBUG_INSTANT && (activeInstallSession.getSessionParams().installFlags & 2048) != 0) {
                Slog.d(PackageManagerService.TAG, "Ephemeral install of " + activeInstallSession.getPackageName());
            }
            this.verificationInfo = new VerificationInfo(activeInstallSession.getSessionParams().originatingUri, activeInstallSession.getSessionParams().referrerUri, activeInstallSession.getSessionParams().originatingUid, activeInstallSession.getInstallerUid());
            this.origin = OriginInfo.fromStagedFile(activeInstallSession.getStagedDir());
            this.move = null;
            this.installReason = PackageManagerService.this.fixUpInstallReason(activeInstallSession.getInstallerPackageName(), activeInstallSession.getInstallerUid(), activeInstallSession.getSessionParams().installReason);
            this.observer = activeInstallSession.getObserver();
            this.installFlags = activeInstallSession.getSessionParams().installFlags;
            this.installerPackageName = activeInstallSession.getInstallerPackageName();
            this.volumeUuid = activeInstallSession.getSessionParams().volumeUuid;
            this.packageAbiOverride = activeInstallSession.getSessionParams().abiOverride;
            this.grantedRuntimePermissions = activeInstallSession.getSessionParams().grantedRuntimePermissions;
            this.whitelistedRestrictedPermissions = activeInstallSession.getSessionParams().whitelistedRestrictedPermissions;
            this.signingDetails = activeInstallSession.getSigningDetails();
            this.requiredInstalledVersionCode = activeInstallSession.getSessionParams().requiredInstalledVersionCode;
        }

        public String toString() {
            return "InstallParams{" + Integer.toHexString(System.identityHashCode(this)) + " file=" + this.origin.file + "}";
        }

        private int installLocationPolicy(PackageInfoLite pkgLite) {
            PackageSetting ps;
            String packageName = pkgLite.packageName;
            int installLocation = pkgLite.installLocation;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package installedPkg = PackageManagerService.this.mPackages.get(packageName);
                PackageParser.Package dataOwnerPkg = installedPkg;
                if (dataOwnerPkg == null && (ps = PackageManagerService.this.mSettings.mPackages.get(packageName)) != null) {
                    dataOwnerPkg = ps.pkg;
                }
                if (this.requiredInstalledVersionCode != -1) {
                    if (dataOwnerPkg == null) {
                        Slog.w(PackageManagerService.TAG, "Required installed version code was " + this.requiredInstalledVersionCode + " but package is not installed");
                        return -8;
                    } else if (dataOwnerPkg.getLongVersionCode() != this.requiredInstalledVersionCode) {
                        Slog.w(PackageManagerService.TAG, "Required installed version code was " + this.requiredInstalledVersionCode + " but actual installed version is " + dataOwnerPkg.getLongVersionCode());
                        return -8;
                    }
                }
                if (dataOwnerPkg != null && !PackageManagerServiceUtils.isDowngradePermitted(this.installFlags, dataOwnerPkg.applicationInfo.flags)) {
                    try {
                        PackageManagerService.checkDowngrade(dataOwnerPkg, pkgLite);
                    } catch (PackageManagerException e) {
                        Slog.w(PackageManagerService.TAG, "Downgrade detected: " + e.getMessage());
                        return -7;
                    }
                }
                if (installedPkg != null) {
                    if ((this.installFlags & 2) == 0) {
                        return -4;
                    }
                    if ((installedPkg.applicationInfo.flags & 1) != 0) {
                        return 1;
                    }
                    if (installLocation == 1) {
                        return 1;
                    }
                    if (installLocation != 2) {
                        if (PackageManagerService.isExternal(installedPkg)) {
                            return 2;
                        }
                        return 1;
                    }
                }
                return pkgLite.recommendedInstallLocation;
            }
        }

        /* JADX WARNING: Removed duplicated region for block: B:130:0x0391  */
        /* JADX WARNING: Removed duplicated region for block: B:142:0x042e  */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleStartCopy() {
            int i;
            UserHandle verifierUser;
            int requiredUid;
            int[] installedUsers;
            int ret;
            int ret2 = 1;
            if (this.origin.staged) {
                if (this.origin.file != null) {
                    this.installFlags |= 16;
                } else {
                    throw new IllegalStateException("Invalid stage location");
                }
            }
            boolean onInt = (this.installFlags & 16) != 0;
            boolean ephemeral = (this.installFlags & 2048) != 0;
            PackageInfoLite pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(PackageManagerService.this.mContext, this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
            if (PackageManagerService.DEBUG_INSTANT && ephemeral) {
                Slog.v(PackageManagerService.TAG, "pkgLite for install: " + pkgLite);
            }
            if (!this.origin.staged && pkgLite.recommendedInstallLocation == -1) {
                long lowThreshold = StorageManager.from(PackageManagerService.this.mContext).getStorageLowBytes(Environment.getDataDirectory());
                long sizeBytes = PackageManagerServiceUtils.calculateInstalledSize(this.origin.resolvedPath, this.packageAbiOverride);
                if (sizeBytes >= 0) {
                    try {
                        PackageManagerService.this.mInstaller.freeCache(null, sizeBytes + lowThreshold, 0, 0);
                        pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(PackageManagerService.this.mContext, this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, "Failed to free cache", e);
                    }
                }
                if (pkgLite.recommendedInstallLocation == -6) {
                    pkgLite.recommendedInstallLocation = -1;
                }
            }
            if (OppoFeatureCache.get(IColorAppInstallProgressManager.DEFAULT).tryRetstrictPackgeInstall(this.installerPackageName, pkgLite, this.observer) == -111) {
                this.mRet = -111;
                return;
            }
            if (1 == 1) {
                int loc = pkgLite.recommendedInstallLocation;
                if (loc == -3) {
                    ret2 = -19;
                } else if (loc == -4) {
                    ret2 = -1;
                } else if (loc == -1) {
                    ret2 = -4;
                } else if (loc == -2) {
                    ret2 = -2;
                } else if (loc == -6) {
                    ret2 = -3;
                } else if (loc == -5) {
                    ret2 = -20;
                } else {
                    this.installFlags = PackageManagerService.sPmsExt.customizeInstallPkgFlags(this.installFlags, pkgLite, PackageManagerService.this.mSettings.mPackages, getUser());
                    int loc2 = installLocationPolicy(pkgLite);
                    if (loc2 == -7) {
                        ret2 = -25;
                    } else if (loc2 == -8) {
                        ret2 = -121;
                    } else if (!onInt) {
                        if (loc2 == 2) {
                            this.installFlags &= -17;
                        } else if (loc2 == 3) {
                            if (PackageManagerService.DEBUG_INSTANT) {
                                Slog.v(PackageManagerService.TAG, "...setting INSTALL_EPHEMERAL install flag");
                            }
                            this.installFlags |= 2048;
                            this.installFlags &= -17;
                        } else {
                            this.installFlags |= 16;
                        }
                    }
                }
            }
            InstallArgs args = PackageManagerService.this.createInstallArgs(this);
            args.abiOverride = PackageManagerService.mCompatibilityHelper.abiOverride(args.abiOverride, pkgLite.packageName);
            args.installArgsEx = OppoBasePackageManagerService.InstallArgsEx.initInstallArgsEx(this.installParamsEx);
            args.installArgsEx.packageName = pkgLite.packageName;
            this.mVerificationCompleted = true;
            this.mEnableRollbackCompleted = true;
            this.mArgs = args;
            if (ret2 == 1) {
                UserHandle verifierUser2 = getUser();
                if (verifierUser2 == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                } else {
                    verifierUser = verifierUser2;
                }
                if (PackageManagerService.this.mRequiredVerifierPackage == null) {
                    requiredUid = -1;
                } else {
                    PackageManagerService packageManagerService = PackageManagerService.this;
                    requiredUid = packageManagerService.getPackageUid(packageManagerService.mRequiredVerifierPackage, 268435456, verifierUser.getIdentifier());
                }
                VerificationInfo verificationInfo2 = this.verificationInfo;
                int installerUid = verificationInfo2 == null ? -1 : verificationInfo2.installerUid;
                if (this.origin.existing || requiredUid == -1) {
                    ret = ret2;
                } else if (PackageManagerService.this.isVerificationEnabled(verifierUser.getIdentifier(), this.installFlags, installerUid)) {
                    Intent verification = new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                    verification.addFlags(268435456);
                    verification.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                    verification.addFlags(1);
                    List<ResolveInfo> receivers = PackageManagerService.this.queryIntentReceiversInternal(verification, PackageManagerService.PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false);
                    if (PackageManagerService.DEBUG_VERIFY) {
                        Slog.d(PackageManagerService.TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers");
                    }
                    final int verificationId = PackageManagerService.access$4008(PackageManagerService.this);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_PACKAGE", this.installerPackageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALL_FLAGS", this.installFlags);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_PACKAGE_NAME", pkgLite.packageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_VERSION_CODE", pkgLite.versionCode);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_LONG_VERSION_CODE", pkgLite.getLongVersionCode());
                    VerificationInfo verificationInfo3 = this.verificationInfo;
                    if (verificationInfo3 != null) {
                        if (verificationInfo3.originatingUri != null) {
                            verification.putExtra("android.intent.extra.ORIGINATING_URI", this.verificationInfo.originatingUri);
                        }
                        if (this.verificationInfo.referrer != null) {
                            verification.putExtra("android.intent.extra.REFERRER", this.verificationInfo.referrer);
                        }
                        if (this.verificationInfo.originatingUid >= 0) {
                            verification.putExtra("android.intent.extra.ORIGINATING_UID", this.verificationInfo.originatingUid);
                        }
                        if (this.verificationInfo.installerUid >= 0) {
                            verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_UID", this.verificationInfo.installerUid);
                        }
                    }
                    PackageVerificationState verificationState = new PackageVerificationState(requiredUid, this);
                    PackageManagerService.this.mPendingVerification.append(verificationId, verificationState);
                    List<ComponentName> sufficientVerifiers = PackageManagerService.this.matchVerifiers(pkgLite, receivers, verificationState);
                    DeviceIdleController.LocalService idleController = PackageManagerService.this.getDeviceIdleController();
                    long idleDuration = PackageManagerService.this.getVerificationTimeout();
                    if (sufficientVerifiers != null) {
                        int N = sufficientVerifiers.size();
                        if (N == 0) {
                            Slog.i(PackageManagerService.TAG, "Additional verifiers required, but none installed.");
                            ret2 = -22;
                            PackageManagerService packageManagerService2 = PackageManagerService.this;
                            ComponentName requiredVerifierComponent = packageManagerService2.matchComponentForVerifier(packageManagerService2.mRequiredVerifierPackage, receivers);
                            if (ret2 != 1 && PackageManagerService.this.mRequiredVerifierPackage != null) {
                                Trace.asyncTraceBegin(262144, "verification", verificationId);
                                verification.setComponent(requiredVerifierComponent);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), PackageManagerService.this.mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(verification, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT", new BroadcastReceiver() {
                                    /* class com.android.server.pm.PackageManagerService.InstallParams.AnonymousClass1 */

                                    public void onReceive(Context context, Intent intent) {
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(16);
                                        msg.arg1 = verificationId;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, PackageManagerService.this.getVerificationTimeout());
                                    }
                                }, null, 0, null, null);
                                this.mVerificationCompleted = false;
                            }
                            if ((this.installFlags & 262144) != 0) {
                                final int enableRollbackToken = PackageManagerService.access$4308(PackageManagerService.this);
                                Trace.asyncTraceBegin(262144, "enable_rollback", enableRollbackToken);
                                PackageManagerService.this.mPendingEnableRollback.append(enableRollbackToken, this);
                                synchronized (PackageManagerService.this.mPackages) {
                                    PackageSetting ps = PackageManagerService.this.mSettings.getPackageLPr(pkgLite.packageName);
                                    if (ps != null) {
                                        installedUsers = ps.queryInstalledUsers(PackageManagerService.sUserManager.getUserIds(), true);
                                    } else {
                                        installedUsers = new int[0];
                                    }
                                }
                                Intent enableRollbackIntent = new Intent("android.intent.action.PACKAGE_ENABLE_ROLLBACK");
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_TOKEN", enableRollbackToken);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_INSTALL_FLAGS", this.installFlags);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_INSTALLED_USERS", installedUsers);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_USER", getRollbackUser().getIdentifier());
                                enableRollbackIntent.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                                enableRollbackIntent.addFlags(1);
                                enableRollbackIntent.addFlags(67108864);
                                PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(enableRollbackIntent, UserHandle.SYSTEM, "android.permission.PACKAGE_ROLLBACK_AGENT", new BroadcastReceiver() {
                                    /* class com.android.server.pm.PackageManagerService.InstallParams.AnonymousClass2 */

                                    public void onReceive(Context context, Intent intent) {
                                        long rollbackTimeout = DeviceConfig.getLong("rollback", PackageManagerService.PROPERTY_ENABLE_ROLLBACK_TIMEOUT_MILLIS, 10000);
                                        if (rollbackTimeout < 0) {
                                            rollbackTimeout = 10000;
                                        }
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(22);
                                        msg.arg1 = enableRollbackToken;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, rollbackTimeout);
                                    }
                                }, null, 0, null, null);
                                i = 0;
                                this.mEnableRollbackCompleted = false;
                            } else {
                                i = 0;
                            }
                        } else {
                            int i2 = 0;
                            while (i2 < N) {
                                ComponentName verifierComponent = sufficientVerifiers.get(i2);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                Intent sufficientIntent = new Intent(verification);
                                sufficientIntent.setComponent(verifierComponent);
                                PackageManagerService.this.mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);
                                i2++;
                                N = N;
                            }
                        }
                    }
                    ret2 = ret2;
                    PackageManagerService packageManagerService22 = PackageManagerService.this;
                    ComponentName requiredVerifierComponent2 = packageManagerService22.matchComponentForVerifier(packageManagerService22.mRequiredVerifierPackage, receivers);
                    if (ret2 != 1) {
                    }
                    if ((this.installFlags & 262144) != 0) {
                    }
                } else {
                    ret = ret2;
                }
                ret2 = ret;
                if ((this.installFlags & 262144) != 0) {
                }
            } else {
                i = 0;
            }
            OppoFeatureCache.get(IColorAppInstallProgressManager.DEFAULT).sendFailBroInCopyFinishStage(ret2, pkgLite, this.installerPackageName, getUser() == null ? i : getUser().getIdentifier());
            this.mRet = ret2;
        }

        /* access modifiers changed from: package-private */
        public void setReturnCode(int ret) {
            if (this.mRet == 1) {
                this.mRet = ret;
            }
        }

        /* access modifiers changed from: package-private */
        public void handleVerificationFinished() {
            this.mVerificationCompleted = true;
            handleReturnCode();
        }

        /* access modifiers changed from: package-private */
        public void handleRollbackEnabled() {
            this.mEnableRollbackCompleted = true;
            handleReturnCode();
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleReturnCode() {
            if (this.mVerificationCompleted && this.mEnableRollbackCompleted) {
                if ((this.installFlags & 8388608) != 0) {
                    String packageName = "";
                    try {
                        new PackageParser();
                        packageName = PackageParser.parsePackageLite(this.origin.file, 0).packageName;
                    } catch (PackageParser.PackageParserException e) {
                        Slog.e(PackageManagerService.TAG, "Can't parse package at " + this.origin.file.getAbsolutePath(), e);
                    }
                    try {
                        this.observer.onPackageInstalled(packageName, this.mRet, "Dry run", new Bundle());
                    } catch (RemoteException e2) {
                        Slog.i(PackageManagerService.TAG, "Observer no longer exists.");
                    }
                } else {
                    if (this.mRet == 1) {
                        this.mRet = this.mArgs.copyApk();
                    }
                    PackageManagerService.this.processPendingInstall(this.mArgs, this.mRet);
                }
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private InstallArgs createInstallArgs(InstallParams params) {
        if (params.move != null) {
            return new MoveInstallArgs(params);
        }
        return new FileInstallArgs(params);
    }

    private InstallArgs createInstallArgsForExisting(String codePath, String resourcePath, String[] instructionSets) {
        return new FileInstallArgs(codePath, resourcePath, instructionSets);
    }

    /* access modifiers changed from: package-private */
    public static abstract class InstallArgs {
        String abiOverride;
        OppoBasePackageManagerService.InstallArgsEx installArgsEx;
        final int installFlags;
        final String[] installGrantPermissions;
        final int installReason;
        final String installerPackageName;
        String[] instructionSets;
        final MultiPackageInstallParams mMultiPackageInstallParams;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final PackageParser.SigningDetails signingDetails;
        final int traceCookie;
        final String traceMethod;
        final UserHandle user;
        final String volumeUuid;
        final List<String> whitelistedRestrictedPermissions;

        /* access modifiers changed from: package-private */
        public abstract void cleanUpResourcesLI();

        /* access modifiers changed from: package-private */
        public abstract int copyApk();

        /* access modifiers changed from: package-private */
        public abstract boolean doPostDeleteLI(boolean z);

        /* access modifiers changed from: package-private */
        public abstract int doPostInstall(int i, int i2);

        /* access modifiers changed from: package-private */
        public abstract int doPreInstall(int i);

        /* access modifiers changed from: package-private */
        public abstract boolean doRename(int i, PackageParser.Package v);

        /* access modifiers changed from: package-private */
        public abstract String getCodePath();

        /* access modifiers changed from: package-private */
        public abstract String getResourcePath();

        InstallArgs(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, UserHandle user2, String[] instructionSets2, String abiOverride2, String[] installGrantPermissions2, List<String> whitelistedRestrictedPermissions2, String traceMethod2, int traceCookie2, PackageParser.SigningDetails signingDetails2, int installReason2, MultiPackageInstallParams multiPackageInstallParams) {
            this.origin = origin2;
            this.move = move2;
            this.installFlags = installFlags2;
            this.observer = observer2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.user = user2;
            this.instructionSets = instructionSets2;
            this.abiOverride = abiOverride2;
            this.installGrantPermissions = installGrantPermissions2;
            this.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions2;
            this.traceMethod = traceMethod2;
            this.traceCookie = traceCookie2;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
            this.mMultiPackageInstallParams = multiPackageInstallParams;
        }

        /* access modifiers changed from: package-private */
        public int doPreCopy() {
            return 1;
        }

        /* access modifiers changed from: package-private */
        public int doPostCopy(int uid) {
            return 1;
        }

        /* access modifiers changed from: protected */
        public boolean isEphemeral() {
            return (this.installFlags & 2048) != 0;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.user;
        }
    }

    /* access modifiers changed from: package-private */
    public void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
        if (allCodePaths.isEmpty()) {
            return;
        }
        if (instructionSets != null) {
            String[] dexCodeInstructionSets = InstructionSets.getDexCodeInstructionSets(instructionSets);
            for (String codePath : allCodePaths) {
                for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                    try {
                        this.mInstaller.rmdex(codePath, dexCodeInstructionSet);
                    } catch (Installer.InstallerException e) {
                    }
                }
            }
            return;
        }
        throw new IllegalStateException("instructionSet == null");
    }

    /* access modifiers changed from: package-private */
    public class FileInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        FileInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.whitelistedRestrictedPermissions, params.traceMethod, params.traceCookie, params.signingDetails, params.installReason, params.mParentInstallParams);
        }

        FileInstallArgs(String codePath, String resourcePath, String[] instructionSets) {
            super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, null, 0, PackageParser.SigningDetails.UNKNOWN, 0, null);
            File file = null;
            this.codeFile = codePath != null ? new File(codePath) : null;
            this.resourceFile = resourcePath != null ? new File(resourcePath) : file;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int copyApk() {
            Trace.traceBegin(262144, "copyApk");
            try {
                return doCopyApk();
            } finally {
                Trace.traceEnd(262144);
            }
        }

        private int doCopyApk() {
            int ret;
            if (this.origin.staged) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.d(PackageManagerService.TAG, this.origin.file + " already staged; skipping copy");
                }
                this.codeFile = this.origin.file;
                this.resourceFile = this.origin.file;
                return 1;
            }
            try {
                File tempDir = PackageManagerService.this.mInstallerService.allocateStageDirLegacy(this.volumeUuid, (this.installFlags & 2048) != 0);
                this.codeFile = tempDir;
                this.resourceFile = tempDir;
                int ret2 = PackageManagerServiceUtils.copyPackage(this.origin.file.getAbsolutePath(), this.codeFile);
                if (ret2 != 1) {
                    Slog.e(PackageManagerService.TAG, "Failed to copy package");
                    return ret2;
                }
                File libraryRoot = new File(this.codeFile, "lib");
                NativeLibraryHelper.Handle handle = null;
                try {
                    handle = NativeLibraryHelper.Handle.create(this.codeFile);
                    ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, this.abiOverride);
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Copying native libraries failed", e);
                    ret = -110;
                } catch (Throwable th) {
                    IoUtils.closeQuietly(handle);
                    throw th;
                }
                IoUtils.closeQuietly(handle);
                return ret;
            } catch (IOException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to create copy file: " + e2);
                return -4;
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doRename(int status, PackageParser.Package pkg) {
            if (status != 1) {
                cleanUp();
                return false;
            }
            File targetDir = this.codeFile.getParentFile();
            File beforeCodeFile = this.codeFile;
            File afterCodeFile = PackageManagerService.this.getNextCodePath(targetDir, pkg.packageName);
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Renaming " + beforeCodeFile + " to " + afterCodeFile);
            }
            try {
                Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
                if (!SELinux.restoreconRecursive(afterCodeFile)) {
                    Slog.w(PackageManagerService.TAG, "Failed to restorecon");
                    return false;
                }
                this.codeFile = afterCodeFile;
                this.resourceFile = afterCodeFile;
                try {
                    pkg.setCodePath(afterCodeFile.getCanonicalPath());
                    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
                    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
                    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
                    pkg.setApplicationInfoCodePath(pkg.codePath);
                    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
                    pkg.setApplicationInfoResourcePath(pkg.codePath);
                    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
                    return true;
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Failed to get path: " + afterCodeFile, e);
                    return false;
                }
            } catch (ErrnoException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to rename", e2);
                return false;
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPostInstall(int status, int uid) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getCodePath() {
            File file = this.codeFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getResourcePath() {
            File file = this.resourceFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp() {
            File file = this.codeFile;
            if (file == null || !file.exists()) {
                return false;
            }
            PackageManagerService.this.removeCodePathLI(this.codeFile);
            File file2 = this.resourceFile;
            if (file2 == null || FileUtils.contains(this.codeFile, file2)) {
                return true;
            }
            this.resourceFile.delete();
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public void cleanUpResourcesLI() {
            List<String> allCodePaths = Collections.EMPTY_LIST;
            File file = this.codeFile;
            if (file != null && file.exists()) {
                try {
                    allCodePaths = PackageParser.parsePackageLite(this.codeFile, 0).getAllCodePaths();
                } catch (PackageParser.PackageParserException e) {
                }
            }
            cleanUp();
            PackageManagerService.this.removeDexFiles(allCodePaths, this.instructionSets);
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doPostDeleteLI(boolean delete) {
            cleanUpResourcesLI();
            return true;
        }
    }

    private static void maybeThrowExceptionForMultiArchCopy(String message, int copyRet) throws PackageManagerException {
        if (copyRet < 0 && copyRet != -114 && copyRet != -113) {
            throw new PackageManagerException(copyRet, message);
        }
    }

    /* access modifiers changed from: package-private */
    public class MoveInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        MoveInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.whitelistedRestrictedPermissions, params.traceMethod, params.traceCookie, params.signingDetails, params.installReason, params.mParentInstallParams);
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int copyApk() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Moving " + this.move.packageName + " from " + this.move.fromUuid + " to " + this.move.toUuid);
            }
            synchronized (PackageManagerService.this.mInstaller) {
                try {
                    PackageManagerService.this.mInstaller.moveCompleteApp(this.move.fromUuid, this.move.toUuid, this.move.packageName, this.move.dataAppName, this.move.appId, this.move.seinfo, this.move.targetSdkVersion);
                } catch (Installer.InstallerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move app", e);
                    return -110;
                }
            }
            this.codeFile = new File(Environment.getDataAppDirectory(this.move.toUuid), this.move.dataAppName);
            this.resourceFile = this.codeFile;
            if (!PackageManagerService.DEBUG_INSTALL) {
                return 1;
            }
            Slog.d(PackageManagerService.TAG, "codeFile after move is " + this.codeFile);
            return 1;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doRename(int status, PackageParser.Package pkg) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
                return false;
            }
            pkg.setApplicationVolumeUuid(pkg.volumeUuid);
            pkg.setApplicationInfoCodePath(pkg.codePath);
            pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
            pkg.setApplicationInfoResourcePath(pkg.codePath);
            pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPostInstall(int status, int uid) {
            if (status == 1) {
                cleanUp(this.move.fromUuid);
            } else {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getCodePath() {
            File file = this.codeFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getResourcePath() {
            File file = this.resourceFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp(String volumeUuid) {
            File codeFile2 = new File(Environment.getDataAppDirectory(volumeUuid), this.move.dataAppName);
            Slog.d(PackageManagerService.TAG, "Cleaning up " + this.move.packageName + " on " + volumeUuid);
            int[] userIds = PackageManagerService.sUserManager.getUserIds();
            synchronized (PackageManagerService.this.mInstallLock) {
                for (int userId : userIds) {
                    try {
                        PackageManagerService.this.mInstaller.destroyAppData(volumeUuid, this.move.packageName, userId, 3, 0);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, String.valueOf(e));
                    }
                }
                PackageManagerService.this.removeCodePathLI(codeFile2);
            }
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public void cleanUpResourcesLI() {
            throw new UnsupportedOperationException();
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doPostDeleteLI(boolean delete) {
            throw new UnsupportedOperationException();
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private File getNextCodePath(File targetDir, String packageName) {
        File result;
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[16];
        do {
            random.nextBytes(bytes);
            String suffix = Base64.encodeToString(bytes, 10);
            result = new File(targetDir, packageName + "-" + suffix);
        } while (result.exists());
        return result;
    }

    public static String deriveCodePathName(String codePath) {
        if (codePath == null) {
            return null;
        }
        File codeFile = new File(codePath);
        String name = codeFile.getName();
        if (codeFile.isDirectory()) {
            return name;
        }
        if (name.endsWith(".apk") || name.endsWith(".tmp")) {
            return name.substring(0, name.lastIndexOf(46));
        }
        Slog.w(TAG, "Odd, " + codePath + " doesn't look like an APK");
        return null;
    }

    /* access modifiers changed from: package-private */
    public static class PackageInstalledInfo {
        ArrayMap<String, PackageInstalledInfo> addedChildPackages;
        String installerPackageName;
        ArrayList<PackageParser.Package> libraryConsumers;
        String name;
        int[] newUsers;
        String origPackage;
        String origPermission;
        int[] origUsers;
        PackageParser.Package pkg;
        PackageRemovedInfo removedInfo;
        int returnCode;
        String returnMsg;
        int uid;

        PackageInstalledInfo() {
        }

        public void setError(int code, String msg) {
            setReturnCode(code);
            setReturnMessage(msg);
            Slog.w(PackageManagerService.TAG, msg);
        }

        public void setError(String msg, PackageParser.PackageParserException e) {
            setReturnCode(e.error);
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setError(String msg, PackageManagerException e) {
            this.returnCode = e.error;
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setReturnCode(int returnCode2) {
            this.returnCode = returnCode2;
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnCode = returnCode2;
            }
        }

        private void setReturnMessage(String returnMsg2) {
            this.returnMsg = returnMsg2;
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnMsg = returnMsg2;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0019, code lost:
        r2 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x001a, code lost:
        $closeResource(r1, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x001d, code lost:
        throw r2;
     */
    private static void updateDigest(MessageDigest digest, File file) throws IOException {
        DigestInputStream digestStream = new DigestInputStream(new FileInputStream(file), digest);
        do {
        } while (digestStream.read() != -1);
        $closeResource(null, digestStream);
    }

    private String getParentOrChildPackageChangedSharedUser(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        if (!Objects.equals(oldPkg.mSharedUserId, newPkg.mSharedUserId)) {
            return newPkg.packageName;
        }
        int newChildCount = 0;
        int oldChildCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        if (newPkg.childPackages != null) {
            newChildCount = newPkg.childPackages.size();
        }
        for (int i = 0; i < newChildCount; i++) {
            PackageParser.Package newChildPkg = (PackageParser.Package) newPkg.childPackages.get(i);
            for (int j = 0; j < oldChildCount; j++) {
                PackageParser.Package oldChildPkg = (PackageParser.Package) oldPkg.childPackages.get(j);
                if (newChildPkg.packageName.equals(oldChildPkg.packageName) && !Objects.equals(newChildPkg.mSharedUserId, oldChildPkg.mSharedUserId)) {
                    return newChildPkg.packageName;
                }
            }
        }
        return null;
    }

    private void removeNativeBinariesLI(PackageSetting ps) {
        PackageSetting childPs;
        if (ps != null) {
            NativeLibraryHelper.removeNativeBinariesLI(ps.legacyNativeLibraryPathString);
            int childCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
            for (int i = 0; i < childCount; i++) {
                synchronized (this.mPackages) {
                    childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i));
                }
                if (childPs != null) {
                    NativeLibraryHelper.removeNativeBinariesLI(childPs.legacyNativeLibraryPathString);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void enableSystemPackageLPw(PackageParser.Package pkg) {
        this.mSettings.enableSystemPackageLPw(pkg.packageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.enableSystemPackageLPw(((PackageParser.Package) pkg.childPackages.get(i)).packageName);
        }
    }

    @GuardedBy({"mPackages"})
    private boolean disableSystemPackageLPw(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        boolean disabled = this.mSettings.disableSystemPackageLPw(oldPkg.packageName, true);
        int childCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = (PackageParser.Package) oldPkg.childPackages.get(i);
            disabled |= this.mSettings.disableSystemPackageLPw(childPkg.packageName, newPkg.hasChildPackage(childPkg.packageName));
        }
        return disabled;
    }

    @GuardedBy({"mPackages"})
    private void setInstallerPackageNameLPw(PackageParser.Package pkg, String installerPackageName) {
        this.mSettings.setInstallerPackageName(pkg.packageName, installerPackageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.setInstallerPackageName(((PackageParser.Package) pkg.childPackages.get(i)).packageName, installerPackageName);
        }
    }

    private void updateSettingsLI(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        updateSettingsInternalLI(newPackage, installerPackageName, allUsers, res.origUsers, res, user, installReason);
        int childCount = newPackage.childPackages != null ? newPackage.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPackage = (PackageParser.Package) newPackage.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPackage.packageName);
            updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user, installReason);
        }
    }

    private void updateSettingsInternalLI(PackageParser.Package pkg, String installerPackageName, int[] allUsers, int[] installedForUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        int i;
        int i2;
        int origUserId;
        Trace.traceBegin(262144, "updateSettings");
        String pkgName = pkg.packageName;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "New package installed in " + pkg.codePath);
        }
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                arrayMap = arrayMap2;
                try {
                    this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                    PackageSetting ps = this.mSettings.mPackages.get(pkgName);
                    int userId = user.getIdentifier();
                    if (ps != null) {
                        if (isSystemApp(pkg)) {
                            if (DEBUG_INSTALL) {
                                Slog.d(TAG, "Implicitly enabling system package on upgrade: " + pkgName);
                            }
                            if (res.origUsers != null) {
                                int[] iArr = res.origUsers;
                                for (int origUserId2 : iArr) {
                                    if (userId != -1) {
                                        origUserId = origUserId2;
                                        if (userId != origUserId) {
                                        }
                                    } else {
                                        origUserId = origUserId2;
                                    }
                                    ps.setEnabled(0, origUserId, installerPackageName);
                                }
                            }
                            if (!(allUsers == null || installedForUsers == null)) {
                                int length = allUsers.length;
                                int i3 = 0;
                                while (i3 < length) {
                                    int currentUserId = allUsers[i3];
                                    boolean installed = ArrayUtils.contains(installedForUsers, currentUserId);
                                    if (DEBUG_INSTALL) {
                                        StringBuilder sb = new StringBuilder();
                                        i2 = length;
                                        sb.append("    user ");
                                        sb.append(currentUserId);
                                        sb.append(" => ");
                                        sb.append(installed);
                                        Slog.d(TAG, sb.toString());
                                    } else {
                                        i2 = length;
                                    }
                                    ps.setInstalled(installed, currentUserId);
                                    i3++;
                                    length = i2;
                                }
                            }
                        }
                        if (userId != -1) {
                            ps.setInstalled(true, userId);
                            i = 0;
                            ps.setEnabled(0, userId, installerPackageName);
                        } else {
                            i = 0;
                        }
                        sPmsExt.updatePackageSettings(userId, pkgName, pkg, ps, allUsers, installerPackageName);
                        Set<Integer> previousUserIds = new ArraySet<>();
                        if (!(res.removedInfo == null || res.removedInfo.installReasons == null)) {
                            int installReasonCount = res.removedInfo.installReasons.size();
                            for (int i4 = 0; i4 < installReasonCount; i4++) {
                                int previousUserId = res.removedInfo.installReasons.keyAt(i4);
                                ps.setInstallReason(res.removedInfo.installReasons.valueAt(i4).intValue(), previousUserId);
                                previousUserIds.add(Integer.valueOf(previousUserId));
                            }
                        }
                        if (userId == -1) {
                            int[] userIds = sUserManager.getUserIds();
                            int length2 = userIds.length;
                            for (int i5 = i; i5 < length2; i5++) {
                                int currentUserId2 = userIds[i5];
                                if (!previousUserIds.contains(Integer.valueOf(currentUserId2))) {
                                    ps.setInstallReason(installReason, currentUserId2);
                                }
                            }
                        } else if (!previousUserIds.contains(Integer.valueOf(userId))) {
                            ps.setInstallReason(installReason, userId);
                        }
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                    res.name = pkgName;
                    res.uid = pkg.applicationInfo.uid;
                    res.pkg = pkg;
                    this.mSettings.setInstallerPackageName(pkgName, installerPackageName);
                    res.setReturnCode(1);
                    Trace.traceBegin(262144, "writeSettings");
                    this.mSettings.writeLPr();
                    Trace.traceEnd(262144);
                    Trace.traceEnd(262144);
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                arrayMap = arrayMap2;
                throw th;
            }
        }
    }

    /* access modifiers changed from: private */
    public static class InstallRequest {
        public final InstallArgs args;
        public final PackageInstalledInfo installResult;

        private InstallRequest(InstallArgs args2, PackageInstalledInfo res) {
            this.args = args2;
            this.installResult = res;
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private void installPackagesTracedLI(List<InstallRequest> requests) {
        try {
            Trace.traceBegin(262144, "installPackages");
            installPackagesLI(requests);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: private */
    public static class CommitRequest {
        final int[] mAllUsers;
        final Map<String, ReconciledPackage> reconciledPackages;

        private CommitRequest(Map<String, ReconciledPackage> reconciledPackages2, int[] allUsers) {
            this.reconciledPackages = reconciledPackages2;
            this.mAllUsers = allUsers;
        }
    }

    /* access modifiers changed from: private */
    public static class ReconcileRequest {
        public final Map<String, PackageParser.Package> allPackages;
        public final Map<String, InstallArgs> installArgs;
        public final Map<String, PackageInstalledInfo> installResults;
        public final Map<String, PackageSetting> lastStaticSharedLibSettings;
        public final Map<String, PrepareResult> preparedPackages;
        public final Map<String, ScanResult> scannedPackages;
        public final Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource;
        public final Map<String, Settings.VersionInfo> versionInfos;

        private ReconcileRequest(Map<String, ScanResult> scannedPackages2, Map<String, InstallArgs> installArgs2, Map<String, PackageInstalledInfo> installResults2, Map<String, PrepareResult> preparedPackages2, Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource2, Map<String, PackageParser.Package> allPackages2, Map<String, Settings.VersionInfo> versionInfos2, Map<String, PackageSetting> lastStaticSharedLibSettings2) {
            this.scannedPackages = scannedPackages2;
            this.installArgs = installArgs2;
            this.installResults = installResults2;
            this.preparedPackages = preparedPackages2;
            this.sharedLibrarySource = sharedLibrarySource2;
            this.allPackages = allPackages2;
            this.versionInfos = versionInfos2;
            this.lastStaticSharedLibSettings = lastStaticSharedLibSettings2;
        }

        private ReconcileRequest(Map<String, ScanResult> scannedPackages2, Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource2, Map<String, PackageParser.Package> allPackages2, Map<String, Settings.VersionInfo> versionInfos2, Map<String, PackageSetting> lastStaticSharedLibSettings2) {
            this(scannedPackages2, Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), sharedLibrarySource2, allPackages2, versionInfos2, lastStaticSharedLibSettings2);
        }
    }

    /* access modifiers changed from: private */
    public static class ReconcileFailure extends PackageManagerException {
        ReconcileFailure(String message) {
            super("Reconcile failed: " + message);
        }

        ReconcileFailure(int reason, String message) {
            super(reason, "Reconcile failed: " + message);
        }

        ReconcileFailure(PackageManagerException e) {
            this(e.error, e.getMessage());
        }
    }

    /* access modifiers changed from: private */
    public static class ReconciledPackage {
        public final List<SharedLibraryInfo> allowedSharedLibraryInfos;
        public ArrayList<SharedLibraryInfo> collectedSharedLibraryInfos;
        public final DeletePackageAction deletePackageAction;
        public final InstallArgs installArgs;
        public final PackageInstalledInfo installResult;
        public final PackageSetting pkgSetting;
        public final PrepareResult prepareResult;
        public final boolean removeAppKeySetData;
        public final ReconcileRequest request;
        public final ScanResult scanResult;
        public final boolean sharedUserSignaturesChanged;
        public final PackageParser.SigningDetails signingDetails;

        private ReconciledPackage(ReconcileRequest request2, InstallArgs installArgs2, PackageSetting pkgSetting2, PackageInstalledInfo installResult2, PrepareResult prepareResult2, ScanResult scanResult2, DeletePackageAction deletePackageAction2, List<SharedLibraryInfo> allowedSharedLibraryInfos2, PackageParser.SigningDetails signingDetails2, boolean sharedUserSignaturesChanged2, boolean removeAppKeySetData2) {
            this.request = request2;
            this.installArgs = installArgs2;
            this.pkgSetting = pkgSetting2;
            this.installResult = installResult2;
            this.prepareResult = prepareResult2;
            this.scanResult = scanResult2;
            this.deletePackageAction = deletePackageAction2;
            this.allowedSharedLibraryInfos = allowedSharedLibraryInfos2;
            this.signingDetails = signingDetails2;
            this.sharedUserSignaturesChanged = sharedUserSignaturesChanged2;
            this.removeAppKeySetData = removeAppKeySetData2;
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private Map<String, PackageParser.Package> getCombinedPackages() {
            ArrayMap<String, PackageParser.Package> combinedPackages = new ArrayMap<>(this.request.allPackages.size() + this.request.scannedPackages.size());
            combinedPackages.putAll(this.request.allPackages);
            for (ScanResult scanResult2 : this.request.scannedPackages.values()) {
                combinedPackages.put(scanResult2.pkgSetting.name, scanResult2.request.pkg);
            }
            return combinedPackages;
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:131:0x032b A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:88:0x0245  */
    @GuardedBy({"mPackages"})
    private static Map<String, ReconciledPackage> reconcilePackagesLocked(ReconcileRequest request, KeySetManagerService ksms) throws ReconcileFailure {
        PackageManagerException e;
        DeletePackageAction deletePackageAction;
        PackageSetting signatureCheckPs;
        PackageSetting disabledPkgSetting;
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries;
        PackageParser.SigningDetails signingDetails;
        PackageManagerException e2;
        IllegalArgumentException e3;
        KeySetManagerService keySetManagerService = ksms;
        Map<String, ScanResult> scannedPackages = request.scannedPackages;
        Map<String, ReconciledPackage> result = new ArrayMap<>(scannedPackages.size());
        ArrayMap<String, PackageParser.Package> combinedPackages = new ArrayMap<>(request.allPackages.size() + scannedPackages.size());
        combinedPackages.putAll(request.allPackages);
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries2 = new ArrayMap<>();
        for (String installPackageName : scannedPackages.keySet()) {
            ScanResult scanResult = scannedPackages.get(installPackageName);
            combinedPackages.put(scanResult.pkgSetting.name, scanResult.request.pkg);
            List<SharedLibraryInfo> allowedSharedLibInfos = getAllowedSharedLibInfos(scanResult, request.sharedLibrarySource);
            SharedLibraryInfo staticLib = scanResult.staticSharedLibraryInfo;
            if (allowedSharedLibInfos != null) {
                for (SharedLibraryInfo info : allowedSharedLibInfos) {
                    if (!addSharedLibraryToPackageVersionMap(incomingSharedLibraries2, info)) {
                        throw new ReconcileFailure("Static Shared Library " + staticLib.getName() + " is being installed twice in this set!");
                    }
                }
            }
            InstallArgs installArgs = request.installArgs.get(installPackageName);
            PackageInstalledInfo res = request.installResults.get(installPackageName);
            PrepareResult prepareResult = request.preparedPackages.get(installPackageName);
            boolean isInstall = installArgs != null;
            if (!isInstall || !(res == null || prepareResult == null)) {
                if (!isInstall || !prepareResult.replace || prepareResult.system) {
                    deletePackageAction = null;
                } else {
                    DeletePackageAction deletePackageAction2 = mayDeletePackageLocked(res.removedInfo, prepareResult.originalPs, prepareResult.disabledPs, prepareResult.childPackageSettings, 1 | ((scanResult.request.scanFlags & 2048) == 0 ? 0 : 8), null);
                    if (deletePackageAction2 != null) {
                        deletePackageAction = deletePackageAction2;
                    } else {
                        throw new ReconcileFailure(-10, "May not delete " + installPackageName + " to replace");
                    }
                }
                int scanFlags = scanResult.request.scanFlags;
                int parseFlags = scanResult.request.parseFlags;
                PackageParser.Package pkg = scanResult.request.pkg;
                PackageSetting disabledPkgSetting2 = scanResult.request.disabledPkgSetting;
                PackageSetting lastStaticSharedLibSetting = request.lastStaticSharedLibSettings.get(installPackageName);
                if (prepareResult == null || lastStaticSharedLibSetting == null) {
                    signatureCheckPs = scanResult.pkgSetting;
                } else {
                    signatureCheckPs = lastStaticSharedLibSetting;
                }
                boolean removeAppKeySetData = false;
                boolean sharedUserSignaturesChanged = false;
                if (keySetManagerService.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                    if (!keySetManagerService.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                        if ((parseFlags & 16) != 0) {
                            reportSettingsProblem(5, "System package " + pkg.packageName + " signature changed; retaining data.");
                        } else {
                            throw new ReconcileFailure(-7, "Package " + pkg.packageName + " upgrade keys do not match the previously installed version");
                        }
                    }
                    signingDetails = pkg.mSigningDetails;
                    disabledPkgSetting = disabledPkgSetting2;
                    incomingSharedLibraries = incomingSharedLibraries2;
                } else {
                    try {
                        Settings.VersionInfo versionInfo = request.versionInfos.get(installPackageName);
                        incomingSharedLibraries = incomingSharedLibraries2;
                        try {
                            if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, disabledPkgSetting2, pkg.mSigningDetails, isCompatSignatureUpdateNeeded(versionInfo), isRecoverSignatureUpdateNeeded(versionInfo))) {
                                removeAppKeySetData = true;
                            }
                            signingDetails = pkg.mSigningDetails;
                            if (signatureCheckPs.sharedUser != null) {
                                disabledPkgSetting = disabledPkgSetting2;
                                try {
                                    if (pkg.mSigningDetails.hasAncestor(signatureCheckPs.sharedUser.signatures.mSigningDetails)) {
                                        signatureCheckPs.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                                    }
                                    if (signatureCheckPs.sharedUser.signaturesChanged == null) {
                                        signatureCheckPs.sharedUser.signaturesChanged = Boolean.FALSE;
                                    }
                                } catch (PackageManagerException e4) {
                                    e2 = e4;
                                    if ((parseFlags & 16) != 0) {
                                    }
                                } catch (IllegalArgumentException e5) {
                                    e3 = e5;
                                    throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e3);
                                }
                            } else {
                                disabledPkgSetting = disabledPkgSetting2;
                            }
                        } catch (PackageManagerException e6) {
                            e2 = e6;
                            disabledPkgSetting = disabledPkgSetting2;
                            if ((parseFlags & 16) != 0) {
                            }
                        } catch (IllegalArgumentException e7) {
                            e3 = e7;
                            throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e3);
                        }
                    } catch (PackageManagerException e8) {
                        e2 = e8;
                        disabledPkgSetting = disabledPkgSetting2;
                        incomingSharedLibraries = incomingSharedLibraries2;
                        if ((parseFlags & 16) != 0) {
                            PackageParser.SigningDetails signingDetails2 = pkg.mSigningDetails;
                            if (signatureCheckPs.sharedUser != null) {
                                Signature[] sharedUserSignatures = signatureCheckPs.sharedUser.signatures.mSigningDetails.signatures;
                                if (signatureCheckPs.sharedUser.signaturesChanged == null || PackageManagerServiceUtils.compareSignatures(sharedUserSignatures, pkg.mSigningDetails.signatures) == 0) {
                                    sharedUserSignaturesChanged = true;
                                    signingDetails = signingDetails2;
                                    signatureCheckPs.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                                    signatureCheckPs.sharedUser.signaturesChanged = Boolean.TRUE;
                                } else if (SystemProperties.getInt("ro.product.first_api_level", 0) <= 29) {
                                    throw new ReconcileFailure(-104, "Signature mismatch for shared user: " + scanResult.pkgSetting.sharedUser);
                                } else {
                                    throw new IllegalStateException("Signature mismatch on system package " + pkg.packageName + " for shared user " + scanResult.pkgSetting.sharedUser);
                                }
                            } else {
                                signingDetails = signingDetails2;
                            }
                            reportSettingsProblem(5, "System package " + pkg.packageName + " signature changed; retaining data.");
                            result.put(installPackageName, new ReconciledPackage(request, installArgs, scanResult.pkgSetting, res, request.preparedPackages.get(installPackageName), scanResult, deletePackageAction, allowedSharedLibInfos, signingDetails, sharedUserSignaturesChanged, removeAppKeySetData));
                            result = result;
                            scannedPackages = scannedPackages;
                            incomingSharedLibraries2 = incomingSharedLibraries;
                            combinedPackages = combinedPackages;
                            keySetManagerService = ksms;
                        } else {
                            throw new ReconcileFailure(e2);
                        }
                    } catch (IllegalArgumentException e9) {
                        e3 = e9;
                        throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e3);
                    }
                }
                result.put(installPackageName, new ReconciledPackage(request, installArgs, scanResult.pkgSetting, res, request.preparedPackages.get(installPackageName), scanResult, deletePackageAction, allowedSharedLibInfos, signingDetails, sharedUserSignaturesChanged, removeAppKeySetData));
                result = result;
                scannedPackages = scannedPackages;
                incomingSharedLibraries2 = incomingSharedLibraries;
                combinedPackages = combinedPackages;
                keySetManagerService = ksms;
            } else {
                throw new ReconcileFailure("Reconcile arguments are not balanced for " + installPackageName + "!");
            }
        }
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries3 = incomingSharedLibraries2;
        ArrayMap<String, PackageParser.Package> combinedPackages2 = combinedPackages;
        Map<String, ScanResult> scannedPackages2 = scannedPackages;
        for (String installPackageName2 : scannedPackages2.keySet()) {
            ScanResult scanResult2 = scannedPackages2.get(installPackageName2);
            if ((scanResult2.request.scanFlags & 16) != 0) {
                scannedPackages2 = scannedPackages2;
            } else if ((scanResult2.request.parseFlags & 16) != 0) {
                scannedPackages2 = scannedPackages2;
            } else {
                try {
                    try {
                        result.get(installPackageName2).collectedSharedLibraryInfos = collectSharedLibraryInfos(scanResult2.request.pkg, combinedPackages2, request.sharedLibrarySource, incomingSharedLibraries3);
                        scannedPackages2 = scannedPackages2;
                        combinedPackages2 = combinedPackages2;
                        incomingSharedLibraries3 = incomingSharedLibraries3;
                    } catch (PackageManagerException e10) {
                        e = e10;
                        throw new ReconcileFailure(e.error, e.getMessage());
                    }
                } catch (PackageManagerException e11) {
                    e = e11;
                    throw new ReconcileFailure(e.error, e.getMessage());
                }
            }
        }
        return result;
    }

    private static List<SharedLibraryInfo> getAllowedSharedLibInfos(ScanResult scanResult, Map<String, LongSparseArray<SharedLibraryInfo>> existingSharedLibraries) {
        PackageSetting updatedSystemPs;
        PackageParser.Package pkg = scanResult.request.pkg;
        if (scanResult.staticSharedLibraryInfo == null && scanResult.dynamicSharedLibraryInfos == null) {
            return null;
        }
        if (scanResult.staticSharedLibraryInfo != null) {
            return Collections.singletonList(scanResult.staticSharedLibraryInfo);
        }
        boolean hasDynamicLibraries = true;
        if ((pkg.applicationInfo.flags & 1) == 0 || scanResult.dynamicSharedLibraryInfos == null) {
            hasDynamicLibraries = false;
        }
        if (!hasDynamicLibraries) {
            return null;
        }
        boolean isUpdatedSystemApp = pkg.isUpdatedSystemApp();
        if (!isUpdatedSystemApp) {
            updatedSystemPs = null;
        } else if (scanResult.request.disabledPkgSetting == null) {
            updatedSystemPs = scanResult.request.oldPkgSetting;
        } else {
            updatedSystemPs = scanResult.request.disabledPkgSetting;
        }
        if (!isUpdatedSystemApp || !(updatedSystemPs.pkg == null || updatedSystemPs.pkg.libraryNames == null)) {
            ArrayList<SharedLibraryInfo> infos = new ArrayList<>(scanResult.dynamicSharedLibraryInfos.size());
            for (SharedLibraryInfo info : scanResult.dynamicSharedLibraryInfos) {
                String name = info.getName();
                if (isUpdatedSystemApp && !updatedSystemPs.pkg.libraryNames.contains(name)) {
                    Slog.w(TAG, "Package " + pkg.packageName + " declares library " + name + " that is not declared on system image; skipping");
                } else if (sharedLibExists(name, -1, existingSharedLibraries)) {
                    Slog.w(TAG, "Package " + pkg.packageName + " declares library " + name + " that already exists; skipping");
                } else {
                    infos.add(info);
                }
            }
            return infos;
        }
        Slog.w(TAG, "Package " + pkg.packageName + " declares libraries that are not declared on the system image; skipping");
        return null;
    }

    private static boolean addSharedLibraryToPackageVersionMap(Map<String, LongSparseArray<SharedLibraryInfo>> target, SharedLibraryInfo library) {
        String name = library.getName();
        if (!target.containsKey(name)) {
            target.put(name, new LongSparseArray<>());
        } else if (library.getType() != 2 || target.get(name).indexOfKey(library.getLongVersion()) >= 0) {
            return false;
        }
        target.get(name).put(library.getLongVersion(), library);
        return true;
    }

    /* JADX WARNING: Removed duplicated region for block: B:102:0x02ac  */
    /* JADX WARNING: Removed duplicated region for block: B:103:0x02be  */
    /* JADX WARNING: Removed duplicated region for block: B:106:0x02c3  */
    /* JADX WARNING: Removed duplicated region for block: B:109:0x02ce  */
    /* JADX WARNING: Removed duplicated region for block: B:115:0x02ff  */
    /* JADX WARNING: Removed duplicated region for block: B:121:0x0307 A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x0169  */
    /* JADX WARNING: Removed duplicated region for block: B:62:0x01bc  */
    /* JADX WARNING: Removed duplicated region for block: B:68:0x01e0  */
    /* JADX WARNING: Removed duplicated region for block: B:71:0x01e6  */
    /* JADX WARNING: Removed duplicated region for block: B:76:0x0210  */
    /* JADX WARNING: Removed duplicated region for block: B:96:0x0278  */
    @GuardedBy({"mPackages"})
    private void commitPackagesLocked(CommitRequest request) {
        PackageParser.Package r20;
        PackageInstalledInfo res;
        PackageSetting ps;
        int childCount;
        int i;
        PackageInstalledInfo res2;
        Set set;
        PackageSetting ps1;
        SystemDeleteException e;
        int deletedChildCount;
        boolean childPackageDeleted;
        int i2;
        int newChildCount;
        PackageParser.Package oldPackage = request.reconciledPackages.values().iterator();
        while (oldPackage.hasNext()) {
            ReconciledPackage reconciledPkg = oldPackage.next();
            PackageParser.Package pkg = reconciledPkg.scanResult.request.pkg;
            String packageName = pkg.packageName;
            PackageInstalledInfo res3 = reconciledPkg.installResult;
            if (reconciledPkg.prepareResult.replace) {
                PackageParser.Package oldPackage2 = this.mPackages.get(packageName);
                r20 = oldPackage;
                setInstallAndUpdateTime(pkg, ((PackageSetting) oldPackage2.mExtras).firstInstallTime, System.currentTimeMillis());
                if (reconciledPkg.prepareResult.system) {
                    removePackageLI(oldPackage2, true);
                    if (!disableSystemPackageLPw(oldPackage2, pkg)) {
                        res3.removedInfo.args = createInstallArgsForExisting(oldPackage2.applicationInfo.getCodePath(), oldPackage2.applicationInfo.getResourcePath(), InstructionSets.getAppDexInstructionSets(oldPackage2.applicationInfo));
                    } else {
                        res3.removedInfo.args = null;
                    }
                    int deletedChildCount2 = oldPackage2.childPackages != null ? oldPackage2.childPackages.size() : 0;
                    int newChildCount2 = pkg.childPackages != null ? pkg.childPackages.size() : 0;
                    int i3 = 0;
                    while (i3 < deletedChildCount2) {
                        PackageParser.Package deletedChildPkg = (PackageParser.Package) oldPackage2.childPackages.get(i3);
                        int j = 0;
                        while (true) {
                            if (j >= newChildCount2) {
                                deletedChildCount = deletedChildCount2;
                                childPackageDeleted = true;
                                break;
                            }
                            deletedChildCount = deletedChildCount2;
                            if (deletedChildPkg.packageName.equals(((PackageParser.Package) pkg.childPackages.get(j)).packageName)) {
                                childPackageDeleted = false;
                                break;
                            } else {
                                j++;
                                deletedChildCount2 = deletedChildCount;
                            }
                        }
                        if (childPackageDeleted) {
                            PackageSetting ps12 = this.mSettings.getDisabledSystemPkgLPr(deletedChildPkg.packageName);
                            if (ps12 == null || res3.removedInfo.removedChildPackages == null) {
                                i2 = i3;
                                newChildCount = newChildCount2;
                            } else {
                                PackageRemovedInfo removedChildRes = res3.removedInfo.removedChildPackages.get(deletedChildPkg.packageName);
                                i2 = i3;
                                newChildCount = newChildCount2;
                                removePackageDataLIF(ps12, request.mAllUsers, removedChildRes, 0, false);
                                removedChildRes.removedForAllUsers = this.mPackages.get(ps12.name) == null;
                            }
                        } else {
                            i2 = i3;
                            newChildCount = newChildCount2;
                        }
                        i3 = i2 + 1;
                        deletedChildCount2 = deletedChildCount;
                        newChildCount2 = newChildCount;
                    }
                    res = res3;
                } else {
                    try {
                        set = null;
                        res2 = res3;
                        try {
                            executeDeletePackageLIF(reconciledPkg.deletePackageAction, packageName, true, request.mAllUsers, true, pkg);
                        } catch (SystemDeleteException e2) {
                            e = e2;
                        }
                    } catch (SystemDeleteException e3) {
                        e = e3;
                        set = null;
                        res2 = res3;
                        if (Build.IS_ENG) {
                            throw new RuntimeException("Unexpected failure", e);
                        }
                        if (DEBUG_INSTALL) {
                        }
                        int[] uidArray = {oldPackage2.applicationInfo.uid};
                        ArrayList<String> pkgList = new ArrayList<>(1);
                        pkgList.add(oldPackage2.applicationInfo.packageName);
                        sendResourcesChangedBroadcast(false, true, pkgList, uidArray, (IIntentReceiver) null);
                        ps1 = this.mSettings.mPackages.get(reconciledPkg.prepareResult.existingPackage.packageName);
                        if ((reconciledPkg.installArgs.installFlags & 1) != 0) {
                        }
                        if (ps1.childPackageNames != null) {
                        }
                        if (reconciledPkg.installResult.returnCode != 1) {
                        }
                        commitReconciledScanResultLocked(reconciledPkg);
                        updateSettingsLI(pkg, reconciledPkg.installArgs.installerPackageName, request.mAllUsers, res, reconciledPkg.installArgs.user, reconciledPkg.installArgs.installReason);
                        ps = this.mSettings.mPackages.get(packageName);
                        if (ps == null) {
                        }
                        if (pkg.childPackages != null) {
                        }
                        while (i < childCount) {
                        }
                        if (res.returnCode != 1) {
                        }
                        oldPackage = r20;
                    }
                    if (oldPackage2.isForwardLocked() || isExternal(oldPackage2)) {
                        if (DEBUG_INSTALL) {
                            Slog.i(TAG, "upgrading pkg " + oldPackage2 + " is ASEC-hosted -> UNAVAILABLE");
                        }
                        int[] uidArray2 = {oldPackage2.applicationInfo.uid};
                        ArrayList<String> pkgList2 = new ArrayList<>(1);
                        pkgList2.add(oldPackage2.applicationInfo.packageName);
                        sendResourcesChangedBroadcast(false, true, pkgList2, uidArray2, (IIntentReceiver) null);
                    }
                    ps1 = this.mSettings.mPackages.get(reconciledPkg.prepareResult.existingPackage.packageName);
                    if ((reconciledPkg.installArgs.installFlags & 1) != 0) {
                        if (ps1.mOldCodePaths == null) {
                            ps1.mOldCodePaths = new ArraySet();
                        }
                        Collections.addAll(ps1.mOldCodePaths, oldPackage2.baseCodePath);
                        if (oldPackage2.splitCodePaths != null) {
                            Collections.addAll(ps1.mOldCodePaths, oldPackage2.splitCodePaths);
                        }
                    } else {
                        ps1.mOldCodePaths = set;
                    }
                    if (ps1.childPackageNames != null) {
                        for (int i4 = ps1.childPackageNames.size() - 1; i4 >= 0; i4--) {
                            this.mSettings.mPackages.get((String) ps1.childPackageNames.get(i4)).mOldCodePaths = ps1.mOldCodePaths;
                        }
                    }
                    if (reconciledPkg.installResult.returnCode != 1) {
                        PackageSetting ps2 = this.mSettings.getPackageLPr(pkg.packageName);
                        if (ps2 != null) {
                            res = res2;
                            res.removedInfo.removedForAllUsers = this.mPackages.get(ps2.name) == null;
                            if (res.removedInfo.removedChildPackages != null) {
                                for (int i5 = res.removedInfo.removedChildPackages.size() - 1; i5 >= 0; i5--) {
                                    if (res.addedChildPackages.containsKey(res.removedInfo.removedChildPackages.keyAt(i5))) {
                                        res.removedInfo.removedChildPackages.removeAt(i5);
                                    } else {
                                        PackageRemovedInfo childInfo = res.removedInfo.removedChildPackages.valueAt(i5);
                                        childInfo.removedForAllUsers = this.mPackages.get(childInfo.removedPackage) == null;
                                    }
                                }
                            }
                        } else {
                            res = res2;
                        }
                    } else {
                        res = res2;
                    }
                }
            } else {
                r20 = oldPackage;
                res = res3;
            }
            commitReconciledScanResultLocked(reconciledPkg);
            updateSettingsLI(pkg, reconciledPkg.installArgs.installerPackageName, request.mAllUsers, res, reconciledPkg.installArgs.user, reconciledPkg.installArgs.installReason);
            ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                childCount = 0;
                ps.setUpdateAvailable(false);
            } else {
                childCount = 0;
            }
            if (pkg.childPackages != null) {
                childCount = pkg.childPackages.size();
            }
            for (i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i);
                PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
                PackageSetting childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
            }
            if (res.returnCode != 1) {
                updateSequenceNumberLP(ps, res.newUsers);
                updateInstantAppInstallerLocked(packageName);
            }
            oldPackage = r20;
        }
    }

    /* JADX INFO: Multiple debug info for r14v18 'request'  com.android.server.pm.PackageManagerService$InstallRequest: [D('installArgs' java.util.Map<java.lang.String, com.android.server.pm.PackageManagerService$InstallArgs>), D('request' com.android.server.pm.PackageManagerService$InstallRequest)] */
    /* JADX WARNING: Removed duplicated region for block: B:100:0x0288  */
    /* JADX WARNING: Removed duplicated region for block: B:243:0x055e  */
    /* JADX WARNING: Removed duplicated region for block: B:258:0x05b6  */
    /* JADX WARNING: Removed duplicated region for block: B:85:0x0231  */
    @GuardedBy({"mInstallLock"})
    private void installPackagesLI(List<InstallRequest> requests) {
        Map<String, ScanResult> preparedScans;
        long j;
        Map<String, PrepareResult> prepareResults;
        boolean z;
        Map<String, Boolean> createdAppId;
        PackageManagerException e;
        CommitRequest commitRequest;
        long j2;
        PrepareFailure prepareFailure;
        PrepareResult prepareResult;
        Map<String, PackageSetting> map;
        String packageName;
        long j3;
        Map<String, InstallArgs> installArgs;
        Map<String, PackageInstalledInfo> installResults;
        InstallRequest request;
        int i;
        Map<String, PackageSetting> lastStaticSharedLibSettings;
        PackageManagerException e2;
        boolean z2;
        Map<String, ScanResult> preparedScans2 = new ArrayMap<>(requests.size());
        Map<String, InstallArgs> installArgs2 = new ArrayMap<>(requests.size());
        Map<String, PackageInstalledInfo> installResults2 = new ArrayMap<>(requests.size());
        Map<String, PrepareResult> prepareResults2 = new ArrayMap<>(requests.size());
        Map<String, Settings.VersionInfo> versionInfos = new ArrayMap<>(requests.size());
        Map<String, PackageSetting> lastStaticSharedLibSettings2 = new ArrayMap<>(requests.size());
        Map<String, Boolean> createdAppId2 = new ArrayMap<>(requests.size());
        boolean success = false;
        int i2 = 1;
        long j4 = 262144;
        try {
            Trace.traceBegin(262144, "installPackagesLI");
            for (InstallRequest request2 : requests) {
                try {
                    try {
                        Trace.traceBegin(j4, "preparePackage");
                        prepareResult = preparePackageLI(request2.args, request2.installResult);
                        Trace.traceEnd(j4);
                        request2.installResult.setReturnCode(i2);
                        try {
                            request2.installResult.installerPackageName = request2.args.installerPackageName;
                            packageName = prepareResult.packageToScan.packageName;
                            prepareResults2.put(packageName, prepareResult);
                            installResults2.put(packageName, request2.installResult);
                            installArgs2.put(packageName, request2.args);
                            try {
                            } catch (PackageManagerException e3) {
                                e2 = e3;
                                installResults = installResults2;
                                installArgs = installArgs2;
                                z = false;
                                j3 = 262144;
                                request = request2;
                                i = i2;
                                lastStaticSharedLibSettings = lastStaticSharedLibSettings2;
                                try {
                                    request.installResult.setError("Scanning Failed.", e2);
                                    if (0 == 0) {
                                    }
                                    while (r1.hasNext()) {
                                    }
                                    Trace.traceEnd(j3);
                                    return;
                                } catch (Throwable th) {
                                    e = th;
                                    createdAppId = createdAppId2;
                                    prepareResults = prepareResults2;
                                    preparedScans = preparedScans2;
                                    j = j3;
                                    if (!success) {
                                    }
                                    while (r1.hasNext()) {
                                    }
                                    Trace.traceEnd(j);
                                    throw e;
                                }
                            }
                        } catch (Throwable th2) {
                            e = th2;
                            z = false;
                            map = lastStaticSharedLibSettings2;
                            createdAppId = createdAppId2;
                            prepareResults = prepareResults2;
                            preparedScans = preparedScans2;
                            j = 262144;
                            if (!success) {
                            }
                            while (r1.hasNext()) {
                            }
                            Trace.traceEnd(j);
                            throw e;
                        }
                    } catch (PrepareFailure prepareFailure2) {
                        j2 = j4;
                        request2.installResult.setError(prepareFailure2.error, prepareFailure2.getMessage());
                        request2.installResult.origPackage = prepareFailure2.conflictingPackage;
                        request2.installResult.origPermission = prepareFailure2.conflictingPermission;
                        Trace.traceEnd(j2);
                        if (0 == 0) {
                            for (ScanResult result : preparedScans2.values()) {
                                if (createdAppId2.getOrDefault(result.request.pkg.packageName, false).booleanValue()) {
                                    cleanUpAppIdCreation(result);
                                }
                            }
                            for (InstallRequest request3 : requests) {
                                if (request3.installResult.returnCode == i2) {
                                    request3.installResult.returnCode = 0;
                                }
                            }
                        }
                        for (PrepareResult result2 : prepareResults2.values()) {
                            if (result2.freezer != null) {
                                result2.freezer.close();
                            }
                        }
                        Trace.traceEnd(j2);
                        return;
                    } catch (Throwable th3) {
                        prepareFailure = th3;
                        Trace.traceEnd(j2);
                        throw prepareFailure;
                    }
                } catch (Throwable th4) {
                    e = th4;
                    z = false;
                    createdAppId = createdAppId2;
                    preparedScans = preparedScans2;
                    prepareResults = prepareResults2;
                    j = j4;
                    if (!success) {
                    }
                    while (r1.hasNext()) {
                    }
                    Trace.traceEnd(j);
                    throw e;
                }
                try {
                    j3 = 262144;
                    installResults = installResults2;
                    installArgs = installArgs2;
                    boolean z3 = false;
                    request = request2;
                    Map<String, PackageSetting> lastStaticSharedLibSettings3 = lastStaticSharedLibSettings2;
                    i = 1;
                    try {
                        for (ScanResult result3 : scanPackageTracedLI(prepareResult.packageToScan, prepareResult.parseFlags, prepareResult.scanFlags, System.currentTimeMillis(), request2.args.user)) {
                            if (preparedScans2.put(result3.pkgSetting.pkg.packageName, result3) != null) {
                                try {
                                    request.installResult.setError(-5, "Duplicate package " + result3.pkgSetting.pkg.packageName + " in multi-package install request.");
                                    if (0 == 0) {
                                        for (ScanResult result4 : preparedScans2.values()) {
                                            if (createdAppId2.getOrDefault(result4.request.pkg.packageName, Boolean.valueOf(z3)).booleanValue()) {
                                                cleanUpAppIdCreation(result4);
                                            }
                                        }
                                        for (InstallRequest request4 : requests) {
                                            if (request4.installResult.returnCode == 1) {
                                                PackageInstalledInfo packageInstalledInfo = request4.installResult;
                                                z2 = z3;
                                                int i3 = z2 ? 1 : 0;
                                                int i4 = z2 ? 1 : 0;
                                                packageInstalledInfo.returnCode = i3;
                                            } else {
                                                z2 = z3;
                                            }
                                            boolean z4 = z2 ? 1 : 0;
                                            Object[] objArr = z2 ? 1 : 0;
                                            Object[] objArr2 = z2 ? 1 : 0;
                                            z3 = z4;
                                        }
                                    }
                                    for (PrepareResult result5 : prepareResults2.values()) {
                                        if (result5.freezer != null) {
                                            result5.freezer.close();
                                        }
                                    }
                                    Trace.traceEnd(262144);
                                    return;
                                } catch (PackageManagerException e4) {
                                    e2 = e4;
                                    z = z3;
                                    lastStaticSharedLibSettings = lastStaticSharedLibSettings3;
                                    request.installResult.setError("Scanning Failed.", e2);
                                    if (0 == 0) {
                                    }
                                    while (r1.hasNext()) {
                                    }
                                    Trace.traceEnd(j3);
                                    return;
                                } catch (Throwable th5) {
                                    e = th5;
                                    z = z3;
                                    createdAppId = createdAppId2;
                                    prepareResults = prepareResults2;
                                    preparedScans = preparedScans2;
                                    j = 262144;
                                    if (!success) {
                                    }
                                    while (r1.hasNext()) {
                                    }
                                    Trace.traceEnd(j);
                                    throw e;
                                }
                            } else {
                                z = z3;
                                try {
                                    createdAppId2.put(packageName, Boolean.valueOf(optimisticallyRegisterAppId(result3)));
                                    versionInfos.put(result3.pkgSetting.pkg.packageName, getSettingsVersionForPackage(result3.pkgSetting.pkg));
                                    if (result3.staticSharedLibraryInfo != null) {
                                        PackageSetting sharedLibLatestVersionSetting = getSharedLibLatestVersionSetting(result3);
                                        if (sharedLibLatestVersionSetting != null) {
                                            lastStaticSharedLibSettings = lastStaticSharedLibSettings3;
                                            try {
                                                lastStaticSharedLibSettings.put(result3.pkgSetting.pkg.packageName, sharedLibLatestVersionSetting);
                                            } catch (PackageManagerException e5) {
                                                e2 = e5;
                                            }
                                        } else {
                                            lastStaticSharedLibSettings = lastStaticSharedLibSettings3;
                                        }
                                    } else {
                                        lastStaticSharedLibSettings = lastStaticSharedLibSettings3;
                                    }
                                    z3 = z ? 1 : 0;
                                    lastStaticSharedLibSettings3 = lastStaticSharedLibSettings;
                                } catch (PackageManagerException e6) {
                                    e2 = e6;
                                    lastStaticSharedLibSettings = lastStaticSharedLibSettings3;
                                    request.installResult.setError("Scanning Failed.", e2);
                                    if (0 == 0) {
                                    }
                                    while (r1.hasNext()) {
                                    }
                                    Trace.traceEnd(j3);
                                    return;
                                } catch (Throwable th6) {
                                    e = th6;
                                    createdAppId = createdAppId2;
                                    prepareResults = prepareResults2;
                                    preparedScans = preparedScans2;
                                    j = 262144;
                                    if (!success) {
                                    }
                                    while (r1.hasNext()) {
                                    }
                                    Trace.traceEnd(j);
                                    throw e;
                                }
                            }
                        }
                        installResults2 = installResults;
                        installArgs2 = installArgs;
                        j4 = 262144;
                        lastStaticSharedLibSettings2 = lastStaticSharedLibSettings3;
                        i2 = 1;
                    } catch (PackageManagerException e7) {
                        e2 = e7;
                        lastStaticSharedLibSettings = lastStaticSharedLibSettings3;
                        z = false;
                        request.installResult.setError("Scanning Failed.", e2);
                        if (0 == 0) {
                            for (ScanResult result6 : preparedScans2.values()) {
                                if (createdAppId2.getOrDefault(result6.request.pkg.packageName, Boolean.valueOf(z)).booleanValue()) {
                                    cleanUpAppIdCreation(result6);
                                }
                            }
                            for (InstallRequest request5 : requests) {
                                if (request5.installResult.returnCode == i) {
                                    PackageInstalledInfo packageInstalledInfo2 = request5.installResult;
                                    int i5 = z ? 1 : 0;
                                    int i6 = z ? 1 : 0;
                                    int i7 = z ? 1 : 0;
                                    int i8 = z ? 1 : 0;
                                    int i9 = z ? 1 : 0;
                                    int i10 = z ? 1 : 0;
                                    packageInstalledInfo2.returnCode = i5;
                                }
                            }
                        }
                        for (PrepareResult result7 : prepareResults2.values()) {
                            if (result7.freezer != null) {
                                result7.freezer.close();
                            }
                        }
                        Trace.traceEnd(j3);
                        return;
                    } catch (Throwable th7) {
                        e = th7;
                        z = false;
                        createdAppId = createdAppId2;
                        prepareResults = prepareResults2;
                        preparedScans = preparedScans2;
                        j = 262144;
                        if (!success) {
                            for (ScanResult result8 : preparedScans.values()) {
                                if (createdAppId.getOrDefault(result8.request.pkg.packageName, Boolean.valueOf(z)).booleanValue()) {
                                    cleanUpAppIdCreation(result8);
                                }
                            }
                            for (InstallRequest request6 : requests) {
                                if (request6.installResult.returnCode == 1) {
                                    PackageInstalledInfo packageInstalledInfo3 = request6.installResult;
                                    int i11 = z ? 1 : 0;
                                    int i12 = z ? 1 : 0;
                                    int i13 = z ? 1 : 0;
                                    int i14 = z ? 1 : 0;
                                    int i15 = z ? 1 : 0;
                                    int i16 = z ? 1 : 0;
                                    int i17 = z ? 1 : 0;
                                    int i18 = z ? 1 : 0;
                                    int i19 = z ? 1 : 0;
                                    int i20 = z ? 1 : 0;
                                    int i21 = z ? 1 : 0;
                                    int i22 = z ? 1 : 0;
                                    packageInstalledInfo3.returnCode = i11;
                                }
                            }
                        }
                        for (PrepareResult result9 : prepareResults.values()) {
                            if (result9.freezer != null) {
                                result9.freezer.close();
                            }
                        }
                        Trace.traceEnd(j);
                        throw e;
                    }
                } catch (PackageManagerException e8) {
                    e2 = e8;
                    lastStaticSharedLibSettings = lastStaticSharedLibSettings2;
                    installResults = installResults2;
                    installArgs = installArgs2;
                    z = false;
                    i = 1;
                    j3 = 262144;
                    request = request2;
                    request.installResult.setError("Scanning Failed.", e2);
                    if (0 == 0) {
                    }
                    while (r1.hasNext()) {
                    }
                    Trace.traceEnd(j3);
                    return;
                } catch (Throwable th8) {
                    e = th8;
                    map = lastStaticSharedLibSettings2;
                    z = false;
                    createdAppId = createdAppId2;
                    prepareResults = prepareResults2;
                    preparedScans = preparedScans2;
                    j = 262144;
                    if (!success) {
                    }
                    while (r1.hasNext()) {
                    }
                    Trace.traceEnd(j);
                    throw e;
                }
            }
            z = false;
            z = false;
            z = false;
            try {
                createdAppId = createdAppId2;
                prepareResults = prepareResults2;
                preparedScans = preparedScans2;
                try {
                    ReconcileRequest reconcileRequest = new ReconcileRequest(preparedScans2, installArgs2, installResults2, prepareResults, this.mSharedLibraries, Collections.unmodifiableMap(this.mPackages), versionInfos, lastStaticSharedLibSettings2);
                    synchronized (this.mPackages) {
                        j = j4;
                        try {
                            Trace.traceBegin(j, "reconcilePackages");
                            Map<String, ReconciledPackage> reconciledPackages = reconcilePackagesLocked(reconcileRequest, this.mSettings.mKeySetManagerService);
                            try {
                                Trace.traceBegin(j, "commitPackages");
                                commitRequest = new CommitRequest(reconciledPackages, sUserManager.getUserIds());
                                commitPackagesLocked(commitRequest);
                                success = true;
                                for (PrepareResult result10 : prepareResults.values()) {
                                    if (result10.freezer != null) {
                                        result10.freezer.close();
                                    }
                                }
                                Trace.traceEnd(j);
                            } catch (Throwable th9) {
                                for (PrepareResult result11 : prepareResults.values()) {
                                    if (result11.freezer != null) {
                                        result11.freezer.close();
                                    }
                                }
                                Trace.traceEnd(j);
                                throw th9;
                            }
                        } catch (ReconcileFailure e9) {
                            for (InstallRequest request7 : requests) {
                                request7.installResult.setError("Reconciliation failed...", e9);
                            }
                            if (0 == 0) {
                                for (ScanResult result12 : preparedScans.values()) {
                                    if (createdAppId.getOrDefault(result12.request.pkg.packageName, false).booleanValue()) {
                                        cleanUpAppIdCreation(result12);
                                    }
                                }
                                for (InstallRequest request8 : requests) {
                                    if (request8.installResult.returnCode == 1) {
                                        request8.installResult.returnCode = 0;
                                    }
                                }
                            }
                            for (PrepareResult result13 : prepareResults.values()) {
                                if (result13.freezer != null) {
                                    result13.freezer.close();
                                }
                            }
                            return;
                        } finally {
                            Trace.traceEnd(j);
                        }
                    }
                } catch (Throwable th10) {
                    e = th10;
                    j = j4;
                    if (!success) {
                    }
                    while (r1.hasNext()) {
                    }
                    Trace.traceEnd(j);
                    throw e;
                }
            } catch (Throwable th11) {
                e = th11;
                createdAppId = createdAppId2;
                prepareResults = prepareResults2;
                preparedScans = preparedScans2;
                j = j4;
                if (!success) {
                }
                while (r1.hasNext()) {
                }
                Trace.traceEnd(j);
                throw e;
            }
            try {
                executePostCommitSteps(commitRequest);
                if (1 == 0) {
                    for (ScanResult result14 : preparedScans.values()) {
                        if (createdAppId.getOrDefault(result14.request.pkg.packageName, false).booleanValue()) {
                            cleanUpAppIdCreation(result14);
                        }
                    }
                    for (InstallRequest request9 : requests) {
                        if (request9.installResult.returnCode == i2) {
                            request9.installResult.returnCode = 0;
                        }
                    }
                }
                for (PrepareResult result15 : prepareResults.values()) {
                    if (result15.freezer != null) {
                        result15.freezer.close();
                    }
                }
                Trace.traceEnd(j);
            } catch (Throwable th12) {
                e = th12;
                if (!success) {
                }
                while (r1.hasNext()) {
                }
                Trace.traceEnd(j);
                throw e;
            }
        } catch (Throwable th13) {
            e = th13;
            createdAppId = createdAppId2;
            prepareResults = prepareResults2;
            preparedScans = preparedScans2;
            z = false;
            j = 262144;
            if (!success) {
            }
            while (r1.hasNext()) {
            }
            Trace.traceEnd(j);
            throw e;
        }
    }

    private void executePostCommitSteps(CommitRequest commitRequest) {
        DexoptOptions dexoptOptions;
        for (ReconciledPackage reconciledPkg : commitRequest.reconciledPackages.values()) {
            boolean instantApp = (reconciledPkg.scanResult.request.scanFlags & 16384) != 0;
            PackageParser.Package pkg = reconciledPkg.pkgSetting.pkg;
            String packageName = pkg.packageName;
            prepareAppDataAfterInstallLIF(pkg);
            if (reconciledPkg.prepareResult.clearCodeCache) {
                clearAppDataLIF(pkg, -1, 39);
            }
            if (reconciledPkg.prepareResult.replace) {
                this.mDexManager.notifyPackageUpdated(pkg.packageName, pkg.baseCodePath, pkg.splitCodePaths);
                OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).createProfile(pkg);
            }
            this.mArtManagerService.prepareAppProfiles(pkg, resolveUserIds(reconciledPkg.installArgs.user.getIdentifier()), true);
            boolean isPrecompileEnable = OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).isPrecompileEnable();
            boolean mergeProfileResult = isPrecompileEnable ? OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).mergeProfile(pkg) : false;
            if ((!instantApp || Settings.Global.getInt(this.mContext.getContentResolver(), "instant_app_dexopt_enabled", 0) != 0) && (pkg.applicationInfo.flags & 2) == 0) {
                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {
                    Trace.traceBegin(262144, "compileLayouts");
                    this.mViewCompiler.compileLayouts(pkg);
                    Trace.traceEnd(262144);
                }
                Trace.traceBegin(262144, "dexopt");
                if (pkg.packageName == null || !ActivityThread.inCptWhiteList((int) CompatibilityHelper.FORCE_ADD_APACHE_AND_LOAD_WITHOUT_SPEED_PROFILE, pkg.packageName)) {
                    dexoptOptions = new DexoptOptions(pkg.packageName, 2, (int) UsbTerminalTypes.TERMINAL_BIDIR_SKRPHONE_SUPRESS);
                } else {
                    Slog.w(TAG, "use special dexOpt reason for pkg.packageName:" + pkg.packageName);
                    dexoptOptions = new DexoptOptions(pkg.packageName, 1, (int) UsbTerminalTypes.TERMINAL_BIDIR_SKRPHONE_SUPRESS);
                }
                this.mPackageDexOptimizer.performDexOpt(pkg, null, getOrCreateCompilerPackageStats(pkg), this.mDexManager.getPackageUseInfoOrDefault(packageName), dexoptOptions);
                if (mergeProfileResult) {
                    OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).recordCompiledApp(pkg.packageName);
                } else {
                    OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).removeCompiledApp(pkg.packageName);
                }
                Trace.traceEnd(262144);
            }
            if (!isPrecompileEnable && OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).mergeProfile(pkg)) {
                OppoFeatureCache.get(IColorDexMetadataManager.DEFAULT).registerToCompile(pkg.packageName);
            }
            BackgroundDexOptService.notifyPackageChanged(packageName);
        }
    }

    /* access modifiers changed from: private */
    public static class PrepareResult {
        public final PackageSetting[] childPackageSettings;
        public final boolean clearCodeCache;
        public final PackageSetting disabledPs;
        public final PackageParser.Package existingPackage;
        public final PackageFreezer freezer;
        public final int installReason;
        public final String installerPackageName;
        public final PackageSetting originalPs;
        public final PackageParser.Package packageToScan;
        public final int parseFlags;
        public final String renamedPackage;
        public final boolean replace;
        public final int scanFlags;
        public final boolean system;
        public final UserHandle user;
        public final String volumeUuid;

        private PrepareResult(int installReason2, String volumeUuid2, String installerPackageName2, UserHandle user2, boolean replace2, int scanFlags2, int parseFlags2, PackageParser.Package existingPackage2, PackageParser.Package packageToScan2, boolean clearCodeCache2, boolean system2, String renamedPackage2, PackageFreezer freezer2, PackageSetting originalPs2, PackageSetting disabledPs2, PackageSetting[] childPackageSettings2) {
            this.installReason = installReason2;
            this.volumeUuid = volumeUuid2;
            this.installerPackageName = installerPackageName2;
            this.user = user2;
            this.replace = replace2;
            this.scanFlags = scanFlags2;
            this.parseFlags = parseFlags2;
            this.existingPackage = existingPackage2;
            this.packageToScan = packageToScan2;
            this.clearCodeCache = clearCodeCache2;
            this.system = system2;
            this.renamedPackage = renamedPackage2;
            this.freezer = freezer2;
            this.originalPs = originalPs2;
            this.disabledPs = disabledPs2;
            this.childPackageSettings = childPackageSettings2;
        }
    }

    /* access modifiers changed from: private */
    public static class PrepareFailure extends PackageManagerException {
        public String conflictingPackage;
        public String conflictingPermission;

        PrepareFailure(int error) {
            super(error, "Failed to prepare for install.");
        }

        PrepareFailure(int error, String detailMessage) {
            super(error, detailMessage);
        }

        /* JADX WARNING: Illegal instructions before constructor call */
        PrepareFailure(String message, Exception e) {
            super(r0, ExceptionUtils.getCompleteMessage(message, e));
            int i;
            if (e instanceof PackageParser.PackageParserException) {
                i = ((PackageParser.PackageParserException) e).error;
            } else {
                i = ((PackageManagerException) e).error;
            }
        }

        /* access modifiers changed from: package-private */
        public PrepareFailure conflictsWithExistingPermission(String conflictingPermission2, String conflictingPackage2) {
            this.conflictingPermission = conflictingPermission2;
            this.conflictingPackage = conflictingPackage2;
            return this;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:395:0x0a06, code lost:
        if (r4 == false) goto L_0x0a48;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:396:0x0a08, code lost:
        if (r5 != false) goto L_0x0a3e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:397:0x0a0a, code lost:
        if (r5 != false) goto L_0x0a34;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:398:0x0a0c, code lost:
        if (r9 == false) goto L_0x0a48;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:400:?, code lost:
        assertCodePolicy(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:403:0x0a32, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-2, "Package " + r10.baseCodePath + " code is missing");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:405:0x0a3d, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-116, "Cannot update a system app with an instant app");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:407:0x0a47, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-19, "Cannot install updates to system apps on sdcard");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:409:0x0a4c, code lost:
        if (r49.move == null) goto L_0x0aa0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:410:0x0a4e, code lost:
        r1 = (r8 | 1) | 256;
        r15 = r48;
        r5 = r15.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:411:0x0a57, code lost:
        monitor-enter(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:414:0x0a5c, code lost:
        r14 = r34;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:416:?, code lost:
        r6 = r15.mSettings.mPackages.get(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:417:0x0a64, code lost:
        if (r6 != null) goto L_0x0a7d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:419:0x0a77, code lost:
        r13 = r50;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:421:?, code lost:
        r13.setError(-110, "Missing settings for moved package " + r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:422:0x0a7d, code lost:
        r13 = r50;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:423:0x0a7f, code lost:
        r10.applicationInfo.primaryCpuAbi = r6.primaryCpuAbiString;
        r10.applicationInfo.secondaryCpuAbi = r6.secondaryCpuAbiString;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:424:0x0a8b, code lost:
        monitor-exit(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:425:0x0a8c, code lost:
        r11 = r31;
        r8 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:426:0x0a91, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:428:0x0a95, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:429:0x0a96, code lost:
        r3 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:430:0x0a9b, code lost:
        monitor-exit(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:431:0x0a9c, code lost:
        throw r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:432:0x0a9d, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:433:0x0a9e, code lost:
        r3 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:434:0x0aa0, code lost:
        r15 = r48;
        r13 = r50;
        r14 = r34;
        r5 = r8 | 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:437:0x0aaf, code lost:
        if (android.text.TextUtils.isEmpty(r10.cpuAbiOverride) == false) goto L_0x0aca;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:439:?, code lost:
        r1 = r49.abiOverride;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:440:0x0ab4, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:441:0x0ab5, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:442:0x0aca, code lost:
        r1 = r10.cpuAbiOverride;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:444:0x0ad0, code lost:
        if (r10.isLibrary() != false) goto L_0x0ad4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:445:0x0ad2, code lost:
        r6 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:446:0x0ad4, code lost:
        r6 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:447:0x0ad5, code lost:
        derivePackageAbi(r10, r1, r6);
        r11 = r31;
        r8 = r32;
        android.common.OppoFeatureCache.get(com.android.server.pm.IColorInstallThreadsControlManager.DEFAULT).updateOdexThreads(r8, r11);
        r1 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:449:0x0aef, code lost:
        if (r49.doRename(r13.returnCode, r10) == false) goto L_0x1288;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:451:?, code lost:
        r15.setUpFsVerityIfPossible(r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:452:0x0af5, code lost:
        if (r5 != false) goto L_0x0b01;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:453:0x0af7, code lost:
        r15.startIntentFilterVerifications(r49.user.getIdentifier(), r9, r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:455:0x0b03, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_0x0b1b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:456:0x0b05, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "Not verifying instant app install for app links: " + r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:457:0x0b1b, code lost:
        r3 = r15.freezePackageForInstall(r14, r11, "installPackageLI");
        r26 = r28;
        r31 = r1;
        r32 = r27;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:458:0x0b2e, code lost:
        if (r9 == false) goto L_0x10f5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:459:0x0b30, code lost:
        r26 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:462:0x0b38, code lost:
        if (r10.applicationInfo.isStaticSharedLibrary() == false) goto L_0x0b9b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:465:0x0b3c, code lost:
        r35 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:467:?, code lost:
        r4 = r15.mPackages.get(r10.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:468:0x0b46, code lost:
        if (r4 == null) goto L_0x0b64;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:470:0x0b52, code lost:
        if (r4.getLongVersionCode() != r10.getLongVersionCode()) goto L_0x0b57;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:471:0x0b54, code lost:
        r37 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:473:0x0b63, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-5, "Packages declaring static-shared libs cannot be updated");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:474:0x0b64, code lost:
        r37 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:475:0x0b69, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:476:0x0b6a, code lost:
        r30 = r3;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:477:0x0b81, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:478:0x0b82, code lost:
        r35 = true;
        r30 = r3;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:479:0x0b9b, code lost:
        r35 = true;
        r37 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:481:0x0ba1, code lost:
        if ((r1 & 16384) == 0) goto L_0x0ba5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:482:0x0ba3, code lost:
        r4 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:483:0x0ba5, code lost:
        r4 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:485:?, code lost:
        r5 = r10.packageName;
        android.common.OppoFeatureCache.get(com.android.server.pm.IColorDexMetadataManager.DEFAULT).dumpProfile(r15.mPackages.get(r5));
        r7 = r15.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:486:0x0bc1, code lost:
        monitor-enter(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:489:?, code lost:
        r6 = r15.mPackages.get(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:490:0x0bd0, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x0c2e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:491:0x0bd2, code lost:
        r40 = r8;
        r41 = r9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:493:?, code lost:
        r9 = new java.lang.StringBuilder();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:494:0x0bdd, code lost:
        r42 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:496:?, code lost:
        r9.append("replacePackageLI: new=");
        r9.append(r10);
        r9.append(", old=");
        r9.append(r6);
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, r9.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:497:0x0bf8, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:498:0x0bf9, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:499:0x0c08, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:500:0x0c09, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:501:0x0c2e, code lost:
        r40 = r8;
        r41 = r9;
        r42 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:503:?, code lost:
        r8 = r15.mSettings.mPackages.get(r5);
        r9 = r15.mSettings.getDisabledSystemPkgLPr(r8);
        r11 = r15.mSettings.mKeySetManagerService;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:504:0x0c4c, code lost:
        if (r11.shouldCheckUpgradeKeySetLocked(r8, r1) == false) goto L_0x0c8a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:507:0x0c52, code lost:
        if (r11.checkUpgradeKeySetLocked(r8, r10) == false) goto L_0x0c5c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:508:0x0c54, code lost:
        r43 = r9;
        r45 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:509:0x0c5c, code lost:
        r11 = new java.lang.StringBuilder();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:512:?, code lost:
        r11.append("New package not signed by keys specified by upgrade-keysets: ");
        r11.append(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:513:0x0c79, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-7, r11.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:514:0x0c7a, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:515:0x0c7b, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:516:0x0c8a, code lost:
        r43 = r9;
        r45 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:519:0x0c99, code lost:
        if (r10.mSigningDetails.checkCapability(r6.mSigningDetails, 1) != false) goto L_0x0cce;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:521:0x0ca5, code lost:
        if (r6.mSigningDetails.checkCapability(r10.mSigningDetails, 8) == false) goto L_0x0ca8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:523:0x0cbf, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-7, "New package has a different signature: " + r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:524:0x0cc0, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:525:0x0cc1, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:527:0x0cd0, code lost:
        if (r6.restrictUpdateHash == null) goto L_0x0d77;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:530:0x0cd6, code lost:
        if (r6.isSystem() == false) goto L_0x0d77;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:533:?, code lost:
        r9 = java.security.MessageDigest.getInstance("SHA-512");
        updateDigest(r9, new java.io.File(r10.baseCodePath));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:534:0x0cee, code lost:
        if (com.android.internal.util.ArrayUtils.isEmpty(r10.splitCodePaths) != false) goto L_0x0d11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:535:0x0cf0, code lost:
        r11 = r10.splitCodePaths;
        r12 = r11.length;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:536:0x0cf3, code lost:
        r18 = r14;
        r14 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:537:0x0cf6, code lost:
        if (r14 >= r12) goto L_0x0d13;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:539:?, code lost:
        updateDigest(r9, new java.io.File(r11[r14]));
        r14 = r14 + 1;
        r11 = r11;
        r12 = r12;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:540:0x0d11, code lost:
        r18 = r14;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:545:0x0d1f, code lost:
        if (java.util.Arrays.equals(r6.restrictUpdateHash, r9.digest()) == false) goto L_0x0d26;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:546:0x0d21, code lost:
        r10.restrictUpdateHash = r6.restrictUpdateHash;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:548:0x0d3d, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-2, "New package fails restrict-update check: " + r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:554:0x0d5c, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-2, "Could not compute hash: " + r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:555:0x0d5d, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:556:0x0d5e, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:557:0x0d69, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:558:0x0d6a, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:559:0x0d77, code lost:
        r18 = r14;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:561:?, code lost:
        r9 = r15.getParentOrChildPackageChangedSharedUser(r6, r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:562:0x0d7e, code lost:
        if (r9 != null) goto L_0x1045;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:563:0x0d80, code lost:
        r11 = com.android.server.pm.PackageManagerService.sUserManager.getUserIds();
        r14 = r8.queryInstalledUsers(r11, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:565:0x0d8c, code lost:
        if (r4 == false) goto L_0x0e35;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:568:0x0d90, code lost:
        if (r49.user == null) goto L_0x0de8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:571:0x0d9b, code lost:
        if (r49.user.getIdentifier() != -1) goto L_0x0da0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:572:0x0d9d, code lost:
        r30 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:575:0x0daa, code lost:
        if (r8.getInstantApp(r49.user.getIdentifier()) == false) goto L_0x0db0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:576:0x0dac, code lost:
        r30 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:577:0x0db0, code lost:
        r14 = new java.lang.StringBuilder();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:580:?, code lost:
        r14.append("Can't replace full app with instant app: ");
        r14.append(r5);
        r14.append(" for user: ");
        r14.append(r49.user.getIdentifier());
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, r14.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:581:0x0ddd, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-116);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:582:0x0dde, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:583:0x0ddf, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:584:0x0de8, code lost:
        r30 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:585:0x0dec, code lost:
        r3 = r11.length;
        r4 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:586:0x0dee, code lost:
        if (r4 >= r3) goto L_0x0e39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:587:0x0df0, code lost:
        r14 = r11[r4];
     */
    /* JADX WARNING: Code restructure failed: missing block: B:588:0x0df6, code lost:
        if (r8.getInstantApp(r14) == false) goto L_0x0dfb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:589:0x0df8, code lost:
        r4 = r4 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:590:0x0dfb, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Can't replace full app with instant app: " + r5 + " for user: " + r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:591:0x0e20, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-116);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:592:0x0e21, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:593:0x0e22, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:594:0x0e29, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:595:0x0e2a, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:596:0x0e35, code lost:
        r30 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:598:?, code lost:
        monitor-exit(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:600:?, code lost:
        r13.removedInfo = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r15);
        r13.removedInfo.uid = r6.applicationInfo.uid;
        r13.removedInfo.removedPackage = r6.packageName;
        r13.removedInfo.installerPackageName = r8.installerPackageName;
        r2 = r13.removedInfo;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:601:0x0e59, code lost:
        if (r10.staticSharedLibName == null) goto L_0x0e5d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:602:0x0e5b, code lost:
        r3 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:603:0x0e5d, code lost:
        r3 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:604:0x0e5e, code lost:
        r2.isStaticSharedLib = r3;
        r13.removedInfo.isUpdate = true;
        r13.removedInfo.origUsers = r14;
        r13.removedInfo.installReasons = new android.util.SparseArray<>(r14.length);
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:606:0x0e76, code lost:
        if (r3 >= r14.length) goto L_0x0ea0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:608:?, code lost:
        r2 = r14[r3];
        r13.removedInfo.installReasons.put(r2, java.lang.Integer.valueOf(r8.getInstallReason(r2)));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:609:0x0e89, code lost:
        r3 = r3 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:610:0x0e8c, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:611:0x0e8d, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:612:0x0ea0, code lost:
        r2 = r15.mSettings.getChildSettingsLPr(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:613:0x0ea6, code lost:
        if (r2 == null) goto L_0x0f52;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:614:0x0ea8, code lost:
        r3 = r2.length;
        r4 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:615:0x0eaa, code lost:
        if (r4 >= r3) goto L_0x0f4b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:616:0x0eac, code lost:
        r7 = r2[r4];
        r9 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:617:0x0eaf, code lost:
        if (r7 != null) goto L_0x0eb3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:618:0x0eb1, code lost:
        r14 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:619:0x0eb3, code lost:
        r14 = r7.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:621:0x0eb9, code lost:
        if (r13.addedChildPackages == null) goto L_0x0ef3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:622:0x0ebb, code lost:
        r19 = r3;
        r2 = r13.addedChildPackages.get(r14.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:623:0x0ec7, code lost:
        if (r2 == null) goto L_0x0ef0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:624:0x0ec9, code lost:
        r34 = r5;
        r2.removedInfo.uid = r14.applicationInfo.uid;
        r2.removedInfo.removedPackage = r14.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:625:0x0ed9, code lost:
        if (r7 == null) goto L_0x0ee1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:626:0x0edb, code lost:
        r2.removedInfo.installerPackageName = r7.installerPackageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:627:0x0ee1, code lost:
        r2.removedInfo.isUpdate = true;
        r2.removedInfo.installReasons = r13.removedInfo.installReasons;
        r9 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:628:0x0ef0, code lost:
        r34 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:629:0x0ef3, code lost:
        r19 = r3;
        r34 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:630:0x0ef7, code lost:
        if (r9 != false) goto L_0x0f3d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:631:0x0ef9, code lost:
        r2 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r15);
        r2.removedPackage = r14.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:632:0x0f02, code lost:
        if (r7 == null) goto L_0x0f08;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:633:0x0f04, code lost:
        r2.installerPackageName = r7.installerPackageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:634:0x0f08, code lost:
        r2.isUpdate = false;
        r2.dataRemoved = true;
        r5 = r15.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:635:0x0f10, code lost:
        monitor-enter(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:636:0x0f11, code lost:
        if (r7 == null) goto L_0x0f1d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:637:0x0f13, code lost:
        r46 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:639:?, code lost:
        r2.origUsers = r7.queryInstalledUsers(r11, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:640:0x0f1d, code lost:
        r46 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:641:0x0f1f, code lost:
        monitor-exit(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:643:0x0f24, code lost:
        if (r13.removedInfo.removedChildPackages != null) goto L_0x0f2f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:644:0x0f26, code lost:
        r13.removedInfo.removedChildPackages = new android.util.ArrayMap<>();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:645:0x0f2f, code lost:
        r13.removedInfo.removedChildPackages.put(r14.packageName, r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:650:0x0f3d, code lost:
        r46 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:651:0x0f3f, code lost:
        r4 = r4 + 1;
        r2 = r2;
        r3 = r19;
        r5 = r34;
        r8 = r46;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:652:0x0f4b, code lost:
        r17 = r2;
        r46 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:653:0x0f52, code lost:
        r17 = r2;
        r46 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:654:0x0f58, code lost:
        r2 = isSystemApp(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:655:0x0f5c, code lost:
        if (r2 == false) goto L_0x0fe6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:656:0x0f5e, code lost:
        r3 = isPrivilegedApp(r6);
        r4 = isOemApp(r6);
        r5 = isVendorApp(r6);
        r7 = isProductApp(r6);
        r8 = isOdmApp(r6);
        r14 = 131072 | r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:657:0x0f77, code lost:
        if (r3 == false) goto L_0x0f7c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:658:0x0f79, code lost:
        r19 = 262144;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:659:0x0f7c, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:660:0x0f7e, code lost:
        r14 = r14 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:661:0x0f80, code lost:
        if (r4 == false) goto L_0x0f85;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:662:0x0f82, code lost:
        r19 = 524288;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:663:0x0f85, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:664:0x0f87, code lost:
        r14 = r14 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:665:0x0f89, code lost:
        if (r5 == false) goto L_0x0f8e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:666:0x0f8b, code lost:
        r19 = 1048576;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:667:0x0f8e, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:668:0x0f90, code lost:
        r14 = r14 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:669:0x0f92, code lost:
        if (r7 == false) goto L_0x0f97;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:670:0x0f94, code lost:
        r19 = 2097152;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:671:0x0f97, code lost:
        r19 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:672:0x0f99, code lost:
        r14 = r14 | r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:673:0x0f9b, code lost:
        if (r8 == false) goto L_0x0fa0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:674:0x0f9d, code lost:
        r16 = 8388608;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:675:0x0fa0, code lost:
        r16 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:676:0x0fa2, code lost:
        r14 = r14 | r16;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:677:0x0fa6, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x0fce;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:678:0x0fa8, code lost:
        r16 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:680:?, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "replaceSystemPackageLI: new=" + r10 + ", old=" + r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:681:0x0fce, code lost:
        r16 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:682:0x0fd4, code lost:
        r13.setReturnCode(1);
        r10.setApplicationInfoFlags(128, 128);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:683:0x0fdf, code lost:
        r32 = r27;
        r31 = r14;
        r9 = r41;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:684:0x0fe6, code lost:
        r16 = r2;
        r9 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:687:0x0fed, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x100e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:688:0x0fef, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "replaceNonSystemPackageLI: new=" + r10 + ", old=" + r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:689:0x100e, code lost:
        r1 = r6.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:690:0x1015, code lost:
        if (r10.mExtras == null) goto L_0x101e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:691:0x1017, code lost:
        r7 = ((com.android.server.pm.PackageSetting) r10.mExtras).lastUpdateTime;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:692:0x101e, code lost:
        r1 = r9;
        r38 = r16;
        r2 = r17;
        r4 = r6;
        r3 = r43;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:693:0x1029, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:694:0x102a, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:695:0x103d, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:696:0x103e, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:700:0x1070, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-8, "Package " + r9 + " tried to change user " + r6.mSharedUserId);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:701:0x1071, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:702:0x1072, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:703:0x107c, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:704:0x107d, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:705:0x1089, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:706:0x108a, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:707:0x1098, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:708:0x1099, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:709:0x10ac, code lost:
        monitor-exit(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:710:0x10ad, code lost:
        throw r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:711:0x10ae, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:712:0x10af, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:713:0x10c0, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:714:0x10c1, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:715:0x10c3, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:716:0x10c4, code lost:
        r30 = r3;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:717:0x10db, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:718:0x10dc, code lost:
        r30 = r3;
        r35 = true;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:719:0x10f5, code lost:
        r30 = r3;
        r35 = true;
        r38 = false;
        r40 = r8;
        r42 = r11;
        r45 = r5;
        r18 = r14;
        r2 = null;
        r3 = null;
        r4 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:721:?, code lost:
        r5 = r10.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:722:0x1112, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x1140;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:723:0x1114, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "installNewPackageLI: " + r10);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:724:0x112c, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:725:0x112d, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:726:0x1140, code lost:
        r6 = r15.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:727:0x1142, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:729:?, code lost:
        r7 = r15.mSettings.getRenamedPackageLPr(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:730:0x1149, code lost:
        if (r7 != null) goto L_0x11f6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:733:0x1151, code lost:
        if (r15.mPackages.containsKey(r5) != false) goto L_0x11b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:734:0x1153, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:735:0x1154, code lost:
        r46 = null;
        r37 = r7;
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:741:?, code lost:
        r35 = new com.android.server.pm.PackageManagerService.PrepareResult(r49.installReason, r26, r40, r49.user, r1, r31, r32, r4, r10, r1, r38, r37, r30, r46, r3, r2, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:742:0x1194, code lost:
        if (0 == 0) goto L_0x1199;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:743:0x1196, code lost:
        r30.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:744:0x1199, code lost:
        return r35;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:745:0x119a, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:746:0x119b, code lost:
        r35 = false;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:747:0x11a2, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:748:0x11a3, code lost:
        r35 = false;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:752:0x11e2, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-1, "Attempt to re-install " + r5 + " without first uninstalling.");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:753:0x11e3, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:754:0x11e4, code lost:
        r7 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:756:0x1223, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-1, "Attempt to re-install " + r5 + " without first uninstalling package running as " + r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:757:0x1224, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:758:0x1225, code lost:
        r7 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:759:0x1229, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:760:0x122a, code lost:
        r7 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:762:?, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:764:?, code lost:
        throw r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:765:0x123b, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:766:0x123c, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:767:0x1240, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:768:0x1241, code lost:
        r7 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:769:0x1243, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:770:0x1244, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:771:0x1255, code lost:
        if (r35 != false) goto L_0x1257;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:772:0x1257, code lost:
        r30.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:773:0x125a, code lost:
        throw r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:774:0x125b, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:776:0x1287, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-110, "Failed to set up verity: " + r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:778:0x1292, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-4, "Failed rename");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:779:0x1293, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:780:0x1294, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:781:0x12a7, code lost:
        android.util.Slog.e(com.android.server.pm.PackageManagerService.TAG, "Error deriving application ABI", r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:782:0x12b5, code lost:
        throw new com.android.server.pm.PackageManagerService.PrepareFailure(-110, "Error deriving application ABI");
     */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Removed duplicated region for block: B:216:0x0504 A[Catch:{ all -> 0x0636 }] */
    /* JADX WARNING: Removed duplicated region for block: B:250:0x05ee A[Catch:{ all -> 0x0559, all -> 0x0620 }] */
    /* JADX WARNING: Removed duplicated region for block: B:282:0x06da A[SYNTHETIC, Splitter:B:282:0x06da] */
    /* JADX WARNING: Removed duplicated region for block: B:300:0x0744  */
    /* JADX WARNING: Removed duplicated region for block: B:772:0x1257  */
    @GuardedBy({"mInstallLock"})
    private PrepareResult preparePackageLI(InstallArgs args, PackageInstalledInfo res) throws PrepareFailure {
        Throwable th;
        Exception exc;
        String volumeUuid;
        int parseFlags;
        File tmpPackageFile;
        Exception exc2;
        Throwable th2;
        boolean systemApp;
        String pkgName;
        PackageSetting ps;
        String pkgName2;
        String installerPackageName;
        int installFlags;
        boolean systemApp2;
        PackageSetting ps2;
        int N;
        boolean sigsOk;
        PackageSetting signatureCheckPs;
        KeySetManagerService ksms;
        PackageManagerException e;
        PackageSetting signatureCheckPs2;
        boolean replace;
        String pkgName3;
        Throwable th3;
        String volumeUuid2;
        PackageManagerService packageManagerService = this;
        int installFlags2 = args.installFlags;
        String installerPackageName2 = args.installerPackageName;
        String volumeUuid3 = args.volumeUuid;
        File tmpPackageFile2 = new File(args.getCodePath());
        boolean onExternal = args.volumeUuid != null;
        boolean instantApp = (installFlags2 & 2048) != 0;
        boolean fullApp = (installFlags2 & 16384) != 0;
        boolean virtualPreload = (installFlags2 & 65536) != 0;
        int scanFlags = 6;
        if (args.move != null) {
            scanFlags = 6 | 512;
        }
        if ((installFlags2 & 4096) != 0) {
            scanFlags |= 2048;
        }
        if (instantApp) {
            scanFlags |= 16384;
        }
        if (fullApp) {
            scanFlags |= 32768;
        }
        if (virtualPreload) {
            scanFlags |= 65536;
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile2);
        }
        if (!instantApp || !onExternal) {
            int parseFlags2 = (onExternal ? 8 : 0) | packageManagerService.mDefParseFlags | Integer.MIN_VALUE | 64;
            PackageParser pp = new PackageParser();
            pp.setSeparateProcesses(packageManagerService.mSeparateProcesses);
            pp.setDisplayMetrics(packageManagerService.mMetrics);
            pp.setCallback(packageManagerService.mPackageParserCallback);
            Trace.traceBegin(262144, "parsePackage");
            try {
                PackageParser.Package pkg = pp.parsePackage(tmpPackageFile2, parseFlags2);
                if (isCustomApiSupported) {
                    try {
                        OppoCutomizeManagerInternal customizeMgr = getOppoCutomizeManagerInternal();
                        if (customizeMgr != null && customizeMgr.getAllInstallSysAppList().contains(pkg.applicationInfo.packageName)) {
                            pkg.applicationInfo.flags |= 1;
                            if (customizeMgr.getPrivInstallSysAppList().contains(pkg.applicationInfo.packageName)) {
                                pkg.applicationInfo.privateFlags |= 8;
                            }
                        }
                    } catch (PackageParser.PackageParserException e2) {
                        exc = e2;
                        try {
                            throw new PrepareFailure("Failed parse during installPackageLI", exc);
                        } catch (Throwable th4) {
                            th = th4;
                            Trace.traceEnd(262144);
                            throw th;
                        }
                    } catch (Throwable th5) {
                        th = th5;
                        Trace.traceEnd(262144);
                        throw th;
                    }
                }
                DexMetadataHelper.validatePackageDexMetadata(pkg);
                Trace.traceEnd(262144);
                if (instantApp) {
                    if (pkg.applicationInfo.targetSdkVersion < 26) {
                        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target at least O");
                        throw new PrepareFailure(-116, "Instant app package must target at least O");
                    } else if (pkg.mSharedUserId != null) {
                        Slog.w(TAG, "Instant app package " + pkg.packageName + " may not declare sharedUserId.");
                        throw new PrepareFailure(-116, "Instant app package may not declare a sharedUserId");
                    }
                }
                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    renameStaticSharedLibraryPackage(pkg);
                    if (onExternal) {
                        Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
                        throw new PrepareFailure(-19, "Packages declaring static-shared libs cannot be updated");
                    }
                }
                mCompatibilityHelper.customizePackageIfNeeded(pkg);
                if (pkg.childPackages != null) {
                    synchronized (packageManagerService.mPackages) {
                        try {
                            int childCount = pkg.childPackages.size();
                            int i = 0;
                            while (i < childCount) {
                                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i);
                                PackageInstalledInfo childRes = new PackageInstalledInfo();
                                try {
                                    childRes.setReturnCode(1);
                                    childRes.pkg = childPkg;
                                    childRes.name = childPkg.packageName;
                                    try {
                                        PackageSetting childPs = packageManagerService.mSettings.getPackageLPr(childPkg.packageName);
                                        if (childPs != null) {
                                            volumeUuid2 = volumeUuid3;
                                            childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                                        } else {
                                            volumeUuid2 = volumeUuid3;
                                        }
                                        if (packageManagerService.mPackages.containsKey(childPkg.packageName)) {
                                            childRes.removedInfo = new PackageRemovedInfo(packageManagerService);
                                            childRes.removedInfo.removedPackage = childPkg.packageName;
                                            childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                                        }
                                        if (res.addedChildPackages == null) {
                                            res.addedChildPackages = new ArrayMap<>();
                                        }
                                        res.addedChildPackages.put(childPkg.packageName, childRes);
                                        i++;
                                        childCount = childCount;
                                        tmpPackageFile2 = tmpPackageFile2;
                                        pp = pp;
                                        parseFlags2 = parseFlags2;
                                        volumeUuid3 = volumeUuid2;
                                    } catch (Throwable th6) {
                                        th3 = th6;
                                        throw th3;
                                    }
                                } catch (Throwable th7) {
                                    th3 = th7;
                                    throw th3;
                                }
                            }
                            parseFlags = parseFlags2;
                            tmpPackageFile = tmpPackageFile2;
                            volumeUuid = volumeUuid3;
                        } catch (Throwable th8) {
                            th3 = th8;
                            throw th3;
                        }
                    }
                } else {
                    parseFlags = parseFlags2;
                    tmpPackageFile = tmpPackageFile2;
                    volumeUuid = volumeUuid3;
                }
                if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
                    pkg.cpuAbiOverride = args.abiOverride;
                }
                String pkgName4 = pkg.packageName;
                res.name = pkgName4;
                if (TemperatureProvider.SWITCH_ON.equals(SystemProperties.get("persist.version.confidential"))) {
                    if (!packageManagerService.getImeiNumber(packageManagerService.mContext)) {
                        Slog.d(TAG, "install fail because not write IMEI ");
                        if (NoFocusWindow.HUNG_CONFIG_ENABLE.equals(SystemProperties.get("SPECIAL_OPPO_CONFIG"))) {
                            Slog.d(TAG, "SPECIAL_OPPO_CONFIG version");
                        } else {
                            Slog.d(TAG, "Please write IMEI number!!!");
                        }
                        res.returnCode = -15;
                        throw new PrepareFailure(-15, "Please write IMEI number!!! or Release Confidential");
                    } else if (packageManagerService.inCptWhiteList(CompatibilityHelper.RUN_SCORE_BLACK_LIST, pkgName4) || pkgName4.toLowerCase().contains("bench") || pkgName4.toLowerCase().contains("cpuid") || pkgName4.toLowerCase().contains("devicemark")) {
                        Slog.d(TAG, "it is run score packages=" + pkgName4);
                        res.setError(-15, "installPackageLI");
                        throw new PrepareFailure(-15, "Dont allow to install bench app");
                    }
                }
                if (!packageManagerService.hasSystemFeature(OppoCustomizeNotificationHelper.Constants.FEATURE_BUSINESS_CUSTOM, 0) || !PackageManagerCommonSoft.isCustomizDisallowInstallPackage(pkgName4)) {
                    if (isCustomApiSupported) {
                        OppoCutomizeManagerInternal customizeMgr2 = getOppoCutomizeManagerInternal();
                        if (packageManagerService.hasSystemFeature("oppo.customize.function.control_app_install", 0) && SystemProperties.getBoolean("persist.sys.enable_black_list", false)) {
                            if (customizeMgr2 == null || !customizeMgr2.getInstalledAppBlackList().contains(pkgName4)) {
                                Slog.d(TAG, "app is not in blacklist, " + pkgName4);
                            } else {
                                Slog.d(TAG, "app is in blacklist, " + pkgName4);
                                res.setError(-15, "installPackageLI");
                                throw new PrepareFailure(-15, "app is in blacklist !");
                            }
                        }
                        if (packageManagerService.hasSystemFeature("oppo.customize.function.control_app_install", 0) && SystemProperties.getBoolean("persist.sys.enable_white_list", false)) {
                            if (customizeMgr2 == null || !customizeMgr2.getInstalledAppWhiteList().contains(pkgName4)) {
                                Slog.d(TAG, "app is not in whitelist, " + pkgName4);
                                res.setError(-15, "installPackageLI");
                                throw new PrepareFailure(-15, "app is not in whitelist !");
                            }
                            Slog.d(TAG, "app is in whitelist, " + pkgName4);
                        }
                    }
                    if ((((ApplicationInfo) pkg.applicationInfo).flags & 256) == 0 || (installFlags2 & 4) != 0) {
                        try {
                            if (args.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
                                try {
                                    pkg.setSigningDetails(args.signingDetails);
                                } catch (PackageParser.PackageParserException e3) {
                                    exc2 = e3;
                                }
                            } else {
                                PackageParser.collectCertificates(pkg, false);
                            }
                            if (OppoFeatureCache.get(IColorThirdPartyAppSignCheckManager.DEFAULT).isForbidInstallAppByCert(pkg)) {
                                Slog.d(TAG, "matched forbidden packagename and signature");
                                throw new PrepareFailure(-8, "package signature is illegal, pkg =" + pkgName4);
                            } else if (OppoFeatureCache.get(IColorThirdPartyAppSignCheckManager.DEFAULT).isIllegalAppNameAsOppoPackage(pkg, installerPackageName2, installFlags2)) {
                                Slog.d(TAG, "illegal app named as oppo package, pkg is" + pkg.packageName);
                                throw new PrepareFailure(-8, "oppo named app is not match signature");
                            } else if (!instantApp || pkg.mSigningDetails.signatureSchemeVersion >= 2) {
                                boolean replace2 = false;
                                synchronized (packageManagerService.mPackages) {
                                    if ((installFlags2 & 2) != 0) {
                                        try {
                                            String oldName = packageManagerService.mSettings.getRenamedPackageLPr(pkgName4);
                                            if (pkg.mOriginalPackages == null) {
                                                systemApp = false;
                                            } else if (!pkg.mOriginalPackages.contains(oldName)) {
                                                systemApp = false;
                                            } else if (packageManagerService.mPackages.containsKey(oldName)) {
                                                pkg.setPackageName(oldName);
                                                pkgName4 = pkg.packageName;
                                                replace2 = true;
                                                if (DEBUG_INSTALL) {
                                                    StringBuilder sb = new StringBuilder();
                                                    systemApp = false;
                                                    try {
                                                        sb.append("Replacing existing renamed package: oldName=");
                                                        sb.append(oldName);
                                                        sb.append(" pkgName=");
                                                        sb.append(pkgName4);
                                                        Slog.d(TAG, sb.toString());
                                                    } catch (Throwable th9) {
                                                        th2 = th9;
                                                        while (true) {
                                                            try {
                                                                break;
                                                            } catch (Throwable th10) {
                                                                th2 = th10;
                                                            }
                                                        }
                                                        throw th2;
                                                    }
                                                } else {
                                                    systemApp = false;
                                                }
                                                if (pkg.parentPackage != null) {
                                                    if (replace2) {
                                                        PackageParser.Package oldPackage = packageManagerService.mPackages.get(pkgName4);
                                                        int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                                                        int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                                                        pkgName3 = pkgName4;
                                                        if (oldTargetSdk <= 22) {
                                                            replace = replace2;
                                                        } else if (newTargetSdk > 22) {
                                                            replace = replace2;
                                                        } else {
                                                            try {
                                                                throw new PrepareFailure(-26, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old target SDK " + oldTargetSdk + " does.");
                                                            } catch (Throwable th11) {
                                                                th2 = th11;
                                                                while (true) {
                                                                    break;
                                                                }
                                                                throw th2;
                                                            }
                                                        }
                                                        if (!SystemProperties.getBoolean("debug.allow.persist.update", false)) {
                                                            if ((oldPackage.applicationInfo.flags & 8) != 0) {
                                                                if ((2097152 & installFlags2) == 0) {
                                                                    throw new PrepareFailure(-2, "Package " + oldPackage.packageName + " is a persistent app. Persistent apps are not updateable.");
                                                                }
                                                            }
                                                        }
                                                        if (oldPackage.parentPackage != null) {
                                                            throw new PrepareFailure(-106, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages can be updated only through the parent package.");
                                                        }
                                                    } else {
                                                        pkgName3 = pkgName4;
                                                        replace = replace2;
                                                    }
                                                    pkgName = pkgName3;
                                                    replace2 = replace;
                                                } else {
                                                    throw new PrepareFailure(-106, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages can be updated only through the parent package.");
                                                }
                                            } else {
                                                systemApp = false;
                                            }
                                            if (packageManagerService.mPackages.containsKey(pkgName4)) {
                                                replace2 = true;
                                                if (DEBUG_INSTALL) {
                                                    Slog.d(TAG, "Replace existing pacakge: " + pkgName4);
                                                }
                                            }
                                        } catch (Throwable th12) {
                                            th2 = th12;
                                            while (true) {
                                                break;
                                            }
                                            throw th2;
                                        }
                                        try {
                                            if (pkg.parentPackage != null) {
                                            }
                                        } catch (Throwable th13) {
                                            th2 = th13;
                                            while (true) {
                                                break;
                                            }
                                            throw th2;
                                        }
                                    } else {
                                        systemApp = false;
                                        pkgName = pkgName4;
                                    }
                                    try {
                                        ps = packageManagerService.mSettings.mPackages.get(pkgName);
                                        if (ps != null) {
                                            try {
                                                if (DEBUG_INSTALL) {
                                                    try {
                                                        Slog.d(TAG, "Existing package: " + ps);
                                                    } catch (Throwable th14) {
                                                        th2 = th14;
                                                    }
                                                }
                                                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                                                    SharedLibraryInfo libraryInfo = packageManagerService.getLatestSharedLibraVersionLPr(pkg);
                                                    if (libraryInfo != null) {
                                                        signatureCheckPs = packageManagerService.mSettings.getPackageLPr(libraryInfo.getPackageName());
                                                        ksms = packageManagerService.mSettings.mKeySetManagerService;
                                                        if (!ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                                                            try {
                                                                if (ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                                                                    installFlags = installFlags2;
                                                                    pkgName2 = pkgName;
                                                                    installerPackageName = installerPackageName2;
                                                                } else {
                                                                    try {
                                                                        StringBuilder sb2 = new StringBuilder();
                                                                        try {
                                                                            sb2.append("Package ");
                                                                            sb2.append(pkg.packageName);
                                                                            sb2.append(" upgrade keys do not match the previously installed version");
                                                                            throw new PrepareFailure(-7, sb2.toString());
                                                                        } catch (Throwable th15) {
                                                                            th2 = th15;
                                                                            while (true) {
                                                                                break;
                                                                            }
                                                                            throw th2;
                                                                        }
                                                                    } catch (Throwable th16) {
                                                                        th2 = th16;
                                                                        while (true) {
                                                                            break;
                                                                        }
                                                                        throw th2;
                                                                    }
                                                                }
                                                            } catch (Throwable th17) {
                                                                th2 = th17;
                                                                while (true) {
                                                                    break;
                                                                }
                                                                throw th2;
                                                            }
                                                        } else {
                                                            installFlags = installFlags2;
                                                            installerPackageName = installerPackageName2;
                                                            try {
                                                                pkgName2 = pkgName;
                                                                try {
                                                                    if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, null, pkg.mSigningDetails, packageManagerService.isCompatSignatureUpdateNeeded(pkg), packageManagerService.isRecoverSignatureUpdateNeeded(pkg))) {
                                                                        synchronized (packageManagerService.mPackages) {
                                                                            ksms.removeAppKeySetDataLPw(pkg.packageName);
                                                                        }
                                                                    }
                                                                } catch (PackageManagerException e4) {
                                                                    e = e4;
                                                                    throw new PrepareFailure(e.error, e.getMessage());
                                                                }
                                                            } catch (PackageManagerException e5) {
                                                                e = e5;
                                                                throw new PrepareFailure(e.error, e.getMessage());
                                                            } catch (Throwable th18) {
                                                                th2 = th18;
                                                                while (true) {
                                                                    break;
                                                                }
                                                                throw th2;
                                                            }
                                                        }
                                                        if (ps.pkg != null || ps.pkg.applicationInfo == null) {
                                                            systemApp2 = systemApp;
                                                        } else {
                                                            systemApp2 = (ps.pkg.applicationInfo.flags & 1) != 0;
                                                        }
                                                        res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                    } else {
                                                        signatureCheckPs2 = ps;
                                                    }
                                                } else {
                                                    signatureCheckPs2 = ps;
                                                }
                                                signatureCheckPs = signatureCheckPs2;
                                                ksms = packageManagerService.mSettings.mKeySetManagerService;
                                                if (!ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                                                }
                                            } catch (Throwable th19) {
                                                th2 = th19;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                            try {
                                                if (ps.pkg != null) {
                                                }
                                                systemApp2 = systemApp;
                                                try {
                                                    res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                } catch (Throwable th20) {
                                                    th2 = th20;
                                                }
                                            } catch (Throwable th21) {
                                                th2 = th21;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                        } else {
                                            installFlags = installFlags2;
                                            pkgName2 = pkgName;
                                            installerPackageName = installerPackageName2;
                                            systemApp2 = systemApp;
                                        }
                                    } catch (Throwable th22) {
                                        th2 = th22;
                                        while (true) {
                                            break;
                                        }
                                        throw th2;
                                    }
                                    try {
                                        int N2 = pkg.permissions.size();
                                        int i2 = N2 - 1;
                                        while (i2 >= 0) {
                                            PackageParser.Permission perm = (PackageParser.Permission) pkg.permissions.get(i2);
                                            BasePermission bp = packageManagerService.mPermissionManager.getPermissionTEMP(perm.info.name);
                                            if ((perm.info.protectionLevel & 4096) == 0 || systemApp2) {
                                                ps2 = ps;
                                                N = N2;
                                            } else {
                                                ps2 = ps;
                                                StringBuilder sb3 = new StringBuilder();
                                                N = N2;
                                                sb3.append("Non-System package ");
                                                sb3.append(pkg.packageName);
                                                sb3.append(" attempting to delcare ephemeral permission ");
                                                sb3.append(perm.info.name);
                                                sb3.append("; Removing ephemeral.");
                                                Slog.w(TAG, sb3.toString());
                                                perm.info.protectionLevel &= -4097;
                                            }
                                            if (bp != null) {
                                                String sourcePackageName = bp.getSourcePackageName();
                                                PackageSettingBase sourcePackageSetting = bp.getSourcePackageSetting();
                                                KeySetManagerService ksms2 = packageManagerService.mSettings.mKeySetManagerService;
                                                if (sourcePackageName.equals(pkg.packageName) && ksms2.shouldCheckUpgradeKeySetLocked(sourcePackageSetting, scanFlags)) {
                                                    sigsOk = ksms2.checkUpgradeKeySetLocked(sourcePackageSetting, pkg);
                                                } else if (sourcePackageSetting.signatures.mSigningDetails.checkCapability(pkg.mSigningDetails, 4)) {
                                                    sigsOk = true;
                                                } else if (pkg.mSigningDetails.checkCapability(sourcePackageSetting.signatures.mSigningDetails, 4)) {
                                                    sourcePackageSetting.signatures.mSigningDetails = pkg.mSigningDetails;
                                                    sigsOk = true;
                                                } else {
                                                    sigsOk = false;
                                                }
                                                if (!sigsOk) {
                                                    if (((mColorPmsEx != null ? mColorPmsEx.duplicatePermCheck(args.installArgsEx) : false) || sourcePackageName.startsWith("android.appsecurity.cts.tinyapp")) && !sourcePackageName.equals(PLATFORM_PACKAGE_NAME)) {
                                                        throw new PrepareFailure(-112, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName).conflictsWithExistingPermission(perm.info.name, sourcePackageName);
                                                    }
                                                    Map<String, String> eventMap = new HashMap<>();
                                                    if (!sourcePackageName.equals(PLATFORM_PACKAGE_NAME)) {
                                                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName);
                                                        eventMap.put(sourcePackageName, perm.info.name);
                                                        eventMap.put(pkg.packageName, perm.info.name);
                                                        pkg.permissions.remove(i2);
                                                    } else {
                                                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                                                        eventMap.put(pkg.packageName, perm.info.name);
                                                        pkg.permissions.remove(i2);
                                                    }
                                                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName) && (perm.info.protectionLevel & 15) == 1 && !bp.isRuntime()) {
                                                    Slog.w(TAG, "Package " + pkg.packageName + " trying to change a non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                                                    perm.info.protectionLevel = bp.getProtectionLevel();
                                                }
                                            }
                                            i2--;
                                            packageManagerService = this;
                                            N2 = N;
                                            ps = ps2;
                                        }
                                    } catch (Throwable th23) {
                                        th2 = th23;
                                        while (true) {
                                            break;
                                        }
                                        throw th2;
                                    }
                                }
                            } else {
                                Slog.w(TAG, "Instant app package " + pkg.packageName + " is not signed with at least APK Signature Scheme v2");
                                throw new PrepareFailure(-116, "Instant app package must be signed with APK Signature Scheme v2 or greater");
                            }
                        } catch (PackageParser.PackageParserException e6) {
                            exc2 = e6;
                            throw new PrepareFailure("Failed collect during installPackageLI", exc2);
                        }
                    } else {
                        throw new PrepareFailure(-15, "installPackageLI");
                    }
                } else {
                    Log.d(TAG, "app is in customize uninstall app list,and forbid install, " + pkgName4);
                    throw new PrepareFailure(-15, "app is in customize unistall app list,and forbid install !");
                }
            } catch (PackageParser.PackageParserException e7) {
                exc = e7;
                throw new PrepareFailure("Failed parse during installPackageLI", exc);
            } catch (Throwable th24) {
                th = th24;
                Trace.traceEnd(262144);
                throw th;
            }
        } else {
            Slog.i(TAG, "Incompatible ephemeral install; external=" + onExternal);
            throw new PrepareFailure(-116);
        }
    }

    private void setUpFsVerityIfPossible(PackageParser.Package pkg) throws Installer.InstallerException, PrepareFailure, IOException, DigestException, NoSuchAlgorithmException {
        boolean standardMode = PackageManagerServiceUtils.isApkVerityEnabled();
        boolean legacyMode = PackageManagerServiceUtils.isLegacyApkVerityEnabled();
        if (standardMode || legacyMode) {
            ArrayMap<String, String> fsverityCandidates = new ArrayMap<>();
            int i = 0;
            if (legacyMode) {
                synchronized (this.mPackages) {
                    PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null && ps.isPrivileged()) {
                        fsverityCandidates.put(pkg.baseCodePath, null);
                        if (pkg.splitCodePaths != null) {
                            String[] strArr = pkg.splitCodePaths;
                            int length = strArr.length;
                            while (i < length) {
                                fsverityCandidates.put(strArr[i], null);
                                i++;
                            }
                        }
                    }
                }
            } else {
                fsverityCandidates.put(pkg.baseCodePath, VerityUtils.getFsveritySignatureFilePath(pkg.baseCodePath));
                String dmPath = DexMetadataHelper.buildDexMetadataPathForApk(pkg.baseCodePath);
                if (new File(dmPath).exists()) {
                    fsverityCandidates.put(dmPath, VerityUtils.getFsveritySignatureFilePath(dmPath));
                }
                if (pkg.splitCodePaths != null) {
                    String[] strArr2 = pkg.splitCodePaths;
                    int length2 = strArr2.length;
                    while (i < length2) {
                        String path = strArr2[i];
                        fsverityCandidates.put(path, VerityUtils.getFsveritySignatureFilePath(path));
                        String splitDmPath = DexMetadataHelper.buildDexMetadataPathForApk(path);
                        if (new File(splitDmPath).exists()) {
                            fsverityCandidates.put(splitDmPath, VerityUtils.getFsveritySignatureFilePath(splitDmPath));
                        }
                        i++;
                    }
                }
            }
            for (Map.Entry<String, String> entry : fsverityCandidates.entrySet()) {
                String filePath = entry.getKey();
                String signaturePath = entry.getValue();
                if (legacyMode) {
                    VerityUtils.SetupResult result = VerityUtils.generateApkVeritySetupData(filePath);
                    if (result.isOk()) {
                        if (Build.IS_DEBUGGABLE) {
                            Slog.i(TAG, "Enabling verity to " + filePath);
                        }
                        FileDescriptor fd = result.getUnownedFileDescriptor();
                        try {
                            byte[] rootHash = VerityUtils.generateApkVerityRootHash(filePath);
                            try {
                                this.mInstaller.assertFsverityRootHashMatches(filePath, rootHash);
                            } catch (Installer.InstallerException e) {
                                this.mInstaller.installApkVerity(filePath, fd, result.getContentSize());
                                this.mInstaller.assertFsverityRootHashMatches(filePath, rootHash);
                            }
                        } finally {
                            IoUtils.closeQuietly(fd);
                        }
                    } else if (result.isFailed()) {
                        throw new PrepareFailure(-118, "Failed to generate verity");
                    }
                } else if (new File(signaturePath).exists() && !VerityUtils.hasFsverity(filePath)) {
                    try {
                        VerityUtils.setUpFsverity(filePath, signaturePath);
                    } catch (IOException | SecurityException | DigestException | NoSuchAlgorithmException e2) {
                        throw new PrepareFailure(-118, "Failed to enable fs-verity: " + e2);
                    }
                }
            }
        }
    }

    private void startIntentFilterVerifications(int userId, boolean replacing, PackageParser.Package pkg) {
        ComponentName componentName = this.mIntentFilterVerifierComponent;
        if (componentName == null) {
            Slog.w(TAG, "No IntentFilter verification will not be done as there is no IntentFilterVerifier available!");
            return;
        }
        int childCount = 0;
        int verifierUid = getPackageUid(componentName.getPackageName(), 268435456, userId == -1 ? 0 : userId);
        Message msg = this.mHandler.obtainMessage(17);
        msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
        this.mHandler.sendMessage(msg);
        if (pkg.childPackages != null) {
            childCount = pkg.childPackages.size();
        }
        for (int i = 0; i < childCount; i++) {
            Message msg2 = this.mHandler.obtainMessage(17);
            msg2.obj = new IFVerificationParams((PackageParser.Package) pkg.childPackages.get(i), replacing, userId, verifierUid);
            this.mHandler.sendMessage(msg2);
        }
    }

    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:130:0x010f */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:105:0x0208 */
    /* JADX DEBUG: Multi-variable search result rejected for r9v2, resolved type: boolean */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r9v1 */
    /* JADX WARN: Type inference failed for: r9v3 */
    /* JADX WARN: Type inference failed for: r9v4 */
    /* JADX WARN: Type inference failed for: r9v10 */
    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x0213, code lost:
        if (r20 == false) goto L_0x024f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0215, code lost:
        if (r2 <= 0) goto L_0x024f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x0219, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_0x0249;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x021b, code lost:
        r0 = new java.lang.StringBuilder();
        r0.append("Starting ");
        r0.append(r2);
        r0.append(" IntentFilter verification");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x022d, code lost:
        if (r2 <= r9) goto L_0x0233;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x022f, code lost:
        r3 = "s";
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x0233, code lost:
        r3 = "";
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x0235, code lost:
        r0.append(r3);
        r0.append(" for userId:");
        r0.append(r27);
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, r0.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x0249, code lost:
        r26.mIntentFilterVerifier.startVerifications(r27);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0251, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_DOMAIN_VERIFICATION == false) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0253, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "No web filters or no new host policy for " + r12);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:?, code lost:
        return;
     */
    /* JADX WARNING: Removed duplicated region for block: B:82:0x01b0  */
    private void verifyIntentFiltersIfNeeded(int userId, int verifierUid, boolean replacing, PackageParser.Package pkg) {
        IntentFilterVerificationInfo ivi;
        boolean z;
        boolean z2;
        boolean hostSetExpanded;
        boolean keepCurState;
        PackageParser.Activity a;
        int size = pkg.activities.size();
        if (size == 0) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No activity, so no need to verify any IntentFilter!");
            }
        } else if (hasDomainURLs(pkg)) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "Checking for userId:" + userId + " if any IntentFilter from the " + size + " Activities needs verification ...");
            }
            int count = 0;
            String packageName = pkg.packageName;
            ArraySet<String> domains = new ArraySet<>();
            synchronized (this.mPackages) {
                try {
                    IntentFilterVerificationInfo ivi2 = this.mSettings.getIntentFilterVerificationLPr(packageName);
                    boolean previouslyVerified = ivi2 != null;
                    if (replacing || !previouslyVerified) {
                        if (DEBUG_DOMAIN_VERIFICATION) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("    Previous verified hosts: ");
                            sb.append(ivi2 == null ? "[none]" : ivi2.getDomainsString());
                            Slog.i(TAG, sb.toString());
                        }
                        boolean needsVerification = needsNetworkVerificationLPr(packageName);
                        Iterator it = pkg.activities.iterator();
                        boolean handlesWebUris = false;
                        boolean needToRunVerify = false;
                        while (it.hasNext()) {
                            try {
                                Iterator it2 = ((PackageParser.Activity) it.next()).intents.iterator();
                                boolean handlesWebUris2 = handlesWebUris;
                                while (true) {
                                    if (!it2.hasNext()) {
                                        break;
                                    }
                                    PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it2.next();
                                    handlesWebUris2 = handlesWebUris2;
                                    if (filter.handlesWebUris(true)) {
                                        handlesWebUris2 = true;
                                    }
                                    if (!needsVerification || !filter.needsVerification()) {
                                        handlesWebUris2 = handlesWebUris2;
                                    } else {
                                        if (DEBUG_DOMAIN_VERIFICATION) {
                                            Slog.d(TAG, "autoVerify requested, processing all filters");
                                        }
                                        needToRunVerify = true;
                                    }
                                }
                                needToRunVerify = needToRunVerify;
                                handlesWebUris = handlesWebUris2;
                            } catch (Throwable th) {
                                ivi = th;
                                throw ivi;
                            }
                        }
                        if (!needToRunVerify) {
                            if (!previouslyVerified) {
                                z2 = 1;
                                z = false;
                                if (DEBUG_DOMAIN_VERIFICATION) {
                                    Slog.i(TAG, "    Update published hosts: " + domains.toString());
                                }
                                hostSetExpanded = (previouslyVerified || (ivi2 != null && !ivi2.getDomains().containsAll(domains))) ? z2 : z;
                                int currentPolicy = this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                                if (!hostSetExpanded || currentPolicy != 2) {
                                    keepCurState = z;
                                } else {
                                    boolean z3 = z2 == true ? 1 : 0;
                                    boolean z4 = z2 == true ? 1 : 0;
                                    boolean z5 = z2 == true ? 1 : 0;
                                    boolean z6 = z2 == true ? 1 : 0;
                                    keepCurState = z3;
                                }
                                if (!needToRunVerify && keepCurState) {
                                    if (DEBUG_DOMAIN_VERIFICATION) {
                                        Slog.i(TAG, "Host set not expanding + ALWAYS -> no need to reverify");
                                    }
                                    ivi2.setDomains(domains);
                                    scheduleWriteSettingsLocked();
                                    return;
                                } else if (!previouslyVerified && !needToRunVerify) {
                                    if (keepCurState) {
                                        z2 = z;
                                    }
                                    clearIntentFilterVerificationsLPw(packageName, userId, z2);
                                    return;
                                }
                            }
                        }
                        int verificationId = this.mIntentFilterVerificationToken;
                        this.mIntentFilterVerificationToken = verificationId + 1;
                        Iterator it3 = pkg.activities.iterator();
                        while (it3.hasNext()) {
                            PackageParser.Activity a2 = (PackageParser.Activity) it3.next();
                            Iterator it4 = a2.intents.iterator();
                            int count2 = count;
                            while (it4.hasNext()) {
                                try {
                                    PackageParser.ActivityIntentInfo filter2 = (PackageParser.ActivityIntentInfo) it4.next();
                                    if (filter2.handlesWebUris(false)) {
                                        if (DEBUG_DOMAIN_VERIFICATION) {
                                            Slog.d(TAG, "Verification needed for IntentFilter:" + filter2.toString());
                                        }
                                        a = a2;
                                        this.mIntentFilterVerifier.addOneIntentFilterVerification(verifierUid, userId, verificationId, filter2, packageName);
                                        domains.addAll(filter2.getHostsList());
                                        count2++;
                                    } else {
                                        a = a2;
                                    }
                                    a2 = a;
                                } catch (Throwable th2) {
                                    ivi = th2;
                                    throw ivi;
                                }
                            }
                            count = count2;
                        }
                        z2 = 1;
                        z = false;
                        if (DEBUG_DOMAIN_VERIFICATION) {
                        }
                        if (previouslyVerified) {
                        }
                        int currentPolicy2 = this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                        if (!hostSetExpanded) {
                        }
                        keepCurState = z;
                        if (!needToRunVerify) {
                        }
                        if (!previouslyVerified) {
                        }
                    } else {
                        if (DEBUG_DOMAIN_VERIFICATION) {
                            Slog.i(TAG, "Package " + packageName + " already verified: status=" + ivi2.getStatusString());
                        }
                    }
                } catch (Throwable th3) {
                    ivi = th3;
                    throw ivi;
                }
            }
        } else if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "No domain URLs, so no need to verify any IntentFilter!");
        }
    }

    @GuardedBy({"mPackages"})
    private boolean needsNetworkVerificationLPr(String packageName) {
        int status;
        IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(packageName);
        if (ivi == null || (status = ivi.getStatus()) == 0 || status == 1 || status == 2) {
            return true;
        }
        return false;
    }

    private static boolean isMultiArch(ApplicationInfo info) {
        return (info.flags & Integer.MIN_VALUE) != 0;
    }

    /* access modifiers changed from: private */
    public static boolean isExternal(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 262144) != 0;
    }

    private static boolean isExternal(PackageSetting ps) {
        return (ps.pkgFlags & 262144) != 0;
    }

    private static boolean isSystemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 1) != 0;
    }

    private static boolean isPrivilegedApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 8) != 0;
    }

    private static boolean isOemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 131072) != 0;
    }

    private static boolean isVendorApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 262144) != 0;
    }

    private static boolean isProductApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 524288) != 0;
    }

    private static boolean isProductServicesApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 2097152) != 0;
    }

    private static boolean isOdmApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 1073741824) != 0;
    }

    private static boolean hasDomainURLs(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 16) != 0;
    }

    private static boolean isSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 1) != 0;
    }

    private static boolean isUpdatedSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 128) != 0;
    }

    private Settings.VersionInfo getSettingsVersionForPackage(PackageParser.Package pkg) {
        if (!isExternal(pkg)) {
            return this.mSettings.getInternalVersion();
        }
        if (TextUtils.isEmpty(pkg.volumeUuid)) {
            return this.mSettings.getExternalVersion();
        }
        return this.mSettings.findOrCreateVersion(pkg.volumeUuid);
    }

    private void deleteTempPackageFiles() {
        $$Lambda$PackageManagerService$xKFHvZAUir1Y_lClMWZh87peKs8 r0 = $$Lambda$PackageManagerService$xKFHvZAUir1Y_lClMWZh87peKs8.INSTANCE;
    }

    static /* synthetic */ boolean lambda$deleteTempPackageFiles$15(File dir, String name) {
        return name.startsWith("vmdl") && name.endsWith(".tmp");
    }

    public void deletePackageAsUser(String packageName, int versionCode, IPackageDeleteObserver observer, int userId, int flags) {
        deletePackageVersioned(new VersionedPackage(packageName, versionCode), new PackageManager.LegacyPackageDeleteObserver(observer).getBinder(), userId, flags);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:102:0x0252, code lost:
        r0 = th;
     */
    public void deletePackageVersioned(VersionedPackage versionedPackage, IPackageDeleteObserver2 observer, int userId, int deleteFlags) {
        String internalPackageName;
        boolean isDisallowUninstallApps;
        String forbidUninstallApps;
        String forbidUninstallApps2;
        String tmpStr;
        List<String> appList;
        int callingUid = Binder.getCallingUid();
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        boolean canViewInstantApps = canViewInstantApps(callingUid, userId);
        OppoPackageManagerHelper.setDataCollection();
        OppoPackageManagerHelper.restoreDeleteInfo(getPackageInfo(versionedPackage.getPackageName(), 128, userId));
        Preconditions.checkNotNull(versionedPackage);
        Preconditions.checkNotNull(observer);
        Preconditions.checkArgumentInRange(versionedPackage.getLongVersionCode(), -1, (long) JobStatus.NO_LATEST_RUNTIME, "versionCode must be >= -1");
        String packageName = versionedPackage.getPackageName();
        long versionCode = versionedPackage.getLongVersionCode();
        if (packageName != null) {
            OidtPackageManagerHelper.getInstance().detectUninstallForOIDT(this.mContext, this.mPackages, packageName);
        }
        synchronized (this.mPackages) {
            internalPackageName = resolveInternalPackageNameLPr(packageName, versionCode);
        }
        int uid = Binder.getCallingUid();
        if (isOrphaned(internalPackageName) || isCallerAllowedToSilentlyUninstall(uid, internalPackageName)) {
            boolean deleteAllUsers = (deleteFlags & 2) != 0;
            int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]{userId};
            if (UserHandle.getUserId(uid) != userId || (deleteAllUsers && users.length > 1)) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "deletePackage for user " + userId);
            }
            String forbidUninstallApps3 = SystemProperties.get("persist.sys.forbiduninstall.packagelist");
            List<String> forbidUninstallAppList = new ArrayList<>();
            if (forbidUninstallApps3 != null && forbidUninstallApps3.length() > 0) {
                forbidUninstallAppList.addAll(Arrays.asList(forbidUninstallApps3.split(",")));
            }
            OppoCutomizeManagerInternal customizeMgr = getOppoCutomizeManagerInternal();
            if (customizeMgr == null || (appList = customizeMgr.getDisallowUninstallApps()) == null) {
                isDisallowUninstallApps = false;
            } else {
                isDisallowUninstallApps = appList.contains(packageName);
            }
            if (isDisallowUninstallApps) {
                forbidUninstallApps = packageName;
            } else if (forbidUninstallAppList.contains(packageName)) {
                forbidUninstallApps = packageName;
            } else if (isUserRestricted(userId, "no_uninstall_apps")) {
                this.mHandler.post(new Runnable(observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$0EUxpdbuTb7cQLNvaW7DZICCCU */
                    private final /* synthetic */ IPackageDeleteObserver2 f$0;
                    private final /* synthetic */ String f$1;

                    {
                        this.f$0 = r1;
                        this.f$1 = r2;
                    }

                    public final void run() {
                        PackageManagerService.lambda$deletePackageVersioned$17(this.f$0, this.f$1);
                    }
                });
                return;
            } else if (!OppoFeatureCache.get(IColorChildrenModeInstallManager.DEFAULT).prohibitDeleteInChildMode(userId, packageName, observer, false)) {
                if (!hasSystemFeature(OppoCustomizeNotificationHelper.Constants.FEATURE_BUSINESS_CUSTOM, 0) || !SystemProperties.getBoolean("persist.sys.forbiduninstall.package.policy.whitelist", false)) {
                    forbidUninstallApps2 = forbidUninstallApps3;
                } else {
                    OppoCutomizeManagerInternal oppoCustomizeMgr = getOppoCutomizeManagerInternal();
                    if (oppoCustomizeMgr != null) {
                        forbidUninstallApps2 = forbidUninstallApps3;
                        List<String> uninstallPkgWhitelist = oppoCustomizeMgr.getAppUninstallationPolicies(1);
                        if (uninstallPkgWhitelist != null && uninstallPkgWhitelist.contains(packageName)) {
                            try {
                                observer.onPackageDeleted(packageName, -3, (String) null);
                                return;
                            } catch (RemoteException e) {
                                return;
                            }
                        }
                    } else {
                        forbidUninstallApps2 = forbidUninstallApps3;
                    }
                }
                String[] packageNames = getPackagesForUid(uid);
                if (packageNames == null || 1 != packageNames.length) {
                    tmpStr = "pkg-" + getNameForUid(uid);
                } else {
                    tmpStr = packageNames[0];
                }
                if (!OppoFeatureCache.get(IColorChildrenModeInstallManager.DEFAULT).prohibitDeleteInChildMode(userId, packageName, observer, false)) {
                    if (deleteAllUsers || !getBlockUninstallForUser(internalPackageName, userId)) {
                        if (DEBUG_REMOVE) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("deletePackageAsUser: pkg=");
                            sb.append(internalPackageName);
                            sb.append(" user=");
                            sb.append(userId);
                            sb.append(" deleteAllUsers: ");
                            sb.append(deleteAllUsers);
                            sb.append(" version=");
                            sb.append(versionCode == -1 ? "VERSION_CODE_HIGHEST" : Long.valueOf(versionCode));
                            Slog.d(TAG, sb.toString());
                        }
                        this.mHandler.post(new Runnable(uid, userId, packageName, observer, internalPackageName, callingUid, canViewInstantApps, deleteAllUsers, versionCode, deleteFlags, users, tmpStr) {
                            /* class com.android.server.pm.$$Lambda$PackageManagerService$ysNkMlwUdabvQTETNEEnFTMdPC0 */
                            private final /* synthetic */ int f$1;
                            private final /* synthetic */ int f$10;
                            private final /* synthetic */ int[] f$11;
                            private final /* synthetic */ String f$12;
                            private final /* synthetic */ int f$2;
                            private final /* synthetic */ String f$3;
                            private final /* synthetic */ IPackageDeleteObserver2 f$4;
                            private final /* synthetic */ String f$5;
                            private final /* synthetic */ int f$6;
                            private final /* synthetic */ boolean f$7;
                            private final /* synthetic */ boolean f$8;
                            private final /* synthetic */ long f$9;

                            {
                                this.f$1 = r2;
                                this.f$2 = r3;
                                this.f$3 = r4;
                                this.f$4 = r5;
                                this.f$5 = r6;
                                this.f$6 = r7;
                                this.f$7 = r8;
                                this.f$8 = r9;
                                this.f$9 = r10;
                                this.f$10 = r12;
                                this.f$11 = r13;
                                this.f$12 = r14;
                            }

                            public final void run() {
                                PackageManagerService.this.lambda$deletePackageVersioned$19$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6, this.f$7, this.f$8, this.f$9, this.f$10, this.f$11, this.f$12);
                            }
                        });
                        if (userId == 0) {
                            OppoFeatureCache.get(IColorPkgStartInfoManager.DEFAULT).removePkgFromNotLaunchedList(packageName, false);
                            return;
                        }
                        return;
                    }
                    this.mHandler.post(new Runnable(observer, packageName) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$CS3aJUelGPn4PWtkx1QPsjrbNtc */
                        private final /* synthetic */ IPackageDeleteObserver2 f$0;
                        private final /* synthetic */ String f$1;

                        {
                            this.f$0 = r1;
                            this.f$1 = r2;
                        }

                        public final void run() {
                            PackageManagerService.lambda$deletePackageVersioned$18(this.f$0, this.f$1);
                        }
                    });
                    return;
                }
                return;
            } else {
                return;
            }
            try {
                observer.onPackageDeleted(forbidUninstallApps, -3, (String) null);
                return;
            } catch (RemoteException e2) {
                return;
            }
        } else {
            this.mHandler.post(new Runnable(packageName, observer) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$yQ3ZqZMHaduvv1mk1KLU_DO0B8c */
                private final /* synthetic */ String f$0;
                private final /* synthetic */ IPackageDeleteObserver2 f$1;

                {
                    this.f$0 = r1;
                    this.f$1 = r2;
                }

                public final void run() {
                    PackageManagerService.lambda$deletePackageVersioned$16(this.f$0, this.f$1);
                }
            });
            return;
        }
        while (true) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$16(String packageName, IPackageDeleteObserver2 observer) {
        try {
            Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
            intent.setData(Uri.fromParts("package", packageName, null));
            intent.putExtra("android.content.pm.extra.CALLBACK", observer.asBinder());
            observer.onUserActionRequired(intent);
        } catch (RemoteException e) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$17(IPackageDeleteObserver2 observer, String packageName) {
        try {
            observer.onPackageDeleted(packageName, -3, (String) null);
        } catch (RemoteException e) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$18(IPackageDeleteObserver2 observer, String packageName) {
        try {
            observer.onPackageDeleted(packageName, -4, (String) null);
        } catch (RemoteException e) {
        }
    }

    public /* synthetic */ void lambda$deletePackageVersioned$19$PackageManagerService(int uid, int userId, String packageName, IPackageDeleteObserver2 observer, String internalPackageName, int callingUid, boolean canViewInstantApps, boolean deleteAllUsers, long versionCode, int deleteFlags, int[] users, String delCallerPkg) {
        boolean doDeletePackage;
        String str;
        int returnCode;
        int returnCode2;
        int[] blockUninstallUserIds;
        int i;
        int i2;
        if (!OppoFeatureCache.get(IColorForbidUninstallAppManager.DEFAULT).isForbidDeletePackage(uid, userId, packageName, observer)) {
            PackageSetting ps = this.mSettings.mPackages.get(internalPackageName);
            if (ps != null) {
                doDeletePackage = !ps.getInstantApp(UserHandle.getUserId(callingUid)) || canViewInstantApps;
            } else {
                doDeletePackage = true;
            }
            if (!doDeletePackage) {
                str = TAG;
                returnCode = -1;
            } else if (!deleteAllUsers) {
                if (userId != 0) {
                    str = TAG;
                } else if (OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).isMultiApp(internalPackageName)) {
                    str = TAG;
                    int returnCode3 = deletePackageX(internalPackageName, versionCode, ZenModeHelper.OPPO_MULTI_USER_ID, deleteFlags);
                    if (returnCode3 != 1) {
                        Slog.w(str, "Package delete failed for multi app returnCode " + returnCode3);
                    }
                } else {
                    str = TAG;
                }
                returnCode = deletePackageX(internalPackageName, versionCode, userId, deleteFlags);
            } else {
                str = TAG;
                int[] blockUninstallUserIds2 = getBlockUninstallForUsers(internalPackageName, users);
                if (ArrayUtils.isEmpty(blockUninstallUserIds2)) {
                    returnCode2 = deletePackageX(internalPackageName, versionCode, userId, deleteFlags);
                } else {
                    int userFlags = deleteFlags & -3;
                    int length = users.length;
                    int userId1 = 0;
                    while (userId1 < length) {
                        int userId12 = users[userId1];
                        if (!ArrayUtils.contains(blockUninstallUserIds2, userId12)) {
                            i2 = userId1;
                            i = length;
                            blockUninstallUserIds = blockUninstallUserIds2;
                            int returnCode4 = deletePackageX(internalPackageName, versionCode, userId12, userFlags);
                            if (returnCode4 != 1) {
                                Slog.w(str, "Package delete failed for user " + userId12 + ", returnCode " + returnCode4);
                            }
                        } else {
                            i2 = userId1;
                            i = length;
                            blockUninstallUserIds = blockUninstallUserIds2;
                        }
                        userId1 = i2 + 1;
                        length = i;
                        blockUninstallUserIds2 = blockUninstallUserIds;
                    }
                    returnCode2 = -4;
                }
                returnCode = returnCode2;
            }
            try {
                observer.onPackageDeleted(packageName, returnCode, (String) null);
            } catch (RemoteException e) {
                Log.i(str, "Observer no longer exists.");
            }
            OppoFeatureCache.get(IColorRemovableAppManager.DEFAULT).changePackageInstalledState(ps, packageName, false);
            if (mColorPmsEx != null) {
                mColorPmsEx.sendUpdateExtraAppInfoMessage(packageName, this.mHandler);
            }
            OppoUsageManager.getOppoUsageManager().recordApkDeleteEvent(packageName, delCallerPkg, (String) null);
        }
    }

    private String resolveExternalPackageNameLPr(PackageParser.Package pkg) {
        if (pkg.staticSharedLibName != null) {
            return pkg.manifestPackageName;
        }
        return pkg.packageName;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private String resolveInternalPackageNameLPr(String packageName, long versionCode) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        String packageName2 = normalizedPackageName != null ? normalizedPackageName : packageName;
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mStaticLibsByDeclaringPackage.get(packageName2);
        if (versionedLib == null || versionedLib.size() <= 0) {
            return packageName2;
        }
        LongSparseLongArray versionsCallerCanSee = null;
        int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
        if (!(callingAppId == 1000 || callingAppId == 2000 || callingAppId == 0)) {
            versionsCallerCanSee = new LongSparseLongArray();
            String libName = versionedLib.valueAt(0).getName();
            String[] uidPackages = getPackagesForUid(Binder.getCallingUid());
            if (uidPackages != null) {
                for (String uidPackage : uidPackages) {
                    PackageSetting ps = this.mSettings.getPackageLPr(uidPackage);
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0) {
                        long libVersion = ps.usesStaticLibrariesVersions[libIdx];
                        versionsCallerCanSee.append(libVersion, libVersion);
                    }
                }
            }
        }
        if (versionsCallerCanSee != null && versionsCallerCanSee.size() <= 0) {
            return packageName2;
        }
        SharedLibraryInfo highestVersion = null;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            SharedLibraryInfo libraryInfo = versionedLib.valueAt(i);
            if (versionsCallerCanSee == null || versionsCallerCanSee.indexOfKey(libraryInfo.getLongVersion()) >= 0) {
                long libVersionCode = libraryInfo.getDeclaringPackage().getLongVersionCode();
                if (versionCode != -1) {
                    if (libVersionCode == versionCode) {
                        return libraryInfo.getPackageName();
                    }
                } else if (highestVersion == null) {
                    highestVersion = libraryInfo;
                } else if (libVersionCode > highestVersion.getDeclaringPackage().getLongVersionCode()) {
                    highestVersion = libraryInfo;
                }
            }
        }
        if (highestVersion != null) {
            return highestVersion.getPackageName();
        }
        return packageName2;
    }

    /* access modifiers changed from: package-private */
    public boolean isCallerVerifier(int callingUid) {
        int callingUserId = UserHandle.getUserId(callingUid);
        String str = this.mRequiredVerifierPackage;
        if (str == null || callingUid != getPackageUid(str, 0, callingUserId)) {
            return false;
        }
        return true;
    }

    private boolean isCallerAllowedToSilentlyUninstall(int callingUid, String pkgName) {
        if (callingUid == 2000 || callingUid == 0 || UserHandle.getAppId(callingUid) == 1000 || OppoFeatureCache.get(IColorSensitivePermGrantPolicyManager.DEFAULT).allowSilentUninstall(callingUid)) {
            return true;
        }
        int callingUserId = UserHandle.getUserId(callingUid);
        if (callingUid == getPackageUid(getInstallerPackageName(pkgName), 0, callingUserId)) {
            return true;
        }
        String str = this.mRequiredVerifierPackage;
        if (str != null && callingUid == getPackageUid(str, 0, callingUserId)) {
            return true;
        }
        String str2 = this.mRequiredUninstallerPackage;
        if (str2 != null && callingUid == getPackageUid(str2, 0, callingUserId)) {
            return true;
        }
        String str3 = this.mStorageManagerPackage;
        if ((str3 == null || callingUid != getPackageUid(str3, 0, callingUserId)) && checkUidPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callingUid) != 0) {
            return false;
        }
        return true;
    }

    private int[] getBlockUninstallForUsers(String packageName, int[] userIds) {
        int[] result = EMPTY_INT_ARRAY;
        for (int userId : userIds) {
            if (getBlockUninstallForUser(packageName, userId)) {
                result = ArrayUtils.appendInt(result, userId);
            }
        }
        return result;
    }

    public boolean isPackageDeviceAdminOnAnyUser(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (checkUidPermission("android.permission.MANAGE_USERS", callingUid) != 0) {
            EventLog.writeEvent(1397638484, "128599183", -1, "");
            throw new SecurityException("android.permission.MANAGE_USERS permission is required to call this API");
        } else if (getInstantAppPackageName(callingUid) == null || isCallerSameApp(packageName, callingUid)) {
            return isPackageDeviceAdmin(packageName, -1);
        } else {
            return false;
        }
    }

    private boolean isPackageDeviceAdmin(String packageName, int userId) {
        String deviceOwnerPackageName;
        int[] users;
        IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"));
        if (dpm != null) {
            try {
                ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent(false);
                if (deviceOwnerComponentName == null) {
                    deviceOwnerPackageName = null;
                } else {
                    deviceOwnerPackageName = deviceOwnerComponentName.getPackageName();
                }
                if (packageName.equals(deviceOwnerPackageName)) {
                    return true;
                }
                for (int i : userId == -1 ? sUserManager.getUserIds() : new int[]{userId}) {
                    if (dpm.packageHasActiveAdmins(packageName, i)) {
                        return true;
                    }
                }
            } catch (RemoteException e) {
            }
        }
        return false;
    }

    private boolean shouldKeepUninstalledPackageLPr(String packageName) {
        List<String> list = this.mKeepUninstalledPackages;
        return list != null && list.contains(packageName);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x0209, code lost:
        if (r0 == null) goto L_0x021c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:?, code lost:
        r29.mInstantAppRegistry.onPackageUninstalledLPw(r0, r17.removedUsers);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x0213, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:?, code lost:
        updateSequenceNumberLP(r0, r17.removedUsers);
        updateInstantAppInstallerLocked(r30);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x0227, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x022e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:?, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:?, code lost:
        monitor-exit(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x023d, code lost:
        if (r1 == false) goto L_0x0261;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x023f, code lost:
        android.common.OppoFeatureCache.get(com.android.server.am.IColorMultiAppManager.DEFAULT).handleUninstallPkg(r33, r30);
        com.android.server.pm.PackageManagerCommonSoft.supportDeleteChannelFile(r30);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x024f, code lost:
        if ((r34 & 8) != 0) goto L_0x0254;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0251, code lost:
        r16 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0254, code lost:
        r16 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0256, code lost:
        r17.sendPackageRemovedBroadcasts(r16);
        r17.sendSystemPackageUpdatedBroadcasts();
        r17.sendSystemPackageAppearedBroadcasts();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x0261, code lost:
        java.lang.Runtime.getRuntime().gc();
        r3 = r29.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x026a, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x026d, code lost:
        if (r17.args == null) goto L_0x027c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:131:?, code lost:
        r17.args.doPostDeleteLI(true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x0275, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x027e, code lost:
        if (r20 != null) goto L_0x0281;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:?, code lost:
        r2 = r20.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x0283, code lost:
        if (r2 == null) goto L_0x02d0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x0287, code lost:
        if (r2.isStub == false) goto L_0x02d0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x0289, code lost:
        r7 = r29.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x028b, code lost:
        monitor-enter(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:?, code lost:
        r8 = r29.mSettings.mPackages.get(r2.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x0298, code lost:
        if (r8 == null) goto L_0x02a2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x029c, code lost:
        r13 = r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:?, code lost:
        r8.setEnabled(r13, r33, com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x02a2, code lost:
        r13 = r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x02a4, code lost:
        monitor-exit(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x02a5, code lost:
        if (r13 == 0) goto L_0x02a9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x02a7, code lost:
        if (r13 != 1) goto L_0x02d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x02ab, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_COMPRESSION == false) goto L_0x02c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x02ad, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Enabling system stub after removal; pkg: " + r2.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x02c5, code lost:
        enableCompressedPackage(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x02c9, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:161:0x02cc, code lost:
        monitor-exit(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x02cd, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x02ce, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x02d2, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x02d3, code lost:
        if (r1 == false) goto L_0x02d6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x02d9, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x02dd, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x02e2, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x02e3, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:0x02e4, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x02e6, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x02ec, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:?, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:?, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:183:0x02f3, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x02f5, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x02ff, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x0300, code lost:
        r3 = r1;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x030c, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x030d, code lost:
        r3 = r1;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:?, code lost:
        throw r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x031c, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x031e, code lost:
        if (r3 != null) goto L_0x0320;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:195:0x0320, code lost:
        $closeResource(r1, r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x0323, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x0324, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x0331, code lost:
        monitor-exit(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:200:0x0332, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:201:0x0333, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:?, code lost:
        return -1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:220:?, code lost:
        return 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x0174, code lost:
        if (isUpdatedSystemApp(r0) == false) goto L_0x017d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x0178, code lost:
        if ((r34 & 4) != 0) goto L_0x017d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x017a, code lost:
        r12 = -1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x017d, code lost:
        r12 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x017f, code lost:
        r13 = r29.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0181, code lost:
        monitor-enter(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0184, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_REMOVE == false) goto L_0x01b4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:?, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "deletePackageX: pkg=" + r30 + " user=" + r33);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x01a5, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x01b4, code lost:
        r1 = freezePackageForDelete(r30, r12, r34, "deletePackageX");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:?, code lost:
        r1 = deletePackageLIF(r30, android.os.UserHandle.of(r0), true, r0, r34 | Integer.MIN_VALUE, r17, true, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x01ee, code lost:
        r2 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x01f1, code lost:
        if (r1 == null) goto L_0x0202;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:?, code lost:
        $closeResource(null, r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x01f7, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:?, code lost:
        r3 = r29.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x0204, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x0205, code lost:
        if (r1 == false) goto L_0x0237;
     */
    public int deletePackageX(String packageName, long versionCode, int userId, int deleteFlags) {
        Throwable th;
        PackageSetting disabledSystemPs;
        int origEnabledState;
        PackageRemovedInfo info;
        PackageSetting disabledSystemPs2;
        int currUserId;
        PackageRemovedInfo info2 = new PackageRemovedInfo(this);
        int removeUser = (deleteFlags & 2) != 0 ? -1 : userId;
        if (isPackageDeviceAdmin(packageName, removeUser)) {
            if (deleteFailedByPolicy()) {
                Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
                return -2;
            }
            OppoPackageManagerHelper.removeActiveAdmin(this, packageName, userId);
        }
        synchronized (this.mPackages) {
            try {
                PackageSetting uninstalledPs = this.mSettings.mPackages.get(packageName);
                if (uninstalledPs == null) {
                    try {
                        Slog.w(TAG, "Not removing non-existent package " + packageName);
                        return -1;
                    } catch (Throwable th2) {
                        th = th2;
                        while (true) {
                            try {
                                break;
                            } catch (Throwable th3) {
                                th = th3;
                            }
                        }
                        throw th;
                    }
                } else if (versionCode == -1 || uninstalledPs.versionCode == versionCode) {
                    PackageSetting disabledSystemPs3 = this.mSettings.getDisabledSystemPkgLPr(packageName);
                    int origEnabledState2 = uninstalledPs.getEnabled(userId);
                    PackageParser.Package pkg = this.mPackages.get(packageName);
                    int[] allUsers = sUserManager.getUserIds();
                    if (pkg != null) {
                        try {
                            if (pkg.staticSharedLibName != null) {
                                info = info2;
                                try {
                                    SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
                                    if (libraryInfo != null) {
                                        int length = allUsers.length;
                                        int i = 0;
                                        while (i < length) {
                                            int currUserId2 = allUsers[i];
                                            if (removeUser != -1) {
                                                currUserId = currUserId2;
                                                if (removeUser != currUserId) {
                                                    disabledSystemPs2 = disabledSystemPs3;
                                                    i++;
                                                    origEnabledState2 = origEnabledState2;
                                                    disabledSystemPs3 = disabledSystemPs2;
                                                }
                                            } else {
                                                currUserId = currUserId2;
                                            }
                                            disabledSystemPs2 = disabledSystemPs3;
                                            List<VersionedPackage> libClientPackages = getPackagesUsingSharedLibraryLPr(libraryInfo, 4202496, currUserId);
                                            if (!ArrayUtils.isEmpty(libClientPackages)) {
                                                Slog.w(TAG, "Not removing package " + pkg.manifestPackageName + " hosting lib " + libraryInfo.getName() + " version " + libraryInfo.getLongVersion() + " used by " + libClientPackages + " for user " + currUserId);
                                                return -6;
                                            }
                                            i++;
                                            origEnabledState2 = origEnabledState2;
                                            disabledSystemPs3 = disabledSystemPs2;
                                        }
                                        origEnabledState = origEnabledState2;
                                        disabledSystemPs = disabledSystemPs3;
                                    } else {
                                        origEnabledState = origEnabledState2;
                                        disabledSystemPs = disabledSystemPs3;
                                    }
                                    info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);
                                } catch (Throwable th4) {
                                    th = th4;
                                    while (true) {
                                        break;
                                    }
                                    throw th;
                                }
                            }
                        } catch (Throwable th5) {
                            th = th5;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    }
                    origEnabledState = origEnabledState2;
                    disabledSystemPs = disabledSystemPs3;
                    info = info2;
                    try {
                        info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);
                    } catch (Throwable th6) {
                        th = th6;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                } else {
                    Slog.w(TAG, "Not removing package " + packageName + " with versionCode " + uninstalledPs.versionCode + " != " + versionCode);
                    return -1;
                }
            } catch (Throwable th7) {
                th = th7;
                while (true) {
                    break;
                }
                throw th;
            }
        }
    }

    public static class PackageRemovedInfo {
        ArrayMap<String, PackageInstalledInfo> appearedChildPackages;
        InstallArgs args = null;
        int[] broadcastUsers = null;
        boolean dataRemoved;
        SparseArray<Integer> installReasons;
        String installerPackageName;
        int[] instantUserIds = null;
        boolean isRemovedPackageSystemUpdate = false;
        boolean isStaticSharedLib;
        boolean isUpdate;
        int[] origUsers;
        final PackageSender packageSender;
        int removedAppId = -1;
        ArrayMap<String, PackageRemovedInfo> removedChildPackages;
        boolean removedForAllUsers;
        String removedPackage;
        int[] removedUsers = null;
        int uid = -1;

        PackageRemovedInfo(PackageSender packageSender2) {
            this.packageSender = packageSender2;
        }

        /* access modifiers changed from: package-private */
        public void sendPackageRemovedBroadcasts(boolean killApp) {
            sendPackageRemovedBroadcastInternal(killApp);
            ArrayMap<String, PackageRemovedInfo> arrayMap = this.removedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.removedChildPackages.valueAt(i).sendPackageRemovedBroadcastInternal(killApp);
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageUpdatedBroadcasts() {
            if (this.isRemovedPackageSystemUpdate) {
                sendSystemPackageUpdatedBroadcastsInternal();
                ArrayMap<String, PackageRemovedInfo> arrayMap = this.removedChildPackages;
                int childCount = arrayMap != null ? arrayMap.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    PackageRemovedInfo childInfo = this.removedChildPackages.valueAt(i);
                    if (childInfo.isRemovedPackageSystemUpdate) {
                        childInfo.sendSystemPackageUpdatedBroadcastsInternal();
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageAppearedBroadcasts() {
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.appearedChildPackages;
            int packageCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < packageCount; i++) {
                PackageInstalledInfo installedInfo = this.appearedChildPackages.valueAt(i);
                this.packageSender.sendPackageAddedForNewUsers(installedInfo.name, true, false, UserHandle.getAppId(installedInfo.uid), installedInfo.newUsers, null);
            }
        }

        private void sendSystemPackageUpdatedBroadcastsInternal() {
            Bundle extras = new Bundle(2);
            int i = this.removedAppId;
            if (i < 0) {
                i = this.uid;
            }
            extras.putInt("android.intent.extra.UID", i);
            extras.putBoolean("android.intent.extra.REPLACING", true);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, this.removedPackage, null, null, null);
            String str = this.installerPackageName;
            if (str != null) {
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, str, null, null, null);
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, this.installerPackageName, null, null, null);
            }
        }

        private void sendPackageRemovedBroadcastInternal(boolean killApp) {
            if (!this.isStaticSharedLib) {
                Bundle extras = new Bundle(2);
                int removedUid = this.removedAppId;
                if (removedUid < 0) {
                    removedUid = this.uid;
                }
                extras.putInt("android.intent.extra.UID", removedUid);
                extras.putBoolean("android.intent.extra.DATA_REMOVED", this.dataRemoved);
                extras.putBoolean("android.intent.extra.DONT_KILL_APP", !killApp);
                if (this.isUpdate || this.isRemovedPackageSystemUpdate) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                extras.putBoolean("android.intent.extra.REMOVED_FOR_ALL_USERS", this.removedForAllUsers);
                String str = this.removedPackage;
                if (str != null) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", str, extras, 0, null, null, this.broadcastUsers, this.instantUserIds);
                    String str2 = this.installerPackageName;
                    if (str2 != null) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, str2, null, this.broadcastUsers, this.instantUserIds);
                    }
                    if (this.dataRemoved && !this.isRemovedPackageSystemUpdate) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_FULLY_REMOVED", this.removedPackage, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                        this.packageSender.notifyPackageRemoved(this.removedPackage, removedUid);
                    }
                }
                if (this.removedAppId >= 0) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.UID_REMOVED", null, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void populateUsers(int[] userIds, PackageSetting deletedPackageSetting) {
            this.removedUsers = userIds;
            if (this.removedUsers == null) {
                this.broadcastUsers = null;
                return;
            }
            this.broadcastUsers = PackageManagerService.EMPTY_INT_ARRAY;
            this.instantUserIds = PackageManagerService.EMPTY_INT_ARRAY;
            for (int i = userIds.length - 1; i >= 0; i--) {
                int userId = userIds[i];
                if (deletedPackageSetting.getInstantApp(userId)) {
                    this.instantUserIds = ArrayUtils.appendInt(this.instantUserIds, userId);
                } else {
                    this.broadcastUsers = ArrayUtils.appendInt(this.broadcastUsers, userId);
                }
            }
        }
    }

    private void removePackageDataLIF(PackageSetting deletedPs, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) {
        PackageParser.Package resolvedPkg;
        String packageName = deletedPs.name;
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "removePackageDataLI: " + deletedPs);
        }
        PackageParser.Package deletedPkg = deletedPs.pkg;
        if (outInfo != null) {
            outInfo.removedPackage = packageName;
            outInfo.installerPackageName = deletedPs.installerPackageName;
            outInfo.isStaticSharedLib = (deletedPkg == null || deletedPkg.staticSharedLibName == null) ? false : true;
            outInfo.populateUsers(deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true), deletedPs);
        }
        removePackageLI(deletedPs.name, (flags & Integer.MIN_VALUE) != 0);
        if ((flags & 1) == 0) {
            if (deletedPkg != null) {
                resolvedPkg = deletedPkg;
            } else {
                resolvedPkg = new PackageParser.Package(deletedPs.name);
                resolvedPkg.setVolumeUuid(deletedPs.volumeUuid);
            }
            destroyAppDataLIF(resolvedPkg, -1, 7);
            destroyAppProfilesLIF(resolvedPkg);
            if (outInfo != null) {
                outInfo.dataRemoved = true;
            }
        }
        int removedAppId = -1;
        boolean installedStateChanged = false;
        if ((flags & 1) == 0) {
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            synchronized (this.mPackages) {
                clearIntentFilterVerificationsLPw(deletedPs.name, -1, true);
                clearDefaultBrowserIfNeeded(packageName);
                this.mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName);
                removedAppId = this.mSettings.removePackageLPw(packageName);
                if (outInfo != null) {
                    outInfo.removedAppId = removedAppId;
                }
                this.mPermissionManager.updatePermissions(deletedPs.name, null, false, this.mPackages.values(), this.mPermissionCallback);
                if (deletedPs.sharedUser != null) {
                    int[] userIds = UserManagerService.getInstance().getUserIds();
                    int length = userIds.length;
                    int i = 0;
                    while (true) {
                        if (i >= length) {
                            break;
                        }
                        int userIdToKill = this.mSettings.updateSharedUserPermsLPw(deletedPs, userIds[i]);
                        if (userIdToKill == -1) {
                            break;
                        } else if (userIdToKill >= 0) {
                            break;
                        } else {
                            i++;
                        }
                    }
                    this.mHandler.post(new Runnable(deletedPs) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$dXhuyxmq1KMoFv5e0Vx_o3hKjBI */
                        private final /* synthetic */ PackageSetting f$1;

                        {
                            this.f$1 = r2;
                        }

                        public final void run() {
                            PackageManagerService.this.lambda$removePackageDataLIF$20$PackageManagerService(this.f$1);
                        }
                    });
                }
                clearPackagePreferredActivitiesLPw(deletedPs.name, changedUsers, -1);
            }
            if (changedUsers.size() > 0) {
                updateDefaultHomeNotLocked(changedUsers);
                postPreferredActivityChangedBroadcast(-1);
            }
        }
        if (!(allUserHandles == null || outInfo == null || outInfo.origUsers == null)) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Propagating install state across downgrade");
            }
            for (int userId : allUserHandles) {
                boolean installed = ArrayUtils.contains(outInfo.origUsers, userId);
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "    user " + userId + " => " + installed);
                }
                if (installed != deletedPs.getInstalled(userId)) {
                    installedStateChanged = true;
                }
                deletedPs.setInstalled(installed, userId);
            }
        }
        synchronized (this.mPackages) {
            if (writeSettings) {
                try {
                    this.mSettings.writeLPr();
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (installedStateChanged) {
                this.mSettings.writeKernelMappingLPr(deletedPs);
            }
        }
        if (removedAppId != -1) {
            removeKeystoreDataIfNeeded(-1, removedAppId);
        }
    }

    public /* synthetic */ void lambda$removePackageDataLIF$20$PackageManagerService(PackageSetting deletedPs) {
        killApplication(deletedPs.name, deletedPs.appId, KILL_APP_REASON_GIDS_CHANGED);
    }

    static boolean locationIsPrivileged(String path) {
        try {
            File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
            File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), "priv-app");
            File privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
            File privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
            File privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
            File oppoPrivilegedProductAppDir = new File(Environment.getOppoProductDirectory(), "priv-app");
            File oppoPrivilegedEngineerAppDir = new File(Environment.getOppoEngineerDirectory(), "priv-app");
            File oppoPrivilegedVersionAppDir = new File(Environment.getOppoVersionDirectory(), "priv-app");
            File oppoPrivilegedCustomAppDir = new File(Environment.getOppoCustomDirectory(), "priv-app");
            if (!path.startsWith(privilegedAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                if (!path.startsWith(privilegedVendorAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                    if (!path.startsWith(privilegedOdmAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                        if (!path.startsWith(privilegedProductAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                            if (!path.startsWith(privilegedProductServicesAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                                if (!path.startsWith(oppoPrivilegedProductAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                                    if (!path.startsWith(oppoPrivilegedEngineerAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                                        if (!path.startsWith(oppoPrivilegedVersionAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                                            if (path.startsWith(oppoPrivilegedCustomAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                                                return true;
                                            }
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return true;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsOem(String path) {
        try {
            return path.startsWith(Environment.getOemDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsVendor(String path) {
        try {
            if (!path.startsWith(Environment.getVendorDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                if (!path.startsWith(Environment.getOdmDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                    if (path.startsWith(Environment.getOppoEngineerDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                        return true;
                    }
                    return false;
                }
            }
            return true;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsProduct(String path) {
        try {
            if (!path.startsWith(Environment.getProductDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                if (!path.startsWith(Environment.getOppoProductDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                    if (path.startsWith(Environment.getOppoVersionDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                        return true;
                    }
                    return false;
                }
            }
            return true;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsProductServices(String path) {
        try {
            return path.startsWith(Environment.getProductServicesDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsCustom(String path) {
        try {
            return path.startsWith(Environment.getOppoCustomDirectory().getCanonicalPath());
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsOdm(String path) {
        try {
            return path.startsWith(Environment.getOdmDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    private void deleteSystemPackageLIF(DeletePackageAction action, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) throws SystemDeleteException {
        int flags2;
        PackageSetting stubPs;
        PackageSetting stubPs2;
        PackageRemovedInfo childInfo;
        boolean applyUserRestrictions = (allUserHandles == null || outInfo == null || outInfo.origUsers == null) ? false : true;
        PackageParser.Package deletedPkg = deletedPs.pkg;
        PackageSetting disabledPs = action.disabledPs;
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deleteSystemPackageLI: newPs=" + deletedPkg.packageName + " disabledPs=" + disabledPs);
        }
        Slog.d(TAG, "Deleting system pkg from data partition");
        if (DEBUG_REMOVE && applyUserRestrictions) {
            Slog.d(TAG, "Remembering install states:");
            for (int userId : allUserHandles) {
                Slog.d(TAG, "   u=" + userId + " inst=" + ArrayUtils.contains(outInfo.origUsers, userId));
            }
        }
        if (outInfo != null) {
            outInfo.isRemovedPackageSystemUpdate = true;
            if (outInfo.removedChildPackages != null) {
                int childCount = deletedPs.childPackageNames != null ? deletedPs.childPackageNames.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    String childPackageName = (String) deletedPs.childPackageNames.get(i);
                    if (!(disabledPs.childPackageNames == null || !disabledPs.childPackageNames.contains(childPackageName) || (childInfo = outInfo.removedChildPackages.get(childPackageName)) == null)) {
                        childInfo.isRemovedPackageSystemUpdate = true;
                    }
                }
            }
        }
        if (disabledPs.versionCode < deletedPs.versionCode) {
            flags2 = flags & -2;
        } else {
            flags2 = flags | 1;
        }
        deleteInstalledPackageLIF(deletedPs, true, flags2, allUserHandles, outInfo, writeSettings, disabledPs.pkg);
        synchronized (this.mPackages) {
            enableSystemPackageLPw(disabledPs.pkg);
            removeNativeBinariesLI(deletedPs);
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "Re-installing system package: " + disabledPs);
        }
        try {
            installPackageFromSystemLIF(disabledPs.codePathString, allUserHandles, outInfo == null ? null : outInfo.origUsers, deletedPs.getPermissionsState(), writeSettings);
            if (disabledPs.pkg.isStub && (stubPs2 = this.mSettings.mPackages.get(deletedPkg.packageName)) != null) {
                stubPs2.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            }
        } catch (PackageManagerException e) {
            Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName + ": " + e.getMessage());
            throw new SystemDeleteException(e);
        } catch (Throwable th) {
            if (disabledPs.pkg.isStub && (stubPs = this.mSettings.mPackages.get(deletedPkg.packageName)) != null) {
                stubPs.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            }
            throw th;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private PackageParser.Package installPackageFromSystemLIF(String codePathString, int[] allUserHandles, int[] origUserHandles, PermissionsState origPermissionState, boolean writeSettings) throws PackageManagerException {
        int scanFlags;
        int i;
        boolean applyUserRestrictions;
        File codePath;
        boolean installed;
        boolean z = true;
        int parseFlags = this.mDefParseFlags | 1 | 16;
        int scanFlags2 = 131072;
        if (locationIsPrivileged(codePathString)) {
            scanFlags2 = 131072 | 262144;
        }
        if (locationIsOem(codePathString)) {
            scanFlags2 |= 524288;
        }
        if (locationIsVendor(codePathString)) {
            scanFlags2 |= 1048576;
        }
        if (locationIsProduct(codePathString)) {
            scanFlags2 |= 2097152;
        }
        if (locationIsProductServices(codePathString)) {
            scanFlags2 |= DumpState.DUMP_CHANGES;
        }
        if (locationIsOdm(codePathString)) {
            scanFlags = scanFlags2 | 8388608;
        } else {
            scanFlags = scanFlags2;
        }
        File codePath2 = new File(codePathString);
        PackageParser.Package pkg = scanPackageTracedLI(codePath2, parseFlags, scanFlags, 0, (UserHandle) null);
        try {
            updateSharedLibrariesLocked(pkg, null, Collections.unmodifiableMap(this.mPackages));
        } catch (PackageManagerException e) {
            Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
        }
        prepareAppDataAfterInstallLIF(pkg);
        synchronized (this.mPackages) {
            try {
                PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                if (origPermissionState != null) {
                    try {
                        ps.getPermissionsState().copyFrom(origPermissionState);
                    } catch (Throwable th) {
                        th = th;
                    }
                }
                this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                if (allUserHandles == null || origUserHandles == null) {
                    z = false;
                }
                boolean applyUserRestrictions2 = z;
                if (applyUserRestrictions2) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across reinstall");
                    }
                    boolean installedStateChanged = false;
                    int i2 = 0;
                    for (int length = allUserHandles.length; i2 < length; length = i) {
                        int userId = allUserHandles[i2];
                        boolean installed2 = ArrayUtils.contains(origUserHandles, userId);
                        if (DEBUG_REMOVE) {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            StringBuilder sb = new StringBuilder();
                            i = length;
                            sb.append("    user ");
                            sb.append(userId);
                            sb.append(" => ");
                            installed = installed2;
                            sb.append(installed);
                            Slog.d(TAG, sb.toString());
                        } else {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            i = length;
                            installed = installed2;
                        }
                        if (installed != ps.getInstalled(userId)) {
                            installedStateChanged = true;
                        }
                        ps.setInstalled(installed, userId);
                        this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                        i2++;
                        codePath2 = codePath;
                        applyUserRestrictions2 = applyUserRestrictions;
                    }
                    this.mSettings.writeAllUsersPackageRestrictionsLPr();
                    if (installedStateChanged) {
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                }
                if (writeSettings) {
                    this.mSettings.writeLPr();
                }
                return pkg;
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    private void deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        int childCount;
        PackageSetting childPs;
        synchronized (this.mPackages) {
            if (outInfo != null) {
                try {
                    outInfo.uid = ps.appId;
                } catch (Throwable th) {
                    throw th;
                }
            }
            childCount = 0;
            if (!(outInfo == null || outInfo.removedChildPackages == null)) {
                int childCount2 = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
                for (int i = 0; i < childCount2; i++) {
                    String childPackageName = (String) ps.childPackageNames.get(i);
                    PackageSetting childPs2 = this.mSettings.mPackages.get(childPackageName);
                    PackageRemovedInfo childInfo = outInfo.removedChildPackages.get(childPackageName);
                    if (childInfo != null) {
                        childInfo.uid = childPs2.appId;
                    }
                }
            }
        }
        removePackageDataLIF(ps, allUserHandles, outInfo, flags, writeSettings);
        if (ps.childPackageNames != null) {
            childCount = ps.childPackageNames.size();
        }
        for (int i2 = 0; i2 < childCount; i2++) {
            synchronized (this.mPackages) {
                childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i2));
            }
            if (childPs != null) {
                removePackageDataLIF(childPs, allUserHandles, (outInfo == null || outInfo.removedChildPackages == null) ? null : outInfo.removedChildPackages.get(childPs.name), ((flags & 1) == 0 || replacingPackage == null || replacingPackage.hasChildPackage(childPs.name)) ? flags : flags & -2, writeSettings);
            }
        }
        if (ps.parentPackageName == null && deleteCodeAndResources && outInfo != null) {
            outInfo.args = createInstallArgsForExisting(ps.codePathString, ps.resourcePathString, InstructionSets.getAppDexInstructionSets(ps));
        }
    }

    public boolean setBlockUninstallForUser(String packageName, boolean blockUninstall, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || pkg.staticSharedLibName == null) {
                this.mSettings.setBlockUninstallLPw(userId, packageName, blockUninstall);
                this.mSettings.writePackageRestrictionsLPr(userId);
                return true;
            }
            Slog.w(TAG, "Cannot block uninstall of package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
            return false;
        }
    }

    public boolean getBlockUninstallForUser(String packageName, int userId) {
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
                    return this.mSettings.getBlockUninstallLPr(userId, packageName);
                }
            }
            return false;
        }
    }

    public boolean setRequiredForSystemUser(String packageName, boolean systemUserApp) {
        enforceSystemOrRoot("setRequiredForSystemUser can only be run by the system or root");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Log.w(TAG, "Package doesn't exist: " + packageName);
                return false;
            }
            if (systemUserApp) {
                ps.pkgPrivateFlags |= 512;
            } else {
                ps.pkgPrivateFlags &= -513;
            }
            this.mSettings.writeLPr();
            return true;
        }
    }

    /* access modifiers changed from: private */
    public static class DeletePackageAction {
        public final PackageSetting deletingPs;
        public final PackageSetting disabledPs;
        public final int flags;
        public final PackageRemovedInfo outInfo;
        public final UserHandle user;

        private DeletePackageAction(PackageSetting deletingPs2, PackageSetting disabledPs2, PackageRemovedInfo outInfo2, int flags2, UserHandle user2) {
            this.deletingPs = deletingPs2;
            this.disabledPs = disabledPs2;
            this.outInfo = outInfo2;
            this.flags = flags2;
            this.user = user2;
        }
    }

    @GuardedBy({"mPackages"})
    private static DeletePackageAction mayDeletePackageLocked(PackageRemovedInfo outInfo, PackageSetting ps, PackageSetting disabledPs, PackageSetting[] children, int flags, UserHandle user) {
        if (ps == null) {
            return null;
        }
        if (isSystemApp(ps)) {
            if (ps.parentPackageName != null) {
                Slog.w(TAG, "Attempt to delete child system package " + ps.pkg.packageName);
                return null;
            }
            boolean deleteAllUsers = true;
            boolean deleteSystem = (flags & 4) != 0;
            if (!(user == null || user.getIdentifier() == -1)) {
                deleteAllUsers = false;
            }
            if ((!deleteSystem || deleteAllUsers) && disabledPs == null) {
                Slog.w(TAG, "Attempt to delete unknown system package " + ps.pkg.packageName);
                return null;
            }
        }
        int parentReferenceCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
        int childCount = children != null ? children.length : 0;
        if (childCount != parentReferenceCount) {
            return null;
        }
        if (!(childCount == 0 || outInfo == null || outInfo.removedChildPackages == null)) {
            for (PackageSetting child : children) {
                if (child == null || !ps.childPackageNames.contains(child.name)) {
                    return null;
                }
            }
        }
        return new DeletePackageAction(ps, disabledPs, outInfo, flags, user);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:36:0x00a6, code lost:
        r0 = th;
     */
    private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        DeletePackageAction action;
        OppoCutomizeManagerInternal customizeMgr;
        synchronized (this.mPackages) {
            PackageSetting pstemp = this.mSettings.mPackages.get(packageName);
            if (isCustomApiSupported && (customizeMgr = getOppoCutomizeManagerInternal()) != null && customizeMgr.getDetachableInstallSysAppList().contains(pstemp.pkg.packageName)) {
                pstemp.pkgFlags &= -2;
            }
            action = mayDeletePackageLocked(outInfo, pstemp, this.mSettings.getDisabledSystemPkgLPr(pstemp), this.mSettings.getChildSettingsLPr(pstemp), flags, user);
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deletePackageLI: " + packageName + " user " + user);
        }
        if (action == null) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "deletePackageLI: action was null");
            }
            return false;
        }
        try {
            executeDeletePackageLIF(action, packageName, deleteCodeAndResources, allUserHandles, writeSettings, replacingPackage);
            return true;
        } catch (SystemDeleteException e) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "deletePackageLI: system deletion failure", e);
            }
            return false;
        }
        while (true) {
        }
    }

    /* access modifiers changed from: private */
    public static class SystemDeleteException extends Exception {
        public final PackageManagerException reason;

        private SystemDeleteException(PackageManagerException reason2) {
            this.reason = reason2;
        }
    }

    private void executeDeletePackageLIF(DeletePackageAction action, String packageName, boolean deleteCodeAndResources, int[] allUserHandles, boolean writeSettings, PackageParser.Package replacingPackage) throws SystemDeleteException {
        int childCount;
        boolean keepUninstalledPackage;
        PackageSetting ps = action.deletingPs;
        PackageRemovedInfo outInfo = action.outInfo;
        UserHandle user = action.user;
        int flags = action.flags;
        boolean systemApp = isSystemApp(ps);
        int removedUserId = -1;
        if (ps.parentPackageName == null || (systemApp && (flags & 4) == 0)) {
            int userId = user == null ? -1 : user.getIdentifier();
            if (ps.getPermissionsState().hasPermission("android.permission.SUSPEND_APPS", userId)) {
                unsuspendForSuspendingPackage(packageName, userId);
            }
            if ((!systemApp || (flags & 4) != 0) && userId != -1) {
                synchronized (this.mPackages) {
                    markPackageUninstalledForUserLPw(ps, user);
                    if (!systemApp) {
                        boolean keepUninstalledPackage2 = shouldKeepUninstalledPackageLPr(packageName);
                        if (!ps.isAnyInstalled(sUserManager.getUserIds())) {
                            if (!keepUninstalledPackage2) {
                                if (DEBUG_REMOVE) {
                                    Slog.d(TAG, "Not installed by other users, full delete");
                                }
                                ps.setInstalled(true, userId);
                                this.mSettings.writeKernelMappingLPr(ps);
                                keepUninstalledPackage = false;
                            }
                        }
                        if (DEBUG_REMOVE) {
                            Slog.d(TAG, "Still installed by other users");
                        }
                        keepUninstalledPackage = true;
                    } else {
                        if (DEBUG_REMOVE) {
                            Slog.d(TAG, "Deleting system app");
                        }
                        keepUninstalledPackage = true;
                    }
                }
                if (keepUninstalledPackage) {
                    clearPackageStateForUserLIF(ps, userId, outInfo, flags);
                    synchronized (this.mPackages) {
                        scheduleWritePackageRestrictionsLocked(user);
                    }
                    return;
                }
            }
            if (!(ps.childPackageNames == null || outInfo == null)) {
                synchronized (this.mPackages) {
                    int childCount2 = ps.childPackageNames.size();
                    outInfo.removedChildPackages = new ArrayMap<>(childCount2);
                    int i = 0;
                    while (i < childCount2) {
                        String childPackageName = (String) ps.childPackageNames.get(i);
                        PackageRemovedInfo childInfo = new PackageRemovedInfo(this);
                        childInfo.removedPackage = childPackageName;
                        childInfo.installerPackageName = ps.installerPackageName;
                        outInfo.removedChildPackages.put(childPackageName, childInfo);
                        PackageSetting childPs = this.mSettings.getPackageLPr(childPackageName);
                        if (childPs != null) {
                            childCount = childCount2;
                            childInfo.origUsers = childPs.queryInstalledUsers(allUserHandles, true);
                        } else {
                            childCount = childCount2;
                        }
                        i++;
                        childCount2 = childCount;
                    }
                }
            }
            if (systemApp) {
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "Removing system package: " + ps.name);
                }
                deleteSystemPackageLIF(action, ps, allUserHandles, flags, outInfo, writeSettings);
            } else {
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "Removing non-system package: " + ps.name);
                }
                deleteInstalledPackageLIF(ps, deleteCodeAndResources, flags, allUserHandles, outInfo, writeSettings, replacingPackage);
            }
            if (outInfo != null) {
                int childCount3 = 0;
                outInfo.removedForAllUsers = this.mPackages.get(ps.name) == null;
                if (outInfo.removedChildPackages != null) {
                    synchronized (this.mPackages) {
                        int childCount4 = outInfo.removedChildPackages.size();
                        for (int i2 = 0; i2 < childCount4; i2++) {
                            PackageRemovedInfo childInfo2 = outInfo.removedChildPackages.valueAt(i2);
                            if (childInfo2 != null) {
                                childInfo2.removedForAllUsers = this.mPackages.get(childInfo2.removedPackage) == null;
                            }
                        }
                    }
                }
                if (systemApp) {
                    synchronized (this.mPackages) {
                        PackageSetting updatedPs = this.mSettings.getPackageLPr(ps.name);
                        if (updatedPs.childPackageNames != null) {
                            childCount3 = updatedPs.childPackageNames.size();
                        }
                        for (int i3 = 0; i3 < childCount3; i3++) {
                            String childPackageName2 = (String) updatedPs.childPackageNames.get(i3);
                            if (outInfo.removedChildPackages == null || outInfo.removedChildPackages.indexOfKey(childPackageName2) < 0) {
                                PackageSetting childPs2 = this.mSettings.getPackageLPr(childPackageName2);
                                if (childPs2 != null) {
                                    PackageInstalledInfo installRes = new PackageInstalledInfo();
                                    installRes.name = childPackageName2;
                                    installRes.newUsers = childPs2.queryInstalledUsers(allUserHandles, true);
                                    installRes.pkg = this.mPackages.get(childPackageName2);
                                    installRes.uid = childPs2.pkg.applicationInfo.uid;
                                    if (outInfo.appearedChildPackages == null) {
                                        outInfo.appearedChildPackages = new ArrayMap<>();
                                    }
                                    outInfo.appearedChildPackages.put(childPackageName2, installRes);
                                }
                            }
                        }
                    }
                    return;
                }
                return;
            }
            return;
        }
        if (DEBUG_REMOVE) {
            StringBuilder sb = new StringBuilder();
            sb.append("Uninstalled child package:");
            sb.append(packageName);
            sb.append(" for user:");
            sb.append(user == null ? -1 : user);
            Slog.d(TAG, sb.toString());
        }
        if (user != null) {
            removedUserId = user.getIdentifier();
        }
        clearPackageStateForUserLIF(ps, removedUserId, outInfo, flags);
        synchronized (this.mPackages) {
            markPackageUninstalledForUserLPw(ps, user);
            scheduleWritePackageRestrictionsLocked(user);
        }
    }

    @GuardedBy({"mPackages"})
    private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) {
        PackageSetting packageSetting = ps;
        boolean z = false;
        int[] userIds = (user == null || user.getIdentifier() == -1) ? sUserManager.getUserIds() : new int[]{user.getIdentifier()};
        int length = userIds.length;
        int i = 0;
        while (i < length) {
            int nextUserId = userIds[i];
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Marking package:" + packageSetting.name + " uninstalled for user:" + nextUserId);
            }
            ps.setUserState(nextUserId, 0, 0, false, true, true, false, 0, false, null, null, null, null, false, false, null, null, null, packageSetting.readUserState(nextUserId).domainVerificationStatus, 0, 0, null);
            StringBuilder sb = new StringBuilder();
            sb.append("reset oppo-freeze state for ");
            packageSetting = ps;
            sb.append(packageSetting.name);
            sb.append(" after uninstalled for user ");
            sb.append(nextUserId);
            Slog.d(TAG, sb.toString());
            z = false;
            packageSetting.setOppoFreezeState(0, nextUserId);
            i++;
            length = length;
            userIds = userIds;
        }
        this.mSettings.writeKernelMappingLPr(packageSetting);
    }

    private void clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo, int flags) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(ps.name);
        }
        destroyAppProfilesLIF(pkg);
        boolean z = false;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Updating package:" + ps.name + " install state for user:" + nextUserId);
            }
            destroyAppDataLIF(pkg, nextUserId, 7);
            clearDefaultBrowserIfNeededForUser(ps.name, nextUserId);
            removeKeystoreDataIfNeeded(nextUserId, ps.appId);
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            clearPackagePreferredActivitiesLPw(ps.name, changedUsers, nextUserId);
            if (changedUsers.size() > 0) {
                updateDefaultHomeNotLocked(changedUsers);
                postPreferredActivityChangedBroadcast(nextUserId);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(nextUserId);
                }
            }
            synchronized (this.mPackages) {
                resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId);
            }
            if ((flags & 16) != 0) {
                try {
                    MediaStore.deleteContributedMedia(this.mContext, ps.name, UserHandle.of(nextUserId));
                } catch (IOException e) {
                    Slog.w(TAG, "Failed to delete contributed media for " + ps.name, e);
                }
            }
        }
        if (outInfo != null) {
            outInfo.removedPackage = ps.name;
            outInfo.installerPackageName = ps.installerPackageName;
            if (!(pkg == null || pkg.staticSharedLibName == null)) {
                z = true;
            }
            outInfo.isStaticSharedLib = z;
            outInfo.removedAppId = ps.appId;
            outInfo.removedUsers = userIds;
            outInfo.broadcastUsers = userIds;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:21:0x002b, code lost:
        r3 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x002c, code lost:
        if (r0 != null) goto L_0x002e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x002e, code lost:
        $closeResource(r2, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0031, code lost:
        throw r3;
     */
    public void clearApplicationProfileData(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("Only the system can clear all profile data");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        PackageFreezer freezer = freezePackage(packageName, "clearApplicationProfileData");
        synchronized (this.mInstallLock) {
            clearAppProfilesLIF(pkg, -1);
        }
        if (freezer != null) {
            $closeResource(null, freezer);
        }
    }

    public void clearApplicationUserData(final String packageName, final IPackageDataObserver observer, final int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_USER_DATA", null);
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "clear application data");
        PackageSetting ps = this.mSettings.getPackageLPr(packageName);
        final boolean filterApp = ps != null && filterAppAccessLPr(ps, callingUid, userId);
        if (filterApp || !this.mProtectedPackages.isPackageDataProtected(userId, packageName)) {
            this.mHandler.post(new Runnable() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass9 */

                /* JADX WARNING: Code restructure failed: missing block: B:32:0x006c, code lost:
                    r2 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:33:0x006d, code lost:
                    if (r0 != null) goto L_0x006f;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:35:?, code lost:
                    r0.close();
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:36:0x0073, code lost:
                    r3 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:37:0x0074, code lost:
                    r1.addSuppressed(r3);
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:38:0x0077, code lost:
                    throw r2;
                 */
                public void run() {
                    boolean succeeded;
                    PackageManagerService.this.mHandler.removeCallbacks(this);
                    if (!filterApp) {
                        PackageFreezer freezer = PackageManagerService.this.freezePackage(packageName, "clearApplicationUserData");
                        synchronized (PackageManagerService.this.mInstallLock) {
                            succeeded = PackageManagerService.this.clearApplicationUserDataLIF(packageName, userId);
                        }
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mInstantAppRegistry.deleteInstantApplicationMetadataLPw(packageName, userId);
                        }
                        if (freezer != null) {
                            freezer.close();
                        }
                        if (succeeded) {
                            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
                            if (dsm != null) {
                                dsm.checkMemory();
                            }
                            if (PackageManagerService.this.checkPermission("android.permission.SUSPEND_APPS", packageName, userId) == 0) {
                                PackageManagerService.this.unsuspendForSuspendingPackage(packageName, userId);
                            }
                        }
                    } else {
                        succeeded = false;
                    }
                    IPackageDataObserver iPackageDataObserver = observer;
                    if (iPackageDataObserver != null) {
                        try {
                            iPackageDataObserver.onRemoveCompleted(packageName, succeeded);
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                        }
                    }
                }
            });
            return;
        }
        throw new SecurityException("Cannot clear data for a protected package: " + packageName);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x004e, code lost:
        clearAppDataLIF(r2, r8, 7);
        removeKeystoreDataIfNeeded(r8, android.os.UserHandle.getAppId(r2.applicationInfo.uid));
        r1 = getUserManagerInternal();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0065, code lost:
        if (r1.isUserUnlockingOrUnlocked(r8) == false) goto L_0x0069;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x0067, code lost:
        r3 = 3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x006d, code lost:
        if (r1.isUserRunning(r8) == false) goto L_0x0071;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x006f, code lost:
        r3 = 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0071, code lost:
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x0072, code lost:
        prepareAppDataContentsLIF(r2, r8, r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:26:0x0076, code lost:
        return true;
     */
    private boolean clearApplicationUserDataLIF(String packageName, int userId) {
        PackageSetting ps;
        if (packageName == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null && (ps = this.mSettings.mPackages.get(packageName)) != null) {
                pkg = ps.pkg;
            }
            if (pkg == null) {
                Slog.w(TAG, "Package named '" + packageName + "' doesn't exist.");
                return false;
            }
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
        }
    }

    @GuardedBy({"mPackages"})
    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) this.mPackages.valueAt(i).mExtras, userId);
        }
    }

    private void resetNetworkPolicies(int userId) {
        ((NetworkPolicyManagerInternal) LocalServices.getService(NetworkPolicyManagerInternal.class)).resetUserState(userId);
    }

    /* JADX WARNING: Removed duplicated region for block: B:49:0x0176  */
    /* JADX WARNING: Removed duplicated region for block: B:50:0x017b  */
    @GuardedBy({"mPackages"})
    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(PackageSetting ps, int userId) {
        ArraySet<Long> revokedPermissions;
        SparseBooleanArray updatedUsers;
        int permissionCount;
        int i;
        int uid;
        AppOpsManager appOpsManager;
        int uid2;
        int flags;
        if (ps.pkg != null && !OppoFeatureCache.get(IColorMultiAppManager.DEFAULT).shouldSkipResetPermission(userId, ps.pkg.packageName)) {
            String packageName = ps.pkg.packageName;
            final boolean[] permissionRemoved = new boolean[1];
            final ArraySet<Long> revokedPermissions2 = new ArraySet<>();
            final SparseBooleanArray updatedUsers2 = new SparseBooleanArray();
            PermissionManagerServiceInternal.PermissionCallback delayingPermCallback = new PermissionManagerServiceInternal.PermissionCallback() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass10 */

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onGidsChanged(int appId, int userId) {
                    PackageManagerService.this.mPermissionCallback.onGidsChanged(appId, userId);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionChanged() {
                    PackageManagerService.this.mPermissionCallback.onPermissionChanged();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionGranted(int uid, int userId) {
                    PackageManagerService.this.mPermissionCallback.onPermissionGranted(uid, userId);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionGranted() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionGranted();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionRevoked(int uid, int userId) {
                    revokedPermissions2.add(Long.valueOf(IntPair.of(uid, userId)));
                    updatedUsers2.put(userId, true);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionRevoked() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionRevoked();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
                    for (int userId : updatedUserIds) {
                        if (sync) {
                            updatedUsers2.put(userId, true);
                        } else if (!updatedUsers2.get(userId)) {
                            updatedUsers2.put(userId, false);
                        }
                    }
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionRemoved() {
                    permissionRemoved[0] = true;
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionUpdated() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionUpdated();
                }
            };
            AppOpsManager appOpsManager2 = (AppOpsManager) this.mContext.getSystemService(AppOpsManager.class);
            int uid3 = UserHandle.getUid(userId, ps.pkg.applicationInfo.uid);
            int permissionCount2 = ps.pkg.requestedPermissions.size();
            boolean pkgReviewRequired = isPackageNeedsReview(ps.pkg, this.mSettings);
            int i2 = 0;
            while (i2 < permissionCount2) {
                String permName = (String) ps.pkg.requestedPermissions.get(i2);
                BasePermission bp = this.mPermissionManager.getPermissionTEMP(permName);
                if (bp == null) {
                    i = i2;
                    permissionCount = permissionCount2;
                    updatedUsers = updatedUsers2;
                    revokedPermissions = revokedPermissions2;
                    uid = uid3;
                    appOpsManager = appOpsManager2;
                } else if (bp.isRemoved()) {
                    i = i2;
                    permissionCount = permissionCount2;
                    updatedUsers = updatedUsers2;
                    revokedPermissions = revokedPermissions2;
                    uid = uid3;
                    appOpsManager = appOpsManager2;
                } else {
                    if (ps.sharedUser != null) {
                        boolean used = false;
                        int packageCount = ps.sharedUser.packages.size();
                        i = i2;
                        int j = 0;
                        while (true) {
                            if (j >= packageCount) {
                                permissionCount = permissionCount2;
                                uid2 = uid3;
                                break;
                            }
                            PackageSetting pkg = ps.sharedUser.packages.valueAt(j);
                            permissionCount = permissionCount2;
                            if (pkg.pkg != null) {
                                uid2 = uid3;
                                if (!pkg.pkg.packageName.equals(ps.pkg.packageName) && pkg.pkg.requestedPermissions.contains(permName)) {
                                    used = true;
                                    break;
                                }
                            } else {
                                uid2 = uid3;
                            }
                            j++;
                            packageCount = packageCount;
                            permissionCount2 = permissionCount;
                            uid3 = uid2;
                        }
                        if (used) {
                            revokedPermissions = revokedPermissions2;
                            uid = uid2;
                            updatedUsers = updatedUsers2;
                            appOpsManager = appOpsManager2;
                        }
                    } else {
                        i = i2;
                        permissionCount = permissionCount2;
                        uid2 = uid3;
                    }
                    int oldFlags = this.mPermissionManager.getPermissionFlags(permName, packageName, 1000, userId);
                    if (CtaManagerFactory.getInstance().makeCtaManager().isCtaSupported()) {
                        if (pkgReviewRequired && bp.isRuntime() && CtaManagerFactory.getInstance().makeCtaManager().isPlatformPermission(bp.getSourcePackageName(), bp.getName()) && (oldFlags & 16) == 0) {
                            flags = 0 | 72;
                            updatedUsers = updatedUsers2;
                            revokedPermissions = revokedPermissions2;
                            this.mPermissionManager.updatePermissionFlags(permName, packageName, 75, flags, 1000, userId, false, delayingPermCallback);
                            if (!bp.isRuntime()) {
                                uid = uid2;
                                appOpsManager = appOpsManager2;
                            } else if ((oldFlags & 20) != 0) {
                                uid = uid2;
                                appOpsManager = appOpsManager2;
                            } else if ((oldFlags & 32) != 0) {
                                this.mPermissionManager.grantRuntimePermission(permName, packageName, false, 1000, userId, delayingPermCallback);
                                String appOp = AppOpsManager.permissionToOp(permName);
                                if (appOp != null) {
                                    uid = uid2;
                                    appOpsManager = appOpsManager2;
                                    this.mHandler.post(new Runnable(appOpsManager, appOp, uid) {
                                        /* class com.android.server.pm.$$Lambda$PackageManagerService$8lLKUxZNhnq1cR4oo5Pu_xXk4E */
                                        private final /* synthetic */ AppOpsManager f$0;
                                        private final /* synthetic */ String f$1;
                                        private final /* synthetic */ int f$2;

                                        {
                                            this.f$0 = r1;
                                            this.f$1 = r2;
                                            this.f$2 = r3;
                                        }

                                        public final void run() {
                                            this.f$0.setUidMode(this.f$1, this.f$2, 0);
                                        }
                                    });
                                } else {
                                    uid = uid2;
                                    appOpsManager = appOpsManager2;
                                }
                            } else {
                                uid = uid2;
                                appOpsManager = appOpsManager2;
                                if ((flags & 64) == 0) {
                                    this.mPermissionManager.revokeRuntimePermission(permName, packageName, false, userId, delayingPermCallback);
                                }
                            }
                        }
                    } else if (ps.pkg.applicationInfo.targetSdkVersion < 23 && bp.isRuntime()) {
                        flags = 0 | 72;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        this.mPermissionManager.updatePermissionFlags(permName, packageName, 75, flags, 1000, userId, false, delayingPermCallback);
                        if (!bp.isRuntime()) {
                        }
                    }
                    flags = 0;
                    updatedUsers = updatedUsers2;
                    revokedPermissions = revokedPermissions2;
                    this.mPermissionManager.updatePermissionFlags(permName, packageName, 75, flags, 1000, userId, false, delayingPermCallback);
                    if (!bp.isRuntime()) {
                    }
                }
                i2 = i + 1;
                appOpsManager2 = appOpsManager;
                uid3 = uid;
                permissionCount2 = permissionCount;
                updatedUsers2 = updatedUsers;
                revokedPermissions2 = revokedPermissions;
            }
            if (permissionRemoved[0]) {
                this.mPermissionCallback.onPermissionRemoved();
            }
            if (!revokedPermissions2.isEmpty()) {
                int numRevokedPermissions = revokedPermissions2.size();
                for (int i3 = 0; i3 < numRevokedPermissions; i3++) {
                    int revocationUID = IntPair.first(revokedPermissions2.valueAt(i3).longValue());
                    int revocationUserId = IntPair.second(revokedPermissions2.valueAt(i3).longValue());
                    this.mOnPermissionChangeListeners.onPermissionsChanged(revocationUID);
                    this.mHandler.post(new Runnable(revocationUID, revocationUserId) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$T9irnsyd0hjlQ0V6JKQ0qWiY3g */
                        private final /* synthetic */ int f$1;
                        private final /* synthetic */ int f$2;

                        {
                            this.f$1 = r2;
                            this.f$2 = r3;
                        }

                        public final void run() {
                            PackageManagerService.this.lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$22$PackageManagerService(this.f$1, this.f$2);
                        }
                    });
                }
            }
            int numUpdatedUsers = updatedUsers2.size();
            for (int i4 = 0; i4 < numUpdatedUsers; i4++) {
                this.mSettings.writeRuntimePermissionsForUserLPr(updatedUsers2.keyAt(i4), updatedUsers2.valueAt(i4));
            }
        }
    }

    public /* synthetic */ void lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$22$PackageManagerService(int revocationUID, int revocationUserId) {
        killUid(UserHandle.getAppId(revocationUID), revocationUserId, KILL_APP_REASON_PERMISSIONS_REVOKED);
    }

    private static void removeKeystoreDataIfNeeded(int userId, int appId) {
        if (appId >= 0) {
            KeyStore keyStore = KeyStore.getInstance();
            if (keyStore == null) {
                Slog.w(TAG, "Could not contact keystore to clear entries for app id " + appId);
            } else if (userId == -1) {
                for (int individual : sUserManager.getUserIds()) {
                    keyStore.clearUid(UserHandle.getUid(individual, appId));
                }
            } else {
                keyStore.clearUid(UserHandle.getUid(userId, appId));
            }
        }
    }

    public void deleteApplicationCacheFiles(String packageName, IPackageDataObserver observer) {
        deleteApplicationCacheFilesAsUser(packageName, UserHandle.getCallingUserId(), observer);
    }

    public void deleteApplicationCacheFilesAsUser(String packageName, int userId, IPackageDataObserver observer) {
        PackageParser.Package pkg;
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES") != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_CACHE_FILES") == 0) {
                Slog.w(TAG, "Calling uid " + callingUid + " does not have android.permission.INTERNAL_DELETE_CACHE_FILES, silently ignoring");
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES", null);
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "delete application cache files");
        int hasAccessInstantApps = this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        this.mHandler.post(new Runnable(pkg, callingUid, hasAccessInstantApps, userId, observer, packageName) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$QTvvdwSiCiDunKinsETE3x3ruu8 */
            private final /* synthetic */ PackageParser.Package f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ int f$4;
            private final /* synthetic */ IPackageDataObserver f$5;
            private final /* synthetic */ String f$6;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
                this.f$6 = r7;
            }

            public final void run() {
                PackageManagerService.this.lambda$deleteApplicationCacheFilesAsUser$23$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6);
            }
        });
    }

    public /* synthetic */ void lambda$deleteApplicationCacheFilesAsUser$23$PackageManagerService(PackageParser.Package pkg, int callingUid, int hasAccessInstantApps, int userId, IPackageDataObserver observer, String packageName) {
        PackageSetting ps = pkg == null ? null : (PackageSetting) pkg.mExtras;
        boolean doClearData = true;
        if (ps != null) {
            doClearData = !ps.getInstantApp(UserHandle.getUserId(callingUid)) || hasAccessInstantApps == 0;
        }
        if (doClearData) {
            synchronized (this.mInstallLock) {
                clearAppDataLIF(pkg, userId, 23);
                clearAppDataLIF(pkg, userId, 39);
            }
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted(packageName, true);
            } catch (RemoteException e) {
                Log.i(TAG, "Observer no longer exists.");
            }
        }
    }

    public void getPackageSizeInfo(String packageName, int userHandle, IPackageStatsObserver observer) {
        throw new UnsupportedOperationException("Shame on you for calling the hidden API getPackageSizeInfo(). Shame!");
    }

    /* JADX WARNING: Code restructure failed: missing block: B:11:?, code lost:
        r12.mInstaller.getAppSize(r1.volumeUuid, new java.lang.String[]{r13}, r14, 0, r1.appId, new long[]{r1.getCeDataInode(r14)}, new java.lang.String[]{r1.codePathString}, r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x004c, code lost:
        if (isSystemApp(r1) == false) goto L_0x0058;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x0052, code lost:
        if (isUpdatedSystemApp(r1) != false) goto L_0x0058;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:15:0x0054, code lost:
        r15.codeSize = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:16:0x0058, code lost:
        r15.dataSize -= r15.cacheSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0060, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0061, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0062, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, java.lang.String.valueOf(r0));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x006b, code lost:
        return false;
     */
    @GuardedBy({"mInstallLock"})
    private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Slog.w(TAG, "Failed to find settings for " + packageName);
                return false;
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private int getUidTargetSdkVersionLockedLPr(int uid) {
        int v;
        Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
        if (obj instanceof SharedUserSetting) {
            int vers = 10000;
            Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.pkg != null && (v = ps.pkg.applicationInfo.targetSdkVersion) < vers) {
                    vers = v;
                }
            }
            return vers;
        } else if (!(obj instanceof PackageSetting)) {
            return 10000;
        } else {
            PackageSetting ps2 = (PackageSetting) obj;
            if (ps2.pkg != null) {
                return ps2.pkg.applicationInfo.targetSdkVersion;
            }
            return 10000;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private int getPackageTargetSdkVersionLockedLPr(String packageName) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            return p.applicationInfo.targetSdkVersion;
        }
        return 10000;
    }

    public void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Adding preferred");
    }

    private void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "add preferred activity");
        if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
            if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                Slog.w(TAG, "Ignoring addPreferredActivity() from uid " + callingUid);
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        }
        if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
            return;
        }
        if (!(activity == null || activity.getPackageName() == null || !filter.hasCategory("android.intent.category.HOME"))) {
            OppoFeatureCache.get(IColorCommonListManager.DEFAULT).putAppInfo(activity.getPackageName(), userId, "launcher");
        }
        if (DEBUG_PREFERRED) {
            Slog.i(TAG, opname + " activity " + activity.flattenToShortString() + " for user " + userId + ":");
            filter.dump(new LogPrinter(4, TAG), "  ");
        }
        synchronized (this.mPackages) {
            this.mSettings.editPreferredActivitiesLPw(userId).addFilter(new PreferredActivity(filter, match, set, activity, always));
            scheduleWritePackageRestrictionsLocked(userId);
        }
        if (!updateDefaultHomeNotLocked(userId)) {
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    private void postPreferredActivityChangedBroadcast(int userId) {
        this.mHandler.post(new Runnable(userId) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$Yfnee_CTmno9dIMhv8CxkLIk7w */
            private final /* synthetic */ int f$0;

            {
                this.f$0 = r1;
            }

            public final void run() {
                PackageManagerService.lambda$postPreferredActivityChangedBroadcast$24(this.f$0);
            }
        });
    }

    static /* synthetic */ void lambda$postPreferredActivityChangedBroadcast$24(int userId) {
        IActivityManager am = ActivityManager.getService();
        if (am != null) {
            Intent intent = new Intent("android.intent.action.ACTION_PREFERRED_ACTIVITY_CHANGED");
            intent.putExtra("android.intent.extra.user_handle", userId);
            intent.addFlags(67108864);
            try {
                am.broadcastIntent((IApplicationThread) null, intent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, (String[]) null, -1, (Bundle) null, false, false, userId);
            } catch (RemoteException e) {
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:21:0x0067, code lost:
        r15.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
     */
    public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        Throwable th;
        if (filter.countActions() == 1) {
            if (filter.countDataAuthorities() == 0) {
                if (filter.countDataPaths() == 0) {
                    if (filter.countDataSchemes() <= 1) {
                        if (filter.countDataTypes() == 0) {
                            int callingUid = Binder.getCallingUid();
                            this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "replace preferred activity");
                            if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                                synchronized (this.mPackages) {
                                    if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                                        Slog.w(TAG, "Ignoring replacePreferredActivity() from uid " + Binder.getCallingUid());
                                        return;
                                    }
                                }
                            }
                            synchronized (this.mPackages) {
                                try {
                                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
                                    if (pir != null) {
                                        ArrayList<PreferredActivity> existing = pir.findFilters(filter);
                                        if (existing != null && existing.size() == 1) {
                                            PreferredActivity cur = existing.get(0);
                                            if (DEBUG_PREFERRED) {
                                                Slog.i(TAG, "Checking replace of preferred:");
                                                filter.dump(new LogPrinter(4, TAG), "  ");
                                                if (!cur.mPref.mAlways) {
                                                    Slog.i(TAG, "  -- CUR; not mAlways!");
                                                } else {
                                                    Slog.i(TAG, "  -- CUR: mMatch=" + cur.mPref.mMatch);
                                                    Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(cur.mPref.mSetComponents));
                                                    Slog.i(TAG, "  -- CUR: mComponent=" + cur.mPref.mShortComponent);
                                                    Slog.i(TAG, "  -- NEW: mMatch=" + (match & 268369920));
                                                    Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(set));
                                                    Slog.i(TAG, "  -- CUR: mComponent=" + activity.flattenToShortString());
                                                }
                                            }
                                            if (cur.mPref.mAlways) {
                                                try {
                                                    if (cur.mPref.mComponent.equals(activity) && cur.mPref.mMatch == (match & 268369920)) {
                                                        if (cur.mPref.sameSet(set)) {
                                                            if (DEBUG_PREFERRED) {
                                                                Slog.i(TAG, "Replacing with same preferred activity " + cur.mPref.mShortComponent + " for user " + userId + ":");
                                                                filter.dump(new LogPrinter(4, TAG), "  ");
                                                            }
                                                            return;
                                                        }
                                                    }
                                                } catch (Throwable th2) {
                                                    th = th2;
                                                    throw th;
                                                }
                                            }
                                        }
                                        if (existing != null) {
                                            if (DEBUG_PREFERRED) {
                                                Slog.i(TAG, existing.size() + " existing preferred matches for:");
                                                filter.dump(new LogPrinter(4, TAG), "  ");
                                            }
                                            for (int i = existing.size() - 1; i >= 0; i--) {
                                                PreferredActivity pa = existing.get(i);
                                                if (DEBUG_PREFERRED) {
                                                    Slog.i(TAG, "Removing existing preferred activity " + pa.mPref.mComponent + ":");
                                                    pa.dump(new LogPrinter(4, TAG), "  ");
                                                }
                                                pir.removeFilter(pa);
                                            }
                                        }
                                    }
                                    addPreferredActivityInternal(filter, match, set, activity, true, userId, "Replacing preferred");
                                    return;
                                } catch (Throwable th3) {
                                    th = th3;
                                    throw th;
                                }
                            }
                        }
                    }
                }
            }
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, paths, or types; and at most one scheme.");
        }
        throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
    }

    /* JADX WARNING: Code restructure failed: missing block: B:25:0x0065, code lost:
        r1 = android.os.UserHandle.getCallingUserId();
        r2 = new android.util.SparseBooleanArray();
        clearPackagePreferredActivitiesLPw(r7, r2, r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:26:0x0075, code lost:
        if (r2.size() <= 0) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:27:0x0077, code lost:
        updateDefaultHomeNotLocked(r2);
        postPreferredActivityChangedBroadcast(r1);
        r3 = r6.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x007f, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:?, code lost:
        scheduleWritePackageRestrictionsLocked(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x0083, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:40:?, code lost:
        return;
     */
    public void clearPackagePreferredActivities(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                if ((this.mPackages.get(packageName) == null || !isCallerSameApp(packageName, callingUid)) && this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                    if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                        Slog.w(TAG, "Ignoring clearPackagePreferredActivities() from uid " + callingUid);
                        return;
                    }
                    this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                }
                PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                if (ps != null && filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void clearPackagePreferredActivitiesLPw(String packageName, SparseBooleanArray outUserChanged, int userId) {
        ArrayList<PreferredActivity> removed = null;
        synchronized (this.mPackages) {
            for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
                int thisUserId = this.mSettings.mPreferredActivities.keyAt(i);
                PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i);
                if (userId == -1 || userId == thisUserId) {
                    Iterator<PreferredActivity> it = pir.filterIterator();
                    while (it.hasNext()) {
                        PreferredActivity pa = it.next();
                        if (packageName == null || (pa != null && pa.mPref != null && pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                            if (removed == null) {
                                removed = new ArrayList<>();
                            }
                            removed.add(pa);
                        }
                    }
                    if (removed != null) {
                        for (int j = 0; j < removed.size(); j++) {
                            pir.removeFilter(removed.get(j));
                        }
                        outUserChanged.put(thisUserId, true);
                    }
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void clearIntentFilterVerificationsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            clearIntentFilterVerificationsLPw(this.mPackages.valueAt(i).packageName, userId, true);
        }
    }

    /* access modifiers changed from: package-private */
    @GuardedBy({"mPackages"})
    public void clearIntentFilterVerificationsLPw(String packageName, int userId, boolean alsoResetStatus) {
        if (userId == -1) {
            if (this.mSettings.removeIntentFilterVerificationLPw(packageName, sUserManager.getUserIds())) {
                for (int oneUserId : sUserManager.getUserIds()) {
                    scheduleWritePackageRestrictionsLocked(oneUserId);
                }
            }
        } else if (this.mSettings.removeIntentFilterVerificationLPw(packageName, userId, alsoResetStatus)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void clearDefaultBrowserIfNeeded(String packageName) {
        for (int oneUserId : sUserManager.getUserIds()) {
            clearDefaultBrowserIfNeededForUser(packageName, oneUserId);
        }
    }

    private void clearDefaultBrowserIfNeededForUser(String packageName, int userId) {
        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
        if (!TextUtils.isEmpty(defaultBrowserPackageName) && packageName.equals(defaultBrowserPackageName)) {
            setDefaultBrowserPackageName(null, userId);
        }
    }

    public void resetApplicationPreferences(int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        long identity = Binder.clearCallingIdentity();
        try {
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            clearPackagePreferredActivitiesLPw(null, changedUsers, userId);
            if (changedUsers.size() > 0) {
                postPreferredActivityChangedBroadcast(userId);
            }
            synchronized (this.mPackages) {
                this.mSettings.applyDefaultPreferredAppsLPw(userId);
                clearIntentFilterVerificationsLPw(userId);
                primeDomainVerificationsLPw(userId);
                resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
            }
            updateDefaultHomeNotLocked(userId);
            setDefaultBrowserPackageName(null, userId);
            resetNetworkPolicies(userId);
            synchronized (this.mPackages) {
                scheduleWritePackageRestrictionsLocked(userId);
            }
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return 0;
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this.mPackages) {
            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
            if (pir != null) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (outFilters != null) {
                            outFilters.add(new IntentFilter(pa));
                        }
                        if (outActivities != null) {
                            outActivities.add(pa.mPref.mComponent);
                        }
                    }
                }
            }
        }
        return 0;
    }

    public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
        } else if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else {
            if (DEBUG_PREFERRED) {
                Slog.i(TAG, "Adding persistent preferred activity " + activity + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
            }
            synchronized (this.mPackages) {
                this.mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
                scheduleWritePackageRestrictionsLocked(userId);
            }
            updateDefaultHomeNotLocked(userId);
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    public void clearPackagePersistentPreferredActivities(String packageName, int userId) {
        if (Binder.getCallingUid() == 1000) {
            ArrayList<PersistentPreferredActivity> removed = null;
            boolean changed = false;
            synchronized (this.mPackages) {
                for (int i = 0; i < this.mSettings.mPersistentPreferredActivities.size(); i++) {
                    int thisUserId = this.mSettings.mPersistentPreferredActivities.keyAt(i);
                    PersistentPreferredIntentResolver ppir = this.mSettings.mPersistentPreferredActivities.valueAt(i);
                    if (userId == thisUserId) {
                        Iterator<PersistentPreferredActivity> it = ppir.filterIterator();
                        while (it.hasNext()) {
                            PersistentPreferredActivity ppa = it.next();
                            if (ppa.mComponent.getPackageName().equals(packageName)) {
                                if (removed == null) {
                                    removed = new ArrayList<>();
                                }
                                removed.add(ppa);
                            }
                        }
                        if (removed != null) {
                            for (int j = 0; j < removed.size(); j++) {
                                ppir.removeFilter(removed.get(j));
                            }
                            changed = true;
                        }
                    }
                }
            }
            if (changed) {
                updateDefaultHomeNotLocked(userId);
                postPreferredActivityChangedBroadcast(userId);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(userId);
                }
                return;
            }
            return;
        }
        throw new SecurityException("clearPackagePersistentPreferredActivities can only be run by the system");
    }

    private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
        int type;
        do {
            type = parser.next();
            if (type == 2) {
                break;
            }
        } while (type != 1);
        if (type != 2) {
            if (DEBUG_BACKUP) {
                Slog.e(TAG, "Didn't find start tag during restore");
            }
        } else if (expectedStartTag.equals(parser.getName())) {
            do {
            } while (parser.next() == 4);
            functor.apply(parser, userId);
        } else if (DEBUG_BACKUP) {
            Slog.e(TAG, "Found unexpected tag " + parser.getName());
        }
    }

    public byte[] getPreferredActivityBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_PREFERRED_BACKUP);
                synchronized (this.mPackages) {
                    this.mSettings.writePreferredActivitiesLPr(serializer, userId, true);
                }
                serializer.endTag(null, TAG_PREFERRED_BACKUP);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write preferred activities for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getPreferredActivityBackup()");
        }
    }

    public void restorePreferredActivities(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_PREFERRED_BACKUP, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$CFIaoUml0xnIO5ZwPO1dl9xEVgc */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restorePreferredActivities$25$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public /* synthetic */ void lambda$restorePreferredActivities$25$PackageManagerService(XmlPullParser readParser, int readUserId) throws IOException, XmlPullParserException {
        synchronized (this.mPackages) {
            this.mSettings.readPreferredActivitiesLPw(readParser, readUserId);
        }
        updateDefaultHomeNotLocked(readUserId);
    }

    public byte[] getDefaultAppsBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_DEFAULT_APPS);
                synchronized (this.mPackages) {
                    this.mSettings.writeDefaultAppsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_DEFAULT_APPS);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getDefaultAppsBackup()");
        }
    }

    public void restoreDefaultApps(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_DEFAULT_APPS, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$Pp4_btmBWcU4MSQGdxkevYH2ykk */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restoreDefaultApps$26$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring default apps: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restoreDefaultApps()");
        }
    }

    public /* synthetic */ void lambda$restoreDefaultApps$26$PackageManagerService(XmlPullParser parser1, int userId1) throws IOException, XmlPullParserException {
        String defaultBrowser;
        PackageManagerInternal.DefaultBrowserProvider provider;
        synchronized (this.mPackages) {
            this.mSettings.readDefaultAppsLPw(parser1, userId1);
            defaultBrowser = this.mSettings.removeDefaultBrowserPackageNameLPw(userId1);
        }
        if (defaultBrowser != null) {
            synchronized (this.mPackages) {
                provider = this.mDefaultBrowserProvider;
            }
            provider.setDefaultBrowser(defaultBrowser, userId1);
        }
    }

    public byte[] getIntentFilterVerificationBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_INTENT_FILTER_VERIFICATION);
                synchronized (this.mPackages) {
                    this.mSettings.writeAllDomainVerificationsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_INTENT_FILTER_VERIFICATION);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getIntentFilterVerificationBackup()");
        }
    }

    public void restoreIntentFilterVerification(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_INTENT_FILTER_VERIFICATION, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$0SKkmiMHwV7GtNKjt3VjlPFbtJU */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restoreIntentFilterVerification$27$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public /* synthetic */ void lambda$restoreIntentFilterVerification$27$PackageManagerService(XmlPullParser parser1, int userId1) throws IOException, XmlPullParserException {
        synchronized (this.mPackages) {
            this.mSettings.readAllDomainVerificationsLPr(parser1, userId1);
            this.mSettings.writeLPr();
        }
    }

    public void addCrossProfileIntentFilter(IntentFilter intentFilter, String ownerPackage, int sourceUserId, int targetUserId, int flags) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        if (intentFilter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a crossProfile intent filter with no filter actions");
            return;
        }
        synchronized (this.mPackages) {
            CrossProfileIntentFilter newFilter = new CrossProfileIntentFilter(intentFilter, ownerPackage, targetUserId, flags);
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            ArrayList<CrossProfileIntentFilter> existing = resolver.findFilters(intentFilter);
            if (existing != null) {
                int size = existing.size();
                for (int i = 0; i < size; i++) {
                    if (newFilter.equalsIgnoreFilter(existing.get(i))) {
                        return;
                    }
                }
            }
            resolver.addFilter(newFilter);
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    public void clearCrossProfileIntentFilters(int sourceUserId, String ownerPackage) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        synchronized (this.mPackages) {
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            Iterator<CrossProfileIntentFilter> it = new ArraySet<>(resolver.filterSet()).iterator();
            while (it.hasNext()) {
                CrossProfileIntentFilter filter = it.next();
                if (filter.getOwnerPackage().equals(ownerPackage)) {
                    resolver.removeFilter(filter);
                }
            }
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    private void enforceOwnerRights(String pkg, int callingUid) {
        if (UserHandle.getAppId(callingUid) != 1000) {
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageInfo pi = getPackageInfo(pkg, 0, callingUserId);
            if (pi == null) {
                throw new IllegalArgumentException("Unknown package " + pkg + " on user " + callingUserId);
            } else if (!UserHandle.isSameApp(pi.applicationInfo.uid, callingUid)) {
                throw new SecurityException("Calling uid " + callingUid + " does not own package " + pkg);
            }
        }
    }

    public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return getHomeActivitiesAsUser(allHomeCandidates, UserHandle.getCallingUserId());
    }

    public void sendSessionUpdatedBroadcast(PackageInstaller.SessionInfo sessionInfo, int userId) {
        if (!TextUtils.isEmpty(sessionInfo.installerPackageName)) {
            this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_UPDATED").putExtra("android.content.pm.extra.SESSION", sessionInfo).setPackage(sessionInfo.installerPackageName), UserHandle.of(userId));
        }
    }

    public void sendSessionCommitBroadcast(PackageInstaller.SessionInfo sessionInfo, int userId) {
        UserManagerService ums = UserManagerService.getInstance();
        if (ums != null) {
            UserInfo parent = ums.getProfileParent(userId);
            int launcherUid = parent != null ? parent.id : userId;
            ComponentName launcherComponent = getDefaultHomeActivity(launcherUid);
            if (launcherComponent != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(launcherComponent.getPackageName()), UserHandle.of(launcherUid));
            }
            if (this.mAppPredictionServicePackage != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(this.mAppPredictionServicePackage), UserHandle.of(launcherUid));
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ComponentName getDefaultHomeActivity(int userId) {
        List<ResolveInfo> allHomeCandidates = new ArrayList<>();
        ComponentName cn = getHomeActivitiesAsUser(allHomeCandidates, userId);
        if (cn != null) {
            return cn;
        }
        int lastPriority = Integer.MIN_VALUE;
        ComponentName lastComponent = null;
        int size = allHomeCandidates.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo ri = allHomeCandidates.get(i);
            if (ri.priority > lastPriority) {
                lastComponent = ri.activityInfo.getComponentName();
                lastPriority = ri.priority;
            } else if (ri.priority == lastPriority) {
                lastComponent = null;
            }
        }
        return lastComponent;
    }

    private Intent getHomeIntent() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        intent.addCategory("android.intent.category.DEFAULT");
        return intent;
    }

    private IntentFilter getHomeFilter() {
        IntentFilter filter = new IntentFilter("android.intent.action.MAIN");
        filter.addCategory("android.intent.category.HOME");
        filter.addCategory("android.intent.category.DEFAULT");
        return filter;
    }

    /* access modifiers changed from: package-private */
    public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        List<ResolveInfo> resolveInfos = queryIntentActivitiesInternal(getHomeIntent(), null, 128, userId);
        allHomeCandidates.clear();
        if (resolveInfos == null) {
            return null;
        }
        allHomeCandidates.addAll(resolveInfos);
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "mDefaultHomeProvider is null");
            return null;
        }
        String packageName = provider.getDefaultHome(userId);
        if (packageName == null) {
            return null;
        }
        int resolveInfosSize = resolveInfos.size();
        for (int i = 0; i < resolveInfosSize; i++) {
            ResolveInfo resolveInfo = resolveInfos.get(i);
            if (resolveInfo.activityInfo != null && TextUtils.equals(resolveInfo.activityInfo.packageName, packageName)) {
                return new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name);
            }
        }
        return null;
    }

    private void updateDefaultHomeNotLocked(SparseBooleanArray userIds) {
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        for (int i = userIds.size() - 1; i >= 0; i--) {
            updateDefaultHomeNotLocked(userIds.keyAt(i));
        }
    }

    private boolean updateDefaultHomeNotLocked(int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        if (!this.mSystemReady) {
            return false;
        }
        Intent intent = getHomeIntent();
        String packageName = null;
        ResolveInfo preferredResolveInfo = findPreferredActivityNotLocked(intent, null, 0, queryIntentActivitiesInternal(intent, null, 128, userId), 0, true, false, false, userId);
        if (!(preferredResolveInfo == null || preferredResolveInfo.activityInfo == null)) {
            packageName = preferredResolveInfo.activityInfo.packageName;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "Default home provider has not been set");
            return false;
        } else if (TextUtils.equals(provider.getDefaultHome(userId), packageName)) {
            return false;
        } else {
            String[] callingPackages = getPackagesForUid(Binder.getCallingUid());
            if (callingPackages != null && ArrayUtils.contains(callingPackages, this.mRequiredPermissionControllerPackage)) {
                return false;
            }
            provider.setDefaultHomeAsync(packageName, userId, new Consumer(userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$qwyU25HqNXbbzFqzpDmVq8u1E1k */
                private final /* synthetic */ int f$1;

                {
                    this.f$1 = r2;
                }

                @Override // java.util.function.Consumer
                public final void accept(Object obj) {
                    PackageManagerService.this.lambda$updateDefaultHomeNotLocked$28$PackageManagerService(this.f$1, (Boolean) obj);
                }
            });
            return true;
        }
    }

    public /* synthetic */ void lambda$updateDefaultHomeNotLocked$28$PackageManagerService(int userId, Boolean successful) {
        if (successful.booleanValue()) {
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    public void setHomeActivity(ComponentName comp, int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ArrayList<ResolveInfo> homeActivities = new ArrayList<>();
            getHomeActivitiesAsUser(homeActivities, userId);
            boolean found = false;
            int size = homeActivities.size();
            ComponentName[] set = new ComponentName[size];
            for (int i = 0; i < size; i++) {
                ActivityInfo info = homeActivities.get(i).activityInfo;
                ComponentName activityName = new ComponentName(info.packageName, info.name);
                set[i] = activityName;
                if (!found && activityName.equals(comp)) {
                    found = true;
                }
            }
            if (found) {
                replacePreferredActivity(getHomeFilter(), 1048576, set, comp, userId);
                return;
            }
            throw new IllegalArgumentException("Component " + comp + " cannot be home on user " + userId);
        }
    }

    private String getSetupWizardPackageName() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.SETUP_WIZARD");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one setup wizard; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getStorageManagerPackageName() {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.os.storage.action.MANAGE_STORAGE"), null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one storage manager; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    public String getSystemTextClassifierPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039712));
    }

    public String getAttentionServicePackageName() {
        ComponentName componentName;
        String flattenedComponentName = this.mContext.getString(17039698);
        if (flattenedComponentName == null || (componentName = ComponentName.unflattenFromString(flattenedComponentName)) == null || componentName.getPackageName() == null) {
            return null;
        }
        return ensureSystemPackageName(componentName.getPackageName());
    }

    private String getDocumenterPackageName() {
        Intent intent = new Intent("android.intent.action.OPEN_DOCUMENT");
        intent.addCategory("android.intent.category.OPENABLE");
        intent.setType("*/*");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one documenter; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getDeviceConfiguratorPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039716));
    }

    public String getWellbeingPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039714));
    }

    public String getAppPredictionServicePackageName() {
        ComponentName appPredictionServiceComponentName;
        String flattenedAppPredictionServiceComponentName = this.mContext.getString(17039696);
        if (flattenedAppPredictionServiceComponentName == null || (appPredictionServiceComponentName = ComponentName.unflattenFromString(flattenedAppPredictionServiceComponentName)) == null) {
            return null;
        }
        return ensureSystemPackageName(appPredictionServiceComponentName.getPackageName());
    }

    public String getSystemCaptionsServicePackageName() {
        ComponentName systemCaptionsServiceComponentName;
        String flattenedSystemCaptionsServiceComponentName = this.mContext.getString(17039711);
        if (!TextUtils.isEmpty(flattenedSystemCaptionsServiceComponentName) && (systemCaptionsServiceComponentName = ComponentName.unflattenFromString(flattenedSystemCaptionsServiceComponentName)) != null) {
            return ensureSystemPackageName(systemCaptionsServiceComponentName.getPackageName());
        }
        return null;
    }

    public String getIncidentReportApproverPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039744));
    }

    private String ensureSystemPackageName(String packageName) {
        if (packageName == null) {
            return null;
        }
        long token = Binder.clearCallingIdentity();
        try {
            if (getPackageInfo(packageName, 2097152, 0) == null) {
                PackageInfo packageInfo = getPackageInfo(packageName, 0, 0);
                if (packageInfo != null) {
                    EventLog.writeEvent(1397638484, "145981139", Integer.valueOf(packageInfo.applicationInfo.uid), "");
                }
                return null;
            }
            Binder.restoreCallingIdentity(token);
            return packageName;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public void setApplicationEnabledSetting(String appPackageName, int newState, int flags, int userId, String callingPackage) {
        if (sUserManager.exists(userId)) {
            if (callingPackage == null) {
                callingPackage = Integer.toString(Binder.getCallingUid());
            }
            setEnabledSetting(appPackageName, null, newState, flags, userId, callingPackage);
        }
    }

    public void setUpdateAvailable(String packageName, boolean updateAvailable) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                pkgSetting.setUpdateAvailable(updateAvailable);
            }
        }
    }

    public void setComponentEnabledSetting(ComponentName componentName, int newState, int flags, int userId) {
        if (sUserManager.exists(userId)) {
            setEnabledSetting(componentName.getPackageName(), componentName.getClassName(), newState, flags, userId, null);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x0225, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x022a, code lost:
        if (r4.getEnabled(r33) != r31) goto L_0x022e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x022c, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x022d, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x022e, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x022f, code lost:
        r5 = r4.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x0233, code lost:
        if (r5.isStub == false) goto L_0x023d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x0239, code lost:
        if (r5.isSystem() == false) goto L_0x023d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x023b, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x023d, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x023f, code lost:
        if (r0 == false) goto L_0x024c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x0241, code lost:
        if (r31 == 0) goto L_0x0245;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x0243, code lost:
        if (r31 != 1) goto L_0x024c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x0249, code lost:
        if (enableCompressedPackage(r5) != false) goto L_0x024c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x024b, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x024c, code lost:
        if (r31 == 0) goto L_0x0254;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x024e, code lost:
        if (r31 != 1) goto L_0x0251;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0251, code lost:
        r3 = r34;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0254, code lost:
        r3 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0256, code lost:
        r1 = r28.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x0258, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:?, code lost:
        r4.setEnabled(r31, r33, r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x025c, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x0267, code lost:
        r1 = r28.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x0269, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:139:?, code lost:
        r3 = r4.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x026c, code lost:
        if (r3 == null) goto L_0x027d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x0272, code lost:
        if (r3.hasComponentClassName(r30) != false) goto L_0x02c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x0275, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x027d, code lost:
        if (r3 == null) goto L_0x02a7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x0285, code lost:
        if (r3.applicationInfo.targetSdkVersion >= 16) goto L_0x0288;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x02a6, code lost:
        throw new java.lang.IllegalArgumentException("Component class " + r30 + " does not exist in " + r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x02a7, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Failed setComponentEnabledSetting: component class " + r30 + " does not exist in " + r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x02c5, code lost:
        if (r31 == 0) goto L_0x02f4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:0x02c7, code lost:
        if (r31 == 1) goto L_0x02ec;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x02ca, code lost:
        if (r31 == 2) goto L_0x02e4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x02cc, code lost:
        android.util.Slog.e(com.android.server.pm.PackageManagerService.TAG, "Invalid new component state: " + r31);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x02e2, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x02e3, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x02e8, code lost:
        if (r4.disableComponentLPw(r30, r33) != false) goto L_0x02fc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x02ea, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:164:0x02eb, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x02f0, code lost:
        if (r4.enableComponentLPw(r30, r33) != false) goto L_0x02fc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:167:0x02f2, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x02f3, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x02f8, code lost:
        if (r4.restoreComponentLPw(r30, r33) != false) goto L_0x02fc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x02fa, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x02fb, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x02fc, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x02ff, code lost:
        r3 = r28.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x0301, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:179:0x0306, code lost:
        if (isSystemApp(r4) != false) goto L_0x0312;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:?, code lost:
        scheduleWritePackageRestrictionsLocked(r33);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x030c, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x0312, code lost:
        immediatelyWritePackageRestrictionsLocked(r33);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x0315, code lost:
        updateSequenceNumberLP(r4, new int[]{r33});
        r23 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:?, code lost:
        updateInstantAppInstallerLocked(r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x0324, code lost:
        android.os.Binder.restoreCallingIdentity(r23);
        r0 = r28.mPendingBroadcasts.get(r33, r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x032e, code lost:
        if (r0 != null) goto L_0x0332;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:0x0330, code lost:
        r5 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:0x0332, code lost:
        r5 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x0333, code lost:
        if (r5 == false) goto L_0x033c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x0335, code lost:
        r7 = new java.util.ArrayList<>();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x033c, code lost:
        r7 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x0341, code lost:
        if (r7.contains(r3) != false) goto L_0x0346;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x0343, code lost:
        r7.add(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x034a, code lost:
        if ((r32 & 1) != 0) goto L_0x0353;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:200:0x034c, code lost:
        r2 = true;
        r28.mPendingBroadcasts.remove(r33, r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:201:0x0353, code lost:
        if (r5 == false) goto L_0x035a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:0x0355, code lost:
        r28.mPendingBroadcasts.put(r33, r29, r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:204:0x0360, code lost:
        if (r28.mHandler.hasMessages(1) != false) goto L_0x03a1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x0366, code lost:
        r27 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:210:0x036c, code lost:
        if (android.os.SystemClock.uptimeMillis() <= r28.mServiceStartWithDelay) goto L_0x0375;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:212:0x0370, code lost:
        if ((r32 & 268435456) != 0) goto L_0x0375;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:213:0x0372, code lost:
        r0 = 1000;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x0375, code lost:
        r0 = 10000;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:216:0x0386, code lost:
        if (android.common.OppoFeatureCache.get(com.android.server.pm.IColorAppQuickFreezeManager.DEFAULT).customizeSendEmptyMessage(r30, r28.mHandler) != false) goto L_0x038f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:217:0x0388, code lost:
        r14 = true;
        r28.mHandler.sendEmptyMessageDelayed(1, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:218:0x038f, code lost:
        r14 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:0x0391, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:221:0x0399, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:223:0x03a1, code lost:
        r27 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:224:0x03a3, code lost:
        r2 = r27;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:226:?, code lost:
        r0 = android.common.OppoFeatureCache.get(com.android.server.pm.IColorAppQuickFreezeManager.DEFAULT).adjustSendNow(r2, r32);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:229:?, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:230:0x03b4, code lost:
        r24 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:231:0x03b8, code lost:
        if (r0 == false) goto L_0x03ed;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:233:?, code lost:
        r5 = android.os.UserHandle.getUid(r33, r4.appId);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:234:0x03c0, code lost:
        r0 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:235:0x03c4, code lost:
        if ((r32 & 268435456) == 0) goto L_0x03c8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:236:0x03c6, code lost:
        r0 = r32 | 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:238:0x03ca, code lost:
        if ((r0 & 1) == 0) goto L_0x03ce;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:239:0x03cc, code lost:
        r3 = r14;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:240:0x03ce, code lost:
        r3 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:243:?, code lost:
        sendOppoPackageChangedBroadcast(r29, r3, r7, r5, r16, r33);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:244:0x03e1, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:245:0x03e3, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:247:0x03e9, code lost:
        android.os.Binder.restoreCallingIdentity(r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:248:0x03ec, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:250:0x03f2, code lost:
        android.os.Binder.restoreCallingIdentity(r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:251:0x03f6, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:252:0x03f7, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:254:0x03fe, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:256:0x0403, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:259:?, code lost:
        android.os.Binder.restoreCallingIdentity(r23);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:260:0x040d, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:261:0x040e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:263:0x0412, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:266:?, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:267:0x0419, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:268:0x041a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:269:0x041c, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:272:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:273:0x0423, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:274:0x0424, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:275:0x0426, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:278:?, code lost:
        monitor-exit(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:279:0x042d, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:280:0x042e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0131, code lost:
        if (android.os.UserHandle.isSameApp(r15, r4.appId) != false) goto L_0x01af;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x0133, code lost:
        if (r2 == false) goto L_0x015c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x0139, code lost:
        if (filterAppAccessLPr(r4, r15, r33) == false) goto L_0x013c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x0142, code lost:
        if (r28.mProtectedPackages.isPackageStateProtected(r33, r29) != false) goto L_0x0145;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x015b, code lost:
        throw new java.lang.SecurityException("Cannot disable a protected package: " + r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x015c, code lost:
        r1 = new java.lang.StringBuilder();
        r1.append("Attempt to change component state; pid=");
        r1.append(android.os.Binder.getCallingPid());
        r1.append(", uid=");
        r1.append(r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x0177, code lost:
        if (r30 != null) goto L_0x018b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0179, code lost:
        r3 = ", package=" + r29;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x018b, code lost:
        r3 = ", component=" + r29 + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r30;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x01a4, code lost:
        r1.append(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x01ae, code lost:
        throw new java.lang.SecurityException(r1.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x01b5, code lost:
        if (android.content.pm.PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME.equals(r30) == false) goto L_0x01c2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x01b7, code lost:
        if (r2 == false) goto L_0x01ba;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x01c1, code lost:
        throw new java.lang.SecurityException("Cannot disable a system-generated component");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x01c2, code lost:
        r5 = r28.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x01c4, code lost:
        monitor-enter(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x01c7, code lost:
        if (r15 != 2000) goto L_0x0211;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x01cd, code lost:
        if ((r4.pkgFlags & 256) != 0) goto L_0x0211;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x01cf, code lost:
        r3 = r4.getEnabled(r33);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x01d3, code lost:
        if (r30 != null) goto L_0x01e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x01d5, code lost:
        if (r3 == 3) goto L_0x01db;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x01d7, code lost:
        if (r3 == 0) goto L_0x01db;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x01d9, code lost:
        if (r3 != 1) goto L_0x01e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x01db, code lost:
        if (r31 == 3) goto L_0x01e1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x01dd, code lost:
        if (r31 == 0) goto L_0x01e1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x01df, code lost:
        if (r31 != 1) goto L_0x01e2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x0208, code lost:
        throw new java.lang.SecurityException("Shell cannot change component state for " + r29 + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r30 + " to " + r31);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x0209, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:?, code lost:
        monitor-exit(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x021e, code lost:
        if (android.common.OppoFeatureCache.get(com.android.server.pm.IColorForbidHideOrDisableManager.DEFAULT).isPackageForbidDisabled(r15, r31, r29) == false) goto L_0x0221;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x0220, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x0221, code lost:
        if (r30 != null) goto L_0x0267;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x0223, code lost:
        r3 = r28.mPackages;
     */
    private void setEnabledSetting(String packageName, String className, int newState, int flags, int userId, String callingPackage) {
        int permission;
        Throwable th;
        String str;
        boolean z = true;
        if (newState == 0 || newState == 1 || newState == 2 || newState == 3 || newState == 4) {
            int callingUid = Binder.getCallingUid();
            int pid = Binder.getCallingPid();
            if (callingUid == 1000) {
                permission = 0;
            } else {
                int permission2 = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE");
                if (permission2 != 0) {
                    permission = this.mContext.checkCallingOrSelfPermission("oppo.permission.OPPO_COMPONENT_SAFE");
                } else {
                    permission = permission2;
                }
            }
            this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "set enabled");
            boolean allowedByPermission = permission == 0;
            boolean isApp = className == null;
            boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
            String componentName = isApp ? packageName : className;
            synchronized (this.mPackages) {
                try {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting == null) {
                        if (isCallerInstantApp) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Attempt to change component state; pid=");
                            sb.append(Binder.getCallingPid());
                            sb.append(", uid=");
                            sb.append(callingUid);
                            if (className == null) {
                                str = ", package=" + packageName;
                            } else {
                                str = ", component=" + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className;
                            }
                            sb.append(str);
                            throw new SecurityException(sb.toString());
                        } else if (className == null) {
                            try {
                                throw new IllegalArgumentException("Unknown package: " + packageName);
                            } catch (Throwable th2) {
                                th = th2;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th3) {
                                        th = th3;
                                    }
                                }
                                throw th;
                            }
                        } else {
                            throw new IllegalArgumentException("Unknown component: " + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className);
                        }
                    }
                } catch (Throwable th4) {
                    th = th4;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        } else {
            throw new IllegalArgumentException("Invalid new component state: " + newState);
        }
    }

    public void flushPackageRestrictionsAsUser(int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && sUserManager.exists(userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "flushPackageRestrictions");
            synchronized (this.mPackages) {
                this.mSettings.writePackageRestrictionsLPr(userId);
                this.mDirtyUsers.remove(Integer.valueOf(userId));
                if (this.mDirtyUsers.isEmpty()) {
                    this.mHandler.removeMessages(14);
                }
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
        }
        Bundle extras = new Bundle(4);
        extras.putString("android.intent.extra.changed_component_name", componentNames.get(0));
        String[] nameList = new String[componentNames.size()];
        componentNames.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        int flags = !componentNames.contains(packageName) ? 1073741824 : 0;
        int userId = UserHandle.getUserId(packageUid);
        boolean isInstantApp = isInstantApp(packageName, userId);
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", packageName, extras, flags, null, null, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
    }

    public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
        if (sUserManager.exists(userId)) {
            int callingUid = Binder.getCallingUid();
            if (getInstantAppPackageName(callingUid) == null) {
                boolean allowedByPermission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE") == 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "stop package");
                synchronized (this.mPackages) {
                    try {
                        try {
                            if (!filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, userId)) {
                                if (this.mSettings.setPackageStoppedStateLPw(this, packageName, stopped, allowedByPermission, callingUid, userId)) {
                                    scheduleWritePackageRestrictionsLocked(userId);
                                }
                            }
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
            }
        }
    }

    public String getInstallerPackageName(String packageName) {
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                return null;
            }
            if (ps == null && this.mApexManager.isApexPackage(packageName)) {
                return null;
            }
            return this.mSettings.getInstallerPackageNameLPr(packageName);
        }
    }

    public boolean isOrphaned(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mPackages.containsKey(packageName)) {
                return false;
            }
            return this.mSettings.isOrphaned(packageName);
        }
    }

    public int getApplicationEnabledSetting(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get enabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(packageName), callingUid, userId)) {
                return 2;
            }
            return this.mSettings.getApplicationEnabledSettingLPr(packageName, userId);
        }
    }

    public int getComponentEnabledSetting(ComponentName component, int userId) {
        if (component == null) {
            return 0;
        }
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getComponentEnabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(component.getPackageName()), callingUid, component, 0, userId)) {
                return 2;
            }
            return this.mSettings.getComponentEnabledSettingLPr(component, userId);
        }
    }

    public void enterSafeMode() {
        enforceSystemOrRoot("Only the system can request entering safe mode");
        if (!this.mSystemReady) {
            this.mSafeMode = true;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:37:0x0122, code lost:
        com.android.server.pm.PackageManagerService.sUserManager.systemReady();
        r4 = r10.length;
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x0129, code lost:
        if (r5 >= r4) goto L_0x0135;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x012b, code lost:
        r15.mDefaultPermissionPolicy.grantDefaultPermissions(r10[r5]);
        r5 = r5 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x0137, code lost:
        if (r10 != com.android.server.pm.PackageManagerService.EMPTY_INT_ARRAY) goto L_0x013e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x0139, code lost:
        r15.mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x013e, code lost:
        r4 = r15.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x0140, code lost:
        monitor-enter(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:?, code lost:
        r15.mPermissionManager.updateAllPermissions(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, false, r15.mPackages.values(), r15.mPermissionCallback);
        ((com.android.server.policy.PermissionPolicyInternal) com.android.server.LocalServices.getService(com.android.server.policy.PermissionPolicyInternal.class)).setOnInitializedCallback(new com.android.server.pm.$$Lambda$PackageManagerService$orqEly190XwOVPZamgdj4g2IzLU(r15));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x0160, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x0161, code lost:
        com.android.server.pm.PackageManagerService.mCompatibilityHelper.initUpdateBroadcastReceiver();
        com.android.server.pm.PackageManagerService.mDcsUploader.initAlarmForDcs();
        ((android.os.storage.StorageManager) r15.mContext.getSystemService(android.os.storage.StorageManager.class)).registerListener(r15.mStorageListener);
        r15.mInstallerService.systemReady();
        r15.mApexManager.systemReady();
        r15.mPackageDexOptimizer.systemReady();
        getStorageManagerInternal().addExternalStoragePolicy(new com.android.server.pm.PackageManagerService.AnonymousClass12(r15));
        com.android.server.pm.PackageManagerService.sUserManager.reconcileUsers(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
        reconcileApps(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
        r15.mPermissionManager.systemReady();
        onOppoSystemReady();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x01ab, code lost:
        if (r15.mInstantAppResolverConnection == null) goto L_0x01be;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x01ad, code lost:
        r15.mContext.registerReceiver(new com.android.server.pm.PackageManagerService.AnonymousClass13(r15), new android.content.IntentFilter("android.intent.action.BOOT_COMPLETED"));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x01be, code lost:
        r15.mModuleInfoProvider.systemReady();
        r15.mInstallerService.restoreAndApplyStagedSessionIfNeeded();
        android.common.OppoFeatureCache.get(com.android.server.pm.IColorRemovableAppManager.DEFAULT).systemReady(r15.mContext);
        com.mediatek.cta.CtaManagerFactory.getInstance().makeCtaManager().systemReady();
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "mIsPreQUpgrade: " + r15.mIsPreQUpgrade);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x01fb, code lost:
        if (r15.mIsPreQUpgrade == false) goto L_0x0208;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x01fd, code lost:
        android.common.OppoFeatureCache.get(com.android.server.am.IColorMultiAppManager.DEFAULT).syncPermissionsAfterOta();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x020a, code lost:
        if (com.android.server.pm.PackageManagerService.EXP_VERSION == false) goto L_0x021a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x020c, code lost:
        r15.mBlackAppInstallHelper = new com.android.server.pm.BlackAppInstallHelper(r15.mContext);
        r15.mBlackAppInstallHelper.initUpdateBroadcastReceiver();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x021a, code lost:
        android.common.OppoFeatureCache.get(com.android.server.pm.IColorDexMetadataManager.DEFAULT).onSystemReady(r15.mContext);
        android.common.OppoFeatureCache.get(com.android.server.pm.IColorPmsSupportedFunctionManager.DEFAULT).setSupportSessionWrite(true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x0232, code lost:
        return;
     */
    public void systemReady() {
        Throwable th;
        enforceSystemOrRoot("Only the system can claim the system is ready");
        this.mSystemReady = true;
        final ContentResolver resolver = this.mContext.getContentResolver();
        ContentObserver co = new ContentObserver(this.mHandler) {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass11 */

            public void onChange(boolean selfChange) {
                boolean ephemeralFeatureDisabled = Settings.Global.getInt(resolver, "enable_ephemeral_feature", 1) == 0;
                int[] userIds = UserManagerService.getInstance().getUserIds();
                for (int userId : userIds) {
                    PackageManagerService.this.mWebInstantAppsDisabled.put(userId, ephemeralFeatureDisabled || Settings.Secure.getIntForUser(resolver, "instant_apps_enabled", 1, userId) == 0);
                }
            }
        };
        this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("enable_ephemeral_feature"), false, co, -1);
        this.mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor("instant_apps_enabled"), false, co, -1);
        co.onChange(true);
        CarrierAppUtils.disableCarrierAppsUntilPrivileged(this.mContext.getOpPackageName(), this, this.mContext.getContentResolver(), 0);
        disableSkuSpecificApps();
        boolean compatibilityModeEnabled = Settings.Global.getInt(this.mContext.getContentResolver(), "compatibility_mode", 1) == 1;
        PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
        if (DEBUG_SETTINGS) {
            Log.d(TAG, "compatibility mode:" + compatibilityModeEnabled);
        }
        int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;
        synchronized (this.mPackages) {
            try {
                ArrayList<PreferredActivity> removed = new ArrayList<>();
                for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i);
                    removed.clear();
                    for (PreferredActivity pa : pir.filterSet()) {
                        if (!this.mComponentResolver.isActivityDefined(pa.mPref.mComponent)) {
                            removed.add(pa);
                        }
                    }
                    if (removed.size() > 0) {
                        for (int r = 0; r < removed.size(); r++) {
                            PreferredActivity pa2 = removed.get(r);
                            Slog.w(TAG, "Removing dangling preferred activity: " + pa2.mPref.mComponent);
                            pir.removeFilter(pa2);
                        }
                        this.mSettings.writePackageRestrictionsLPr(this.mSettings.mPreferredActivities.keyAt(i));
                    }
                }
                int[] userIds = UserManagerService.getInstance().getUserIds();
                int[] grantPermissionsUserIds2 = grantPermissionsUserIds;
                for (int userId : userIds) {
                    try {
                        if (!this.mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) {
                            grantPermissionsUserIds2 = ArrayUtils.appendInt(grantPermissionsUserIds2, userId);
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
    }

    public /* synthetic */ void lambda$systemReady$29$PackageManagerService(int userId) {
        synchronized (this.mPackages) {
            if (userId == 999) {
                List<PackageInfo> infoList = getInstalledPackages(786432, userId).getList();
                ArrayMap<String, PackageParser.Package> packages = new ArrayMap<>();
                for (PackageInfo info : infoList) {
                    packages.put(info.packageName, this.mPackages.get(info.packageName));
                }
                this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, packages.values(), this.mPermissionCallback);
                return;
            }
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
        }
    }

    public void waitForAppDataPrepared() {
        Future<?> future = this.mPrepareAppDataFuture;
        if (future != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(future, "wait for prepareAppData");
            this.mPrepareAppDataFuture = null;
        }
    }

    public boolean isSafeMode() {
        return this.mSafeMode;
    }

    public boolean hasSystemUidErrors() {
        return this.mHasSystemUidErrors;
    }

    static String arrayToString(int[] array) {
        StringBuilder stringBuilder = new StringBuilder(128);
        stringBuilder.append('[');
        if (array != null) {
            for (int i = 0; i < array.length; i++) {
                if (i > 0) {
                    stringBuilder.append(", ");
                }
                stringBuilder.append(array[i]);
            }
        }
        stringBuilder.append(']');
        return stringBuilder.toString();
    }

    /* JADX DEBUG: Multi-variable search result rejected for r8v0, resolved type: com.android.server.pm.PackageManagerService */
    /* JADX WARN: Multi-variable type inference failed */
    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new PackageManagerShellCommand(this).exec(this, in, out, err, args, callback, resultReceiver);
    }

    /* access modifiers changed from: protected */
    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        String packageName;
        boolean fullPreferred;
        ArraySet<String> permissionNames;
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        char c;
        char c2;
        ArraySet<String> permissionNames2;
        boolean fullPreferred2;
        String libName;
        Iterator<String> it;
        String opt;
        if (DumpUtils.checkDumpAndUsageStatsPermission(this.mContext, TAG, pw)) {
            DumpState dumpState = new DumpState();
            int opti = 0;
            boolean checkin = false;
            while (opti < args.length && (opt = args[opti]) != null && opt.length() > 0 && opt.charAt(0) == '-') {
                opti++;
                if (!"-a".equals(opt)) {
                    if ("-h".equals(opt)) {
                        pw.println("Package manager dump options:");
                        pw.println("  [-h] [-f] [--checkin] [--all-components] [cmd] ...");
                        pw.println("    --checkin: dump for a checkin");
                        pw.println("    -f: print details of intent filters");
                        pw.println("    -h: print this help");
                        pw.println("    --all-components: include all component names in package dump");
                        pw.println("  cmd may be one of:");
                        pw.println("    apex: list active APEXes and APEX session state");
                        pw.println("    l[ibraries]: list known shared libraries");
                        pw.println("    f[eatures]: list device features");
                        pw.println("    k[eysets]: print known keysets");
                        pw.println("    r[esolvers] [activity|service|receiver|content]: dump intent resolvers");
                        pw.println("    perm[issions]: dump permissions");
                        pw.println("    permission [name ...]: dump declaration and use of given permission");
                        pw.println("    pref[erred]: print preferred package settings");
                        pw.println("    preferred-xml [--full]: print preferred package settings as xml");
                        pw.println("    prov[iders]: dump content providers");
                        pw.println("    p[ackages]: dump installed packages");
                        pw.println("    s[hared-users]: dump shared user IDs");
                        pw.println("    m[essages]: print collected runtime messages");
                        pw.println("    v[erifiers]: print package verifier info");
                        pw.println("    d[omain-preferred-apps]: print domains preferred apps");
                        pw.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
                        pw.println("    version: print database version info");
                        pw.println("    write: write current settings now");
                        pw.println("    installs: details about install sessions");
                        pw.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
                        pw.println("    dexopt: dump dexopt state");
                        pw.println("    compiler-stats: dump compiler statistics");
                        pw.println("    service-permissions: dump permissions required by services");
                        pw.println("    <package.name>: info about given package");
                        return;
                    } else if ("--checkin".equals(opt)) {
                        checkin = true;
                    } else if ("--all-components".equals(opt)) {
                        dumpState.setOptionEnabled(2);
                    } else if ("-f".equals(opt)) {
                        dumpState.setOptionEnabled(1);
                    } else if (PriorityDump.PROTO_ARG.equals(opt)) {
                        dumpProto(fd);
                        return;
                    } else {
                        pw.println("Unknown argument: " + opt + "; use -h for help");
                    }
                }
            }
            if (opti < args.length) {
                String cmd = args[opti];
                int opti2 = opti + 1;
                if (PLATFORM_PACKAGE_NAME.equals(cmd) || cmd.contains(".")) {
                    dumpState.setOptionEnabled(1);
                    fullPreferred = false;
                    packageName = cmd;
                    permissionNames = null;
                } else if (!"check-permission".equals(cmd)) {
                    if ("l".equals(cmd) || "libraries".equals(cmd)) {
                        dumpState.setDump(1);
                    } else if ("f".equals(cmd) || "features".equals(cmd)) {
                        dumpState.setDump(2);
                    } else if (ActivityTaskManagerService.DUMP_RECENTS_SHORT_CMD.equals(cmd) || "resolvers".equals(cmd)) {
                        if (opti2 >= args.length) {
                            dumpState.setDump(60);
                        } else {
                            while (opti2 < args.length) {
                                String name = args[opti2];
                                if (ActivityTaskManagerService.DUMP_ACTIVITIES_SHORT_CMD.equals(name) || IColorAppStartupManager.TYPE_ACTIVITY.equals(name)) {
                                    dumpState.setDump(4);
                                } else if ("s".equals(name) || IColorAppStartupManager.TYPE_SERVICE.equals(name)) {
                                    dumpState.setDump(8);
                                } else if (ActivityTaskManagerService.DUMP_RECENTS_SHORT_CMD.equals(name) || "receiver".equals(name)) {
                                    dumpState.setDump(16);
                                } else if ("c".equals(name) || ActivityTaskManagerInternal.ASSIST_KEY_CONTENT.equals(name)) {
                                    dumpState.setDump(32);
                                } else {
                                    pw.println("Error: unknown resolver table type: " + name);
                                    return;
                                }
                                opti2++;
                            }
                            fullPreferred = false;
                            packageName = null;
                            permissionNames = null;
                        }
                    } else if (TAG_PERMISSION.equals(cmd) || "permissions".equals(cmd)) {
                        dumpState.setDump(64);
                    } else if ("permission".equals(cmd)) {
                        if (opti2 >= args.length) {
                            pw.println("Error: permission requires permission name");
                            return;
                        }
                        ArraySet<String> permissionNames3 = new ArraySet<>();
                        while (opti2 < args.length) {
                            permissionNames3.add(args[opti2]);
                            opti2++;
                        }
                        dumpState.setDump(448);
                        permissionNames = permissionNames3;
                        fullPreferred = false;
                        packageName = null;
                    } else if ("pref".equals(cmd) || "preferred".equals(cmd)) {
                        dumpState.setDump(4096);
                    } else if ("preferred-xml".equals(cmd)) {
                        dumpState.setDump(8192);
                        if (opti2 < args.length && "--full".equals(args[opti2])) {
                            int opti3 = opti2 + 1;
                            fullPreferred = true;
                            packageName = null;
                            permissionNames = null;
                        }
                    } else if ("d".equals(cmd) || "domain-preferred-apps".equals(cmd)) {
                        dumpState.setDump(262144);
                    } else if ("p".equals(cmd) || "packages".equals(cmd)) {
                        dumpState.setDump(128);
                    } else if ("s".equals(cmd) || "shared-users".equals(cmd)) {
                        dumpState.setDump(256);
                        if (opti2 < args.length && "noperm".equals(args[opti2])) {
                            dumpState.setOptionEnabled(4);
                        }
                    } else if ("prov".equals(cmd) || "providers".equals(cmd)) {
                        dumpState.setDump(1024);
                    } else if ("m".equals(cmd) || "messages".equals(cmd)) {
                        dumpState.setDump(512);
                    } else if ("v".equals(cmd) || "verifiers".equals(cmd)) {
                        dumpState.setDump(2048);
                    } else if ("i".equals(cmd) || "ifv".equals(cmd) || "intent-filter-verifiers".equals(cmd)) {
                        dumpState.setDump(131072);
                    } else if ("version".equals(cmd)) {
                        dumpState.setDump(32768);
                    } else if ("k".equals(cmd) || "keysets".equals(cmd)) {
                        dumpState.setDump(16384);
                    } else if ("installs".equals(cmd)) {
                        dumpState.setDump(65536);
                    } else if ("frozen".equals(cmd)) {
                        dumpState.setDump(524288);
                    } else if ("volumes".equals(cmd)) {
                        dumpState.setDump(8388608);
                    } else if ("dexopt".equals(cmd)) {
                        dumpState.setDump(1048576);
                    } else if ("compiler-stats".equals(cmd)) {
                        dumpState.setDump(2097152);
                    } else if ("changes".equals(cmd)) {
                        dumpState.setDump(DumpState.DUMP_CHANGES);
                    } else if ("service-permissions".equals(cmd)) {
                        dumpState.setDump(DumpState.DUMP_SERVICE_PERMISSIONS);
                    } else if ("write".equals(cmd)) {
                        synchronized (this.mPackages) {
                            this.mSettings.writeLPr();
                            pw.println("Settings written.");
                        }
                        return;
                    } else if (sPmsExt.dumpCmdHandle(cmd, pw, args, opti2)) {
                        return;
                    } else {
                        if ("ciim".equals(cmd)) {
                            OppoFeatureCache.get(IColorIntentInterceptManager.DEFAULT).dump(pw, args);
                            return;
                        } else if ("oppofreeze".equals(cmd)) {
                            OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).dumpOppoFreezeInfo(pw, args);
                            return;
                        } else if ("cpt".equals(cmd)) {
                            mCompatibilityHelper.dumpScheme(pw, args);
                            return;
                        } else if ("whitelist".equals(cmd)) {
                            if (args.length == 1) {
                                pw.print(mCompatibilityHelper.dumpToString());
                                return;
                            } else {
                                mCompatibilityHelper.dump(pw, args, opti2);
                                return;
                            }
                        } else if ("cpt".equals(cmd)) {
                            mCompatibilityHelper.dumpScheme(pw, args);
                            return;
                        } else if ("preinstalledapp".equals(cmd)) {
                            OppoFeatureCache.get(IColorRemovableAppManager.DEFAULT).dump(pw, args);
                            return;
                        } else if ("log".equals(cmd)) {
                            PackageManagerServiceDynamicLogConfig.dynamicallyConfigLogTag(this, pw, args, opti2);
                            return;
                        } else if ("otadata".equals(cmd)) {
                            OppoFeatureCache.get(IColorOtaDataManager.DEFAULT).dump(pw, args);
                            return;
                        } else if ("debug_switch".equals(cmd)) {
                            PackageManagerServiceDynamicLogConfig.dumpDynamicallyLogSwitch(this, pw, args, opti2);
                            return;
                        }
                    }
                    fullPreferred = false;
                    packageName = null;
                    permissionNames = null;
                } else if (opti2 >= args.length) {
                    pw.println("Error: check-permission missing permission argument");
                    return;
                } else {
                    String perm = args[opti2];
                    int opti4 = opti2 + 1;
                    if (opti4 >= args.length) {
                        pw.println("Error: check-permission missing package argument");
                        return;
                    }
                    String pkg = args[opti4];
                    int opti5 = opti4 + 1;
                    int user = UserHandle.getUserId(Binder.getCallingUid());
                    if (opti5 < args.length) {
                        try {
                            user = Integer.parseInt(args[opti5]);
                        } catch (NumberFormatException e) {
                            pw.println("Error: check-permission user argument is not a number: " + args[opti5]);
                            return;
                        }
                    }
                    pw.println(checkPermission(perm, resolveInternalPackageNameLPr(pkg, -1), user));
                    return;
                }
            } else {
                fullPreferred = false;
                packageName = null;
                permissionNames = null;
            }
            if (checkin) {
                pw.println("vers,1");
            }
            ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
            synchronized (arrayMap2) {
                try {
                    if (dumpState.isDumping(32768) && packageName == null && !checkin) {
                        try {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            pw.println("Database versions:");
                            this.mSettings.dumpVersionLPr(new IndentingPrintWriter(pw, "  "));
                        } catch (Throwable th2) {
                            th = th2;
                            arrayMap = arrayMap2;
                            throw th;
                        }
                    }
                    if (dumpState.isDumping(2048) && packageName == null) {
                        if (!checkin) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            pw.println("Verifiers:");
                            pw.print("  Required: ");
                            pw.print(this.mRequiredVerifierPackage);
                            pw.print(" (uid=");
                            pw.print(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                            pw.println(")");
                        } else if (this.mRequiredVerifierPackage != null) {
                            pw.print("vrfy,");
                            pw.print(this.mRequiredVerifierPackage);
                            pw.print(",");
                            pw.println(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                        }
                    }
                    if (dumpState.isDumping(131072) && packageName == null) {
                        if (this.mIntentFilterVerifierComponent != null) {
                            String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                            if (!checkin) {
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                pw.println("Intent Filter Verifier:");
                                pw.print("  Using: ");
                                pw.print(verifierPackageName);
                                pw.print(" (uid=");
                                pw.print(getPackageUid(verifierPackageName, 268435456, 0));
                                pw.println(")");
                            } else if (verifierPackageName != null) {
                                pw.print("ifv,");
                                pw.print(verifierPackageName);
                                pw.print(",");
                                pw.println(getPackageUid(verifierPackageName, 268435456, 0));
                            }
                        } else {
                            pw.println();
                            pw.println("No Intent Filter Verifier available!");
                        }
                    }
                    if (dumpState.isDumping(1) && packageName == null) {
                        boolean i = false;
                        Iterator<String> it2 = this.mSharedLibraries.keySet().iterator();
                        while (it2.hasNext()) {
                            String libName2 = it2.next();
                            LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(libName2);
                            if (versionedLib != null) {
                                int versionCount = versionedLib.size();
                                boolean printedHeader = i;
                                int i2 = 0;
                                while (i2 < versionCount) {
                                    SharedLibraryInfo libraryInfo = versionedLib.valueAt(i2);
                                    if (!checkin) {
                                        if (!printedHeader) {
                                            if (dumpState.onTitlePrinted()) {
                                                pw.println();
                                            }
                                            pw.println("Libraries:");
                                            printedHeader = true;
                                        }
                                        pw.print("  ");
                                    } else {
                                        pw.print("lib,");
                                    }
                                    pw.print(libraryInfo.getName());
                                    if (libraryInfo.isStatic()) {
                                        StringBuilder sb = new StringBuilder();
                                        sb.append(" version=");
                                        it = it2;
                                        libName = libName2;
                                        sb.append(libraryInfo.getLongVersion());
                                        pw.print(sb.toString());
                                    } else {
                                        it = it2;
                                        libName = libName2;
                                    }
                                    if (!checkin) {
                                        pw.print(" -> ");
                                    }
                                    if (libraryInfo.getPath() != null) {
                                        pw.print(" (jar) ");
                                        pw.print(libraryInfo.getPath());
                                    } else {
                                        pw.print(" (apk) ");
                                        pw.print(libraryInfo.getPackageName());
                                    }
                                    pw.println();
                                    i2++;
                                    it2 = it;
                                    libName2 = libName;
                                }
                                i = printedHeader;
                            }
                        }
                    }
                    if (dumpState.isDumping(2) && packageName == null) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        if (!checkin) {
                            pw.println("Features:");
                        }
                        synchronized (this.mAvailableFeatures) {
                            for (FeatureInfo feat : this.mAvailableFeatures.values()) {
                                if (checkin) {
                                    pw.print("feat,");
                                    pw.print(feat.name);
                                    pw.print(",");
                                    pw.println(feat.version);
                                } else {
                                    pw.print("  ");
                                    pw.print(feat.name);
                                    if (feat.version > 0) {
                                        pw.print(" version=");
                                        pw.print(feat.version);
                                    }
                                    pw.println();
                                }
                            }
                        }
                    }
                    if (!checkin && dumpState.isDumping(4)) {
                        this.mComponentResolver.dumpActivityResolvers(pw, dumpState, packageName);
                    }
                    if (!checkin && dumpState.isDumping(16)) {
                        this.mComponentResolver.dumpReceiverResolvers(pw, dumpState, packageName);
                    }
                    if (!checkin && dumpState.isDumping(8)) {
                        this.mComponentResolver.dumpServiceResolvers(pw, dumpState, packageName);
                    }
                    if (!checkin) {
                        c = ' ';
                        if (dumpState.isDumping(32)) {
                            this.mComponentResolver.dumpProviderResolvers(pw, dumpState, packageName);
                        }
                    } else {
                        c = ' ';
                    }
                    if (checkin || !dumpState.isDumping(4096)) {
                        arrayMap = arrayMap2;
                        fullPreferred2 = fullPreferred;
                        c2 = c;
                        permissionNames2 = permissionNames;
                    } else {
                        int i3 = 0;
                        while (i3 < this.mSettings.mPreferredActivities.size()) {
                            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i3);
                            int user2 = this.mSettings.mPreferredActivities.keyAt(i3);
                            arrayMap = arrayMap2;
                            try {
                                if (pir.dump(pw, dumpState.getTitlePrinted() ? "\nPreferred Activities User " + user2 + ":" : "Preferred Activities User " + user2 + ":", "  ", packageName, true, false)) {
                                    dumpState.setTitlePrinted(true);
                                }
                                i3++;
                                fullPreferred = fullPreferred;
                                permissionNames = permissionNames;
                                c = ' ';
                                arrayMap2 = arrayMap;
                            } catch (Throwable th3) {
                                th = th3;
                                throw th;
                            }
                        }
                        arrayMap = arrayMap2;
                        fullPreferred2 = fullPreferred;
                        c2 = c;
                        permissionNames2 = permissionNames;
                    }
                    if (!checkin && dumpState.isDumping(8192)) {
                        pw.flush();
                        try {
                            BufferedOutputStream str = new BufferedOutputStream(new FileOutputStream(fd));
                            XmlSerializer serializer = new FastXmlSerializer();
                            try {
                                serializer.setOutput(str, StandardCharsets.UTF_8.name());
                                serializer.startDocument(null, true);
                                serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
                                this.mSettings.writePreferredActivitiesLPr(serializer, 0, fullPreferred2);
                                serializer.endDocument();
                                serializer.flush();
                            } catch (IllegalArgumentException e2) {
                                pw.println("Failed writing: " + e2);
                            } catch (IllegalStateException e3) {
                                pw.println("Failed writing: " + e3);
                            } catch (IOException e4) {
                                pw.println("Failed writing: " + e4);
                            }
                        } catch (Throwable th4) {
                            th = th4;
                            throw th;
                        }
                    }
                    if (!checkin && dumpState.isDumping(262144) && packageName == null) {
                        pw.println();
                        if (this.mSettings.mPackages.size() == 0) {
                            pw.println("No applications!");
                            pw.println();
                        } else {
                            String prefix = "  ";
                            Collection<PackageSetting> allPackageSettings = this.mSettings.mPackages.values();
                            if (allPackageSettings.size() == 0) {
                                pw.println("No domain preferred apps!");
                                pw.println();
                            } else {
                                pw.println("App verification status:");
                                pw.println();
                                int count = 0;
                                for (PackageSetting ps : allPackageSettings) {
                                    IntentFilterVerificationInfo ivi = ps.getIntentFilterVerificationInfo();
                                    if (!(ivi == null || ivi.getPackageName() == null)) {
                                        pw.println("  Package: " + ivi.getPackageName());
                                        pw.println("  Domains: " + ivi.getDomainsString());
                                        pw.println("  Status:  " + ivi.getStatusString());
                                        pw.println();
                                        count++;
                                    }
                                }
                                if (count == 0) {
                                    pw.println("  No app verification established.");
                                    pw.println();
                                }
                                int[] userIds = sUserManager.getUserIds();
                                int length = userIds.length;
                                int count2 = 0;
                                while (count2 < length) {
                                    int userId = userIds[count2];
                                    pw.println("App linkages for user " + userId + ":");
                                    pw.println();
                                    int count3 = 0;
                                    for (PackageSetting ps2 : allPackageSettings) {
                                        long status = ps2.getDomainVerificationStatusForUser(userId);
                                        if ((status >> c2) != 0 || DEBUG_DOMAIN_VERIFICATION) {
                                            pw.println("  Package: " + ps2.name);
                                            pw.println("  Domains: " + dumpDomainString(ps2.name));
                                            pw.println("  Status:  " + IntentFilterVerificationInfo.getStatusStringFromValue(status));
                                            pw.println();
                                            count3++;
                                            allPackageSettings = allPackageSettings;
                                            userIds = userIds;
                                            length = length;
                                        }
                                    }
                                    if (count3 == 0) {
                                        pw.println("  No configured app linkages.");
                                        pw.println();
                                    }
                                    count2++;
                                    prefix = prefix;
                                    allPackageSettings = allPackageSettings;
                                    userIds = userIds;
                                    length = length;
                                }
                            }
                        }
                    }
                    if (!checkin && dumpState.isDumping(64)) {
                        this.mSettings.dumpPermissionsLPr(pw, packageName, permissionNames2, dumpState);
                    }
                    if (!checkin && dumpState.isDumping(1024)) {
                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName);
                    }
                    if (!checkin && dumpState.isDumping(16384)) {
                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName, dumpState);
                    }
                    if (dumpState.isDumping(128)) {
                        this.mSettings.dumpPackagesLPr(pw, packageName, permissionNames2, dumpState, checkin);
                    }
                    if (dumpState.isDumping(256)) {
                        this.mSettings.dumpSharedUsersLPr(pw, packageName, permissionNames2, dumpState, checkin);
                    }
                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        pw.println("Package Changes:");
                        pw.print("  Sequence number=");
                        pw.println(this.mChangedPackagesSequenceNumber);
                        int K = this.mChangedPackages.size();
                        for (int i4 = 0; i4 < K; i4++) {
                            SparseArray<String> changes = this.mChangedPackages.valueAt(i4);
                            pw.print("  User ");
                            pw.print(this.mChangedPackages.keyAt(i4));
                            pw.println(":");
                            int N = changes.size();
                            if (N == 0) {
                                pw.print("    ");
                                pw.println("No packages changed");
                            } else {
                                for (int j = 0; j < N; j++) {
                                    int sequenceNumber = changes.keyAt(j);
                                    pw.print("    ");
                                    pw.print("seq=");
                                    pw.print(sequenceNumber);
                                    pw.print(", package=");
                                    pw.println(changes.valueAt(j));
                                }
                            }
                        }
                    }
                    if (!checkin && dumpState.isDumping(524288) && packageName == null) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ", 120);
                        ipw.println();
                        ipw.println("Frozen packages:");
                        ipw.increaseIndent();
                        if (this.mFrozenPackages.size() == 0) {
                            ipw.println("(none)");
                        } else {
                            for (int i5 = 0; i5 < this.mFrozenPackages.size(); i5++) {
                                ipw.println(this.mFrozenPackages.valueAt(i5));
                            }
                        }
                        ipw.decreaseIndent();
                    }
                    if (!checkin && dumpState.isDumping(8388608) && packageName == null) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        IndentingPrintWriter ipw2 = new IndentingPrintWriter(pw, "  ", 120);
                        ipw2.println();
                        ipw2.println("Loaded volumes:");
                        ipw2.increaseIndent();
                        if (this.mLoadedVolumes.size() == 0) {
                            ipw2.println("(none)");
                        } else {
                            for (int i6 = 0; i6 < this.mLoadedVolumes.size(); i6++) {
                                ipw2.println(this.mLoadedVolumes.valueAt(i6));
                            }
                        }
                        ipw2.decreaseIndent();
                    }
                    if (!checkin && dumpState.isDumping(DumpState.DUMP_SERVICE_PERMISSIONS) && packageName == null) {
                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName);
                    }
                    if (!checkin && dumpState.isDumping(1048576)) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        dumpDexoptStateLPr(pw, packageName);
                    }
                    if (!checkin && dumpState.isDumping(2097152)) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        dumpCompilerStatsLPr(pw, packageName);
                    }
                    if (!checkin && dumpState.isDumping(512) && packageName == null) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        this.mSettings.dumpReadMessagesLPr(pw, dumpState);
                        pw.println();
                        pw.println("Package warning messages:");
                        PackageManagerServiceUtils.dumpCriticalInfo(pw, null);
                    }
                    if (checkin && dumpState.isDumping(512)) {
                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                    }
                    if (!checkin && dumpState.isDumping(65536) && packageName == null) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                    }
                    if (!checkin && dumpState.isDumping(DumpState.DUMP_APEX)) {
                        this.mApexManager.dump(pw, packageName);
                    }
                } catch (Throwable th5) {
                    th = th5;
                    arrayMap = arrayMap2;
                    throw th;
                }
            }
        }
    }

    private void disableSkuSpecificApps() {
        String[] apkList = this.mContext.getResources().getStringArray(17236013);
        String[] skuArray = this.mContext.getResources().getStringArray(17236012);
        if (!ArrayUtils.isEmpty(apkList)) {
            String sku = SystemProperties.get("ro.boot.hardware.sku");
            if (TextUtils.isEmpty(sku) || !ArrayUtils.contains(skuArray, sku)) {
                for (String packageName : apkList) {
                    setSystemAppHiddenUntilInstalled(packageName, true);
                    for (UserInfo user : sUserManager.getUsers(false)) {
                        setSystemAppInstallState(packageName, false, user.id);
                    }
                }
            }
        }
    }

    private void dumpProto(FileDescriptor fd) {
        ProtoOutputStream proto = new ProtoOutputStream(fd);
        synchronized (this.mPackages) {
            long requiredVerifierPackageToken = proto.start(1146756268033L);
            proto.write(1138166333441L, this.mRequiredVerifierPackage);
            proto.write(1120986464258L, getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
            proto.end(requiredVerifierPackageToken);
            if (this.mIntentFilterVerifierComponent != null) {
                String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                long verifierPackageToken = proto.start(1146756268034L);
                proto.write(1138166333441L, verifierPackageName);
                proto.write(1120986464258L, getPackageUid(verifierPackageName, 268435456, 0));
                proto.end(verifierPackageToken);
            }
            dumpSharedLibrariesProto(proto);
            dumpFeaturesProto(proto);
            this.mSettings.dumpPackagesProto(proto);
            this.mSettings.dumpSharedUsersProto(proto);
            PackageManagerServiceUtils.dumpCriticalInfo(proto);
        }
        proto.flush();
    }

    private void dumpFeaturesProto(ProtoOutputStream proto) {
        synchronized (this.mAvailableFeatures) {
            int count = this.mAvailableFeatures.size();
            for (int i = 0; i < count; i++) {
                this.mAvailableFeatures.valueAt(i).writeToProto(proto, 2246267895812L);
            }
        }
    }

    private void dumpSharedLibrariesProto(ProtoOutputStream proto) {
        int count = this.mSharedLibraries.size();
        for (int i = 0; i < count; i++) {
            LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(this.mSharedLibraries.keyAt(i));
            if (versionedLib != null) {
                int versionCount = versionedLib.size();
                for (int j = 0; j < versionCount; j++) {
                    SharedLibraryInfo libraryInfo = versionedLib.valueAt(j);
                    long sharedLibraryToken = proto.start(2246267895811L);
                    proto.write(1138166333441L, libraryInfo.getName());
                    boolean isJar = libraryInfo.getPath() != null;
                    proto.write(1133871366146L, isJar);
                    if (isJar) {
                        proto.write(1138166333443L, libraryInfo.getPath());
                    } else {
                        proto.write(1138166333444L, libraryInfo.getPackageName());
                    }
                    proto.end(sharedLibraryToken);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void dumpDexoptStateLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Dexopt state:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            this.mPackageDexOptimizer.dumpDexoptState(ipw, pkg, this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName));
            ipw.decreaseIndent();
        }
    }

    @GuardedBy({"mPackages"})
    private void dumpCompilerStatsLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Compiler stats:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            CompilerStats.PackageStats stats = getCompilerPackageStats(pkg.packageName);
            if (stats == null) {
                ipw.println("(No recorded stats)");
            } else {
                stats.dump(ipw);
            }
            ipw.decreaseIndent();
        }
    }

    private String dumpDomainString(String packageName) {
        List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName).getList();
        List<IntentFilter> filters = getAllIntentFilters(packageName).getList();
        ArraySet<String> result = new ArraySet<>();
        if (iviList.size() > 0) {
            for (IntentFilterVerificationInfo ivi : iviList) {
                result.addAll(ivi.getDomains());
            }
        }
        if (filters != null && filters.size() > 0) {
            for (IntentFilter filter : filters) {
                if (filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"))) {
                    result.addAll(filter.getHostsList());
                }
            }
        }
        StringBuilder sb = new StringBuilder(result.size() * 16);
        Iterator<String> it = result.iterator();
        while (it.hasNext()) {
            String domain = it.next();
            if (sb.length() > 0) {
                sb.append(StringUtils.SPACE);
            }
            sb.append(domain);
        }
        return sb.toString();
    }

    static String getEncryptKey() {
        try {
            String sdEncKey = SystemKeyStore.getInstance().retrieveKeyHexString(SD_ENCRYPTION_KEYSTORE_NAME);
            if (sdEncKey != null || (sdEncKey = SystemKeyStore.getInstance().generateNewKeyHexString(128, SD_ENCRYPTION_ALGORITHM, SD_ENCRYPTION_KEYSTORE_NAME)) != null) {
                return sdEncKey;
            }
            Slog.e(TAG, "Failed to create encryption keys");
            return null;
        } catch (NoSuchAlgorithmException nsae) {
            Slog.e(TAG, "Failed to create encryption keys with exception: " + nsae);
            return null;
        } catch (IOException ioe) {
            Slog.e(TAG, "Failed to retrieve encryption keys with exception: " + ioe);
            return null;
        }
    }

    public int callInstalldCmd(String path, String cmd) {
        if (!hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            return 0;
        }
        try {
            this.mInstaller.customCmd(path, cmd);
            return 1;
        } catch (Installer.InstallerException e) {
            Slog.e(TAG, "Failed to execut " + cmd);
            e.printStackTrace();
            return 1;
        }
    }

    public void backupAppData(final String src, final String packageName, final String dest, final int requestId) {
        Slog.i(TAG, "backupAppData");
        new Thread() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass14 */

            public void run() {
                String action = PackageManagerService.CUSTOM_ACTION_BACKUP_APP_DATA_SUCCESS;
                String from = "";
                try {
                    if (src.equals(SliceClientPermissions.SliceAuthority.DELIMITER)) {
                        from = "data/data/" + packageName;
                    } else {
                        from = "data/data/" + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + src;
                    }
                    PackageManagerService.this.mInstaller.backupAppData(from, dest, requestId);
                } catch (Installer.InstallerException e) {
                    Slog.e(PackageManagerService.TAG, "Failed to backupAppData :" + e);
                    action = PackageManagerService.CUSTOM_ACTION_BACKUP_APP_DATA_FAILED;
                }
                Log.d(PackageManagerService.TAG, "requestId: " + requestId + " ---> back up " + from + StringUtils.SPACE + action);
                Intent intent = new Intent();
                intent.putExtra("requestId", requestId);
                intent.setAction(action);
                PackageManagerService.this.mContext.sendBroadcast(intent);
            }
        }.start();
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<ApplicationInfo> infos, IIntentReceiver finishedReceiver) {
        int size = infos.size();
        String[] packageNames = new String[size];
        int[] packageUids = new int[size];
        for (int i = 0; i < size; i++) {
            ApplicationInfo info = infos.get(i);
            packageNames[i] = info.packageName;
            packageUids[i] = info.uid;
        }
        sendResourcesChangedBroadcast(mediaStatus, replacing, packageNames, packageUids, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<String> pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        sendResourcesChangedBroadcast(mediaStatus, replacing, (String[]) pkgList.toArray(new String[pkgList.size()]), uidArr, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        String action;
        if (pkgList.length > 0) {
            Bundle extras = new Bundle();
            extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
            if (uidArr != null) {
                extras.putIntArray("android.intent.extra.changed_uid_list", uidArr);
            }
            if (replacing) {
                extras.putBoolean("android.intent.extra.REPLACING", replacing);
            }
            if (mediaStatus) {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
            } else {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
            }
            sendPackageBroadcast(action, null, extras, 0, null, finishedReceiver, null, null);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void loadPrivatePackages(VolumeInfo vol) {
        this.mHandler.post(new Runnable(vol) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$dM4FH74RPFFuHWqzdwMz4odvhec */
            private final /* synthetic */ VolumeInfo f$1;

            {
                this.f$1 = r2;
            }

            public final void run() {
                PackageManagerService.this.lambda$loadPrivatePackages$30$PackageManagerService(this.f$1);
            }
        });
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Removed duplicated region for block: B:30:0x00ab A[Catch:{ all -> 0x0070 }] */
    /* renamed from: loadPrivatePackagesInner */
    public void lambda$loadPrivatePackages$30$PackageManagerService(VolumeInfo vol) {
        Settings.VersionInfo ver;
        List<PackageSetting> packages;
        int flags;
        Object obj;
        PackageParser.Package pkg;
        PackageSetting ps;
        PackageManagerException e;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Loading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList<PackageFreezer> freezers = new ArrayList<>();
        ArrayList<ApplicationInfo> loaded = new ArrayList<>();
        int parseFlags = this.mDefParseFlags | 8;
        synchronized (this.mPackages) {
            ver = this.mSettings.findOrCreateVersion(volumeUuid);
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        for (PackageSetting ps2 : packages) {
            freezers.add(freezePackage(ps2.name, "loadPrivatePackagesInner"));
            Object obj2 = this.mInstallLock;
            synchronized (obj2) {
                try {
                    obj = obj2;
                    ps = ps2;
                    try {
                        loaded.add(scanPackageTracedLI(ps2.codePath, parseFlags, 512, 0, (UserHandle) null).applicationInfo);
                    } catch (PackageManagerException e2) {
                        e = e2;
                    }
                } catch (PackageManagerException e3) {
                    e = e3;
                    obj = obj2;
                    ps = ps2;
                    try {
                        Slog.w(TAG, "Failed to scan " + ps.codePath + ": " + e.getMessage());
                        if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                        }
                    } catch (Throwable th) {
                        pkg = th;
                        throw pkg;
                    }
                } catch (Throwable th2) {
                    pkg = th2;
                    obj = obj2;
                    throw pkg;
                }
                if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                    clearAppDataLIF(ps.pkg, -1, 39);
                }
            }
        }
        StorageManager sm = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : ((UserManager) this.mContext.getSystemService(UserManager.class)).getUsers()) {
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            } else {
                continue;
            }
            try {
                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags);
                synchronized (this.mInstallLock) {
                    reconcileAppsDataLI(volumeUuid, user.id, flags, true);
                }
            } catch (IllegalStateException e4) {
                Slog.w(TAG, "Failed to prepare storage: " + e4);
            }
        }
        synchronized (this.mPackages) {
            boolean sdkUpdated = ver.sdkVersion != this.mSdkVersion;
            if (sdkUpdated) {
                PackageManagerServiceUtils.logCriticalInfo(4, "Platform changed from " + ver.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for " + volumeUuid);
            }
            this.mPermissionManager.updateAllPermissions(volumeUuid, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
            ver.forceCurrent();
            this.mSettings.writeLPr();
        }
        Iterator<PackageFreezer> it = freezers.iterator();
        while (it.hasNext()) {
            it.next().close();
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Loaded packages " + loaded);
        }
        sendResourcesChangedBroadcast(true, false, loaded, null);
        this.mLoadedVolumes.add(vol.getId());
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void unloadPrivatePackages(VolumeInfo vol) {
        this.mHandler.post(new Runnable(vol) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$1F746LEL3aKKL8Z1H1MLxe_4jO0 */
            private final /* synthetic */ VolumeInfo f$1;

            {
                this.f$1 = r2;
            }

            public final void run() {
                PackageManagerService.this.lambda$unloadPrivatePackages$31$PackageManagerService(this.f$1);
            }
        });
    }

    /* access modifiers changed from: private */
    /* renamed from: unloadPrivatePackagesInner */
    public void lambda$unloadPrivatePackages$31$PackageManagerService(VolumeInfo vol) {
        Throwable th;
        PackageFreezer freezer;
        PackageSetting ps;
        StringBuilder sb;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Unloading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList<ApplicationInfo> unloaded = new ArrayList<>();
        synchronized (this.mInstallLock) {
            synchronized (this.mPackages) {
                Iterator<PackageSetting> it = this.mSettings.getVolumePackagesLPr(volumeUuid).iterator();
                while (it.hasNext()) {
                    PackageSetting ps2 = it.next();
                    if (ps2.pkg != null) {
                        ApplicationInfo info = ps2.pkg.applicationInfo;
                        PackageRemovedInfo outInfo = new PackageRemovedInfo(this);
                        PackageFreezer freezer2 = freezePackageForDelete(ps2.name, 1, "unloadPrivatePackagesInner");
                        try {
                            try {
                                if (deletePackageLIF(ps2.name, null, false, null, 1, outInfo, false, null)) {
                                    try {
                                        unloaded.add(info);
                                        ps = ps2;
                                    } catch (Throwable th2) {
                                        th = th2;
                                        freezer = freezer2;
                                        try {
                                            throw th;
                                        } catch (Throwable th3) {
                                            if (freezer != null) {
                                                $closeResource(th, freezer);
                                            }
                                            throw th3;
                                        }
                                    }
                                } else {
                                    try {
                                        sb = new StringBuilder();
                                        sb.append("Failed to unload ");
                                        ps = ps2;
                                    } catch (Throwable th4) {
                                        freezer = freezer2;
                                        th = th4;
                                        throw th;
                                    }
                                    try {
                                        sb.append(ps.codePath);
                                        Slog.w(TAG, sb.toString());
                                    } catch (Throwable th5) {
                                        freezer = freezer2;
                                        th = th5;
                                        throw th;
                                    }
                                }
                                if (freezer2 != null) {
                                    $closeResource(null, freezer2);
                                }
                                AttributeCache.instance().removePackage(ps.name);
                                it = it;
                            } catch (Throwable th6) {
                                freezer = freezer2;
                                th = th6;
                                throw th;
                            }
                        } catch (Throwable th7) {
                            freezer = freezer2;
                            th = th7;
                            throw th;
                        }
                    }
                }
                this.mSettings.writeLPr();
            }
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Unloaded packages " + unloaded);
        }
        sendResourcesChangedBroadcast(false, false, unloaded, null);
        this.mLoadedVolumes.remove(vol.getId());
        ResourcesManager.getInstance().invalidatePath(vol.getPath().getAbsolutePath());
        for (int i = 0; i < 3; i++) {
            System.gc();
            System.runFinalization();
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void assertPackageKnownAndInstalled(String volumeUuid, String packageName, int userId) throws PackageManagerException {
        synchronized (this.mPackages) {
            String packageName2 = normalizePackageNameLPr(packageName);
            PackageSetting ps = this.mSettings.mPackages.get(packageName2);
            if (ps == null) {
                throw new PackageManagerException("Package " + packageName2 + " is unknown");
            } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                throw new PackageManagerException("Package " + packageName2 + " found on unknown volume " + volumeUuid + "; expected volume " + ps.volumeUuid);
            } else if (!ps.getInstalled(userId)) {
                throw new PackageManagerException("Package " + packageName2 + " not installed for user " + userId);
            }
        }
    }

    private List<String> collectAbsoluteCodePaths() {
        List<String> codePaths;
        synchronized (this.mPackages) {
            codePaths = new ArrayList<>();
            int packageCount = this.mSettings.mPackages.size();
            for (int i = 0; i < packageCount; i++) {
                codePaths.add(this.mSettings.mPackages.valueAt(i).codePath.getAbsolutePath());
            }
        }
        return codePaths;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void reconcileApps(String volumeUuid) {
        List<String> absoluteCodePaths = collectAbsoluteCodePaths();
        File[] files = FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
        List<File> filesToDelete = null;
        for (File file : files) {
            if ((PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName())) {
                String absolutePath = file.getAbsolutePath();
                boolean pathValid = false;
                int absoluteCodePathCount = absoluteCodePaths.size();
                int i = 0;
                while (true) {
                    if (i >= absoluteCodePathCount) {
                        break;
                    } else if (absolutePath.startsWith(absoluteCodePaths.get(i))) {
                        pathValid = true;
                        break;
                    } else {
                        i++;
                    }
                }
                if (!pathValid) {
                    if (filesToDelete == null) {
                        filesToDelete = new ArrayList<>();
                    }
                    filesToDelete.add(file);
                }
            }
        }
        if (filesToDelete != null) {
            int fileToDeleteCount = filesToDelete.size();
            for (int i2 = 0; i2 < fileToDeleteCount; i2++) {
                File fileToDelete = filesToDelete.get(i2);
                PackageManagerServiceUtils.logCriticalInfo(5, "Destroying orphaned" + fileToDelete);
                synchronized (this.mInstallLock) {
                    removeCodePathLI(fileToDelete);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void reconcileAppsData(int userId, int flags, boolean migrateAppsData) {
        for (VolumeInfo vol : ((StorageManager) this.mContext.getSystemService(StorageManager.class)).getWritablePrivateVolumes()) {
            String volumeUuid = vol.getFsUuid();
            synchronized (this.mInstallLock) {
                reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppsData);
            }
        }
    }

    @GuardedBy({"mInstallLock"})
    private void reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData) {
        reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppData, false);
    }

    @GuardedBy({"mInstallLock"})
    private List<String> reconcileAppsDataLI(final String volumeUuid, final int userId, final int flags, final boolean migrateAppData, final boolean onlyCoreApps) {
        List<PackageSetting> packages;
        int i;
        File[] files;
        Installer.InstallerException e2;
        boolean wizardStatu;
        int i2;
        File[] files2;
        int i3;
        Installer.InstallerException e22;
        Slog.i(TAG, "reconcileAppsData for " + volumeUuid + " u" + userId + " 0x" + Integer.toHexString(flags) + " migrateAppData=" + migrateAppData);
        sMtkSystemServerIns.addBootEvent("PMS:reconcileAppsDataLI");
        final List<String> result = onlyCoreApps ? new ArrayList<>() : null;
        final File ceDir = Environment.getDataUserCeDirectory(volumeUuid, userId);
        File deDir = Environment.getDataUserDeDirectory(volumeUuid, userId);
        int i4 = 0;
        if ((flags & 2) != 0) {
            try {
                int statu = getComponentEnabledSetting(new ComponentName("com.coloros.bootreg", "com.coloros.bootreg.activity.WelcomePage"), 0);
                boolean wizardStatu2 = true;
                if (!(statu == 1 || statu == 0)) {
                    wizardStatu2 = false;
                }
                wizardStatu = wizardStatu2;
            } catch (Exception e) {
                Slog.i(TAG, "Cant get wizard componment status" + e);
                wizardStatu = false;
            }
            boolean clearReserve = SystemProperties.getBoolean("persist.sys.clear_reserve", false);
            if (!this.mFirstBoot && !onlyCoreApps && (flags & 1) == 0 && !wizardStatu && !isBootFromOTA() && !clearReserve) {
                if (userId == 0) {
                    new Thread() {
                        /* class com.android.server.pm.PackageManagerService.AnonymousClass15 */

                        public void run() {
                            List<PackageSetting> packages;
                            Slog.i(PackageManagerService.TAG, "reconcileAppsData 1 for StorageManager.FLAG_STORAGE_CE start");
                            if (!StorageManager.isFileEncryptedNativeOrEmulated() || StorageManager.isUserKeyUnlocked(userId)) {
                                File[] files = FileUtils.listFilesOrEmpty(ceDir);
                                for (File file : files) {
                                    String packageName = file.getName();
                                    try {
                                        PackageManagerService.this.assertPackageKnownAndInstalled(volumeUuid, packageName, userId);
                                    } catch (PackageManagerException e) {
                                        Slog.i(PackageManagerService.TAG, "reconcileAppsData 1 Destroying " + file + " due to: " + e);
                                        PackageManagerServiceUtils.logCriticalInfo(5, "Destroying " + file + " due to: " + e);
                                        try {
                                            PackageManagerService.this.mInstaller.destroyAppData(volumeUuid, packageName, userId, 2, 0);
                                            Slog.i(PackageManagerService.TAG, "reconcileAppsData 1 destroyAppData packageName=" + packageName);
                                        } catch (Installer.InstallerException e2) {
                                            PackageManagerServiceUtils.logCriticalInfo(5, "Failed to destroy: " + e2);
                                        }
                                    }
                                }
                                Slog.i(PackageManagerService.TAG, "reconcileAppsData 1 for StorageManager.FLAG_STORAGE_CE end");
                                synchronized (PackageManagerService.this.mPackages) {
                                    packages = PackageManagerService.this.mSettings.getVolumePackagesLPr(volumeUuid);
                                }
                                int preparedCount = 0;
                                for (PackageSetting ps : packages) {
                                    String packageName2 = ps.name;
                                    if (ps.pkg == null) {
                                        Slog.w(PackageManagerService.TAG, "Odd, missing scanned package " + packageName2);
                                    } else if (onlyCoreApps && !ps.pkg.coreApp) {
                                        result.add(packageName2);
                                    } else if (ps.getInstalled(userId)) {
                                        PackageManagerService.this.prepareAppDataAndMigrateLIF(ps.pkg, userId, flags, migrateAppData);
                                        preparedCount++;
                                    }
                                }
                                Slog.i(PackageManagerService.TAG, "1 reconcileAppsData finished " + preparedCount + " packages");
                                return;
                            }
                            throw new RuntimeException("Yikes, someone asked us to reconcile CE storage while " + userId + " was still locked; this would have caused massive data loss!");
                        }
                    }.start();
                    Slog.i(TAG, "reconcileAppsData finish");
                    return result;
                }
            }
            Slog.i(TAG, "reconcileAppsData for StorageManager.FLAG_STORAGE_CE start");
            if (clearReserve) {
                SystemProperties.set("persist.sys.clear_reserve", TemperatureProvider.SWITCH_OFF);
            }
            if (!StorageManager.isFileEncryptedNativeOrEmulated() || StorageManager.isUserKeyUnlocked(userId)) {
                File[] files3 = FileUtils.listFilesOrEmpty(ceDir);
                int length = files3.length;
                int i5 = 0;
                while (i5 < length) {
                    File file = files3[i5];
                    String packageName = file.getName();
                    try {
                        assertPackageKnownAndInstalled(volumeUuid, packageName, userId);
                        i3 = i5;
                        files2 = files3;
                        i2 = length;
                    } catch (PackageManagerException e3) {
                        PackageManagerServiceUtils.logCriticalInfo(5, "Destroying " + file + " due to: " + e3);
                        try {
                            i3 = i5;
                            files2 = files3;
                            i2 = length;
                            try {
                                this.mInstaller.destroyAppData(volumeUuid, packageName, userId, 2, 0);
                            } catch (Installer.InstallerException e4) {
                                e22 = e4;
                            }
                        } catch (Installer.InstallerException e5) {
                            e22 = e5;
                            i3 = i5;
                            files2 = files3;
                            i2 = length;
                            PackageManagerServiceUtils.logCriticalInfo(5, "Failed to destroy: " + e22);
                            i5 = i3 + 1;
                            files3 = files2;
                            length = i2;
                        }
                    }
                    i5 = i3 + 1;
                    files3 = files2;
                    length = i2;
                }
                Slog.i(TAG, "reconcileAppsData for StorageManager.FLAG_STORAGE_CE end");
            } else {
                throw new RuntimeException("Yikes, someone asked us to reconcile CE storage while " + userId + " was still locked; this would have caused massive data loss!");
            }
        }
        if ((flags & 1) != 0) {
            Slog.i(TAG, "reconcileAppsData for StorageManager.FLAG_STORAGE_DE start");
            File[] files4 = FileUtils.listFilesOrEmpty(deDir);
            int length2 = files4.length;
            while (i4 < length2) {
                File file2 = files4[i4];
                String packageName2 = file2.getName();
                try {
                    assertPackageKnownAndInstalled(volumeUuid, packageName2, userId);
                    files = files4;
                    i = length2;
                } catch (PackageManagerException e6) {
                    PackageManagerServiceUtils.logCriticalInfo(5, "Destroying " + file2 + " due to: " + e6);
                    try {
                        files = files4;
                        i = length2;
                        try {
                            this.mInstaller.destroyAppData(volumeUuid, packageName2, userId, 1, 0);
                        } catch (Installer.InstallerException e7) {
                            e2 = e7;
                        }
                    } catch (Installer.InstallerException e8) {
                        e2 = e8;
                        files = files4;
                        i = length2;
                        PackageManagerServiceUtils.logCriticalInfo(5, "Failed to destroy: " + e2);
                        i4++;
                        files4 = files;
                        length2 = i;
                    }
                }
                i4++;
                files4 = files;
                length2 = i;
            }
        }
        Slog.i(TAG, "reconcileAppsData, will try to execute prepareAppDataAndMigrateLIF");
        synchronized (this.mPackages) {
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        int preparedCount = 0;
        for (PackageSetting ps : packages) {
            String packageName3 = ps.name;
            if (ps.pkg == null) {
                Slog.w(TAG, "Odd, missing scanned package " + packageName3);
            } else if (onlyCoreApps && !ps.pkg.coreApp) {
                result.add(packageName3);
            } else if (ps.getInstalled(userId)) {
                prepareAppDataAndMigrateLIF(ps.pkg, userId, flags, migrateAppData);
                preparedCount++;
            }
        }
        Slog.i(TAG, "reconcileAppsData finished ");
        return result;
    }

    private void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) {
        PackageSetting ps;
        int flags;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
            this.mSettings.writeKernelMappingLPr(ps);
        }
        UserManagerService um = sUserManager;
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers(false)) {
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            if (ps.getInstalled(user.id)) {
                prepareAppDataLIF(pkg, user.id, flags);
            }
        }
    }

    private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void prepareAppDataAndMigrateLIF(PackageParser.Package pkg, int userId, int flags, boolean maybeMigrateAppData) {
        prepareAppDataLIF(pkg, userId, flags);
        if (maybeMigrateAppData && maybeMigrateAppDataLIF(pkg, userId)) {
            prepareAppDataLIF(pkg, userId, flags);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:31:0x00ae  */
    /* JADX WARNING: Removed duplicated region for block: B:47:0x0106  */
    /* JADX WARNING: Removed duplicated region for block: B:60:0x0147  */
    private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        ApplicationInfo app;
        ApplicationInfo app2;
        long ceDataInode;
        ApplicationInfo app3;
        Installer.InstallerException e;
        int i;
        if (DEBUG_APP_DATA) {
            Slog.v(TAG, "prepareAppData for " + pkg.packageName + " u" + userId + " 0x" + Integer.toHexString(flags));
        }
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        if (ps == null) {
            app = pkg.applicationInfo;
        } else {
            app = PackageParser.generateApplicationInfo(pkg, 0, ps.readUserState(userId), userId);
        }
        if (app == null) {
            app2 = pkg.applicationInfo;
        } else {
            app2 = app;
        }
        int appId = UserHandle.getAppId(app2.uid);
        Preconditions.checkNotNull(app2.seInfo);
        StringBuilder sb = new StringBuilder();
        sb.append(app2.seInfo);
        sb.append(app2.seInfoUser != null ? app2.seInfoUser : "");
        String seInfo = sb.toString();
        long ceDataInode2 = -1;
        try {
            app3 = app2;
            try {
                ceDataInode = this.mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, seInfo, app2.targetSdkVersion);
            } catch (Installer.InstallerException e2) {
                e = e2;
                if (!app3.isSystemApp()) {
                    PackageManagerServiceUtils.logCriticalInfo(6, "Failed to create app data for " + packageName + ", but trying to recover: " + e);
                    destroyAppDataLeafLIF(pkg, userId, flags);
                    try {
                        try {
                            i = 3;
                            try {
                                ceDataInode2 = this.mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, seInfo, app3.targetSdkVersion);
                                PackageManagerServiceUtils.logCriticalInfo(3, "Recovery succeeded!");
                            } catch (Installer.InstallerException e3) {
                            }
                        } catch (Installer.InstallerException e4) {
                            i = 3;
                            PackageManagerServiceUtils.logCriticalInfo(i, "Recovery failed!");
                            ceDataInode = ceDataInode2;
                            this.mArtManagerService.prepareAppProfiles(pkg, userId, false);
                            synchronized (this.mPackages) {
                            }
                        }
                    } catch (Installer.InstallerException e5) {
                        i = 3;
                        PackageManagerServiceUtils.logCriticalInfo(i, "Recovery failed!");
                        ceDataInode = ceDataInode2;
                        this.mArtManagerService.prepareAppProfiles(pkg, userId, false);
                        synchronized (this.mPackages) {
                        }
                    }
                    ceDataInode = ceDataInode2;
                } else {
                    Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
                    ceDataInode = -1;
                }
                this.mArtManagerService.prepareAppProfiles(pkg, userId, false);
                synchronized (this.mPackages) {
                }
            }
        } catch (Installer.InstallerException e6) {
            e = e6;
            app3 = app2;
            if (!app3.isSystemApp()) {
            }
            this.mArtManagerService.prepareAppProfiles(pkg, userId, false);
            synchronized (this.mPackages) {
            }
        }
        if (this.mIsUpgrade || this.mFirstBoot || userId != 0) {
            this.mArtManagerService.prepareAppProfiles(pkg, userId, false);
        }
        if (!((flags & 2) == 0 || ceDataInode == -1)) {
            synchronized (this.mPackages) {
                if (ps != null) {
                    ps.setCeDataInode(ceDataInode, userId);
                }
            }
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
    }

    private void prepareAppDataContentsLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataContentsLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataContentsLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        ApplicationInfo app = pkg.applicationInfo;
        if ((flags & 2) != 0 && app.primaryCpuAbi != null && !VMRuntime.is64BitAbi(app.primaryCpuAbi)) {
            try {
                this.mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, app.nativeLibraryDir, userId);
            } catch (Installer.InstallerException e) {
                Slog.e(TAG, "Failed to link native for " + packageName + ": " + e);
            }
        }
    }

    private boolean maybeMigrateAppDataLIF(PackageParser.Package pkg, int userId) {
        if (!pkg.isSystem() || StorageManager.isFileEncryptedNativeOrEmulated()) {
            return false;
        }
        try {
            this.mInstaller.migrateAppData(pkg.volumeUuid, pkg.packageName, userId, pkg.applicationInfo.isDefaultToDeviceProtectedStorage() ? 1 : 2);
        } catch (Installer.InstallerException e) {
            PackageManagerServiceUtils.logCriticalInfo(5, "Failed to migrate " + pkg.packageName + ": " + e.getMessage());
        }
        return true;
    }

    public PackageFreezer freezePackage(String packageName, String killReason) {
        return freezePackage(packageName, -1, killReason);
    }

    public PackageFreezer freezePackage(String packageName, int userId, String killReason) {
        return new PackageFreezer(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int installFlags, String killReason) {
        return freezePackageForInstall(packageName, -1, installFlags, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) {
        if ((installFlags & 4096) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int deleteFlags, String killReason) {
        return freezePackageForDelete(packageName, -1, deleteFlags, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int userId, int deleteFlags, String killReason) {
        if ((deleteFlags & 8) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    /* access modifiers changed from: private */
    public class PackageFreezer implements AutoCloseable {
        private final PackageFreezer[] mChildren;
        private final CloseGuard mCloseGuard;
        private final AtomicBoolean mClosed;
        private final String mPackageName;
        private final boolean mWeFroze;

        public PackageFreezer() {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            this.mPackageName = null;
            this.mChildren = null;
            this.mWeFroze = false;
            this.mCloseGuard.open("close");
        }

        public PackageFreezer(String packageName, int userId, String killReason) {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            synchronized (PackageManagerService.this.mPackages) {
                this.mPackageName = packageName;
                this.mWeFroze = PackageManagerService.this.mFrozenPackages.add(this.mPackageName);
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(this.mPackageName);
                if (ps != null) {
                    PackageManagerService.this.killApplication(ps.name, ps.appId, userId, killReason);
                }
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null || p.childPackages == null) {
                    this.mChildren = null;
                } else {
                    int N = p.childPackages.size();
                    this.mChildren = new PackageFreezer[N];
                    for (int i = 0; i < N; i++) {
                        this.mChildren[i] = new PackageFreezer(((PackageParser.Package) p.childPackages.get(i)).packageName, userId, killReason);
                    }
                }
            }
            this.mCloseGuard.open("close");
        }

        /* access modifiers changed from: protected */
        @Override // java.lang.Object
        public void finalize() throws Throwable {
            try {
                this.mCloseGuard.warnIfOpen();
                close();
            } finally {
                super.finalize();
            }
        }

        @Override // java.lang.AutoCloseable
        public void close() {
            this.mCloseGuard.close();
            if (this.mClosed.compareAndSet(false, true)) {
                synchronized (PackageManagerService.this.mPackages) {
                    if (this.mWeFroze) {
                        PackageManagerService.this.mFrozenPackages.remove(this.mPackageName);
                    }
                    if (this.mChildren != null) {
                        for (PackageFreezer freezer : this.mChildren) {
                            freezer.close();
                        }
                    }
                }
            }
        }
    }

    private void checkPackageFrozen(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mFrozenPackages.contains(packageName)) {
                Slog.wtf(TAG, "Expected " + packageName + " to be frozen!", new Throwable());
            }
        }
    }

    public int movePackage(String packageName, String volumeUuid) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        int callingUid = Binder.getCallingUid();
        UserHandle user = new UserHandle(UserHandle.getUserId(callingUid));
        int moveId = this.mNextMoveId.getAndIncrement();
        this.mHandler.post(new Runnable(packageName, volumeUuid, moveId, callingUid, user) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$uo2Qs0M_YmpseropZZft4hdSstM */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ String f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ int f$4;
            private final /* synthetic */ UserHandle f$5;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
            }

            public final void run() {
                PackageManagerService.this.lambda$movePackage$32$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5);
            }
        });
        return moveId;
    }

    public /* synthetic */ void lambda$movePackage$32$PackageManagerService(String packageName, String volumeUuid, int moveId, int callingUid, UserHandle user) {
        try {
            movePackageInternal(packageName, volumeUuid, moveId, callingUid, user);
        } catch (PackageManagerException e) {
            Slog.w(TAG, "Failed to move " + packageName, e);
            this.mMoveCallbacks.notifyStatusChanged(moveId, e.error);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x0327, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Not enough free space to move");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x0328, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x033a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x034c, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x034d, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x0368, code lost:
        r4.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0373, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Move location not mounted private volume");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x010e, code lost:
        r2 = new android.os.Bundle();
        r2.putString("android.intent.extra.PACKAGE_NAME", r57);
        r2.putString("android.intent.extra.TITLE", r3);
        r56.mMoveCallbacks.notifyCreated(r59, r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x012b, code lost:
        if (java.util.Objects.equals(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, r58) == false) goto L_0x0135;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x012d, code lost:
        r1 = android.os.Environment.getDataAppDirectory(r58);
        r44 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x013c, code lost:
        if (java.util.Objects.equals("primary_physical", r58) == false) goto L_0x014a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x013e, code lost:
        r1 = r12.getPrimaryPhysicalVolume().getPath();
        r44 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x014a, code lost:
        r0 = r12.findVolumeByUuid(r58);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x014e, code lost:
        if (r0 == null) goto L_0x035c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x0154, code lost:
        if (r0.getType() != 1) goto L_0x035c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x015a, code lost:
        if (r0.isMountedWritable() == false) goto L_0x034f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x015c, code lost:
        r44 = true;
        r1 = android.os.Environment.getDataAppDirectory(r58);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0164, code lost:
        if (r44 == false) goto L_0x01b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x0166, code lost:
        r0 = r0.length;
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0168, code lost:
        if (r5 >= r0) goto L_0x01ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x016a, code lost:
        r0 = r0[r5];
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0172, code lost:
        if (android.os.storage.StorageManager.isFileEncryptedNativeOrEmulated() == false) goto L_0x01a5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x0178, code lost:
        if (android.os.storage.StorageManager.isUserKeyUnlocked(r0) == false) goto L_0x017f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x01a0, code lost:
        throw new com.android.server.pm.PackageManagerException(-10, "User " + r0 + " must be unlocked");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x01a5, code lost:
        r5 = r5 + 1;
        r0 = r0;
        r2 = r2;
        r3 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x01ae, code lost:
        r19 = r2;
        r22 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x01b3, code lost:
        r19 = r2;
        r22 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x01b7, code lost:
        r0 = new android.content.pm.PackageStats(null, -1);
        r2 = r56.mInstaller;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x01c1, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:?, code lost:
        r0 = r0.length;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x01c3, code lost:
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x01c4, code lost:
        if (r3 >= r0) goto L_0x020f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x01d2, code lost:
        if (getPackageSizeInfoLI(r57, r0[r3], r0) == false) goto L_0x01d9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x01d4, code lost:
        r3 = r3 + 1;
        r0 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x01d9, code lost:
        r4.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x01e8, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Failed to measure package size");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x01e9, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x01fc, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x0214, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_INSTALL == false) goto L_0x0238;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x0216, code lost:
        android.util.Slog.d(com.android.server.pm.PackageManagerService.TAG, "Measured code size " + r0.codeSize + ", data size " + r0.dataSize);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x0238, code lost:
        r45 = r1.getUsableSpace();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x023c, code lost:
        if (r44 == false) goto L_0x0248;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x023e, code lost:
        r24 = r4;
        r47 = r0.codeSize + r0.dataSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x0248, code lost:
        r24 = r4;
        r47 = r0.codeSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x0254, code lost:
        if (r47 > r12.getStorageBytesUntilLow(r1)) goto L_0x031a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x0256, code lost:
        r56.mMoveCallbacks.notifyStatusChanged(r59, 10);
        r3 = new java.util.concurrent.CountDownLatch(1);
        r21 = new com.android.server.pm.PackageManagerService.AnonymousClass16(r56);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x027a, code lost:
        if (r44 == false) goto L_0x02b4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x027c, code lost:
        r2 = r56;
        new java.lang.Thread(new com.android.server.pm.$$Lambda$PackageManagerService$khEgFp5g734PWfRphYmdVxJ78QQ(r56, r3, r45, r1, r47, r59)).start();
        r0 = new com.android.server.pm.PackageManagerService.MoveInfo(r59, r24, r58, r57, r3.getName(), r40, r3, r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x02b4, code lost:
        r2 = r56;
        r0 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x02bd, code lost:
        r8 = r2.mHandler.obtainMessage(5);
        r10 = new com.android.server.pm.PackageManagerService.InstallParams(r56, com.android.server.pm.PackageManagerService.OriginInfo.fromExistingFile(r3), r0, r21, 16 | 2, r3, r58, null, r61, r3, null, null, android.content.pm.PackageParser.SigningDetails.UNKNOWN, 0, -1);
        r10.setTraceMethod("movePackage").setTraceCookie(java.lang.System.identityHashCode(r10));
        r8.obj = r10;
        android.os.Trace.asyncTraceBegin(262144, "movePackage", java.lang.System.identityHashCode(r8.obj));
        android.os.Trace.asyncTraceBegin(262144, "queueInstall", java.lang.System.identityHashCode(r8.obj));
        r2.mHandler.sendMessage(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x0319, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x031a, code lost:
        r4.close();
     */
    private void movePackageInternal(final String packageName, String volumeUuid, final int moveId, int callingUid, UserHandle user) throws PackageManagerException {
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        PackageManager pm = this.mContext.getPackageManager();
        synchronized (this.mPackages) {
            try {
                PackageParser.Package pkg = this.mPackages.get(packageName);
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (pkg != null && ps != null) {
                    if (!filterAppAccessLPr(ps, callingUid, user.getIdentifier())) {
                        if (!pkg.applicationInfo.isSystemApp()) {
                            boolean isInternalStorage = "private".equals(volumeUuid);
                            boolean allow3rdPartyOnInternal = this.mContext.getResources().getBoolean(17891339);
                            if (!isInternalStorage || allow3rdPartyOnInternal) {
                                String currentVolumeUuid = ps.volumeUuid;
                                File probe = new File(pkg.codePath);
                                File probeOat = new File(probe, "oat");
                                if (!probe.isDirectory() || !probeOat.isDirectory()) {
                                    throw new PackageManagerException(-6, "Move only supported for modern cluster style installs");
                                } else if (!Objects.equals(currentVolumeUuid, volumeUuid)) {
                                    if (pkg.applicationInfo.isInternal()) {
                                        if (isPackageDeviceAdminOnAnyUser(packageName)) {
                                            throw new PackageManagerException(-8, "Device admin cannot be moved");
                                        }
                                    }
                                    if (!this.mFrozenPackages.contains(packageName)) {
                                        final boolean isCurrentLocationExternal = isExternal(pkg);
                                        File codeFile = new File(pkg.codePath);
                                        String installerPackageName = ps.installerPackageName;
                                        String packageAbiOverride = ps.cpuAbiOverrideString;
                                        int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                                        String seinfo = pkg.applicationInfo.seInfo;
                                        String label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
                                        int targetSdkVersion = pkg.applicationInfo.targetSdkVersion;
                                        final PackageFreezer freezer = freezePackage(packageName, "movePackageInternal");
                                        int[] installedUserIds = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                    } else {
                                        throw new PackageManagerException(-7, "Failed to move already frozen package");
                                    }
                                } else {
                                    throw new PackageManagerException(-6, "Package already moved to " + volumeUuid);
                                }
                            } else {
                                try {
                                    throw new PackageManagerException(-9, "3rd party apps are not allowed on internal storage");
                                } catch (Throwable th) {
                                    pkg = th;
                                    throw pkg;
                                }
                            }
                        } else {
                            throw new PackageManagerException(-3, "Cannot move system application");
                        }
                    }
                }
                throw new PackageManagerException(-2, "Missing package");
            } catch (Throwable th2) {
                pkg = th2;
                throw pkg;
            }
        }
    }

    public /* synthetic */ void lambda$movePackageInternal$33$PackageManagerService(CountDownLatch installedLatch, long startFreeBytes, File measurePath, long sizeBytes, int moveId) {
        while (!installedLatch.await(1, TimeUnit.SECONDS)) {
            this.mMoveCallbacks.notifyStatusChanged(moveId, ((int) MathUtils.constrain((80 * (startFreeBytes - measurePath.getUsableSpace())) / sizeBytes, 0, 80)) + 10);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void logAppMovedStorage(String packageName, boolean isPreviousLocationExternal) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        if (pkg != null) {
            int packageExternalStorageType = getPackageExternalStorageType(((StorageManager) this.mContext.getSystemService(StorageManager.class)).findVolumeByUuid(pkg.applicationInfo.storageUuid.toString()), isExternal(pkg));
            if (!isPreviousLocationExternal && isExternal(pkg)) {
                StatsLog.write(183, packageExternalStorageType, 1, packageName);
            } else if (isPreviousLocationExternal && !isExternal(pkg)) {
                StatsLog.write(183, packageExternalStorageType, 2, packageName);
            }
        }
    }

    public int movePrimaryStorage(String volumeUuid) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        final int realMoveId = this.mNextMoveId.getAndIncrement();
        Bundle extras = new Bundle();
        extras.putString("android.os.storage.extra.FS_UUID", volumeUuid);
        this.mMoveCallbacks.notifyCreated(realMoveId, extras);
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).setPrimaryStorageUuid(volumeUuid, new IPackageMoveObserver.Stub() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass17 */

            public void onCreated(int moveId, Bundle extras) {
            }

            public void onStatusChanged(int moveId, int status, long estMillis) {
                PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(realMoveId, status, estMillis);
            }
        });
        return realMoveId;
    }

    public int getMoveStatus(int moveId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        return this.mMoveCallbacks.mLastStatus.get(moveId);
    }

    public void registerMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.register(callback);
    }

    public void unregisterMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.unregister(callback);
    }

    public boolean setInstallLocation(int loc) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.WRITE_SECURE_SETTINGS", null);
        if (getInstallLocation() == loc) {
            return true;
        }
        if (loc != 0 && loc != 1 && loc != 2) {
            return false;
        }
        Settings.Global.putInt(this.mContext.getContentResolver(), "default_install_location", loc);
        return true;
    }

    public int getInstallLocation() {
        return Settings.Global.getInt(this.mContext.getContentResolver(), "default_install_location", 0);
    }

    /* access modifiers changed from: package-private */
    public void cleanUpUser(UserManagerService userManager, int userHandle) {
        synchronized (this.mPackages) {
            this.mDirtyUsers.remove(Integer.valueOf(userHandle));
            this.mUserNeedsBadging.delete(userHandle);
            this.mSettings.removeUserLPw(userHandle);
            this.mPendingBroadcasts.remove(userHandle);
            this.mInstantAppRegistry.onUserRemovedLPw(userHandle);
            removeUnusedPackagesLPw(userManager, userHandle);
        }
    }

    @GuardedBy({"mPackages"})
    private void removeUnusedPackagesLPw(UserManagerService userManager, int userHandle) {
        int[] users = userManager.getUserIds();
        for (PackageSetting ps : this.mSettings.mPackages.values()) {
            if (ps.pkg != null) {
                String packageName = ps.pkg.packageName;
                if ((ps.pkgFlags & 1) == 0 && TextUtils.isEmpty(ps.pkg.staticSharedLibName)) {
                    boolean keep = shouldKeepUninstalledPackageLPr(packageName);
                    if (!keep) {
                        int i = 0;
                        while (true) {
                            if (i >= users.length) {
                                break;
                            }
                            if (users[i] != userHandle && ps.getInstalled(users[i])) {
                                keep = true;
                                break;
                            }
                            i++;
                        }
                    }
                    if (!keep) {
                        this.mHandler.post(new Runnable(packageName, userHandle) {
                            /* class com.android.server.pm.$$Lambda$PackageManagerService$Pm72V71sQAfx1TmE9rlLUh1hk */
                            private final /* synthetic */ String f$1;
                            private final /* synthetic */ int f$2;

                            {
                                this.f$1 = r2;
                                this.f$2 = r3;
                            }

                            public final void run() {
                                PackageManagerService.this.lambda$removeUnusedPackagesLPw$34$PackageManagerService(this.f$1, this.f$2);
                            }
                        });
                    }
                }
            }
        }
    }

    public /* synthetic */ void lambda$removeUnusedPackagesLPw$34$PackageManagerService(String packageName, int userHandle) {
        deletePackageX(packageName, -1, userHandle, 0);
    }

    /* access modifiers changed from: package-private */
    public void createNewUser(int userId, String[] disallowedPackages) {
        synchronized (this.mInstallLock) {
            this.mSettings.createNewUserLI(this, this.mInstaller, userId, disallowedPackages);
        }
        synchronized (this.mPackages) {
            scheduleWritePackageRestrictionsLocked(userId);
            scheduleWritePackageListLocked(userId);
            primeDomainVerificationsLPw(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void onNewUserCreated(int userId) {
        this.mDefaultPermissionPolicy.grantDefaultPermissions(userId);
        OppoFeatureCache.get(IColorRuntimePermGrantPolicyManager.DEFAULT).grantDefaultRuntimePermissionNewUser(userId);
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, true, this.mPackages.values(), this.mPermissionCallback);
        }
    }

    public VerifierDeviceIdentity getVerifierDeviceIdentity() throws RemoteException {
        VerifierDeviceIdentity verifierDeviceIdentityLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can read the verifier device identity");
        synchronized (this.mPackages) {
            verifierDeviceIdentityLPw = this.mSettings.getVerifierDeviceIdentityLPw();
        }
        return verifierDeviceIdentityLPw;
    }

    public void setPermissionEnforced(String permission, boolean enforced) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS", "setPermissionEnforced");
        if ("android.permission.READ_EXTERNAL_STORAGE".equals(permission)) {
            synchronized (this.mPackages) {
                if (this.mSettings.mReadExternalStorageEnforced == null || this.mSettings.mReadExternalStorageEnforced.booleanValue() != enforced) {
                    this.mSettings.mReadExternalStorageEnforced = enforced ? Boolean.TRUE : Boolean.FALSE;
                    this.mSettings.writeLPr();
                }
            }
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                long token = Binder.clearCallingIdentity();
                try {
                    am.killProcessesBelowForeground("setPermissionEnforcement");
                } catch (RemoteException e) {
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(token);
                    throw th;
                }
                Binder.restoreCallingIdentity(token);
                return;
            }
            return;
        }
        throw new IllegalArgumentException("No selective enforcement for " + permission);
    }

    @Deprecated
    public boolean isPermissionEnforced(String permission) {
        return true;
    }

    public boolean isStorageLow() {
        long token = Binder.clearCallingIdentity();
        try {
            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
            if (dsm != null) {
                return dsm.isMemoryLow();
            }
            Binder.restoreCallingIdentity(token);
            return false;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public IPackageInstaller getPackageInstaller() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return this.mInstallerService;
    }

    public IArtManager getArtManager() {
        return this.mArtManagerService;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean userNeedsBadging(int userId) {
        boolean b;
        int index = this.mUserNeedsBadging.indexOfKey(userId);
        if (index >= 0) {
            return this.mUserNeedsBadging.valueAt(index);
        }
        long token = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            if (userInfo == null || !userInfo.isManagedProfile()) {
                b = false;
            } else {
                b = true;
            }
            this.mUserNeedsBadging.put(userId, b);
            return b;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public KeySet getKeySetByAlias(String packageName, String alias) {
        KeySet keySet;
        if (packageName == null || alias == null) {
            return null;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getKeySetByAliasAndPackageNameLPr(packageName, alias));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public KeySet getSigningKeySet(String packageName) {
        KeySet keySet;
        if (packageName == null) {
            return null;
        }
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                if (pkg.applicationInfo.uid != callingUid) {
                    if (1000 != callingUid) {
                        throw new SecurityException("May not access signing KeySet of other apps.");
                    }
                }
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getSigningKeySetByPackageNameLPr(packageName));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName + ", uid:" + callingUid);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            return this.mSettings.mKeySetManagerService.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
        }
    }

    public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            return this.mSettings.mKeySetManagerService.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private void deletePackageIfUnusedLPr(String packageName) {
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps != null && !ps.isAnyInstalled(sUserManager.getUserIds())) {
            this.mHandler.post(new Runnable(packageName) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$5ZIUWyGNHzwepbT13GAaLSTvy4 */
                private final /* synthetic */ String f$1;

                {
                    this.f$1 = r2;
                }

                public final void run() {
                    PackageManagerService.this.lambda$deletePackageIfUnusedLPr$35$PackageManagerService(this.f$1);
                }
            });
        }
    }

    public /* synthetic */ void lambda$deletePackageIfUnusedLPr$35$PackageManagerService(String packageName) {
        deletePackageX(packageName, -1, 0, 2);
    }

    /* access modifiers changed from: private */
    public static void checkDowngrade(PackageParser.Package before, PackageInfoLite after) throws PackageManagerException {
        if (after.getLongVersionCode() < before.getLongVersionCode()) {
            throw new PackageManagerException(-25, "Update version code " + after.versionCode + " is older than current " + before.getLongVersionCode());
        } else if (after.getLongVersionCode() == before.getLongVersionCode()) {
            if (after.baseRevisionCode < before.baseRevisionCode) {
                throw new PackageManagerException(-25, "Update base revision code " + after.baseRevisionCode + " is older than current " + before.baseRevisionCode);
            } else if (!ArrayUtils.isEmpty(after.splitNames)) {
                for (int i = 0; i < after.splitNames.length; i++) {
                    String splitName = after.splitNames[i];
                    int j = ArrayUtils.indexOf(before.splitNames, splitName);
                    if (j != -1 && after.splitRevisionCodes[i] < before.splitRevisionCodes[j]) {
                        throw new PackageManagerException(-25, "Update split " + splitName + " revision code " + after.splitRevisionCodes[i] + " is older than current " + before.splitRevisionCodes[j]);
                    }
                }
            }
        }
    }

    /* access modifiers changed from: private */
    public static class MoveCallbacks extends Handler {
        private static final int MSG_CREATED = 1;
        private static final int MSG_STATUS_CHANGED = 2;
        private final RemoteCallbackList<IPackageMoveObserver> mCallbacks = new RemoteCallbackList<>();
        private final SparseIntArray mLastStatus = new SparseIntArray();

        public MoveCallbacks(Looper looper) {
            super(looper);
        }

        public void register(IPackageMoveObserver callback) {
            this.mCallbacks.register(callback);
        }

        public void unregister(IPackageMoveObserver callback) {
            this.mCallbacks.unregister(callback);
        }

        public void handleMessage(Message msg) {
            SomeArgs args = (SomeArgs) msg.obj;
            int n = this.mCallbacks.beginBroadcast();
            for (int i = 0; i < n; i++) {
                try {
                    invokeCallback(this.mCallbacks.getBroadcastItem(i), msg.what, args);
                } catch (RemoteException e) {
                }
            }
            this.mCallbacks.finishBroadcast();
            args.recycle();
        }

        private void invokeCallback(IPackageMoveObserver callback, int what, SomeArgs args) throws RemoteException {
            if (what == 1) {
                callback.onCreated(args.argi1, (Bundle) args.arg2);
            } else if (what == 2) {
                callback.onStatusChanged(args.argi1, args.argi2, ((Long) args.arg3).longValue());
            }
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private void notifyCreated(int moveId, Bundle extras) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " created " + extras.toString());
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.arg2 = extras;
            obtainMessage(1, args).sendToTarget();
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private void notifyStatusChanged(int moveId, int status) {
            notifyStatusChanged(moveId, status, -1);
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private void notifyStatusChanged(int moveId, int status, long estMillis) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " status " + status);
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.argi2 = status;
            args.arg3 = Long.valueOf(estMillis);
            obtainMessage(2, args).sendToTarget();
            synchronized (this.mLastStatus) {
                this.mLastStatus.put(moveId, status);
            }
        }
    }

    /* access modifiers changed from: private */
    public static final class OnPermissionChangeListeners extends Handler {
        private static final int MSG_ON_PERMISSIONS_CHANGED = 1;
        private final RemoteCallbackList<IOnPermissionsChangeListener> mPermissionListeners = new RemoteCallbackList<>();

        public OnPermissionChangeListeners(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            if (msg.what == 1) {
                handleOnPermissionsChanged(msg.arg1);
            }
        }

        public void addListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.register(listener);
        }

        public void removeListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.unregister(listener);
        }

        public void onPermissionsChanged(int uid) {
            if (this.mPermissionListeners.getRegisteredCallbackCount() > 0) {
                obtainMessage(1, uid, 0).sendToTarget();
            }
        }

        private void handleOnPermissionsChanged(int uid) {
            int count = this.mPermissionListeners.beginBroadcast();
            for (int i = 0; i < count; i++) {
                try {
                    try {
                        this.mPermissionListeners.getBroadcastItem(i).onPermissionsChanged(uid);
                    } catch (RemoteException e) {
                        Log.e(PackageManagerService.TAG, "Permission listener is dead", e);
                    }
                } catch (Throwable th) {
                    this.mPermissionListeners.finishBroadcast();
                    throw th;
                }
            }
            this.mPermissionListeners.finishBroadcast();
        }
    }

    /* access modifiers changed from: private */
    public class PackageManagerNative extends IPackageManagerNative.Stub {
        private PackageManagerNative() {
        }

        public String[] getNamesForUids(int[] uids) throws RemoteException {
            String[] results = PackageManagerService.this.getNamesForUids(uids);
            for (int i = results.length - 1; i >= 0; i--) {
                if (results[i] == null) {
                    results[i] = "";
                }
            }
            return results;
        }

        public String getInstallerForPackage(String packageName) throws RemoteException {
            String installerName = PackageManagerService.this.getInstallerPackageName(packageName);
            if (!TextUtils.isEmpty(installerName)) {
                return installerName;
            }
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo == null || (appInfo.flags & 1) == 0) {
                return "";
            }
            return "preload";
        }

        public long getVersionCodeForPackage(String packageName) throws RemoteException {
            try {
                PackageInfo pInfo = PackageManagerService.this.getPackageInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
                if (pInfo != null) {
                    return pInfo.getLongVersionCode();
                }
                return 0;
            } catch (Exception e) {
                return 0;
            }
        }

        public int getTargetSdkVersionForPackage(String packageName) throws RemoteException {
            ApplicationInfo info = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (info != null) {
                return info.targetSdkVersion;
            }
            throw new RemoteException("Couldn't get ApplicationInfo for package " + packageName);
        }

        public boolean[] isAudioPlaybackCaptureAllowed(String[] packageNames) throws RemoteException {
            int callingUser = UserHandle.getUserId(Binder.getCallingUid());
            boolean[] results = new boolean[packageNames.length];
            for (int i = results.length - 1; i >= 0; i--) {
                boolean z = false;
                ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageNames[i], 0, callingUser);
                if (appInfo != null) {
                    z = appInfo.isAudioPlaybackCaptureAllowed();
                }
                results[i] = z;
            }
            return results;
        }

        public int getLocationFlags(String packageName) throws RemoteException {
            int i = 0;
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo != null) {
                int isSystemApp = appInfo.isSystemApp() | (appInfo.isVendor() ? 2 : 0);
                if (appInfo.isProduct()) {
                    i = 4;
                }
                return i | isSystemApp;
            }
            throw new RemoteException("Couldn't get ApplicationInfo for package " + packageName);
        }

        public void sendArrayCommonDcsUpload(String logTag, String eventId, int pairs, String[] data) throws RemoteException {
            int size = data.length;
            if (size % 2 == 0 && size / 2 == pairs) {
                HashMap<String, String> dataMap = new HashMap<>();
                for (int i = 0; i < size; i += 2) {
                    dataMap.put(data[i], data[i + 1]);
                }
                if (PackageManagerService.mDcsUploader != null) {
                    PackageManagerService.mDcsUploader.sendToCommonDcsUpload(logTag, eventId, dataMap);
                    return;
                }
                return;
            }
            Slog.w(PackageManagerService.TAG, "sendCommonDcsUpload, data not matched!");
        }

        public String getModuleMetadataPackageName() throws RemoteException {
            return PackageManagerService.this.mModuleInfoProvider.getPackageName();
        }
    }

    private class PackageManagerInternalImpl extends PackageManagerInternal {
        private PackageManagerInternalImpl() {
        }

        public void updatePermissionFlagsTEMP(String permName, String packageName, int flagMask, int flagValues, int userId) {
            PackageManagerService.this.updatePermissionFlags(permName, packageName, flagMask, flagValues, true, userId);
        }

        public List<ApplicationInfo> getInstalledApplications(int flags, int userId, int callingUid) {
            return PackageManagerService.this.getInstalledApplicationsListInternal(flags, userId, callingUid);
        }

        public boolean isPlatformSigned(String packageName) {
            PackageParser.Package pkg;
            PackageSetting packageSetting = PackageManagerService.this.mSettings.mPackages.get(packageName);
            if (packageSetting == null || (pkg = packageSetting.pkg) == null) {
                return false;
            }
            if (pkg.mSigningDetails.hasAncestorOrSelf(PackageManagerService.this.mPlatformPackage.mSigningDetails) || PackageManagerService.this.mPlatformPackage.mSigningDetails.checkCapability(pkg.mSigningDetails, 4)) {
                return true;
            }
            return false;
        }

        public boolean isDataRestoreSafe(byte[] restoringFromSigHash, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasSha256Certificate(restoringFromSigHash, 1);
        }

        public boolean isDataRestoreSafe(Signature restoringFromSig, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasCertificate(restoringFromSig, 1);
        }

        public boolean hasSignatureCapability(int serverUid, int clientUid, @PackageParser.SigningDetails.CertCapabilities int capability) {
            PackageParser.SigningDetails serverSigningDetails = getSigningDetails(serverUid);
            PackageParser.SigningDetails clientSigningDetails = getSigningDetails(clientUid);
            return serverSigningDetails.checkCapability(clientSigningDetails, capability) || clientSigningDetails.hasAncestorOrSelf(serverSigningDetails);
        }

        private PackageParser.SigningDetails getSigningDetails(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null) {
                    return null;
                }
                return p.mSigningDetails;
            }
        }

        private PackageParser.SigningDetails getSigningDetails(int uid) {
            synchronized (PackageManagerService.this.mPackages) {
                Object obj = PackageManagerService.this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        return ((SharedUserSetting) obj).signatures.mSigningDetails;
                    } else if (obj instanceof PackageSetting) {
                        return ((PackageSetting) obj).signatures.mSigningDetails;
                    }
                }
                return PackageParser.SigningDetails.UNKNOWN;
            }
        }

        public int getPermissionFlagsTEMP(String permName, String packageName, int userId) {
            return PackageManagerService.this.getPermissionFlags(permName, packageName, userId);
        }

        public boolean isInstantApp(String packageName, int userId) {
            return PackageManagerService.this.isInstantApp(packageName, userId);
        }

        public String getInstantAppPackageName(int uid) {
            return PackageManagerService.this.getInstantAppPackageName(uid);
        }

        public boolean filterAppAccess(PackageParser.Package pkg, int callingUid, int userId) {
            boolean filterAppAccessLPr;
            synchronized (PackageManagerService.this.mPackages) {
                filterAppAccessLPr = PackageManagerService.this.filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, userId);
            }
            return filterAppAccessLPr;
        }

        public PackageParser.Package getPackage(String packageName) {
            PackageParser.Package r1;
            synchronized (PackageManagerService.this.mPackages) {
                r1 = PackageManagerService.this.mPackages.get(PackageManagerService.this.resolveInternalPackageNameLPr(packageName, -1));
            }
            return r1;
        }

        public PackageList getPackageList(PackageManagerInternal.PackageListObserver observer) {
            PackageList packageList;
            synchronized (PackageManagerService.this.mPackages) {
                int N = PackageManagerService.this.mPackages.size();
                ArrayList<String> list = new ArrayList<>(N);
                for (int i = 0; i < N; i++) {
                    list.add(PackageManagerService.this.mPackages.keyAt(i));
                }
                packageList = new PackageList(list, observer);
                if (observer != null) {
                    PackageManagerService.this.mPackageListObservers.add(packageList);
                }
            }
            return packageList;
        }

        public void removePackageListObserver(PackageManagerInternal.PackageListObserver observer) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mPackageListObservers.remove(observer);
            }
        }

        public PackageParser.Package getDisabledSystemPackage(String packageName) {
            PackageParser.Package r2;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(packageName);
                r2 = ps != null ? ps.pkg : null;
            }
            return r2;
        }

        public String getDisabledSystemPackageName(String packageName) {
            PackageParser.Package pkg = getDisabledSystemPackage(packageName);
            if (pkg == null) {
                return null;
            }
            return pkg.packageName;
        }

        public String getKnownPackageName(int knownPackage, int userId) {
            switch (knownPackage) {
                case 0:
                    return PackageManagerService.PLATFORM_PACKAGE_NAME;
                case 1:
                    return PackageManagerService.this.mSetupWizardPackage;
                case 2:
                    return PackageManagerService.this.mRequiredInstallerPackage;
                case 3:
                    return PackageManagerService.this.mRequiredVerifierPackage;
                case 4:
                    return PackageManagerService.this.getDefaultBrowserPackageName(userId);
                case 5:
                    return PackageManagerService.this.mSystemTextClassifierPackage;
                case 6:
                    return PackageManagerService.this.mRequiredPermissionControllerPackage;
                case 7:
                    return PackageManagerService.this.mWellbeingPackage;
                case 8:
                    return PackageManagerService.this.mDocumenterPackage;
                case 9:
                    return PackageManagerService.this.mConfiguratorPackage;
                case 10:
                    return PackageManagerService.this.mIncidentReportApproverPackage;
                case 11:
                    return PackageManagerService.this.mAppPredictionServicePackage;
                default:
                    return null;
            }
        }

        public boolean isResolveActivityComponent(ComponentInfo component) {
            return PackageManagerService.this.mResolveActivity.packageName.equals(component.packageName) && PackageManagerService.this.mResolveActivity.name.equals(component.name);
        }

        public void setLocationPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationPackagesProvider(provider);
        }

        public void setLocationExtraPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationExtraPackagesProvider(provider);
        }

        public void setVoiceInteractionPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setVoiceInteractionPackagesProvider(provider);
        }

        public void setUseOpenWifiAppPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setUseOpenWifiAppPackagesProvider(provider);
        }

        public void setSyncAdapterPackagesprovider(PackageManagerInternal.SyncAdapterPackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSyncAdapterPackagesProvider(provider);
        }

        public void grantDefaultPermissionsToDefaultUseOpenWifiApp(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultUseOpenWifiApp(packageName, userId);
        }

        public void setKeepUninstalledPackages(List<String> packageList) {
            Preconditions.checkNotNull(packageList);
            List<String> removedFromList = null;
            synchronized (PackageManagerService.this.mPackages) {
                if (PackageManagerService.this.mKeepUninstalledPackages != null) {
                    int packagesCount = PackageManagerService.this.mKeepUninstalledPackages.size();
                    for (int i = 0; i < packagesCount; i++) {
                        String oldPackage = (String) PackageManagerService.this.mKeepUninstalledPackages.get(i);
                        if (packageList == null || !packageList.contains(oldPackage)) {
                            if (removedFromList == null) {
                                removedFromList = new ArrayList<>();
                            }
                            removedFromList.add(oldPackage);
                        }
                    }
                }
                PackageManagerService.this.mKeepUninstalledPackages = new ArrayList(packageList);
                if (removedFromList != null) {
                    int removedCount = removedFromList.size();
                    for (int i2 = 0; i2 < removedCount; i2++) {
                        PackageManagerService.this.deletePackageIfUnusedLPr(removedFromList.get(i2));
                    }
                }
            }
        }

        public boolean isPermissionsReviewRequired(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                if (pkg == null) {
                    return false;
                }
                return PackageManagerService.this.mPermissionManager.isPermissionsReviewRequired(pkg, userId);
            }
        }

        public PackageInfo getPackageInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getPackageInfoInternal(packageName, -1, flags, filterCallingUid, userId);
        }

        public Bundle getSuspendedPackageLauncherExtras(String packageName, int userId) {
            Bundle bundle;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                PersistableBundle launcherExtras = null;
                if (ps != null) {
                    launcherExtras = ps.readUserState(userId).suspendedLauncherExtras;
                }
                bundle = launcherExtras != null ? new Bundle(launcherExtras.deepCopy()) : null;
            }
            return bundle;
        }

        public boolean isPackageSuspended(String packageName, int userId) {
            boolean suspended;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                suspended = ps != null ? ps.getSuspended(userId) : false;
            }
            return suspended;
        }

        public String getSuspendingPackage(String suspendedPackage, int userId) {
            String str;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                str = ps != null ? ps.readUserState(userId).suspendingPackage : null;
            }
            return str;
        }

        public SuspendDialogInfo getSuspendedDialogInfo(String suspendedPackage, int userId) {
            SuspendDialogInfo suspendDialogInfo;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                suspendDialogInfo = ps != null ? ps.readUserState(userId).dialogInfo : null;
            }
            return suspendDialogInfo;
        }

        public int getDistractingPackageRestrictions(String packageName, int userId) {
            int distractionFlags;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                distractionFlags = ps != null ? ps.getDistractionFlags(userId) : 0;
            }
            return distractionFlags;
        }

        public int getPackageUid(String packageName, int flags, int userId) {
            return PackageManagerService.this.getPackageUid(packageName, flags, userId);
        }

        public ApplicationInfo getApplicationInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getApplicationInfoInternal(packageName, flags, filterCallingUid, userId);
        }

        public ActivityInfo getActivityInfo(ComponentName component, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getActivityInfoInternal(component, flags, filterCallingUid, userId);
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, int filterCallingUid, int userId) {
            return queryIntentActivities(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, filterCallingUid, userId);
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.queryIntentActivitiesInternal(intent, resolvedType, flags, filterCallingUid, userId, false, true);
        }

        public List<ResolveInfo> queryIntentServices(Intent intent, int flags, int callingUid, int userId) {
            return PackageManagerService.this.queryIntentServicesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, userId, callingUid, false);
        }

        public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
            return PackageManagerService.this.getHomeActivitiesAsUser(allHomeCandidates, userId);
        }

        public ComponentName getDefaultHomeActivity(int userId) {
            return PackageManagerService.this.getDefaultHomeActivity(userId);
        }

        public void setDeviceAndProfileOwnerPackages(int deviceOwnerUserId, String deviceOwnerPackage, SparseArray<String> profileOwnerPackages) {
            PackageManagerService.this.mProtectedPackages.setDeviceAndProfileOwnerPackages(deviceOwnerUserId, deviceOwnerPackage, profileOwnerPackages);
            ArraySet<Integer> usersWithPoOrDo = new ArraySet<>();
            if (deviceOwnerPackage != null) {
                usersWithPoOrDo.add(Integer.valueOf(deviceOwnerUserId));
            }
            int sz = profileOwnerPackages.size();
            for (int i = 0; i < sz; i++) {
                if (profileOwnerPackages.valueAt(i) != null) {
                    usersWithPoOrDo.add(Integer.valueOf(profileOwnerPackages.keyAt(i)));
                }
            }
            PackageManagerService.this.unsuspendForNonSystemSuspendingPackages(usersWithPoOrDo);
        }

        public boolean isPackageDataProtected(int userId, String packageName) {
            return PackageManagerService.this.mProtectedPackages.isPackageDataProtected(userId, packageName);
        }

        public boolean isPackageStateProtected(String packageName, int userId) {
            return PackageManagerService.this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }

        public boolean isPackageEphemeral(int userId, String packageName) {
            boolean instantApp;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                instantApp = ps != null ? ps.getInstantApp(userId) : false;
            }
            return instantApp;
        }

        public boolean wasPackageEverLaunched(String packageName, int userId) {
            boolean wasPackageEverLaunchedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                wasPackageEverLaunchedLPr = PackageManagerService.this.mSettings.wasPackageEverLaunchedLPr(packageName, userId);
            }
            return wasPackageEverLaunchedLPr;
        }

        public boolean isEnabledAndMatches(ComponentInfo info, int flags, int userId) {
            boolean isEnabledAndMatchLPr;
            synchronized (PackageManagerService.this.mPackages) {
                isEnabledAndMatchLPr = PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info, flags, userId);
            }
            return isEnabledAndMatchLPr;
        }

        public boolean userNeedsBadging(int userId) {
            boolean userNeedsBadging;
            synchronized (PackageManagerService.this.mPackages) {
                userNeedsBadging = PackageManagerService.this.userNeedsBadging(userId);
            }
            return userNeedsBadging;
        }

        public void grantRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.grantRuntimePermission(permName, packageName, overridePolicy, Binder.getCallingUid(), userId, PackageManagerService.this.mPermissionCallback);
        }

        public void revokeRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.revokeRuntimePermission(permName, packageName, overridePolicy, userId, PackageManagerService.this.mPermissionCallback);
        }

        public String getNameForUid(int uid) {
            return PackageManagerService.this.getNameForUid(uid);
        }

        public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
            PackageManagerService.this.requestInstantAppResolutionPhaseTwo(responseObj, origIntent, resolvedType, callingPackage, verificationBundle, userId);
        }

        public void grantEphemeralAccess(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mInstantAppRegistry.grantInstantAccessLPw(userId, intent, targetAppId, ephemeralAppId);
            }
        }

        public boolean isInstantAppInstallerComponent(ComponentName component) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                z = PackageManagerService.this.mInstantAppInstallerActivity != null && PackageManagerService.this.mInstantAppInstallerActivity.getComponentName().equals(component);
            }
            return z;
        }

        public void pruneInstantApps() {
            PackageManagerService.this.mInstantAppRegistry.pruneInstantApps();
        }

        public String getSetupWizardPackageName() {
            return PackageManagerService.this.mSetupWizardPackage;
        }

        public void setExternalSourcesPolicy(PackageManagerInternal.ExternalSourcesPolicy policy) {
            if (policy != null) {
                PackageManagerService.this.mExternalSourcesPolicy = policy;
            }
        }

        public boolean isPackagePersistent(String packageName) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                z = false;
                if (pkg != null && (pkg.applicationInfo.flags & 9) == 9) {
                    z = true;
                }
            }
            return z;
        }

        public boolean isLegacySystemApp(PackageParser.Package pkg) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) pkg.mExtras;
                z = PackageManagerService.this.mPromoteSystemApps && ps.isSystem() && PackageManagerService.this.mExistingSystemPackages.contains(ps.name);
            }
            return z;
        }

        public List<PackageInfo> getOverlayPackages(int userId) {
            PackageInfo pkg;
            ArrayList<PackageInfo> overlayPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (!(p.mOverlayTarget == null || (pkg = PackageManagerService.this.generatePackageInfo((PackageSetting) p.mExtras, 0, userId)) == null)) {
                        overlayPackages.add(pkg);
                    }
                }
            }
            return overlayPackages;
        }

        public List<String> getTargetPackageNames(int userId) {
            List<String> targetPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget == null) {
                        targetPackages.add(p.packageName);
                    }
                }
            }
            return targetPackages;
        }

        public boolean setEnabledOverlayPackages(int userId, String targetPackageName, List<String> overlayPackageNames) {
            synchronized (PackageManagerService.this.mPackages) {
                if (targetPackageName != null) {
                    if (PackageManagerService.this.mPackages.get(targetPackageName) != null) {
                        ArrayList<String> overlayPaths = null;
                        if (overlayPackageNames != null && overlayPackageNames.size() > 0) {
                            int N = overlayPackageNames.size();
                            overlayPaths = new ArrayList<>(N);
                            for (int i = 0; i < N; i++) {
                                String packageName = overlayPackageNames.get(i);
                                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                                if (pkg == null) {
                                    Slog.e(PackageManagerService.TAG, "failed to find package " + packageName);
                                    return false;
                                }
                                overlayPaths.add(pkg.baseCodePath);
                            }
                        }
                        PackageManagerService.this.mSettings.mPackages.get(targetPackageName).setOverlayPaths(overlayPaths, userId);
                        return true;
                    }
                }
                Slog.e(PackageManagerService.TAG, "failed to find package " + targetPackageName);
                return false;
            }
        }

        public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
            return PackageManagerService.this.resolveIntentInternal(intent, resolvedType, flags, userId, resolveForStart, filterCallingUid);
        }

        public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
            return PackageManagerService.this.resolveServiceInternal(intent, resolvedType, flags, userId, callingUid);
        }

        public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
            return PackageManagerService.this.resolveContentProviderInternal(name, flags, userId);
        }

        public void addIsolatedUid(int isolatedUid, int ownerUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.put(isolatedUid, ownerUid);
            }
        }

        public void removeIsolatedUid(int isolatedUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.delete(isolatedUid);
            }
        }

        public int getUidTargetSdkVersion(int uid) {
            int uidTargetSdkVersionLockedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                uidTargetSdkVersionLockedLPr = PackageManagerService.this.getUidTargetSdkVersionLockedLPr(uid);
            }
            return uidTargetSdkVersionLockedLPr;
        }

        public int getPackageTargetSdkVersion(String packageName) {
            int packageTargetSdkVersionLockedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                packageTargetSdkVersionLockedLPr = PackageManagerService.this.getPackageTargetSdkVersionLockedLPr(packageName);
            }
            return packageTargetSdkVersionLockedLPr;
        }

        public boolean canAccessInstantApps(int callingUid, int userId) {
            return PackageManagerService.this.canViewInstantApps(callingUid, userId);
        }

        public boolean canAccessComponent(int callingUid, ComponentName component, int userId) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(component.getPackageName());
                z = ps != null && !PackageManagerService.this.filterAppAccessLPr(ps, callingUid, component, 0, userId);
            }
            return z;
        }

        public boolean hasInstantApplicationMetadata(String packageName, int userId) {
            boolean hasInstantApplicationMetadataLPr;
            synchronized (PackageManagerService.this.mPackages) {
                hasInstantApplicationMetadataLPr = PackageManagerService.this.mInstantAppRegistry.hasInstantApplicationMetadataLPr(packageName, userId);
            }
            return hasInstantApplicationMetadataLPr;
        }

        public void notifyPackageUse(String packageName, int reason) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.notifyPackageUseLocked(packageName, reason);
            }
        }

        public PackageManagerInternal.CheckPermissionDelegate getCheckPermissionDelegate() {
            PackageManagerInternal.CheckPermissionDelegate checkPermissionDelegateLocked;
            synchronized (PackageManagerService.this.mPackages) {
                checkPermissionDelegateLocked = PackageManagerService.this.getCheckPermissionDelegateLocked();
            }
            return checkPermissionDelegateLocked;
        }

        public void setCheckPermissionDelegate(PackageManagerInternal.CheckPermissionDelegate delegate) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.setCheckPermissionDelegateLocked(delegate);
            }
        }

        public SparseArray<String> getAppsWithSharedUserIds() {
            SparseArray<String> appsWithSharedUserIdsLocked;
            synchronized (PackageManagerService.this.mPackages) {
                appsWithSharedUserIdsLocked = PackageManagerService.this.getAppsWithSharedUserIdsLocked();
            }
            return appsWithSharedUserIdsLocked;
        }

        public String getSharedUserIdForPackage(String packageName) {
            String sharedUserIdForPackageLocked;
            synchronized (PackageManagerService.this.mPackages) {
                sharedUserIdForPackageLocked = PackageManagerService.this.getSharedUserIdForPackageLocked(packageName);
            }
            return sharedUserIdForPackageLocked;
        }

        public String[] getPackagesForSharedUserId(String sharedUserId, int userId) {
            String[] packagesForSharedUserIdLocked;
            synchronized (PackageManagerService.this.mPackages) {
                packagesForSharedUserIdLocked = PackageManagerService.this.getPackagesForSharedUserIdLocked(sharedUserId, userId);
            }
            return packagesForSharedUserIdLocked;
        }

        public boolean isOnlyCoreApps() {
            return PackageManagerService.this.isOnlyCoreApps();
        }

        public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
            PackageManagerService.this.freeStorage(volumeUuid, bytes, storageFlags);
        }

        public void forEachPackage(Consumer<PackageParser.Package> actionLocked) {
            PackageManagerService.this.forEachPackage(actionLocked);
        }

        public void forEachInstalledPackage(Consumer<PackageParser.Package> actionLocked, int userId) {
            PackageManagerService.this.forEachInstalledPackage(actionLocked, userId);
        }

        public ArraySet<String> getEnabledComponents(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return new ArraySet<>();
                }
                return setting.getEnabledComponents(userId);
            }
        }

        public ArraySet<String> getDisabledComponents(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return new ArraySet<>();
                }
                return setting.getDisabledComponents(userId);
            }
        }

        public int getApplicationEnabledState(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return 0;
                }
                return setting.getEnabled(userId);
            }
        }

        public void setEnableRollbackCode(int token, int enableRollbackCode) {
            PackageManagerService.this.setEnableRollbackCode(token, enableRollbackCode);
        }

        public boolean compileLayouts(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                if (pkg == null) {
                    return false;
                }
                return PackageManagerService.this.mArtManagerService.compileLayouts(pkg);
            }
        }

        public void finishPackageInstall(int token, boolean didLaunch) {
            PackageManagerService.this.finishPackageInstall(token, didLaunch);
        }

        public String removeLegacyDefaultBrowserPackageName(int userId) {
            String removeDefaultBrowserPackageNameLPw;
            synchronized (PackageManagerService.this.mPackages) {
                removeDefaultBrowserPackageNameLPw = PackageManagerService.this.mSettings.removeDefaultBrowserPackageNameLPw(userId);
            }
            return removeDefaultBrowserPackageNameLPw;
        }

        public void setDefaultBrowserProvider(PackageManagerInternal.DefaultBrowserProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultBrowserProvider = provider;
            }
        }

        public void setDefaultDialerProvider(PackageManagerInternal.DefaultDialerProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultDialerProvider = provider;
            }
        }

        public void setDefaultHomeProvider(PackageManagerInternal.DefaultHomeProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultHomeProvider = provider;
            }
        }

        public boolean isApexPackage(String packageName) {
            return PackageManagerService.this.mApexManager.isApexPackage(packageName);
        }

        public void uninstallApex(String packageName, long versionCode, int userId, IntentSender intentSender) {
            int callerUid = Binder.getCallingUid();
            if (callerUid == 0 || callerUid == 2000) {
                PackageInstallerService.PackageDeleteObserverAdapter adapter = new PackageInstallerService.PackageDeleteObserverAdapter(PackageManagerService.this.mContext, intentSender, packageName, false, userId);
                if (userId != -1) {
                    adapter.onPackageDeleted(packageName, -5, "Can't uninstall an apex for a single user");
                    return;
                }
                ApexManager am = PackageManagerService.this.mApexManager;
                PackageInfo activePackage = am.getPackageInfo(packageName, 1);
                if (activePackage == null) {
                    adapter.onPackageDeleted(packageName, -5, packageName + " is not an apex package");
                } else if (versionCode != -1 && activePackage.getLongVersionCode() != versionCode) {
                    adapter.onPackageDeleted(packageName, -5, "Active version " + activePackage.getLongVersionCode() + " is not equal to " + versionCode + "]");
                } else if (!am.uninstallApex(activePackage.applicationInfo.sourceDir)) {
                    adapter.onPackageDeleted(packageName, -5, "Failed to uninstall apex " + packageName);
                } else {
                    adapter.onPackageDeleted(packageName, 1, null);
                }
            } else {
                throw new SecurityException("Not allowed to uninstall apexes");
            }
        }

        public boolean wereDefaultPermissionsGrantedSinceBoot(int userId) {
            boolean wereDefaultPermissionsGrantedSinceBoot;
            synchronized (PackageManagerService.this.mPackages) {
                wereDefaultPermissionsGrantedSinceBoot = PackageManagerService.this.mDefaultPermissionPolicy.wereDefaultPermissionsGrantedSinceBoot(userId);
            }
            return wereDefaultPermissionsGrantedSinceBoot;
        }

        public boolean inCptWhiteList(int type, String verifyStr) {
            return PackageManagerService.mCompatibilityHelper.isInWhiteList(type, verifyStr);
        }

        public List<String> getCptListByType(int tag) {
            return PackageManagerService.mCompatibilityHelper.getCptListByType(tag);
        }

        public void sendCptUpload(String pkgName, String point, int callingUid) {
            PackageInfo pkgInfo = getPackageInfo(pkgName, 0, callingUid, PackageManagerService.this.mContext.getUserId());
            if (PackageManagerService.mCompatibilityHelper.getUploader() != null) {
                PackageManagerService.mCompatibilityHelper.getUploader().sendToUploadCpt(pkgInfo, point);
            }
        }

        public void setRuntimePermissionsFingerPrint(String fingerPrint, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.setRuntimePermissionsFingerPrintLPr(fingerPrint, userId);
            }
        }

        public void migrateLegacyObbData() {
            try {
                PackageManagerService.this.mInstaller.migrateLegacyObbData();
            } catch (Exception e) {
                Slog.wtf(PackageManagerService.TAG, e);
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private SparseArray<String> getAppsWithSharedUserIdsLocked() {
        SparseArray<String> sharedUserIds = new SparseArray<>();
        synchronized (this.mPackages) {
            for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
                sharedUserIds.put(UserHandle.getAppId(setting.userId), setting.name);
            }
        }
        return sharedUserIds;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private String getSharedUserIdForPackageLocked(String packageName) {
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps == null || !ps.isSharedUser()) {
            return null;
        }
        return ps.sharedUser.name;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private String[] getPackagesForSharedUserIdLocked(String sharedUserId, int userId) {
        try {
            int i = 0;
            SharedUserSetting sus = this.mSettings.getSharedUserLPw(sharedUserId, 0, 0, false);
            if (sus == null) {
                return EmptyArray.STRING;
            }
            String[] res = new String[sus.packages.size()];
            Iterator<PackageSetting> it = sus.packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.getInstalled(userId)) {
                    res[i] = ps.name;
                    i++;
                } else {
                    res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                }
            }
            return res;
        } catch (PackageManagerException e) {
            return EmptyArray.STRING;
        }
    }

    public int getRuntimePermissionsVersion(int userId) {
        int defaultRuntimePermissionsVersionLPr;
        Preconditions.checkArgumentNonnegative(userId);
        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "setRuntimePermissionVersion");
        synchronized (this.mPackages) {
            defaultRuntimePermissionsVersionLPr = this.mSettings.getDefaultRuntimePermissionsVersionLPr(userId);
        }
        return defaultRuntimePermissionsVersionLPr;
    }

    public void setRuntimePermissionsVersion(int version, int userId) {
        Preconditions.checkArgumentNonnegative(version);
        Preconditions.checkArgumentNonnegative(userId);
        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "setRuntimePermissionVersion");
        synchronized (this.mPackages) {
            this.mSettings.setDefaultRuntimePermissionsVersionLPr(version, userId);
        }
    }

    public void grantDefaultPermissionsToEnabledCarrierApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantPermissionsToEnabledCarrierApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledCarrierApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledImsServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledImsServices");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledImsServices(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$Jk56TooKBJVbCXzf9mkL2I94Ey0 */
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.lambda$grantDefaultPermissionsToEnabledTelephonyDataServices$36$PackageManagerService(this.f$1, this.f$2);
                }
            });
        }
    }

    public /* synthetic */ void lambda$grantDefaultPermissionsToEnabledTelephonyDataServices$36$PackageManagerService(String[] packageNames, int userId) throws Exception {
        this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledTelephonyDataServices(packageNames, userId);
    }

    public void revokeDefaultPermissionsFromDisabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromDisabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$Wj5mb4brzWgOPLO1KKQ_kaMGbx4 */
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.lambda$revokeDefaultPermissionsFromDisabledTelephonyDataServices$37$PackageManagerService(this.f$1, this.f$2);
                }
            });
        }
    }

    public /* synthetic */ void lambda$revokeDefaultPermissionsFromDisabledTelephonyDataServices$37$PackageManagerService(String[] packageNames, int userId) throws Exception {
        this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromDisabledTelephonyDataServices(packageNames, userId);
    }

    public void grantDefaultPermissionsToActiveLuiApp(String packageName, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToActiveLuiApp");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToActiveLuiApp(packageName, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void revokeDefaultPermissionsFromLuiApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromLuiApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromLuiApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void forEachPackage(Consumer<PackageParser.Package> actionLocked) {
        synchronized (this.mPackages) {
            int numPackages = this.mPackages.size();
            for (int i = 0; i < numPackages; i++) {
                actionLocked.accept(this.mPackages.valueAt(i));
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void forEachInstalledPackage(Consumer<PackageParser.Package> actionLocked, int userId) {
        synchronized (this.mPackages) {
            int numPackages = this.mPackages.size();
            for (int i = 0; i < numPackages; i++) {
                PackageParser.Package pkg = this.mPackages.valueAt(i);
                PackageSetting setting = this.mSettings.getPackageLPr(pkg.packageName);
                if (setting != null) {
                    if (setting.getInstalled(userId)) {
                        actionLocked.accept(pkg);
                    }
                }
            }
        }
    }

    private static void enforceSystemOrPhoneCaller(String tag) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 1001 && callingUid != 1000) {
            throw new SecurityException("Cannot call " + tag + " from UID " + callingUid);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isHistoricalPackageUsageAvailable() {
        return this.mPackageUsage.isHistoricalPackageUsageAvailable();
    }

    /* access modifiers changed from: package-private */
    public Collection<PackageParser.Package> getPackages() {
        ArrayList arrayList;
        synchronized (this.mPackages) {
            arrayList = new ArrayList(this.mPackages.values());
        }
        return arrayList;
    }

    public void logAppProcessStartIfNeeded(String processName, int uid, String seinfo, String apkFile, int pid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && SecurityLog.isLoggingEnabled()) {
            Bundle data = new Bundle();
            data.putLong("startTimestamp", System.currentTimeMillis());
            data.putString("processName", processName);
            data.putInt(WatchlistLoggingHandler.WatchlistEventKeys.UID, uid);
            data.putString("seinfo", seinfo);
            data.putString("apkFile", apkFile);
            data.putInt("pid", pid);
            Message msg = this.mProcessLoggingHandler.obtainMessage(1);
            msg.setData(data);
            this.mProcessLoggingHandler.sendMessage(msg);
        }
    }

    public CompilerStats.PackageStats getCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getPackageStats(pkgName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(PackageParser.Package pkg) {
        return getOrCreateCompilerPackageStats(pkg.packageName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getOrCreatePackageStats(pkgName);
    }

    public void deleteCompilerPackageStats(String pkgName) {
        this.mCompilerStats.deletePackageStats(pkgName);
    }

    private List<String> loadCustomizeWhiteList(String path) {
        int type;
        String value;
        ArrayList<String> emptyList = new ArrayList<>();
        File file = new File(path);
        if (!file.exists()) {
            Slog.w(TAG, path + " file don't exist!");
            return emptyList;
        }
        ArrayList<String> ret = new ArrayList<>();
        FileInputStream stream = null;
        boolean success = false;
        try {
            FileInputStream stream2 = new FileInputStream(file);
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(stream2, null);
            do {
                type = parser.next();
                if (type == 2 && "p".equals(parser.getName()) && (value = parser.getAttributeValue(null, "att")) != null) {
                    ret.add(value);
                }
            } while (type != 1);
            success = true;
            try {
                stream2.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (NullPointerException e2) {
            Slog.w(TAG, "failed parsing ", e2);
            if (0 != 0) {
                stream.close();
            }
        } catch (NumberFormatException e3) {
            Slog.w(TAG, "failed parsing ", e3);
            if (0 != 0) {
                stream.close();
            }
        } catch (XmlPullParserException e4) {
            Slog.w(TAG, "failed parsing ", e4);
            if (0 != 0) {
                stream.close();
            }
        } catch (IOException e5) {
            Slog.w(TAG, "failed parsing ", e5);
            if (0 != 0) {
                stream.close();
            }
        } catch (IndexOutOfBoundsException e6) {
            Slog.w(TAG, "failed parsing ", e6);
            if (0 != 0) {
                stream.close();
            }
        } catch (Throwable th) {
            if (0 != 0) {
                try {
                    stream.close();
                } catch (IOException e7) {
                    e7.printStackTrace();
                }
            }
            throw th;
        }
        if (success) {
            return ret;
        }
        Slog.w(TAG, path + " file failed parsing!");
        return emptyList;
    }

    public boolean checkWhiteList(String packageName) {
        List<String> list = this.mCustomizeList;
        if (list == null || list.size() <= 0 || packageName == null) {
            return false;
        }
        try {
            for (String pkg : this.mCustomizeList) {
                if (pkg.equalsIgnoreCase(packageName)) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            Slog.w(TAG, "check white list has exception! ", e);
            return false;
        }
    }

    public String checkEMMApkRuntimePermission(String packageName) {
        PackageParser.Package pkg;
        int i = 0;
        if (!hasSystemFeature("oppo.customize.function.checkpermission", 0)) {
            return "Permission Denial: has not com.chinatelecom.permission.security.EMM";
        }
        int uid = Binder.getCallingUid();
        String[] packageNames = getPackagesForUid(uid);
        boolean found = false;
        int length = packageNames.length;
        while (true) {
            if (i >= length) {
                break;
            } else if (packageNames[i].equals(packageName)) {
                found = true;
                break;
            } else {
                i++;
            }
        }
        if (!found) {
            return "Can't find package " + packageName;
        } else if (checkUidPermission("com.chinatelecom.permission.security.EMM", uid) != 0) {
            return "Permission Denial: has not com.chinatelecom.permission.security.EMM";
        } else {
            synchronized (this.mPackages) {
                pkg = this.mPackages.get(packageName);
            }
            if (pkg != null) {
                return "";
            }
            return "Can't find package " + packageName;
        }
    }

    public int getInstallReason(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "get install reason");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, userId)) {
                return 0;
            }
            if (ps == null) {
                return 0;
            }
            return ps.getInstallReason(userId);
        }
    }

    public boolean canRequestPackageInstalls(String packageName, int userId) {
        return canRequestPackageInstallsInternal(packageName, 0, userId, true);
    }

    private boolean canRequestPackageInstallsInternal(String packageName, int flags, int userId, boolean throwIfPermNotDeclared) {
        PackageManagerInternal.ExternalSourcesPolicy externalSourcesPolicy;
        int callingUid = Binder.getCallingUid();
        int uid = getPackageUid(packageName, 0, userId);
        if (callingUid == uid || callingUid == 0 || callingUid == 1000) {
            ApplicationInfo info = getApplicationInfo(packageName, flags, userId);
            if (info == null || info.targetSdkVersion < 26 || isInstantApp(packageName, userId)) {
                return false;
            }
            if (!ArrayUtils.contains(getAppOpPermissionPackages("android.permission.REQUEST_INSTALL_PACKAGES"), packageName)) {
                if (!throwIfPermNotDeclared) {
                    Slog.e(TAG, "Need to declare android.permission.REQUEST_INSTALL_PACKAGES to call this api");
                    return false;
                }
                throw new SecurityException("Need to declare android.permission.REQUEST_INSTALL_PACKAGES to call this api");
            } else if (sUserManager.hasUserRestriction("no_install_unknown_sources", userId) || sUserManager.hasUserRestriction("no_install_unknown_sources_globally", userId) || (externalSourcesPolicy = this.mExternalSourcesPolicy) == null || externalSourcesPolicy.getPackageTrustedToInstallApps(packageName, uid) != 0) {
                return false;
            } else {
                return true;
            }
        } else {
            throw new SecurityException("Caller uid " + callingUid + " does not own package " + packageName);
        }
    }

    public ComponentName getInstantAppResolverSettingsComponent() {
        return this.mInstantAppResolverSettingsComponent;
    }

    public ComponentName getInstantAppInstallerComponent() {
        ActivityInfo activityInfo;
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && (activityInfo = this.mInstantAppInstallerActivity) != null) {
            return activityInfo.getComponentName();
        }
        return null;
    }

    public String getInstantAppAndroidId(String packageName, int userId) {
        String instantAppAndroidIdLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppAndroidId");
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppAndroidId");
        if (!isInstantApp(packageName, userId)) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppAndroidIdLPw = this.mInstantAppRegistry.getInstantAppAndroidIdLPw(packageName, userId);
        }
        return instantAppAndroidIdLPw;
    }

    /* access modifiers changed from: package-private */
    public boolean canHaveOatDir(String packageName) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null) {
                return false;
            }
            return p.canHaveOatDir();
        }
    }

    private String getOatDir(PackageParser.Package pkg) {
        if (!pkg.canHaveOatDir()) {
            return null;
        }
        File codePath = new File(pkg.codePath);
        if (codePath.isDirectory()) {
            return PackageDexOptimizer.getOatDir(codePath).getAbsolutePath();
        }
        return null;
    }

    /* access modifiers changed from: package-private */
    public void deleteOatArtifactsOfPackage(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(pkg.applicationInfo);
        List<String> codePaths = pkg.getAllCodePaths();
        String oatDir = getOatDir(pkg);
        for (String codePath : codePaths) {
            for (String isa : instructionSets) {
                try {
                    this.mInstaller.deleteOdex(codePath, isa, oatDir);
                } catch (Installer.InstallerException e) {
                    Log.e(TAG, "Failed deleting oat files for " + codePath, e);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public Set<String> getUnusedPackages(long downgradeTimeThresholdMillis) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Set<String> unusedPackages = new HashSet<>();
        long currentTimeInMillis = System.currentTimeMillis();
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                Iterator<PackageParser.Package> it = this.mPackages.values().iterator();
                while (it.hasNext()) {
                    PackageParser.Package pkg = it.next();
                    PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null) {
                        arrayMap = arrayMap2;
                        if (PackageManagerServiceUtils.isUnusedSinceTimeInMillis(ps.firstInstallTime, currentTimeInMillis, downgradeTimeThresholdMillis, getDexManager().getPackageUseInfoOrDefault(pkg.packageName), pkg.getLatestPackageUseTimeInMills(), pkg.getLatestForegroundPackageUseTimeInMills())) {
                            unusedPackages.add(pkg.packageName);
                        }
                        arrayMap2 = arrayMap;
                        it = it;
                    }
                }
                return unusedPackages;
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    public void onAmsAddedtoServiceMgr() {
        if (CtaManagerFactory.getInstance().makeCtaManager().isCtaSupported() && this.mIsPreNUpgrade) {
            for (int userId : UserManagerService.getInstance().getUserIds()) {
                this.mDefaultPermissionPolicy.grantCtaPermToPreInstalledPackage(userId);
            }
        }
    }

    private void grantCtaRuntimePerm(boolean updated, PackageInstalledInfo res) {
        if (CtaManagerFactory.getInstance().makeCtaManager().needGrantCtaRuntimePerm(updated, res.pkg.applicationInfo.targetSdkVersion)) {
            this.mPermissionManager.grantRequestedRuntimePermissions(res.pkg, res.newUsers, CtaManagerFactory.getInstance().makeCtaManager().getCtaOnlyPermissions(), Binder.getCallingUid(), this.mPermissionCallback);
        }
    }

    public boolean isPackageNeedsReview(PackageParser.Package pkg, Settings settings) {
        if (!CtaManagerFactory.getInstance().makeCtaManager().isCtaSupported()) {
            return false;
        }
        boolean appSupportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion >= 23;
        if (pkg.mSharedUserId != null) {
            SharedUserSetting suid = null;
            try {
                suid = settings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
            } catch (PackageManagerException e) {
            }
            if (suid != null) {
                Iterator<PackageSetting> it = suid.packages.iterator();
                while (it.hasNext()) {
                    PackageSetting setting = it.next();
                    if (appSupportsRuntimePermissions) {
                        if (isSystemApp(setting.pkg)) {
                            return false;
                        }
                    } else if (setting.pkg.applicationInfo.targetSdkVersion >= 23) {
                        return false;
                    }
                }
            }
            return true;
        } else if (!appSupportsRuntimePermissions || !isSystemApp(pkg)) {
            return true;
        } else {
            return false;
        }
    }

    public void setHarmfulAppWarning(String packageName, CharSequence warning, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "setHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                this.mSettings.setHarmfulAppWarningLPw(packageName, warning, userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            return;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public CharSequence getHarmfulAppWarning(String packageName, int userId) {
        String harmfulAppWarningLPr;
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "getHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                harmfulAppWarningLPr = this.mSettings.getHarmfulAppWarningLPr(packageName, userId);
            }
            return harmfulAppWarningLPr;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public boolean isPackageStateProtected(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "isPackageStateProtected");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.MANAGE_DEVICE_ADMINS", callingUid) == 0) {
            return this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }
        throw new SecurityException("Caller must have the android.permission.MANAGE_DEVICE_ADMINS permission.");
    }

    public void sendDeviceCustomizationReadyBroadcast() {
        this.mContext.enforceCallingPermission("android.permission.SEND_DEVICE_CUSTOMIZATION_READY", "sendDeviceCustomizationReadyBroadcast");
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent("android.intent.action.DEVICE_CUSTOMIZATION_READY");
            intent.setFlags(DumpState.DUMP_SERVICE_PERMISSIONS);
            try {
                ActivityManager.getService().broadcastIntent((IApplicationThread) null, intent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, new String[]{"android.permission.RECEIVE_DEVICE_CUSTOMIZATION_READY"}, -1, (Bundle) null, false, false, -1);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean isBootFromOTA() {
        if (new File("/cache/recovery/intent").exists()) {
            Slog.i(TAG, "/cache/recovery/intent file is exist!!!");
            String otaResultStr = readOTAUpdateResult("/cache/recovery/intent");
            if ("0".equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "is boot from OTA");
                }
                return true;
            } else if (NoFocusWindow.HUNG_CONFIG_ENABLE.equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "not boot from OTA,normal boot");
                }
                return false;
            } else if ("2".equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "is boot from recover");
                }
                return true;
            } else if ("3".equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "not boot from recover,normal boot");
                }
                return false;
            } else {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "OTA update file's date is invalid,normal boot");
                }
                return false;
            }
        } else {
            if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                Slog.i(TAG, "OTA file path is no exist,normal boot");
            }
            return false;
        }
    }

    private static String readOTAUpdateResult(String fileName) {
        String resultStr = null;
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(new File(fileName)));
            resultStr = reader.readLine();
            try {
                reader.close();
            } catch (IOException e1) {
                Slog.e(TAG, "readOTAUpdateResult close the reader failed!!!", e1);
            }
        } catch (IOException e) {
            Slog.e(TAG, "readOTAUpdateResult failed!!!", e);
            if (reader != null) {
                reader.close();
            }
        } catch (Throwable th) {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e12) {
                    Slog.e(TAG, "readOTAUpdateResult close the reader failed!!!", e12);
                }
            }
            throw th;
        }
        return resultStr;
    }

    private boolean checkAppInstallPermission(String pkgName) {
        if (this.mBlackAppInstallHelper == null) {
            this.mBlackAppInstallHelper = new BlackAppInstallHelper(this.mContext);
            this.mBlackAppInstallHelper.initUpdateBroadcastReceiver();
        }
        if (pkgName == null) {
            Slog.i(TAG, "pkgname is null!!");
            return false;
        }
        BlackAppInstallHelper blackAppInstallHelper = this.mBlackAppInstallHelper;
        if (blackAppInstallHelper == null) {
            Slog.i(TAG, "mBlackAppInstallHelper is null!!!");
            return false;
        } else if (!blackAppInstallHelper.getBlackAppList().contains(pkgName)) {
            return true;
        } else {
            Slog.i(TAG, "black install app list contains " + pkgName);
            return false;
        }
    }

    private boolean getImeiNumber(Context context) {
        String imei = ((TelephonyManager) context.getSystemService("phone")).getDeviceId();
        if (imei == null || imei.equals("")) {
            Slog.d(TAG, "getImeiNumber empty");
            return false;
        } else if (imei.length() >= 14) {
            return true;
        } else {
            Slog.d(TAG, "getImeiNumber invalid");
            return false;
        }
    }

    static class ActiveInstallSession {
        private String mInstallerPackageName;
        private final int mInstallerUid;
        private final IPackageInstallObserver2 mObserver;
        private final String mPackageName;
        private final PackageInstaller.SessionParams mSessionParams;
        private final PackageParser.SigningDetails mSigningDetails;
        private final File mStagedDir;
        private final UserHandle mUser;

        ActiveInstallSession(String packageName, File stagedDir, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, PackageParser.SigningDetails signingDetails) {
            this.mPackageName = packageName;
            this.mStagedDir = stagedDir;
            this.mObserver = observer;
            this.mSessionParams = sessionParams;
            this.mInstallerPackageName = installerPackageName;
            this.mInstallerUid = installerUid;
            this.mUser = user;
            this.mSigningDetails = signingDetails;
        }

        public String getPackageName() {
            return this.mPackageName;
        }

        public File getStagedDir() {
            return this.mStagedDir;
        }

        public IPackageInstallObserver2 getObserver() {
            return this.mObserver;
        }

        public PackageInstaller.SessionParams getSessionParams() {
            return this.mSessionParams;
        }

        public String getInstallerPackageName() {
            return this.mInstallerPackageName;
        }

        public int getInstallerUid() {
            return this.mInstallerUid;
        }

        public UserHandle getUser() {
            return this.mUser;
        }

        public PackageParser.SigningDetails getSigningDetails() {
            return this.mSigningDetails;
        }

        public void setInstallerPackageName(String newName) {
            this.mInstallerPackageName = newName;
        }
    }

    public class ColorPackageManagerServiceInner implements IColorPackageManagerServiceInner {
        public ColorPackageManagerServiceInner() {
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public String[] getPackagesForUid(int uid) {
            return PackageManagerService.this.getPackagesForUid(uid);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public ApplicationInfo getApplicationInfoInternal(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getApplicationInfoInternal(packageName, flags, filterCallingUid, userId);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public ResolveInfo resolveIntentInternal(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
            return PackageManagerService.this.resolveIntentInternal(intent, resolvedType, flags, userId, resolveForStart, filterCallingUid);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public List<ResolveInfo> queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) {
            return PackageManagerService.this.queryIntentReceiversInternal(intent, resolvedType, flags, userId, allowDynamicSplits);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid, boolean includeInstantApps) {
            return PackageManagerService.this.queryIntentServicesInternal(intent, resolvedType, flags, userId, callingUid, includeInstantApps);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public List<ResolveInfo> queryIntentContentProvidersInternal(Intent intent, String resolvedType, int flags, int userId) {
            return PackageManagerService.this.queryIntentContentProvidersInternal(intent, resolvedType, flags, userId);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public void onSystemAppPermissionRevoked(int uid, int userId) {
            PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
            }
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public PackageParser.Activity getPackageParserActivity(ComponentName cmp) {
            return PackageManagerService.this.mComponentResolver.getActivity(cmp);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public ArrayMap getPackages() {
            return PackageManagerService.this.mPackages;
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public boolean getInstalled(PackageSetting ps, int userId) {
            return ps != null && ps.getInstalled(userId);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public boolean isCustomDataApp(String pkgName) {
            ArraySet<String> set = PackageManagerCommonSoft.getDataPackageNameList();
            if (set != null) {
                return set.contains(pkgName);
            }
            return false;
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public void scanDirTracedLI(File scanDir, int parseFlags, int scanFlags, long currentTime) {
            PackageManagerService.this.scanDirTracedLI(scanDir, parseFlags, scanFlags, currentTime);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public void setInstallerPackageName(ActiveInstallSession session, String newName) {
            session.setInstallerPackageName(newName);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public PackageParser.Package installPackageFromSystemLIF(String codePathString, int[] allUserHandles, int[] origUserHandles, PermissionsState origPermissionState, boolean writeSettings) throws PackageManagerException {
            return PackageManagerService.this.installPackageFromSystemLIF(codePathString, allUserHandles, origUserHandles, origPermissionState, writeSettings);
        }

        @Override // com.android.server.pm.IColorPackageManagerServiceInner
        public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) {
            return PackageManagerService.this.queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
        }
    }

    private void sendOppoPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid, int callPid, int userId) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
        }
        Bundle extras = new Bundle(6);
        extras.putString("android.intent.extra.changed_component_name", componentNames.get(0));
        String[] nameList = new String[componentNames.size()];
        componentNames.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        extras.putInt("freezeState", OppoFeatureCache.get(IColorAppQuickFreezeManager.DEFAULT).getOppoFreezePackageState(packageName, userId));
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", packageName, extras, !componentNames.contains(packageName) ? 1073741824 : 0, null, null, new int[]{UserHandle.getUserId(packageUid)}, new int[]{UserHandle.getUserId(packageUid)});
    }

    public List<ResolveInfo> queryIntentActivitiesExported(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
    }
}
